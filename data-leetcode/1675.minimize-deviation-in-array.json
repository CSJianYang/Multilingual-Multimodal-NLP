[
    {
        "title": "Loud and Rich",
        "question_content": "There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.\nYou are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).\nReturn an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.\n&nbsp;\nExample 1:\n\nInput: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\nOutput: [5,5,2,5,4,5,6,7]\nExplanation: \nanswer[0] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.\nanswer[7] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.\nThe other answers can be filled out with similar reasoning.\n\nExample 2:\n\nInput: richer = [], quiet = [0]\nOutput: [0]\n\n&nbsp;\nConstraints:\n\n\tn == quiet.length\n\t1 <= n <= 500\n\t0 <= quiet[i] < n\n\tAll the values of quiet are unique.\n\t0 <= richer.length <= n * (n - 1) / 2\n\t0 <= ai, bi < n\n\tai != bi\n\tAll the pairs of richer are unique.\n\tThe observations in richer are all logically consistent.",
        "solutions": [
            {
                "id": 137918,
                "title": "c-java-python-concise-dfs",
                "content": "**Explanation**:\\nThe description is not easy to understand.\\nIn fact it\\'s a basic dfs traversal problem.\\nFor every people, call a sub function `dfs` to compare the `quiet` with others, who is richer than him.\\nAlso we will note this answer to avoid repeated calculation.\\n\\n\\n**Time Complexity**:\\nO(richer.length),\\nSub function `dfs` traverse every people only once, and every `richer` is traversed only one once.\\n\\n**C++:**\\n```\\n    unordered_map<int, vector<int>> richer2;\\n    vector<int> res;\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for (auto v : richer) richer2[v[1]].push_back(v[0]);\\n        res = vector<int> (quiet.size(), -1);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2[i]) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n```\\n\\n**Java:**\\n```\\n    HashMap<Integer, List<Integer>> richer2 = new HashMap<>();\\n    int res[];\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        for (int i = 0; i < n; ++i) richer2.put(i, new ArrayList<Integer>());\\n        for (int[] v : richer) richer2.get(v[1]).add(v[0]);\\n        res = new int[n]; Arrays.fill(res, -1);\\n        for (int i = 0; i < n; i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, int[] quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2.get(i)) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n```\\n\\n**Python:**\\n```\\nclass Solution(object):\\n\\n    def loudAndRich(self, richer, quiet):\\n        m = collections.defaultdict(list)\\n        for i, j in richer: m[j].append(i)\\n        res = [-1] * len(quiet)\\n\\n        def dfs(i):\\n            if res[i] >= 0: return res[i]\\n            res[i] = i\\n            for j in m[i]:\\n                if quiet[res[i]] > quiet[dfs(j)]: res[i] = res[j]\\n            return res[i]\\n\\n        for i in range(len(quiet)): dfs(i)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    unordered_map<int, vector<int>> richer2;\\n    vector<int> res;\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for (auto v : richer) richer2[v[1]].push_back(v[0]);\\n        res = vector<int> (quiet.size(), -1);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2[i]) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n```\n```\\n    HashMap<Integer, List<Integer>> richer2 = new HashMap<>();\\n    int res[];\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        for (int i = 0; i < n; ++i) richer2.put(i, new ArrayList<Integer>());\\n        for (int[] v : richer) richer2.get(v[1]).add(v[0]);\\n        res = new int[n]; Arrays.fill(res, -1);\\n        for (int i = 0; i < n; i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, int[] quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2.get(i)) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n```\n```\\nclass Solution(object):\\n\\n    def loudAndRich(self, richer, quiet):\\n        m = collections.defaultdict(list)\\n        for i, j in richer: m[j].append(i)\\n        res = [-1] * len(quiet)\\n\\n        def dfs(i):\\n            if res[i] >= 0: return res[i]\\n            res[i] = i\\n            for j in m[i]:\\n                if quiet[res[i]] > quiet[dfs(j)]: res[i] = res[j]\\n            return res[i]\\n\\n        for i in range(len(quiet)): dfs(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138088,
                "title": "c-with-topological-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        const int N = quiet.size();\\n        vector<vector<int>> graph(N);\\n        vector<int> indegrees(N, 0);\\n        for (auto& r : richer) {\\n            ++indegrees[r[1]];\\n            graph[r[0]].push_back(r[1]);\\n        }\\n        \\n        deque<int> q;\\n        for (int i = 0; i < indegrees.size(); ++i) {\\n            if (indegrees[i] == 0) {\\n                q.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> answers(N);\\n        iota(answers.begin(), answers.end(), 0);\\n        while (!q.empty()) {\\n            auto idx = q.front();\\n            q.pop_front();\\n            for (auto next : graph[idx]) {\\n                if (quiet[answers[next]] > quiet[answers[idx]]) {\\n                    answers[next] = answers[idx];\\n                }\\n                if (--indegrees[next] == 0) {\\n                    q.push_back(next);\\n                }\\n            }\\n        }\\n        return answers;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        const int N = quiet.size();\\n        vector<vector<int>> graph(N);\\n        vector<int> indegrees(N, 0);\\n        for (auto& r : richer) {\\n            ++indegrees[r[1]];\\n            graph[r[0]].push_back(r[1]);\\n        }\\n        \\n        deque<int> q;\\n        for (int i = 0; i < indegrees.size(); ++i) {\\n            if (indegrees[i] == 0) {\\n                q.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> answers(N);\\n        iota(answers.begin(), answers.end(), 0);\\n        while (!q.empty()) {\\n            auto idx = q.front();\\n            q.pop_front();\\n            for (auto next : graph[idx]) {\\n                if (quiet[answers[next]] > quiet[answers[idx]]) {\\n                    answers[next] = answers[idx];\\n                }\\n                if (--indegrees[next] == 0) {\\n                    q.push_back(next);\\n                }\\n            }\\n        }\\n        return answers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366657,
                "title": "c-bfs-topological-sort-indegree-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        //build graph and calculate indegrees\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n        //initialise ans array and push nodes with 0 degrees into queue\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                //if parent node having more money is quieter , update\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                \\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        //build graph and calculate indegrees\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n        //initialise ans array and push nodes with 0 degrees into queue\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                //if parent node having more money is quieter , update\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                \\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980153,
                "title": "c-kahn-s-algo-bfs-traversal-with-comments-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any person, we look for all the person who is equally rich or richer than them and then we select the quietest among these set of richer people.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(V+E), [V->Number of Nodes, E->Number of Edges]\\n\\n- Space complexity:\\nO(V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        //build graph and calculate indegrees\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n        //initialise ans array and push nodes with 0 degrees into queue\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                //if parent node having more money is quieter , update\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                \\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![9b3e244e-2239-4981-9d94-3578491ea5ed_1672392871.6117275.png](https://assets.leetcode.com/users/images/b5b09507-cc27-4673-b636-1163a6c08831_1672595757.4628367.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        //build graph and calculate indegrees\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n        //initialise ans array and push nodes with 0 degrees into queue\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                //if parent node having more money is quieter , update\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                \\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266859,
                "title": "python-cached-dfs",
                "content": "We want to find the least quiet person that\\'s richer or equal rich to our target. So we can convert the ```richer``` to a directed graph. \\n\\nEach child node is the richer person in the relationship. So when we search from our target node, all the node we visited in such directed graph will be richer persons than our target. And we just find out the least quite one from them.\\n\\nThus, we can use DFS here to collect all children nodes and target node itself (since our target node might be the richest node or all of its children nodes are quieter than itself). Then we just pick out the least quite one (```min(candidates, key=lambda x:quiet[x]```)).\\n\\nAnd previous searched result can be cached and reused. We can just save it in our answer array.\\n```\\ndef loudAndRich(richer, quiet):\\n\\tg, loud = collections.defaultdict(set), [-1]*len(quiet)\\n\\tfor u, v in richer: g[v].add(u)\\n\\tdef dfs(node):\\n\\t\\tif loud[node] < 0: loud[node] = min([dfs(nei) for nei in g[node]]+[node], key=lambda x:quiet[x])\\n\\t\\treturn loud[node]\\n\\treturn list(map(dfs, range(len(quiet))))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```richer```\n```min(candidates, key=lambda x:quiet[x]```\n```\\ndef loudAndRich(richer, quiet):\\n\\tg, loud = collections.defaultdict(set), [-1]*len(quiet)\\n\\tfor u, v in richer: g[v].add(u)\\n\\tdef dfs(node):\\n\\t\\tif loud[node] < 0: loud[node] = min([dfs(nei) for nei in g[node]]+[node], key=lambda x:quiet[x])\\n\\t\\treturn loud[node]\\n\\treturn list(map(dfs, range(len(quiet))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2502004,
                "title": "c-easy-bfs-topological-sort",
                "content": "Read the last paragraph of the question: answer[x] = y if y is the least quiet person among all people who definitely have equal to or more money than the person x\\n**EXPLANATION**:\\nFor any person, we look for all the person who is equally rich or richer than them and then we select the quietest among these set of richer people.\\n**Example**: Richness order: x>y, z>y, w>v. Then we can\\'t decide who is the richest among x,z & w b/c we don\\'t have proper information regarding their comparison. So we assume that all of them are richest.\\nFor any \\'a\\' who is richest we don\\'t have any \\'b\\' who is richer or equally rich, so we have only \\'a\\' himself the only candidate to be checked for quietest so ans[a] = a.\\nThus we use topological sort here in such a way that richest are the least dependent (no indegree)\\n\\nThen the lesser rich will see if the ans of richer one is quieter than his ans(no comparison of richness b/c richness order: ans[richer] >= richer & richer >= lesser rich so obviously ans[richer] >= lesser rich). If yes then he will replace his answer with the ans[richer].\\n\\n**If it helps please UPVOTE! and let others also know**\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) //topological sort\\n    {\\n        int n = quiet.size();\\n        vector<int> ans(n), adj[n], indegree(n,0);\\n        queue<int> q;\\n        int v;\\n        \\n        for(auto r: richer)\\n        {\\n            adj[r[0]].push_back(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            ans[i] = i;\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())   //BFS topo sort\\n        {\\n            v = q.front(), q.pop();\\n            \\n            for(auto u: adj[v])\\n            {\\n                if(quiet[ans[v]] < quiet[ans[u]])  //v is richer than u and b/c ans[v] can also be some other value than v which is more rich and is quietest and quieter than ans[u] then ans[u] will be ans[v]\\n                    ans[u] = ans[v];\\n                if(--indegree[u] == 0)\\n                    q.push(u);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) //topological sort\\n    {\\n        int n = quiet.size();\\n        vector<int> ans(n), adj[n], indegree(n,0);\\n        queue<int> q;\\n        int v;\\n        \\n        for(auto r: richer)\\n        {\\n            adj[r[0]].push_back(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            ans[i] = i;\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())   //BFS topo sort\\n        {\\n            v = q.front(), q.pop();\\n            \\n            for(auto u: adj[v])\\n            {\\n                if(quiet[ans[v]] < quiet[ans[u]])  //v is richer than u and b/c ans[v] can also be some other value than v which is more rich and is quietest and quieter than ans[u] then ans[u] will be ans[v]\\n                    ans[u] = ans[v];\\n                if(--indegree[u] == 0)\\n                    q.push(u);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038943,
                "title": "java-solution-dfs-memoization-o-n-2-beats-100-5ms",
                "content": "\\n    public static int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\t\\tint n = quiet.length;\\n\\t\\tList<Integer>[] graph = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tgraph[i] = new ArrayList<Integer>();\\n\\n\\t\\tfor (int[] rich : richer)\\n\\t\\t\\tgraph[rich[1]].add(rich[0]);\\n\\n\\t\\tint[] ans = new int[n];\\n\\t\\tboolean[] visited = new boolean[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (!visited[i])\\n\\t\\t\\t\\tloudAndRich(n, i, graph, visited, ans, quiet);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic static int loudAndRich(int n, int src, List<Integer>[] graph, boolean[] visited, int[] ans, int[] quiet) {\\n\\n\\t\\tif (visited[src])\\n\\t\\t\\treturn ans[src];\\n\\n\\t\\tvisited[src] = true;\\n\\t\\tList<Integer> nbrs = graph[src];\\n\\t\\tint min = quiet[src];\\n\\t\\tint person = src;\\n\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\tint p = loudAndRich(n, nbr, graph, visited, ans, quiet);\\n\\t\\t\\tif (quiet[p] < min) {\\n\\t\\t\\t\\tmin = quiet[p];\\n\\t\\t\\t\\tperson = p;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[src] = person;\\n\\t\\treturn person;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    public static int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\t\\tint n = quiet.length;\\n\\t\\tList<Integer>[] graph = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tgraph[i] = new ArrayList<Integer>();\\n\\n\\t\\tfor (int[] rich : richer)\\n\\t\\t\\tgraph[rich[1]].add(rich[0]);\\n\\n\\t\\tint[] ans = new int[n];\\n\\t\\tboolean[] visited = new boolean[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (!visited[i])\\n\\t\\t\\t\\tloudAndRich(n, i, graph, visited, ans, quiet);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic static int loudAndRich(int n, int src, List<Integer>[] graph, boolean[] visited, int[] ans, int[] quiet) {\\n\\n\\t\\tif (visited[src])\\n\\t\\t\\treturn ans[src];\\n\\n\\t\\tvisited[src] = true;\\n\\t\\tList<Integer> nbrs = graph[src];\\n\\t\\tint min = quiet[src];\\n\\t\\tint person = src;\\n\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\tint p = loudAndRich(n, nbr, graph, visited, ans, quiet);\\n\\t\\t\\tif (quiet[p] < min) {\\n\\t\\t\\t\\tmin = quiet[p];\\n\\t\\t\\t\\tperson = p;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[src] = person;\\n\\t\\treturn person;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 510945,
                "title": "c-dfs-clean-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int size = quiet.size();\\n        vector<vector<int>> graph(size);\\n        vector<int> ans(size, -1);\\n        // Constructs Graph\\n        for (auto rich : richer) {\\n            graph[rich[1]].push_back(rich[0]);\\n        }\\n        // Run DFS for each person on Graph\\n        for (int i = 0; i < size; i++) {\\n            dfs(graph, quiet, ans, i);\\n        }\\n        return ans;\\n    }\\n\\n    int dfs(vector<vector<int>> &graph, vector<int> &quiet, vector<int> &ans, int currentPerson) {\\n        // Check and return whether if the answer is already calculated or not\\n        if (ans[currentPerson] >= 0) {\\n            return ans[currentPerson];\\n        }\\n        // Save at least person\\'s value itself in case that no richer and least loud person found in search\\n        ans[currentPerson] = currentPerson;\\n        for (auto child : graph[currentPerson]) {\\n            if (quiet[dfs(graph, quiet, ans, child)] < quiet[ans[currentPerson]]) {\\n                ans[currentPerson] = ans[child];\\n            }\\n        }\\n        return ans[currentPerson];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int size = quiet.size();\\n        vector<vector<int>> graph(size);\\n        vector<int> ans(size, -1);\\n        // Constructs Graph\\n        for (auto rich : richer) {\\n            graph[rich[1]].push_back(rich[0]);\\n        }\\n        // Run DFS for each person on Graph\\n        for (int i = 0; i < size; i++) {\\n            dfs(graph, quiet, ans, i);\\n        }\\n        return ans;\\n    }\\n\\n    int dfs(vector<vector<int>> &graph, vector<int> &quiet, vector<int> &ans, int currentPerson) {\\n        // Check and return whether if the answer is already calculated or not\\n        if (ans[currentPerson] >= 0) {\\n            return ans[currentPerson];\\n        }\\n        // Save at least person\\'s value itself in case that no richer and least loud person found in search\\n        ans[currentPerson] = currentPerson;\\n        for (auto child : graph[currentPerson]) {\\n            if (quiet[dfs(graph, quiet, ans, child)] < quiet[ans[currentPerson]]) {\\n                ans[currentPerson] = ans[child];\\n            }\\n        }\\n        return ans[currentPerson];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241019,
                "title": "python-topological-sort-solution",
                "content": "Thanks for the visit. Below is the code for the python solution with topological sort. Basically, I formed graph where the direction of edge is from the node with richer to the one that is less rich. I then performed simple topological sort where I updated each item\\'s corresponding quiettest and richer node. \\n\\n\\n\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        length = len(quiet)\\n        arr = [i for i in range(length)]\\n        indegree = [0 for _ in range(length)]\\n        graph = collections.defaultdict(list)\\n        dq = collections.deque([])\\n        \\n        for a, b in richer:\\n            # Note that the graph is uni-directional\\n            graph[a].append(b)\\n            indegree[b] += 1\\n\\n        for i in range(length):\\n            if not indegree[i]: \\n                dq.append(i)\\n    \\n        while dq:\\n            node = dq.popleft()\\n            \\n            for vertex in graph[node]:\\n                indegree[vertex] -= 1\\n                if quiet[arr[node]] < quiet[arr[vertex]]:\\n                    arr[vertex] = arr[node]\\n                if not indegree[vertex]:\\n                    dq.append(vertex)\\n        return arr\\n```\\n\\nThanks for the visit, and I appreciate any comments.",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        length = len(quiet)\\n        arr = [i for i in range(length)]\\n        indegree = [0 for _ in range(length)]\\n        graph = collections.defaultdict(list)\\n        dq = collections.deque([])\\n        \\n        for a, b in richer:\\n            # Note that the graph is uni-directional\\n            graph[a].append(b)\\n            indegree[b] += 1\\n\\n        for i in range(length):\\n            if not indegree[i]: \\n                dq.append(i)\\n    \\n        while dq:\\n            node = dq.popleft()\\n            \\n            for vertex in graph[node]:\\n                indegree[vertex] -= 1\\n                if quiet[arr[node]] < quiet[arr[vertex]]:\\n                    arr[vertex] = arr[node]\\n                if not indegree[vertex]:\\n                    dq.append(vertex)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021757,
                "title": "java-topological-sort",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        int[]res = new int[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            graph[i] = new ArrayList<>();\\n        Arrays.fill(res,-1);\\n        int[]indegree = new int[n];\\n        for(int[]edge : richer){\\n            graph[edge[0]].add(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0) q.add(i);\\n            res[i] = i;\\n        }\\n        while(!q.isEmpty()){\\n            int u = q.poll();\\n            for(int v : graph[u]){\\n                if(quiet[v]>quiet[u]){\\n                    quiet[v] = quiet[u];\\n                    res[v]=res[u];\\n                }\\n                indegree[v]--;\\n                if(indegree[v]==0) q.offer(v);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        int[]res = new int[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            graph[i] = new ArrayList<>();\\n        Arrays.fill(res,-1);\\n        int[]indegree = new int[n];\\n        for(int[]edge : richer){\\n            graph[edge[0]].add(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0) q.add(i);\\n            res[i] = i;\\n        }\\n        while(!q.isEmpty()){\\n            int u = q.poll();\\n            for(int v : graph[u]){\\n                if(quiet[v]>quiet[u]){\\n                    quiet[v] = quiet[u];\\n                    res[v]=res[u];\\n                }\\n                indegree[v]--;\\n                if(indegree[v]==0) q.offer(v);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731706,
                "title": "dfs-92ms-faster-than-96-05-bfs-kahn-algorithm-88ms-faster-than-98-03-topo-sort",
                "content": "Upvote if is\\'s helpful\\n\\nDFS:\\n\\n\\tclass Solution {\\n\\tpublic:\\n    \\n\\t\\tvector<vector<int>> graph;\\n\\t\\tvector<int> ans;\\n    \\n\\t\\tvoid dfs(int &current, vector<int> &quiet) {\\n        \\n\\t\\t\\tans[current] = current;\\n\\n\\t\\t\\tfor(auto &neighbour : graph[current]) {\\n\\t\\t\\t\\tif(ans[neighbour] == -1) \\n\\t\\t\\t\\t\\tdfs(neighbour, quiet);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(quiet[ans[current]] > quiet[ans[neighbour]])\\n\\t\\t\\t\\t\\tans[current] = ans[neighbour];\\n\\t\\t\\t}\\n        \\n\\t\\t}\\n    \\n\\t\\tvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\t\\t\\tint n = quiet.size();\\n\\t\\t\\tgraph.resize(n);\\n\\t\\t\\tans.resize(n, -1);\\n        \\n\\t\\t\\tfor(auto &pair : richer)\\n\\t\\t\\t\\tgraph[pair[1]].push_back(pair[0]);\\n        \\n\\t\\t\\tfor(int person = 0; person < n; person++) {\\n\\t\\t\\t\\tif(ans[person] == -1)\\n\\t\\t\\t\\t\\tdfs(person, quiet);\\n\\t\\t\\t}\\n        \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\nBFS Kahn algorithm:\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\n\\t\\tvector<vector<int>> graph;\\n\\t\\tvector<int> ans;\\n\\t\\tvector<int> in_degree;\\n    \\n\\t\\tvoid kahn(vector<int> &quiet) {\\n        \\n\\t\\t\\tqueue<int> adj;\\n        \\n\\t\\t\\tfor(int person = 0; person < ans.size(); person++) {\\n\\t\\t\\t\\tif(in_degree[person]==0) {\\n\\t\\t\\t\\t\\tadj.push(person);\\n\\t\\t\\t\\t\\tans[person] = person;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\twhile(!adj.empty()) {\\n\\t\\t\\t\\tint current = adj.front();\\n\\t\\t\\t\\tadj.pop();\\n            \\n\\t\\t\\t\\tfor(auto &child:graph[current]) {\\n\\t\\t\\t\\t\\tif(ans[child] == -1) \\n\\t\\t\\t\\t\\t\\tans[child] = child;\\n                \\n\\t\\t\\t\\t\\tif(quiet[ans[child]] > quiet[ans[current]])\\n\\t\\t\\t\\t\\t\\tans[child] = ans[current];\\n                \\n\\t\\t\\t\\t\\tin_degree[child]--;\\n\\t\\t\\t\\t\\tif(in_degree[child] == 0)\\n\\t\\t\\t\\t\\t\\tadj.push(child);\\n                \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n\\t\\tvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\t\\t\\tint n = quiet.size();\\n\\t\\t\\tgraph.resize(n);\\n\\t\\t\\tans.resize(n, -1);\\n\\t\\t\\tin_degree.resize(n);\\n        \\n\\t\\t\\tfor(auto &pair : richer){\\n\\t\\t\\t\\tgraph[pair[0]].push_back(pair[1]);\\n\\t\\t\\t\\tin_degree[pair[1]]++;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tkahn(quiet);\\n\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n\\t\\tvector<vector<int>> graph;\\n\\t\\tvector<int> ans;\\n    \\n\\t\\tvoid dfs(int &current, vector<int> &quiet) {\\n        \\n\\t\\t\\tans[current] = current;\\n\\n\\t\\t\\tfor(auto &neighbour : graph[current]) {\\n\\t\\t\\t\\tif(ans[neighbour] == -1) \\n\\t\\t\\t\\t\\tdfs(neighbour, quiet);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(quiet[ans[current]] > quiet[ans[neighbour]])\\n\\t\\t\\t\\t\\tans[current] = ans[neighbour];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 707952,
                "title": "python-3-dfs-recursive-solution",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        @lru_cache(None)\\n        def dfs(node):\\n            if node not in graph:\\n                return node\\n            minimum = node\\n            for neighbour in graph[node]:\\n                candidate = dfs(neighbour)\\n                if quiet[minimum] > quiet[candidate]:\\n                    minimum = candidate \\n            return minimum  \\n        n = len(quiet)\\n        graph = defaultdict(list)\\n        for u , v in richer:\\n            graph[v].append(u)\\n        return list(map(dfs , range(n)))\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        @lru_cache(None)\\n        def dfs(node):\\n            if node not in graph:\\n                return node\\n            minimum = node\\n            for neighbour in graph[node]:\\n                candidate = dfs(neighbour)\\n                if quiet[minimum] > quiet[candidate]:\\n                    minimum = candidate \\n            return minimum  \\n        n = len(quiet)\\n        graph = defaultdict(list)\\n        for u , v in richer:\\n            graph[v].append(u)\\n        return list(map(dfs , range(n)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725152,
                "title": "easy-c-topo-sort-solution-with-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        int n = q.size();\\n        vector<int> adj[n];\\n        vector<int> ind(n,0);\\n        for(auto it:r)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int> qu;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i] == 0)\\n            qu.push(i);\\n            ans[i]=i;\\n        }\\n        while(!qu.empty())\\n        {\\n            int node = qu.front();\\n            qu.pop();\\n            for(auto it:adj[node])\\n            {\\n                if(q[node]<q[it])\\n                {\\n                    q[it]=q[node];\\n                    ans[it]=ans[node];\\n                }\\n                ind[it]--;\\n                if(ind[it] == 0)\\n                qu.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        int n = q.size();\\n        vector<int> adj[n];\\n        vector<int> ind(n,0);\\n        for(auto it:r)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int> qu;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i] == 0)\\n            qu.push(i);\\n            ans[i]=i;\\n        }\\n        while(!qu.empty())\\n        {\\n            int node = qu.front();\\n            qu.pop();\\n            for(auto it:adj[node])\\n            {\\n                if(q[node]<q[it])\\n                {\\n                    q[it]=q[node];\\n                    ans[it]=ans[node];\\n                }\\n                ind[it]--;\\n                if(ind[it] == 0)\\n                qu.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618768,
                "title": "c-easy-to-understand-dfs-2-approaches",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<vector<int> > &graph,vector<int> quiet,vector<int> &ans)\\n    {\\n        if(ans[node]!=-1)\\n        return ans[node];\\n        else\\n        {\\n        //storing the node\\'s value as ans for the time being\\n        ans[node]=node;\\n        for(auto child:graph[node])\\n        {\\n            //finding the minimum quitenss for the child connected to the node and storing the ans for the child to the ans for the node(if quitesness of node is not lesser than that)\\n            if(quiet[dfs(child,graph,quiet,ans)]<quiet[ans[node]])\\n            {\\n                ans[node]=ans[child];\\n            }\\n        }\\n        }\\n        return ans[node];\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //constructing the graph\\n        int n=quiet.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            graph[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            //calling dfs func. for each of the nodes\\n            dfs(i,graph,quiet,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Using topological sort**\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> indegree(n,0);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        ans[i]=i;\\n        vector<vector<int> > graph(n);\\n        for(auto &x:richer)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int element=q.front();\\n            q.pop();\\n            for(int node:graph[element])\\n            {\\n                if(quiet[ans[node]]>quiet[ans[element]])\\n                {\\n                    ans[node]=ans[element];\\n                }\\n                indegree[node]--;\\n                if(indegree[node]==0)\\n                q.push(node);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<vector<int> > &graph,vector<int> quiet,vector<int> &ans)\\n    {\\n        if(ans[node]!=-1)\\n        return ans[node];\\n        else\\n        {\\n        //storing the node\\'s value as ans for the time being\\n        ans[node]=node;\\n        for(auto child:graph[node])\\n        {\\n            //finding the minimum quitenss for the child connected to the node and storing the ans for the child to the ans for the node(if quitesness of node is not lesser than that)\\n            if(quiet[dfs(child,graph,quiet,ans)]<quiet[ans[node]])\\n            {\\n                ans[node]=ans[child];\\n            }\\n        }\\n        }\\n        return ans[node];\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //constructing the graph\\n        int n=quiet.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            graph[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            //calling dfs func. for each of the nodes\\n            dfs(i,graph,quiet,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> indegree(n,0);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        ans[i]=i;\\n        vector<vector<int> > graph(n);\\n        for(auto &x:richer)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int element=q.front();\\n            q.pop();\\n            for(int node:graph[element])\\n            {\\n                if(quiet[ans[node]]>quiet[ans[element]])\\n                {\\n                    ans[node]=ans[element];\\n                }\\n                indegree[node]--;\\n                if(indegree[node]==0)\\n                q.push(node);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588417,
                "title": "java-dfs-topological-sort-using-adjacency-list-in-o-n-time",
                "content": "Runtime: 9 ms, faster than 61.89% of Java online submissions for Loud and Rich.\\nMemory Usage: 61.6 MB, less than 16.78% of Java online submissions for Loud and Rich.\\n\\n\\n\\n```\\n// Time O(N)\\n// Space O(N)\\n\\nclass Solution {\\n    \\n     List<Integer>[] graph;\\n         \\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        int n = quiet.length;\\n        if(quiet == null || n == 0) return new int[0];\\n        \\n        //initialize graph with adjacency list\\n        graph = new ArrayList[n];\\n        \\n         for(int node = 0; node < graph.length; node++)\\n            graph[node] = new ArrayList<>();\\n        \\n        //build graph: poor -> rich\\n        for(int i = 0; i < richer.length; i++){\\n            graph[richer[i][1]].add(richer[i][0]);\\n        }\\n        \\n        //answer array\\n        int[] answer = new int[n];\\n        Arrays.fill(answer, -1);\\n        \\n        \\n        for(int i = 0; i < n; i++){\\n            dfs(i, answer, quiet);\\n        }\\n        return answer;\\n\\n    }\\n    \\n    \\n    public int dfs(int node, int[] answer, int[] quiet){\\n        \\n        //filling result array with -1 initially will avoid repetion here\\n        if (answer[node] == -1){\\n            answer[node] = node;\\n            \\n            //depthwise check for every richer person if they are quieter\\n            for (int child: graph[node]){\\n                \\n                int curr = dfs(child, answer, quiet);\\n                \\n                //quieter person\\n                if (quiet[curr] < quiet[answer[node]])\\n                    answer[node] = curr;\\n            }\\n        }\\n        return answer[node];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n    \\n     List<Integer>[] graph;\\n         \\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        int n = quiet.length;\\n        if(quiet == null || n == 0) return new int[0];\\n        \\n        //initialize graph with adjacency list\\n        graph = new ArrayList[n];\\n        \\n         for(int node = 0; node < graph.length; node++)\\n            graph[node] = new ArrayList<>();\\n        \\n        //build graph: poor -> rich\\n        for(int i = 0; i < richer.length; i++){\\n            graph[richer[i][1]].add(richer[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1548347,
                "title": "both-bfs-and-dfs-solution-c-crystal-clear-code",
                "content": "# Approach 1: using DFS \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>>& adj, vector<int>& quiet, vector<int>& ans, int node) {\\n        if(ans[node] != -1) return ans[node];\\n        \\n        ans[node] = node;\\n        for(auto& adjnode : adj[node]) {\\n            int ans_adjnode = dfs(adj, quiet, ans, adjnode);\\n            \\n            if(quiet[ans_adjnode] < quiet[ans[node]]) {\\n                ans[node] = ans_adjnode;\\n            }\\n        }\\n        \\n        return ans[node];\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        vector<vector<int>> adj(n);\\n\\n        for(auto& rich : richer) {\\n            adj[rich[1]].push_back(rich[0]);\\n        }\\n        \\n        vector<int> answer(n, -1);\\n        \\n        for(int i=0; i<n; i++) {\\n            if(answer[i] == -1)\\n                dfs(adj, quiet, answer, i);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\n# Approach 2 : using BFS (Topo Sort)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        for(auto& rich : richer) {\\n            adj[rich[0]].push_back(rich[1]);\\n            indegree[rich[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> answer(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            answer[i] = i;\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        while(q.size()) {\\n            int node = q.front(); q.pop();\\n            \\n            for(auto& adjNode : adj[node]) {\\n                if(quiet[answer[adjNode]] > quiet[answer[node]]) {\\n                    answer[adjNode] = answer[node];\\n                }\\n                \\n                indegree[adjNode]--;\\n                if(indegree[adjNode] == 0) q.push(adjNode);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>>& adj, vector<int>& quiet, vector<int>& ans, int node) {\\n        if(ans[node] != -1) return ans[node];\\n        \\n        ans[node] = node;\\n        for(auto& adjnode : adj[node]) {\\n            int ans_adjnode = dfs(adj, quiet, ans, adjnode);\\n            \\n            if(quiet[ans_adjnode] < quiet[ans[node]]) {\\n                ans[node] = ans_adjnode;\\n            }\\n        }\\n        \\n        return ans[node];\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        vector<vector<int>> adj(n);\\n\\n        for(auto& rich : richer) {\\n            adj[rich[1]].push_back(rich[0]);\\n        }\\n        \\n        vector<int> answer(n, -1);\\n        \\n        for(int i=0; i<n; i++) {\\n            if(answer[i] == -1)\\n                dfs(adj, quiet, answer, i);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        for(auto& rich : richer) {\\n            adj[rich[0]].push_back(rich[1]);\\n            indegree[rich[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> answer(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            answer[i] = i;\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        while(q.size()) {\\n            int node = q.front(); q.pop();\\n            \\n            for(auto& adjNode : adj[node]) {\\n                if(quiet[answer[adjNode]] > quiet[answer[node]]) {\\n                    answer[adjNode] = answer[node];\\n                }\\n                \\n                indegree[adjNode]--;\\n                if(indegree[adjNode] == 0) q.push(adjNode);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310921,
                "title": "easy-c-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n=quiet.size();\\n        vector<int> res(n,-1);\\n        //create a adjacency list\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            //make a directed edge from richer[i][1] to richer[i][0]\\n            //because richer[i][1] is richer than richer[i][0] and also we can explore\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(res[i]==-1)\\n            {\\n                //if it has not been calculated yet\\n                dfs(i,adj,res,quiet);\\n            }\\n        }\\n        return res;\\n    }\\n    int dfs(int person,vector<vector<int>>& adj,vector<int>& res,vector<int>& quiet)\\n    {\\n        int minPerson=person;\\n        for(auto rich:adj[person])\\n        {\\n            if(res[rich]!=-1)\\n            {\\n                //if it has already calculated\\n                if(quiet[res[rich]] < quiet[minPerson])\\n                {\\n                    minPerson=res[rich];\\n                }\\n            }\\n            else{\\n                int somePerson=dfs(rich,adj,res,quiet);\\n                if(quiet[somePerson] < quiet[minPerson])\\n                {\\n                    minPerson=somePerson;\\n                }\\n            } \\n               \\n        }\\n        res[person]=minPerson;\\n        return minPerson;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n=quiet.size();\\n        vector<int> res(n,-1);\\n        //create a adjacency list\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            //make a directed edge from richer[i][1] to richer[i][0]\\n            //because richer[i][1] is richer than richer[i][0] and also we can explore\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(res[i]==-1)\\n            {\\n                //if it has not been calculated yet\\n                dfs(i,adj,res,quiet);\\n            }\\n        }\\n        return res;\\n    }\\n    int dfs(int person,vector<vector<int>>& adj,vector<int>& res,vector<int>& quiet)\\n    {\\n        int minPerson=person;\\n        for(auto rich:adj[person])\\n        {\\n            if(res[rich]!=-1)\\n            {\\n                //if it has already calculated\\n                if(quiet[res[rich]] < quiet[minPerson])\\n                {\\n                    minPerson=res[rich];\\n                }\\n            }\\n            else{\\n                int somePerson=dfs(rich,adj,res,quiet);\\n                if(quiet[somePerson] < quiet[minPerson])\\n                {\\n                    minPerson=somePerson;\\n                }\\n            } \\n               \\n        }\\n        res[person]=minPerson;\\n        return minPerson;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403311,
                "title": "standard-python-bfs-solution-similar-to-topological-sorting",
                "content": "```\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n = len(quiet)\\n        answer = n * [-1]\\n\\t\\t# create a directed graph\\n        pre, suc = [set() for _ in range(n)], [set() for _ in range(n)]\\n        indegree = n * [0]\\n        for x, y in richer:\\n            suc[x].add(y)\\n            pre[y].add(x)\\n            indegree[y] += 1\\n        # visit the sources (richest people) first\\n        curr_level = {x for x in range(n) if indegree[x] == 0}\\n        for x in curr_level:\\n            answer[x] = x\\n        while curr_level:\\n            next_level = set()\\n            for x in curr_level:\\n                for y in suc[x]:\\n                    indegree[y] -= 1\\n                    # new level of sources after removing the previous sources\\n                    if indegree[y] == 0: \\n                        answer[y] = y\\n                        for p in pre[y]:\\n                            if quiet[answer[p]] < quiet[answer[y]]:\\n                                answer[y] = answer[p]\\n                        next_level.add(y)\\n            curr_level = next_level\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n = len(quiet)\\n        answer = n * [-1]\\n\\t\\t# create a directed graph\\n        pre, suc = [set() for _ in range(n)], [set() for _ in range(n)]\\n        indegree = n * [0]\\n        for x, y in richer:\\n            suc[x].add(y)\\n            pre[y].add(x)\\n            indegree[y] += 1\\n        # visit the sources (richest people) first\\n        curr_level = {x for x in range(n) if indegree[x] == 0}\\n        for x in curr_level:\\n            answer[x] = x\\n        while curr_level:\\n            next_level = set()\\n            for x in curr_level:\\n                for y in suc[x]:\\n                    indegree[y] -= 1\\n                    # new level of sources after removing the previous sources\\n                    if indegree[y] == 0: \\n                        answer[y] = y\\n                        for p in pre[y]:\\n                            if quiet[answer[p]] < quiet[answer[y]]:\\n                                answer[y] = answer[p]\\n                        next_level.add(y)\\n            curr_level = next_level\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3556523,
                "title": "python-3-8-lines-cached-dfs-t-m-74-44",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \\n        n = len(quiet)\\n        g, f = defaultdict(list), lambda x: list(map(dfs,x)) \\n        for u, v in richer: g[v].append(u)\\n\\n        @lru_cache(2000)\\n        def dfs(node):\\n            return min(((f(g[node]))+[node]), key=lambda x:quiet[x])\\n        \\n        return f(range(n))\\n```\\n[https://leetcode.com/problems/loud-and-rich/submissions/955947460/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*+*R*) and space complexity is *O*(*N*+*R*) in which *N* ~`len(quiet)`and *R* ~`len(richer)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \\n        n = len(quiet)\\n        g, f = defaultdict(list), lambda x: list(map(dfs,x)) \\n        for u, v in richer: g[v].append(u)\\n\\n        @lru_cache(2000)\\n        def dfs(node):\\n            return min(((f(g[node]))+[node]), key=lambda x:quiet[x])\\n        \\n        return f(range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241793,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[],int node,vector<int>& vis,int& ans,int& mini,vector<int>& quiet){\\n        vis[node] = 1;\\n        if(quiet[node]<mini){\\n            mini = quiet[node];\\n            ans = node;\\n        }\\n        \\n        for(auto it : adj[node]){\\n            if(!vis[it]){\\n                dfs(adj,it,vis,ans,mini,quiet);\\n            }\\n        }\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        for(auto it : richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i = 0;i<n;i++){\\n            vector<int> vis(n,0);\\n            int mini = INT_MAX;\\n            dfs(adj,i,vis,ans[i],mini,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[],int node,vector<int>& vis,int& ans,int& mini,vector<int>& quiet){\\n        vis[node] = 1;\\n        if(quiet[node]<mini){\\n            mini = quiet[node];\\n            ans = node;\\n        }\\n        \\n        for(auto it : adj[node]){\\n            if(!vis[it]){\\n                dfs(adj,it,vis,ans,mini,quiet);\\n            }\\n        }\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        for(auto it : richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i = 0;i<n;i++){\\n            vector<int> vis(n,0);\\n            int mini = INT_MAX;\\n            dfs(adj,i,vis,ans[i],mini,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528688,
                "title": "c-using-topological-sorting",
                "content": "class Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n      \\n\\t  //Use TopoSort\\n       \\n        //n->no of person\\n        int n=quiet.size();\\n        \\n        //stores ans\\n        vector<int> ans(n);\\n        \\n        //initially let no one is poor than other\\n        for(int i=0;i<n;i++) ans[i]=i;\\n      \\n        \\n   \\n        vector<int> adj[n];\\n        \\n        \\n        //outdegree out[i] rep no of people richer than ith person\\n        vector<int> out(n,0);\\n        \\n        for(auto x:richer)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            out[x[1]]++;\\n            \\n            \\n        }\\n        \\n        queue<int> q;\\n        \\n        \\n        for(int i=0;i<n;i++) if(out[i]==0) q.push(i);\\n        \\n        \\n        while(!q.empty())\\n        {\\n            \\n            int u=q.front();\\n            q.pop();\\n           \\n            \\n            //trav neighbour of richer person u ,and updating the least quiet person for its adj node.\\n            for(auto x:adj[u])\\n            { \\n                 if(quiet[ans[x]]>quiet[ans[u]])\\n                {\\n                    ans[x]=ans[u];\\n                }\\n                \\n                //if out[x]==0, means there is no reacher person than this,so we processs it\\n               if(--out[x]==0) q.push(x);\\n                \\n            }\\n            \\n            \\n        }\\n        \\n         \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n      \\n\\t  //Use TopoSort\\n       \\n        //n->no of person\\n        int n=quiet.size();\\n        \\n        //stores ans\\n        vector<int> ans(n);\\n        \\n        //initially let no one is poor than other\\n        for(int i=0;i<n;i++) ans[i]=i;\\n      \\n        \\n   \\n        vector<int> adj[n];\\n        \\n        \\n        //outdegree out[i] rep no of people richer than ith person\\n        vector<int> out(n,0);\\n        \\n        for(auto x:richer)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            out[x[1]]++;\\n            \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1430693,
                "title": "topological-sort-c",
                "content": "```\\n vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n         int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        \\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n       \\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                \\n                if(quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                indg[i]--;\\n                if(indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\n vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n         int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        \\n        \\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n       \\n       \\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            \\n            for(int i : g[curr]){\\n                \\n                if(quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                indg[i]--;\\n                if(indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1358548,
                "title": "c-indegree-count-solution",
                "content": "Runtime: 92 ms, faster than 91.59% of C++ online submissions for Loud and Rich.\\nMemory Usage: 42.6 MB, less than 72.74% of C++ online submissions for Loud and Rich.\\n\\n```\\nIn this problem we have to find the least quiet person who is more or equal reacher than anyone.\\nSo we make edge list of each person from richer array such that edgelist[richer[i][0]] contains richer[i][1]\\nmeans there is a directed edge between richer to poorer person.\\n\\nWe solve the problem using Indegree count. First we populate result vector with own index as it handle \\nthe case for nodes with Indegree count 0 automatically. Then we create the edge list of nodes from richer\\nvector and also update the result vector of richer[i][1] if quiet[result[richer[i][0]]]<quiet[result[richer[i][1]]].\\nThis automatically handles the result of neighbor nodes\\' of Indegree count 0 nodes.\\n\\nThen we populate the Max Priority Queue with nodes and Indegree count pair for nodes Indegree > 0. As \\nwe can see that higher Indegree count nodes will have impact on lower Indegree count nodes. So, we take\\nthe top node of Max Priority Queue and update its neighbor nodes result if current nodes\\' quiteness is less\\nthan the neighbor nodes\\' quiteness and continue until queue is empty.\\n\\nExample:\\nInput: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\\nOutput: [5,5,2,5,4,5,6,7]\\n\\nBelow is the simulation of solution:\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f2e1a1fc-cabd-44f3-acfb-50d804bc25c7_1627103373.6610482.png)\\n\\n![image](https://assets.leetcode.com/users/images/30c4140d-d700-4f58-b171-642ded1bbfd6_1627103656.4510098.png)\\n\\n![image](https://assets.leetcode.com/users/images/cd0a0d30-713f-49a3-9973-5de71ed3fb46_1627106387.578677.png)\\n\\n![image](https://assets.leetcode.com/users/images/32dee1bf-6d96-4d36-9f99-42ea41a26fde_1627106396.6677387.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        // track Indegree count of nodes\\n        vector<int>indegree(n,0);\\n        \\n        // make adjacent list of nodes where a directed edge from richer to poorer person  \\n        vector<vector<int>>edges(n);\\n        \\n        // result vector containing answer\\n        vector<int>result(n);\\n        \\n        // Max priority queue of node and indegree count\\n        // Insert weight Indegree count as first element \\n        priority_queue<pair<int,int>> pQ;\\n\\n        // make default result each person as their own index\\n        for(int i=0;i<n;i++)\\n            result[i]=i;\\n        \\n        // populate the edgelist and update result based on result \\n        // also count the indegree count of node richer[i][1] from righer vector\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            edges[richer[i][0]].push_back(richer[i][1]);\\n            indegree[richer[i][1]]++;\\n            if(quiet[result[richer[i][0]]]<quiet[result[richer[i][1]]])\\n                result[richer[i][1]] = result[richer[i][0]];\\n        }\\n        \\n        // populate the priority queue for nodes with Indegree count > 0\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]>0)\\n                pQ.push(make_pair(indegree[i],i));  //pair {indegree count, node}\\n        }\\n        \\n        int node;\\n        \\n        // process all nodes in priortiy queue\\n        while(!pQ.empty())\\n        {            \\n            node = pQ.top().second;\\n            pQ.pop();\\n\\n            // update result of all neighbor nodes if current node\\'s quiteness is lower\\n            for(int j=0;j<edges[node].size();j++)\\n            {\\n                if(quiet[result[node]]<quiet[result[edges[node][j]]])\\n                    result[edges[node][j]] = result[node];\\n            }\\n        }\\n                                   \\n        return result;                                   \\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nIn this problem we have to find the least quiet person who is more or equal reacher than anyone.\\nSo we make edge list of each person from richer array such that edgelist[richer[i][0]] contains richer[i][1]\\nmeans there is a directed edge between richer to poorer person.\\n\\nWe solve the problem using Indegree count. First we populate result vector with own index as it handle \\nthe case for nodes with Indegree count 0 automatically. Then we create the edge list of nodes from richer\\nvector and also update the result vector of richer[i][1] if quiet[result[richer[i][0]]]<quiet[result[richer[i][1]]].\\nThis automatically handles the result of neighbor nodes\\' of Indegree count 0 nodes.\\n\\nThen we populate the Max Priority Queue with nodes and Indegree count pair for nodes Indegree > 0. As \\nwe can see that higher Indegree count nodes will have impact on lower Indegree count nodes. So, we take\\nthe top node of Max Priority Queue and update its neighbor nodes result if current nodes\\' quiteness is less\\nthan the neighbor nodes\\' quiteness and continue until queue is empty.\\n\\nExample:\\nInput: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\\nOutput: [5,5,2,5,4,5,6,7]\\n\\nBelow is the simulation of solution:\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n        \\n        // track Indegree count of nodes\\n        vector<int>indegree(n,0);\\n        \\n        // make adjacent list of nodes where a directed edge from richer to poorer person  \\n        vector<vector<int>>edges(n);\\n        \\n        // result vector containing answer\\n        vector<int>result(n);\\n        \\n        // Max priority queue of node and indegree count\\n        // Insert weight Indegree count as first element \\n        priority_queue<pair<int,int>> pQ;\\n\\n        // make default result each person as their own index\\n        for(int i=0;i<n;i++)\\n            result[i]=i;\\n        \\n        // populate the edgelist and update result based on result \\n        // also count the indegree count of node richer[i][1] from righer vector\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            edges[richer[i][0]].push_back(richer[i][1]);\\n            indegree[richer[i][1]]++;\\n            if(quiet[result[richer[i][0]]]<quiet[result[richer[i][1]]])\\n                result[richer[i][1]] = result[richer[i][0]];\\n        }\\n        \\n        // populate the priority queue for nodes with Indegree count > 0\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]>0)\\n                pQ.push(make_pair(indegree[i],i));  //pair {indegree count, node}\\n        }\\n        \\n        int node;\\n        \\n        // process all nodes in priortiy queue\\n        while(!pQ.empty())\\n        {            \\n            node = pQ.top().second;\\n            pQ.pop();\\n\\n            // update result of all neighbor nodes if current node\\'s quiteness is lower\\n            for(int j=0;j<edges[node].size();j++)\\n            {\\n                if(quiet[result[node]]<quiet[result[edges[node][j]]])\\n                    result[edges[node][j]] = result[node];\\n            }\\n        }\\n                                   \\n        return result;                                   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665959,
                "title": "cpp-dfs",
                "content": "Runtime: 220 ms, faster than 51.85% of C++ online submissions for Loud and Rich.\\nMemory Usage: 43.1 MB, less than 100.00% of C++ online submissions for Loud and Rich.Rich.\\n    Explanation : \\nwe will create a map where value vector will have all the people having more money than key\\nnow if there\\'s no value found for any key i then output at i will be i because no one has more money than i\\n    if there\\'s value vector present we will find the the output for all the vector elements(people rich than current index)\\n        and then whoever is most quite among them will be my output\\nexample:\\nfor the given example 1 the map will be :\\n0 -> 1\\n1 ->2,3\\n3->4,5,6\\n7->3\\noutput of 2,4,5,6 will be 2,4,5,6 as no one\\'s rich than themselves \\n    for 0 we will find whether 0 is quite or 1 now again for one we will find output for 2,3 and 2 will be 2 but 3 we will agian find value for 4,5,6(because if 3 is rich than 1 and 4 is rich than 3 then 4 is rich than 1) which is 4,5,6 and quite among them is 5 and ans of 5 will be 5 and ans for 1 quite among ans 1,2,5 is 5 and so on\\n```\\n    class Solution {\\n    void dfs( unordered_map<int,vector<int>>& moreMoneyThanMe,vector<int>& quiet, , vector<int>& output, int i, int n){\\n        if(output[i] != -1){\\n            return;\\n        }\\n        int it;\\n        if(moreMoneyThanMe.find(i) == moreMoneyThanMe.end()){\\n            output[i] = i;\\n            return;\\n        }\\n        int min_ = quiet[i]; int ans = i;\\n        for(it = 0; it < moreMoneyThanMe[i].size(); it++){\\n            dfs(moreMoneyThanMe,quiet,output,moreMoneyThanMe[i][it],n);\\n            if(min_ > quiet[output[moreMoneyThanMe[i][it]]]){\\n                min_ = quiet[output[moreMoneyThanMe[i][it]]];\\n                ans = output[moreMoneyThanMe[i][it]];\\n            }\\n        }\\n        output[i] = ans;\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>> moreMoneyThanMe;\\n        int n = quiet.size();\\n        vector<int> output(n,-1);\\n        int i;\\n        for(i = 0; i < richer.size(); i++){\\n            moreMoneyThanMe[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(i = 0; i < n; i++){\\n            if(output[i] == -1){\\n                dfs(moreMoneyThanMe,quiet,output,i,n);\\n            }\\n        }\\n        return output;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    void dfs( unordered_map<int,vector<int>>& moreMoneyThanMe,vector<int>& quiet, , vector<int>& output, int i, int n){\\n        if(output[i] != -1){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 138830,
                "title": "python-topology-sort-solution",
                "content": "Richer can be used to construct a directed graph. Start with the richest, i.e.; nodes without outward edges. For these nodes x, answer[x] = x since there is no y such that y is richer than x. Then for node y that has outward edges to [xi], xi being one of the richest nodes, answer[y] = z where z is some xi having the smallest quiet value among [xi], then this answer can be used in a new iteration to calculate answer for nodes with outward edges to [yi].  \\n```\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        qs = [-1] * len(quiet)\\n        d = {}\\n        for r in richer:\\n            if r[1] not in d:\\n                d[r[1]] = [r[0]]\\n            else:\\n                d[r[1]].append(r[0])\\n        \\n        for i in range(len(quiet)):\\n            if i not in d:\\n                qs[i] = quiet[i]\\n        g = {}\\n        for q in enumerate(quiet):\\n            g[q[1]] = q[0]\\n        \\n        while d:\\n            for k in d.keys():\\n                m = min(list(map(lambda x: qs[x], d[k]))) if d[k] else -1 \\n                if m == -1:\\n                    continue\\n                qs[k] = min(m, quiet[k])\\n                d.pop(k, None)\\n        return map(lambda x: g[x], qs)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        qs = [-1] * len(quiet)\\n        d = {}\\n        for r in richer:\\n            if r[1] not in d:\\n                d[r[1]] = [r[0]]\\n            else:\\n                d[r[1]].append(r[0])\\n        \\n        for i in range(len(quiet)):\\n            if i not in d:\\n                qs[i] = quiet[i]\\n        g = {}\\n        for q in enumerate(quiet):\\n            g[q[1]] = q[0]\\n        \\n        while d:\\n            for k in d.keys():\\n                m = min(list(map(lambda x: qs[x], d[k]))) if d[k] else -1 \\n                if m == -1:\\n                    continue\\n                qs[k] = min(m, quiet[k])\\n                d.pop(k, None)\\n        return map(lambda x: g[x], qs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138125,
                "title": "dfs-with-memory",
                "content": "```\\nclass Solution {\\n    unordered_map<int, set<int>> mp;\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for(int i = 0; i < richer.size(); i++)\\n            mp[richer[i][1]].insert(richer[i][0]);\\n        vector<int> ans(quiet.size(), -1);\\n        for(int i = 0; i < quiet.size(); i++)\\n            if(ans[i] == -1) lookFor(ans, quiet, i);\\n        return ans;\\n    }\\n    void lookFor(vector<int>& ans, vector<int>& quiet, int person){\\n        int man = person;\\n        int noise = quiet[person];\\n        for(int target : mp[person]){\\n            if(ans[target] == -1) lookFor(ans, quiet, target);\\n            if(quiet[ans[target]] < noise){\\n                noise = quiet[ans[target]];\\n                man = ans[target];\\n            }\\n        }\\n        ans[person] = man;\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<int, set<int>> mp;\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for(int i = 0; i < richer.size(); i++)\\n            mp[richer[i][1]].insert(richer[i][0]);\\n        vector<int> ans(quiet.size(), -1);\\n        for(int i = 0; i < quiet.size(); i++)\\n            if(ans[i] == -1) lookFor(ans, quiet, i);\\n        return ans;\\n    }\\n    void lookFor(vector<int>& ans, vector<int>& quiet, int person){\\n        int man = person;\\n        int noise = quiet[person];\\n        for(int target : mp[person]){\\n            if(ans[target] == -1) lookFor(ans, quiet, target);\\n            if(quiet[ans[target]] < noise){\\n                noise = quiet[ans[target]];\\n                man = ans[target];\\n            }\\n        }\\n        ans[person] = man;\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137943,
                "title": "easy-and-readable-dfs-with-memorilization",
                "content": "```\\nclass Solution {\\n    int[] res;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for (int[] row : richer) {\\n            map.putIfAbsent(row[1], new ArrayList<Integer>());\\n            map.get(row[1]).add(row[0]);\\n        }\\n        res = new int[quiet.length];\\n        Arrays.fill(res, -1);\\n        for (int i = 0; i < quiet.length; i++) {\\n            res[i] = dfs(map, i, quiet);\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(HashMap<Integer, List<Integer>> adj, int i, int[] quiet) {\\n        if (res[i] != -1) return res[i];\\n        List<Integer> list = adj.get(i);\\n        res[i] = i;\\n        if (adj.get(i) != null) {\\n            for (int elem : adj.get(i)) {\\n                int n = dfs(adj, elem, quiet);\\n                if (quiet[n] < quiet[res[i]]) res[i] = n;\\n            }\\n        }\\n        return res[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] res;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for (int[] row : richer) {\\n            map.putIfAbsent(row[1], new ArrayList<Integer>());\\n            map.get(row[1]).add(row[0]);\\n        }\\n        res = new int[quiet.length];\\n        Arrays.fill(res, -1);\\n        for (int i = 0; i < quiet.length; i++) {\\n            res[i] = dfs(map, i, quiet);\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(HashMap<Integer, List<Integer>> adj, int i, int[] quiet) {\\n        if (res[i] != -1) return res[i];\\n        List<Integer> list = adj.get(i);\\n        res[i] = i;\\n        if (adj.get(i) != null) {\\n            for (int elem : adj.get(i)) {\\n                int n = dfs(adj, elem, quiet);\\n                if (quiet[n] < quiet[res[i]]) res[i] = n;\\n            }\\n        }\\n        return res[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864688,
                "title": "dp-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the quietest person each person knows within a social network represented as a directed graph. To find the quietest person a particular person p knows, we can traverse the social network starting from p and recursively find the quietest person among p\\'s neighbors. We will use depth-first search (DFS) to achieve this.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We can implement a recursive DFS function dfs(node, adj, quiet) that takes a person node, the adjacency list adj representing the social network, and the quiet vector representing the quietness levels of all people.\\n2. Within the dfs function, we will check if the quietest person for node has already been calculated and stored in the dp array (dynamic programming memoization). If it has, we return that value.\\n3. If the quietest person for node has not been calculated yet, we initialize miniVal to the quietness level of the current person node and miniNode to node. We then loop through all the neighbors of node (i.e., the people node knows) using the adjacency list adj.\\n4. For each neighbor, we recursively call the dfs function to find the quietest person that the neighbor knows. We update miniVal and miniNode if the quietness level of the neighbor is smaller than the current miniVal.\\n5. Finally, we return miniNode as the quietest person that node knows and store this value in the dp array for future use.\\n6. In the loudAndRich function, we initialize the dp array to store the results of the DFS to avoid redundant computations. We also create the adjacency list adj using the richer vector. For each person i in the network, we call the dfs function to find the quietest person that i knows and store the result in the ans\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe DFS function dfs is called once for each person in the network, and within each call, we may visit each neighbor once. Hence, the time complexity is O(N + E), where N is the number of people and E is the number of edges in the social network (richer relationships).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n We use additional space for the dp array, the adjacency list adj, and the ans vector. The space complexity is O(N + E) for the adjacency list and O(N) for the dp array and ans vector, resulting in a total space complexity of O(N + E).\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){\\n        if(dp[node]!=-1) return dp[node];\\n\\n        int miniVal  = quiet[node]; // if there is no outgoing edge from the node\\n        // then the node is the quitiest person he knows who is as rich \\n        // as him \\n        int miniNode = node;\\n        // stores the node with the properties\\n\\n        for(auto it:adj[node]){\\n            int miniIndex = dfs(it,adj,quiet);// do a dfs traversal for all the\\n            // adjNode\\n            if(quiet[miniIndex] < miniVal){\\n                miniVal = quiet[miniIndex];\\n                miniNode = miniIndex;\\n            } \\n\\n        }\\n\\n        return dp[node] = miniNode;        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        dp.resize(n,-1);\\n        vector<vector<int>>adj(n);\\n        vector<int>ans;\\n        for(auto it: richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        for(int i =0;i<n;i++){\\n            int res = dfs(i,adj,quiet);\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){\\n        if(dp[node]!=-1) return dp[node];\\n\\n        int miniVal  = quiet[node]; // if there is no outgoing edge from the node\\n        // then the node is the quitiest person he knows who is as rich \\n        // as him \\n        int miniNode = node;\\n        // stores the node with the properties\\n\\n        for(auto it:adj[node]){\\n            int miniIndex = dfs(it,adj,quiet);// do a dfs traversal for all the\\n            // adjNode\\n            if(quiet[miniIndex] < miniVal){\\n                miniVal = quiet[miniIndex];\\n                miniNode = miniIndex;\\n            } \\n\\n        }\\n\\n        return dp[node] = miniNode;        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        dp.resize(n,-1);\\n        vector<vector<int>>adj(n);\\n        vector<int>ans;\\n        for(auto it: richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        for(int i =0;i<n;i++){\\n            int res = dfs(i,adj,quiet);\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491512,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            for(int i : g[curr]){\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        graph = defaultdict(list)\\n        for a, b in richer:\\n            graph[b].append(a)\\n        \\n        n = len(quiet)\\n        answer = [i for i in range(n)]\\n\\n        seen = set()\\n        \\n        def dfs(x, seen, answer):\\n            seen.add(x)\\n            for y in graph[x]:\\n                if y not in seen:\\n                    dfs(y, seen, answer)\\n                temp = answer[x]\\n                if quiet[temp] > quiet[answer[y]]:\\n                    answer[x] = answer[y]\\n        \\n        for i in range(n):\\n            if i not in seen:\\n                dfs(i, seen, answer)\\n\\n        return answer\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        int[] res = new int[n];\\n        for(int i=0; i<n; i++){\\n            res[i] = i;\\n        }\\n        boolean changed = true;\\n        while(changed){\\n            changed = false;\\n            for(int[] rich : richer){\\n                if(quiet[res[rich[0]]] < quiet[res[rich[1]]]){\\n                    res[rich[1]] = res[rich[0]];\\n                    changed = true;\\n                }\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> indg(n,0), ans(n,INT_MAX);\\n        vector<vector<int>> g(n);\\n        queue<int> q;\\n        for(int i=0;i<richer.size();i++){\\n            g[richer[i][0]].push_back(richer[i][1]);\\n            indg[richer[i][1]]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n            if(indg[i]==0)\\n                q.push(i);\\n        }\\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            for(int i : g[curr]){\\n                if(ans[i] == INT_MAX || quiet[ans[i]] > quiet[ans[curr]])\\n                    ans[i] = ans[curr];\\n                if(--indg[i]==0)\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        graph = defaultdict(list)\\n        for a, b in richer:\\n            graph[b].append(a)\\n        \\n        n = len(quiet)\\n        answer = [i for i in range(n)]\\n\\n        seen = set()\\n        \\n        def dfs(x, seen, answer):\\n            seen.add(x)\\n            for y in graph[x]:\\n                if y not in seen:\\n                    dfs(y, seen, answer)\\n                temp = answer[x]\\n                if quiet[temp] > quiet[answer[y]]:\\n                    answer[x] = answer[y]\\n        \\n        for i in range(n):\\n            if i not in seen:\\n                dfs(i, seen, answer)\\n\\n        return answer\\n```\n```Java []\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        int[] res = new int[n];\\n        for(int i=0; i<n; i++){\\n            res[i] = i;\\n        }\\n        boolean changed = true;\\n        while(changed){\\n            changed = false;\\n            for(int[] rich : richer){\\n                if(quiet[res[rich[0]]] < quiet[res[rich[1]]]){\\n                    res[rich[1]] = res[rich[0]];\\n                    changed = true;\\n                }\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750857,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> richer2;\\n    vector<int> res;\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for (auto v : richer) richer2[v[1]].push_back(v[0]);\\n        res = vector<int> (quiet.size(), -1);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2[i]) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> richer2;\\n    vector<int> res;\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        for (auto v : richer) richer2[v[1]].push_back(v[0]);\\n        res = vector<int> (quiet.size(), -1);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet) {\\n        if (res[i] >= 0) return res[i];\\n        res[i] = i;\\n        for (int j : richer2[i]) if (quiet[res[i]] > quiet[dfs(j, quiet)]) res[i] = res[j];\\n        return res[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714041,
                "title": "python-pure-topological-sort",
                "content": "**Explanation**\\nwe want to know the quietest person that is richer than self, which means we want to process all that are richer than self. this is where topological sort comes in. \\n\\nusing topological sort we want to process the richest ones first. i.e the count of the richer person for a person needs to be zero.\\n\\nWhen processing a rich person we want to compare it\\'s quietness against people poorer. so we will compare the quieteness of self against other poor people.\\n\\n**P.S** we will store the pointer of the quietest person on answer.\\n\\n\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        richer_count = [0 for _ in range(len(quiet))]\\n        graph = defaultdict(list)\\n        answer = [idx for idx in range(len(quiet))]\\n        \\n        ## create the graph so that we go from the richer to the poorer\\n        for rich, poor in richer:\\n            graph[rich].append(poor)\\n            richer_count[poor] += 1\\n            \\n        ## we include the richest ones.\\n        queue = collections.deque([])\\n        for person, rich_count in enumerate(richer_count):\\n            if not rich_count:\\n                queue.append(person)\\n                \\n        while queue:\\n            person = queue.popleft()\\n            ## pointer to the quietest person\\n            quieter_person = answer[person]\\n            \\n            for poorer in graph[person]:\\n                ## pointer to the quietest person richer than me\\n                quieter_richer = answer[poorer]\\n                ## on the answer we are storing the pointer to the quietest one. so for the next poorer we are going to store the pointer which contains the quietest\\n                answer[poorer] = min(quieter_person, quieter_richer, key = lambda prsn : quiet[prsn])\\n                richer_count[poorer] -= 1\\n                if not richer_count[poorer]:\\n                    queue.append(poorer)\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        richer_count = [0 for _ in range(len(quiet))]\\n        graph = defaultdict(list)\\n        answer = [idx for idx in range(len(quiet))]\\n        \\n        ## create the graph so that we go from the richer to the poorer\\n        for rich, poor in richer:\\n            graph[rich].append(poor)\\n            richer_count[poor] += 1\\n            \\n        ## we include the richest ones.\\n        queue = collections.deque([])\\n        for person, rich_count in enumerate(richer_count):\\n            if not rich_count:\\n                queue.append(person)\\n                \\n        while queue:\\n            person = queue.popleft()\\n            ## pointer to the quietest person\\n            quieter_person = answer[person]\\n            \\n            for poorer in graph[person]:\\n                ## pointer to the quietest person richer than me\\n                quieter_richer = answer[poorer]\\n                ## on the answer we are storing the pointer to the quietest one. so for the next poorer we are going to store the pointer which contains the quietest\\n                answer[poorer] = min(quieter_person, quieter_richer, key = lambda prsn : quiet[prsn])\\n                richer_count[poorer] -= 1\\n                if not richer_count[poorer]:\\n                    queue.append(poorer)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545576,
                "title": "easy-dfs-solution-in-cpp",
                "content": "**Finding all ansector of given node and than had a check for most quietest anscestor that the current node**\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int parent,vector<vector<int>>&edge,vector<int>&vis,vector<vector<int>>&ansc){\\n        \\n        vis[i]=1;\\n        for(auto ele:edge[i]){\\n            if(!vis[ele])dfs(ele,parent,edge,vis,ansc);\\n        }\\n        \\n        if(i!=parent)\\n            ansc[i].push_back(parent);\\n    }\\n    \\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>>ansc(n),edge(n);\\n        \\n        for(auto ele:richer){\\n            edge[ele[0]].push_back(ele[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int>vis(n);\\n            dfs(i,i,edge,vis,ansc);\\n        }\\n        \\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            int mini=quiet[i],a=i;\\n            \\n            for(auto ele:ansc[i]){\\n                if(mini>=quiet[ele]){\\n                    a=ele;\\n                    mini=quiet[ele];\\n                }\\n            }\\n            \\n            ans[i]=a;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(int i,int parent,vector<vector<int>>&edge,vector<int>&vis,vector<vector<int>>&ansc){\\n        \\n        vis[i]=1;\\n        for(auto ele:edge[i]){\\n            if(!vis[ele])dfs(ele,parent,edge,vis,ansc);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2445906,
                "title": "c-graph-bfs-easy-solution",
                "content": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> loudAndRich(vector<vector < int>> &richer, vector< int > &quiet)\\n\\t\\t{\\n\\t\\t\\tint n = quiet.size();\\n\\n\\t\\t\\tvector<int> indgree(n, 0);\\n\\t\\t\\tvector<int> dist(n, INT_MAX);\\n\\t\\t\\tqueue<int> q;\\n\\n\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\tfor (auto x: richer)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> data = x;\\n\\t\\t\\t\\tint a = data[0];\\n\\t\\t\\t\\tint b = data[1];\\n\\t\\t\\t\\tadj[a].push_back(b);\\n\\t\\t\\t\\tindgree[b]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdist[i] = i;\\n\\t\\t\\t\\tif (indgree[i] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint f = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor (auto x: adj[f])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (quiet[dist[x]] > quiet[dist[f]])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdist[x] = dist[f];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tindgree[x]--;\\n\\n\\t\\t\\t\\t\\tif (indgree[x] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(x);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dist;\\n\\n\\t\\t}\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> loudAndRich(vector<vector < int>> &richer, vector< int > &quiet)\\n\\t\\t{\\n\\t\\t\\tint n = quiet.size();\\n\\n\\t\\t\\tvector<int> indgree(n, 0);\\n\\t\\t\\tvector<int> dist(n, INT_MAX);\\n\\t\\t\\tqueue<int> q;\\n\\n\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\tfor (auto x: richer)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> data = x;\\n\\t\\t\\t\\tint a = data[0];\\n\\t\\t\\t\\tint b = data[1];\\n\\t\\t\\t\\tadj[a].push_back(b);\\n\\t\\t\\t\\tindgree[b]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1957788,
                "title": "c-topological-sort-with-explanation",
                "content": "class Solution {\\npublic:\\n    \\n    /*\\n        The problem statement is bit confusing to understand. \\n        First Let us Understand the question.\\n        If we assume the graph as a directed graph such that x->y means y is ritcher than x.\\n        \\n        Let\\'s Take example of the question that has been provided to us in the question.\\n        richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\\n        \\n        so its adjacency list representation would look something like\\n        \\n        0 | 1\\n        1 | 2 3\\n        2 |\\n        3 | 4 5 6\\n        4 | \\n        5 | \\n        6 | \\n        7 | 3\\n        \\n        and now if we perform dfs over each node and store the minimum quietness and the candidate then we will get our answer.\\n        But this is not a efficient approach and may give TLE.\\n        \\n        So let\\'s Try to look this question from some other perspective.\\n        \\n        What if we change the edge direction then our adjacency list will look something like this\\n        \\n        0 |  \\n        1 | 0\\n        2 | 1\\n        3 | 1 7\\n        4 | 3\\n        5 | 3\\n        6 | 3\\n        7 | \\n        \\n        and in degree would be\\n        \\n        index - 0 1 2 3 4 5 6 7\\n        in    - 1 2 0 3 0 0 0 1\\n        \\n        and if we observe this the nodes with indegree 0 have the same queitness as they don\\'t have any one richer than them.\\n        so here we may get an idea that we might use topological sort in this question to get our answer.\\n        \\n        so we will push the nodes with indegree 0 in the queue and keep their quetness as it is.\\n        as we perfom the topological sort we will check if the quiet[parent]<quiet[child], then this means that parent is richer than \\n        child and he is more quieter than him then we can update our ans.\\n        and finally after performing topological sort we will get the answer.\\n    \\n    */\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int> > graph(n);\\n        vector<int> in(n,0);\\n        for(auto i:richer)\\n        {\\n            graph[i[0]].push_back(i[1]);\\n            in[i[1]]++;\\n        }\\n        queue<int> q;\\n        vector<int> ans(n);\\n        iota(ans.begin(),ans.end(),0);\\n        for(int i=0;i<n;++i)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n                ans[i]=i;\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int cur=q.front();\\n            q.pop();\\n            for(auto child:graph[cur])\\n            {\\n                in[child]--;\\n                if(quiet[cur]<quiet[child])\\n                {\\n                    quiet[child]=quiet[cur];\\n                    ans[child]=ans[cur];\\n                }\\n                if(in[child]==0)\\n                    q.push(child);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    /*\\n        The problem statement is bit confusing to understand. \\n        First Let us Understand the question.\\n        If we assume the graph as a directed graph such that x->y means y is ritcher than x.\\n        \\n        Let\\'s Take example of the question that has been provided to us in the question.\\n        richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\\n        \\n        so its adjacency list representation would look something like\\n        \\n        0 | 1\\n        1 | 2 3\\n        2 |\\n        3 | 4 5 6\\n        4 | \\n        5 | \\n        6 | \\n        7 | 3\\n        \\n        and now if we perform dfs over each node and store the minimum quietness and the candidate then we will get our answer.\\n        But this is not a efficient approach and may give TLE.\\n        \\n        So let\\'s Try to look this question from some other perspective.\\n        \\n        What if we change the edge direction then our adjacency list will look something like this\\n        \\n        0 |  \\n        1 | 0\\n        2 | 1\\n        3 | 1 7\\n        4 | 3\\n        5 | 3\\n        6 | 3\\n        7 | \\n        \\n        and in degree would be\\n        \\n        index - 0 1 2 3 4 5 6 7\\n        in    - 1 2 0 3 0 0 0 1\\n        \\n        and if we observe this the nodes with indegree 0 have the same queitness as they don\\'t have any one richer than them.\\n        so here we may get an idea that we might use topological sort in this question to get our answer.\\n        \\n        so we will push the nodes with indegree 0 in the queue and keep their quetness as it is.\\n        as we perfom the topological sort we will check if the quiet[parent]<quiet[child], then this means that parent is richer than \\n        child and he is more quieter than him then we can update our ans.\\n        and finally after performing topological sort we will get the answer.\\n    \\n    */\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int> > graph(n);\\n        vector<int> in(n,0);\\n        for(auto i:richer)\\n        {\\n            graph[i[0]].push_back(i[1]);\\n            in[i[1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1473739,
                "title": "well-documented-python-solution",
                "content": "```\\nclass Solution(object):\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def find_quietest(i):\\n            \\n            #recursively visit all the neighbors of i and calculate least noisy\\n            #sinc we have to apply min ops on the quiet[node_number]; we are storing both node_num and val of quiet[node_number]\\n            #for instance dict1 = {0: [1], 1: [2, 3], 3: [4, 5, 6], 7: [3]}\\n            #queit = [3,2,5,4,6,1,7,0]\\n            \\'\\'\\'\\n            for node 0: we take min((0, 3), find_quietest(1)) --> min((0, 3), (5, 1)) --> (5,1)\\n            find_quietest(1) = min((1, 2), find_quietest(2), find_quietest(3))\\n                             = min((1, 2), (2, 5), (5, 1))\\n                             = (5, 1)\\n            find_quietest(2) = (2, 5)\\n            find_quietest(3) = min((3, 4), find_quietest(4), find_quietest(5), find_quietest(6)) \\n                             = min((3,4), (4,6), (5,1), (6,7))\\n                             = (5,1)\\n            find_quietest(4) = (4, 6)\\n            find_quietest(5) = (5, 1)\\n            find_quietest(6) = (6, 7)\\n            \\n            \\'\\'\\'\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            #as no information has been given about i\\n            if i not in dict1:\\n                return (i, quiet[i])\\n            \\n            quietest = (i, quiet[i])\\n            \\n            for richer in dict1[i]:\\n                quietest = min(quietest, find_quietest(richer), key= lambda x: x[1])\\n            \\n            return quietest\\n        \\n        #base \\n        if len(quiet) == 1:\\n            return quiet\\n        \\n        dict1 = {}\\n        memo = {}\\n        \\n        \\n        #Convert richer into a directed graph\\n        #For example: [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]\\n        #dict[0] = [1] which indicates 1 has more money than 0\\n        #so value at key x is all people richer than x\\n        for val in richer:\\n            if val[1] in dict1:\\n                dict1[val[1]].append(val[0])\\n            else:\\n                dict1[val[1]] = [val[0]]\\n        \\n        \\n        #create a copy of quiet as every person will be either itself or least quiet between itself and all its richer neighbors  \\n        result = list(quiet)\\n        \\n        for i in range(len(quiet)):\\n            #navigate all the neighbors richer than the node\\n            output = find_quietest(i)\\n            result[i] = output[0]\\n            #used for memoization\\n            memo[i] = output\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def find_quietest(i):\\n            \\n            #recursively visit all the neighbors of i and calculate least noisy\\n            #sinc we have to apply min ops on the quiet[node_number]; we are storing both node_num and val of quiet[node_number]\\n            #for instance dict1 = {0: [1], 1: [2, 3], 3: [4, 5, 6], 7: [3]}\\n            #queit = [3,2,5,4,6,1,7,0]\\n            \\'\\'\\'\\n            for node 0: we take min((0, 3), find_quietest(1)) --> min((0, 3), (5, 1)) --> (5,1)\\n            find_quietest(1) = min((1, 2), find_quietest(2), find_quietest(3))\\n                             = min((1, 2), (2, 5), (5, 1))\\n                             = (5, 1)\\n            find_quietest(2) = (2, 5)\\n            find_quietest(3) = min((3, 4), find_quietest(4), find_quietest(5), find_quietest(6)) \\n                             = min((3,4), (4,6), (5,1), (6,7))\\n                             = (5,1)\\n            find_quietest(4) = (4, 6)\\n            find_quietest(5) = (5, 1)\\n            find_quietest(6) = (6, 7)\\n            \\n            \\'\\'\\'\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            #as no information has been given about i\\n            if i not in dict1:\\n                return (i, quiet[i])\\n            \\n            quietest = (i, quiet[i])\\n            \\n            for richer in dict1[i]:\\n                quietest = min(quietest, find_quietest(richer), key= lambda x: x[1])\\n            \\n            return quietest\\n        \\n        #base \\n        if len(quiet) == 1:\\n            return quiet\\n        \\n        dict1 = {}\\n        memo = {}\\n        \\n        \\n        #Convert richer into a directed graph\\n        #For example: [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]\\n        #dict[0] = [1] which indicates 1 has more money than 0\\n        #so value at key x is all people richer than x\\n        for val in richer:\\n            if val[1] in dict1:\\n                dict1[val[1]].append(val[0])\\n            else:\\n                dict1[val[1]] = [val[0]]\\n        \\n        \\n        #create a copy of quiet as every person will be either itself or least quiet between itself and all its richer neighbors  \\n        result = list(quiet)\\n        \\n        for i in range(len(quiet)):\\n            #navigate all the neighbors richer than the node\\n            output = find_quietest(i)\\n            result[i] = output[0]\\n            #used for memoization\\n            memo[i] = output\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433995,
                "title": "javascript-dfs-memo-with-explanation",
                "content": "From the richer array [[a,b]], create a map with key and adjacency list\\n* key = person index (b)\\n* adjacency list = list of people directly richer than person (push a into map.get(b))\\n\\nCreate answer array. From person 0 to person n - 1 (0 indexed), find the quietest person and fill it into answer array.\\n* getQuietest(person) method finds the quiestest person richer or equal to the given person. \\n* It does so by comparing the quiet value of the given person and everyone in the person\\'s adj list, and if the adjacent people have their own adj list, do a DFS search through it. This will cover all richer/equal to ppl. Find the min quiet value from all these people and return the index of the quietest person.\\n* Before every return value, store the return value into the memo map. This prevents searching through the same person again.\\n \\n```\\nvar loudAndRich = function(richer, quiet) {\\n    const map = new Map();\\n    for (const [rich, poor] of richer) {\\n        map.set(poor, (map.get(poor) || new Set()).add(rich));        \\n    }\\n    \\n    const memo = new Map();\\n    const getQuietest = (person) => {\\n        if (memo.has(person)) return memo.get(person);\\n        const richerList = map.get(person);\\n        let min = quiet[person];\\n        let quietest = person;\\n        if (!richerList) {\\n            memo.set(person, quietest);\\n            return quietest;\\n        }\\n        for (const rich of richerList) {         \\n            if (quiet[getQuietest(rich)] < min) {\\n                min = quiet[getQuietest(rich)];\\n                quietest = getQuietest(rich);\\n            }            \\n        }\\n        memo.set(person, quietest);\\n        return quietest;\\n    }\\n    const answer = [];\\n    for (let i=0; i<quiet.length; i++) {\\n        answer.push(getQuietest(i));\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nvar loudAndRich = function(richer, quiet) {\\n    const map = new Map();\\n    for (const [rich, poor] of richer) {\\n        map.set(poor, (map.get(poor) || new Set()).add(rich));        \\n    }\\n    \\n    const memo = new Map();\\n    const getQuietest = (person) => {\\n        if (memo.has(person)) return memo.get(person);\\n        const richerList = map.get(person);\\n        let min = quiet[person];\\n        let quietest = person;\\n        if (!richerList) {\\n            memo.set(person, quietest);\\n            return quietest;\\n        }\\n        for (const rich of richerList) {         \\n            if (quiet[getQuietest(rich)] < min) {\\n                min = quiet[getQuietest(rich)];\\n                quietest = getQuietest(rich);\\n            }            \\n        }\\n        memo.set(person, quietest);\\n        return quietest;\\n    }\\n    const answer = [];\\n    for (let i=0; i<quiet.length; i++) {\\n        answer.push(getQuietest(i));\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383787,
                "title": "python-topological-sort-robbing-everyone-from-rich-to-poor",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n = len(quiet)\\n        \\n        # build adjacency list and indegree for topological sort\\n        adj_list = [[] for _ in range(n)]\\n        indegree = [0] * n\\n        for rich, poor in richer:\\n            adj_list[rich].append(poor)\\n            indegree[poor] += 1\\n        \\n        # traverse(or rob) each node(or person) in topological order, from richest to poorest\\n        richer_and_louder = list(range(n))\\n        richest = [i for i, count in enumerate(indegree) if count == 0]\\n        for rich in iter(lambda: richest.pop() if richest else None, None):    #rob one by one until they all broke\\n            for poor in adj_list[rich]:\\n                richer_and_louder[poor] = min(richer_and_louder[poor], richer_and_louder[rich], key=quiet.__getitem__)\\n                indegree[poor] -= 1    # lower the poor\\'s poverty ranking since the richer has been robbed\\n                if indegree[poor] == 0:\\n                    richest.append(poor)   # poor is the one of the richest since no one is richer than him/her\\n        return richer_and_louder\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n = len(quiet)\\n        \\n        # build adjacency list and indegree for topological sort\\n        adj_list = [[] for _ in range(n)]\\n        indegree = [0] * n\\n        for rich, poor in richer:\\n            adj_list[rich].append(poor)\\n            indegree[poor] += 1\\n        \\n        # traverse(or rob) each node(or person) in topological order, from richest to poorest\\n        richer_and_louder = list(range(n))\\n        richest = [i for i, count in enumerate(indegree) if count == 0]\\n        for rich in iter(lambda: richest.pop() if richest else None, None):    #rob one by one until they all broke\\n            for poor in adj_list[rich]:\\n                richer_and_louder[poor] = min(richer_and_louder[poor], richer_and_louder[rich], key=quiet.__getitem__)\\n                indegree[poor] -= 1    # lower the poor\\'s poverty ranking since the richer has been robbed\\n                if indegree[poor] == 0:\\n                    richest.append(poor)   # poor is the one of the richest since no one is richer than him/her\\n        return richer_and_louder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381156,
                "title": "simple-java-dfs-solution-99-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    ArrayList<ArrayList<Integer>> graph;\\n    int output[];   //to store result\\n    \\n    public void addEdge(int u, int v){\\n        graph.get(u).add(v);\\n    }\\n    \\n    public void buildGraph(int[][] richer){\\n        for(int[] pair: richer){\\n            int poor= pair[1];\\n            int rich= pair[0];\\n            addEdge(poor,rich);  //adding edges from poor to rich\\n        }\\n    }\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n= quiet.length;\\n        graph= new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        buildGraph(richer);  //build adjacency list so that we can do dfs\\n        output= new int[n];\\n        Arrays.fill(output,-1);\\n        for(int i=0;i<n;i++){    //doing dfs\\n            if(output[i]==-1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    public int dfs(int person, int quiet[]){\\n        \\n         if(output[person]!=-1)    //if we already know answer for this person return same answer (Memoization)\\n             return output[person];\\n        int least_quiet_person=person;   //initially the person himself is the least_quiet_person\\n        int least_quietness= quiet[person];\\n        \\n        for(int nbr: graph.get(person)){\\n            int newPerson= dfs(nbr,quiet);\\n            if(quiet[newPerson]<least_quietness){      //while doing dfs, if we found  a person who is more quiet we update our values\\n                least_quietness= quiet[newPerson];\\n                least_quiet_person=newPerson;\\n            }\\n        }\\n        output[person]=least_quiet_person;  //store the answer in output array\\n        return least_quiet_person;\\n        \\n      }\\n}      \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<ArrayList<Integer>> graph;\\n    int output[];   //to store result\\n    \\n    public void addEdge(int u, int v){\\n        graph.get(u).add(v);\\n    }\\n    \\n    public void buildGraph(int[][] richer){\\n        for(int[] pair: richer){\\n            int poor= pair[1];\\n            int rich= pair[0];\\n            addEdge(poor,rich);  //adding edges from poor to rich\\n        }\\n    }\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n= quiet.length;\\n        graph= new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        buildGraph(richer);  //build adjacency list so that we can do dfs\\n        output= new int[n];\\n        Arrays.fill(output,-1);\\n        for(int i=0;i<n;i++){    //doing dfs\\n            if(output[i]==-1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    public int dfs(int person, int quiet[]){\\n        \\n         if(output[person]!=-1)    //if we already know answer for this person return same answer (Memoization)\\n             return output[person];\\n        int least_quiet_person=person;   //initially the person himself is the least_quiet_person\\n        int least_quietness= quiet[person];\\n        \\n        for(int nbr: graph.get(person)){\\n            int newPerson= dfs(nbr,quiet);\\n            if(quiet[newPerson]<least_quietness){      //while doing dfs, if we found  a person who is more quiet we update our values\\n                least_quietness= quiet[newPerson];\\n                least_quiet_person=newPerson;\\n            }\\n        }\\n        output[person]=least_quiet_person;  //store the answer in output array\\n        return least_quiet_person;\\n        \\n      }\\n}      \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782931,
                "title": "python-3-dfs-memoization-lru-cache",
                "content": "- First, we make a graph with dictionary, where key is person `x` and values are those who is richer than `x` (list of people). \\n- Second, we do a DFS and at the same time `lru_cache` will take care of the repeat input of any person `i`\\n\\n- `cur`: current quiet level\\n- `r`: current rich people who is least quiet\\n\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = collections.defaultdict(list)\\n        for x, y in richer: graph[y].append(x)\\n\\t\\t\\n        @lru_cache(maxsize=None)\\n        def dfs(i):\\n            cur, r = quiet[i], i\\n            if i not in graph: return cur, r\\n            for rich in graph[i]:\\n                cur1, r1 = dfs(rich)\\n                if cur1 < cur:\\n                    cur, r = cur1, r1\\n            return cur, r \\n        return [dfs(i)[1] for i in range(len(quiet))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = collections.defaultdict(list)\\n        for x, y in richer: graph[y].append(x)\\n\\t\\t\\n        @lru_cache(maxsize=None)\\n        def dfs(i):\\n            cur, r = quiet[i], i\\n            if i not in graph: return cur, r\\n            for rich in graph[i]:\\n                cur1, r1 = dfs(rich)\\n                if cur1 < cur:\\n                    cur, r = cur1, r1\\n            return cur, r \\n        return [dfs(i)[1] for i in range(len(quiet))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039098,
                "title": "easy-topological-sort",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<int> in(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.size();i++)\\n        {\\n           int u=richer[i][0];\\n           int v=richer[i][1];\\n           graph[u].push_back(v);\\n           in[v]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n    \\n       while(!q.empty())\\n       {\\n           int top=q.front();\\n           q.pop();\\n           for(auto x: graph[top])\\n           {   in[x]--;\\n               if(in[x]==0) q.push(x);\\n               if(quiet[ans[x]]>quiet[ans[top]])\\n               {\\n                   ans[x]=ans[top];\\n               }\\n\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<int> in(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.size();i++)\\n        {\\n           int u=richer[i][0];\\n           int v=richer[i][1];\\n           graph[u].push_back(v);\\n           in[v]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n    \\n       while(!q.empty())\\n       {\\n           int top=q.front();\\n           q.pop();\\n           for(auto x: graph[top])\\n           {   in[x]--;\\n               if(in[x]==0) q.push(x);\\n               if(quiet[ans[x]]>quiet[ans[top]])\\n               {\\n                   ans[x]=ans[top];\\n               }\\n\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872237,
                "title": "easy-c-solution-using-topo-sort-94-ms-solution-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        int c = richer.size();\\n        vector<int> adj[n], rev[n], indegree(n, 0), dup, m[n], ans(n);\\n        for(int i = 0; i < c; i++){\\n            int a = richer[i][0];\\n            int b = richer[i][1];\\n            adj[a].push_back(b);\\n            rev[b].push_back(a);\\n            indegree[b]++;\\n        }\\n        dup = indegree;\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0){\\n                q.push({i, 0});\\n            }\\n        }\\n        while(!q.empty()){\\n            int temp = q.front().first;\\n            int lvl = q.front().second;\\n            q.pop();\\n            m[lvl].push_back(quiet[temp]);\\n            for(auto it: adj[temp]){\\n                indegree[it]--;\\n                if(indegree[it] == 0){\\n                    q.push({it, lvl+1});\\n                }\\n            }\\n        }\\n        map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            mp[quiet[i]] = i;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(m[i].size() == 0) break;\\n            for(auto it: m[i]){\\n                int c = mp[it];\\n                if(rev[c].size() == 0){ \\n                    ans[c] = c;\\n                }\\n                else{\\n                    int mini = quiet[c];\\n                    for(auto it2: rev[c]){\\n                        mini = min(mini, quiet[ans[it2]]);\\n                    }\\n                    ans[c] = mp[mini];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        int c = richer.size();\\n        vector<int> adj[n], rev[n], indegree(n, 0), dup, m[n], ans(n);\\n        for(int i = 0; i < c; i++){\\n            int a = richer[i][0];\\n            int b = richer[i][1];\\n            adj[a].push_back(b);\\n            rev[b].push_back(a);\\n            indegree[b]++;\\n        }\\n        dup = indegree;\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0){\\n                q.push({i, 0});\\n            }\\n        }\\n        while(!q.empty()){\\n            int temp = q.front().first;\\n            int lvl = q.front().second;\\n            q.pop();\\n            m[lvl].push_back(quiet[temp]);\\n            for(auto it: adj[temp]){\\n                indegree[it]--;\\n                if(indegree[it] == 0){\\n                    q.push({it, lvl+1});\\n                }\\n            }\\n        }\\n        map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            mp[quiet[i]] = i;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(m[i].size() == 0) break;\\n            for(auto it: m[i]){\\n                int c = mp[it];\\n                if(rev[c].size() == 0){ \\n                    ans[c] = c;\\n                }\\n                else{\\n                    int mini = quiet[c];\\n                    for(auto it2: rev[c]){\\n                        mini = min(mini, quiet[ans[it2]]);\\n                    }\\n                    ans[c] = mp[mini];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819772,
                "title": "kahn-s-algorithm-topological-sort-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, We can see there is a sequence a --> b --> c --> d, a is richer than b, b richer than c and so on. We can also observe one thing that the richest person cannot have anyone more quiet than him with more money. So, the answer for the richest will be the same person itself. So, we begin with the richest person (i.e in graph terms we can say that their indegree will be zero)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use Kahn\\'s algorithm to traverse the graph(persons) and updating their quietness and the answer array at the same time.\\n\\n# Complexity\\n- Time complexity:\\nO(N+E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        vector<int> indeg(n,0);\\n        for(auto it: richer){\\n            adj[it[0]].push_back(it[1]);\\n            indeg[it[1]]++;\\n        }\\n\\n        queue<int> q;\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++){\\n            if(indeg[i] == 0){\\n                q.push(i);\\n            }\\n            answer[i] = i;\\n        }\\n\\n        while(!q.empty()){\\n            int curr = q.front();\\n            int currQ = quiet[curr];\\n            q.pop();\\n            for(auto it:adj[curr]){\\n                if(currQ<quiet[it]){\\n                    answer[it] = answer[curr];\\n                    quiet[it] = currQ;\\n                }\\n                indeg[it]--;\\n                if(indeg[it] == 0)\\n                q.push(it);\\n            }\\n\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        vector<int> indeg(n,0);\\n        for(auto it: richer){\\n            adj[it[0]].push_back(it[1]);\\n            indeg[it[1]]++;\\n        }\\n\\n        queue<int> q;\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++){\\n            if(indeg[i] == 0){\\n                q.push(i);\\n            }\\n            answer[i] = i;\\n        }\\n\\n        while(!q.empty()){\\n            int curr = q.front();\\n            int currQ = quiet[curr];\\n            q.pop();\\n            for(auto it:adj[curr]){\\n                if(currQ<quiet[it]){\\n                    answer[it] = answer[curr];\\n                    quiet[it] = currQ;\\n                }\\n                indeg[it]--;\\n                if(indeg[it] == 0)\\n                q.push(it);\\n            }\\n\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736867,
                "title": "simple-c-approach-using-topo-sort-and-dfs",
                "content": "# Intuition\\nI have used topo sort and made some minor changes to get the answer.\\n\\n# Space Complexity\\nApprox O(3V) -> adjacency list to store the graph, indegree for sorting and answer for storing the answer. \\'V\\' number of node.\\n\\n# Time Complexity\\nApprox O(V) + O(V + E)\\n\\n# Approach\\n- Initially I created the adj list and a indegree vector.\\n- Then I initialized the answer vector \\'ans\\' with the node itself because incase of node with indegree of zero the answer will be the node itself => `[0, 1, 2 , 3, 4, 5, 6, 7]`\\n- Then I have just added the nodes with indegree \\'0\\' to a queue.\\n- Next I will move directly to the condition as the rest of the code is pretty standard one.\\n- In the if statement I have compared the quiet value of the node that is stored as ans for the \"Current node\" with the quiet value of node stored in the ans for the \"child notes you may say\". Confused ?\\n- Consider the scenario `2 with quiet value of 5 ` and `1 with quiet value of 2`.\\n- In the if state `if(quiet[ans[node]] < quiet[ans[it]])` turns out to be `quiet[2] < quiet[1]` => `5 < 2`. The condition stands false and `ans[1] = 1`.\\n- Conside another scenario where condition is true. `5 with quiet value of 1` and `3 with quiet value of 4`.\\n- In the if state `if(quiet[ans[node]] < quiet[ans[it]])` turns out to be `quiet[5] < quiet[3]` => `1 < 4`. The condition stands true and `ans[3] = 5`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int V=quiet.size();\\n        vector<int> adj[V];\\n        vector<int> vis(V,0);\\n        vector<int> indegree(V,0);\\n        \\n        for(auto it:richer){\\n            adj[it[0]].push_back(it[1]);\\n            indegree[it[1]]++;\\n        }\\n\\n        vector<int> ans(V);\\n        queue<int> q;\\n        for(int i=0;i<V;i++){\\n            // initializing ans of each node with node value.\\n            ans[i]=i;\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto it: adj[node]){\\n                indegree[it]--;\\n\\n                // Updating the answer value of child node if the quiet value of child node is more than parent node.\\n               if(quiet[ans[node]] < quiet[ans[it]]){\\n                    ans[it]=ans[node];\\n                }\\n                if(indegree[it]==0)q.push(it);\\n            }\\n        }\\n\\n\\n\\n        return ans;\\n\\n    }\\n};\\n\\n**PLEASE CONSIDER UPVOTING IF YOU HAVE UNDERSTOOD MY APPROACH. USE A DRY RUN TO UNDERSTAND IT BETTER. **\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int V=quiet.size();\\n        vector<int> adj[V];\\n        vector<int> vis(V,0);\\n        vector<int> indegree(V,0);\\n        \\n        for(auto it:richer){\\n            adj[it[0]].push_back(it[1]);\\n            indegree[it[1]]++;\\n        }\\n\\n        vector<int> ans(V);\\n        queue<int> q;\\n        for(int i=0;i<V;i++){\\n            // initializing ans of each node with node value.\\n            ans[i]=i;\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto it: adj[node]){\\n                indegree[it]--;\\n\\n                // Updating the answer value of child node if the quiet value of child node is more than parent node.\\n               if(quiet[ans[node]] < quiet[ans[it]]){\\n                    ans[it]=ans[node];\\n                }\\n                if(indegree[it]==0)q.push(it);\\n            }\\n        }\\n\\n\\n\\n        return ans;\\n\\n    }\\n};\\n\\n**PLEASE CONSIDER UPVOTING IF YOU HAVE UNDERSTOOD MY APPROACH. USE A DRY RUN TO UNDERSTAND IT BETTER. **\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353212,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int[] quietest = new int[quiet.length];\\n        for(int i = 0; i < quiet.length; i++){\\n            quietest[i] = searchForQuietest(richer, quiet, i, quietest);\\n        }\\n        return quietest;\\n    }\\n    public int searchForQuietest(int[][] richer, int[] quiet, int person, int[] quietest){\\n        int leastQuiet = person;\\n        for(int i = 0; i < richer.length; i++){\\n            if(richer[i][1] == person){\\n                int leastQuietPerson;\\n                if(quietest[richer[i][0]] != 0)\\n                    leastQuietPerson = quietest[richer[i][0]];\\n                else leastQuietPerson = searchForQuietest(richer, quiet, richer[i][0], quietest);\\n                leastQuiet = Math.min(quiet[leastQuietPerson], quiet[leastQuiet]) == quiet[leastQuiet]?leastQuiet: leastQuietPerson;\\n            }\\n        }\\n    return leastQuiet;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int[] quietest = new int[quiet.length];\\n        for(int i = 0; i < quiet.length; i++){\\n            quietest[i] = searchForQuietest(richer, quiet, i, quietest);\\n        }\\n        return quietest;\\n    }\\n    public int searchForQuietest(int[][] richer, int[] quiet, int person, int[] quietest){\\n        int leastQuiet = person;\\n        for(int i = 0; i < richer.length; i++){\\n            if(richer[i][1] == person){\\n                int leastQuietPerson;\\n                if(quietest[richer[i][0]] != 0)\\n                    leastQuietPerson = quietest[richer[i][0]];\\n                else leastQuietPerson = searchForQuietest(richer, quiet, richer[i][0], quietest);\\n                leastQuiet = Math.min(quiet[leastQuietPerson], quiet[leastQuiet]) == quiet[leastQuiet]?leastQuiet: leastQuietPerson;\\n            }\\n        }\\n    return leastQuiet;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050307,
                "title": "c-dp-easy-and-clean-code",
                "content": "# Intuition\\nMake a list of all the people who are richer than ith person\\n\\n# Approach\\nTraverse the list and store person with minimum quietness level.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void makeList(unordered_map<int, list<int>> &adj, vector<vector<int>>& richer){\\n        for(auto i : richer){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n    }\\n\\n    pair<int, int> solve(unordered_map<int, list<int>> &adj, vector<int>& quiet, vector<pair<int, int>> &dp, int node){\\n        if(dp[node].first != -1) return dp[node];\\n\\n        pair<int, int> num = {node, quiet[node]};\\n\\n        for(auto i : adj[node]){\\n            pair<int, int> temp = solve(adj, quiet, dp, i);\\n\\n            if(temp.second < num.second){\\n                num = temp;\\n            }\\n        }\\n\\n        return dp[node] = num;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        unordered_map<int, list<int>> adj;\\n        makeList(adj, richer);\\n\\n        vector<pair<int, int>> dp(n, {-1, -1});\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++){\\n            pair<int, int> res = solve(adj, quiet, dp, i);\\n            ans[i] = res.first;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeList(unordered_map<int, list<int>> &adj, vector<vector<int>>& richer){\\n        for(auto i : richer){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n    }\\n\\n    pair<int, int> solve(unordered_map<int, list<int>> &adj, vector<int>& quiet, vector<pair<int, int>> &dp, int node){\\n        if(dp[node].first != -1) return dp[node];\\n\\n        pair<int, int> num = {node, quiet[node]};\\n\\n        for(auto i : adj[node]){\\n            pair<int, int> temp = solve(adj, quiet, dp, i);\\n\\n            if(temp.second < num.second){\\n                num = temp;\\n            }\\n        }\\n\\n        return dp[node] = num;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        unordered_map<int, list<int>> adj;\\n        makeList(adj, richer);\\n\\n        vector<pair<int, int>> dp(n, {-1, -1});\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++){\\n            pair<int, int> res = solve(adj, quiet, dp, i);\\n            ans[i] = res.first;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982984,
                "title": "fastest-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N+LENGTH OF RICHER)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*LENGTH OF RICHER)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dfs(self,node,visited,ans,value,lst):\\n        # print(node)\\n        visited[node]=1\\n        for i in lst[node]:\\n            if visited[i]==0:\\n                self.dfs(i,visited,ans,value,lst)\\n            x=value[i]\\n            # print(node,i,value[node],x)\\n            if x<value[node]:\\n                value[node]=x\\n                ans[node]=ans[i]\\n        return \\n\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n=len(quiet)\\n        visited=[0]*n\\n        lst=[[] for i in range(n)]\\n        for i,j in richer:\\n            lst[j].append(i)\\n        # print(lst)\\n        ans=[i for i in range(n)]\\n        value=[quiet[i] for i in range(n)]\\n        for i in range(n):\\n            if visited[i]==0:\\n                self.dfs(i,visited,ans,value,lst)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self,node,visited,ans,value,lst):\\n        # print(node)\\n        visited[node]=1\\n        for i in lst[node]:\\n            if visited[i]==0:\\n                self.dfs(i,visited,ans,value,lst)\\n            x=value[i]\\n            # print(node,i,value[node],x)\\n            if x<value[node]:\\n                value[node]=x\\n                ans[node]=ans[i]\\n        return \\n\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n=len(quiet)\\n        visited=[0]*n\\n        lst=[[] for i in range(n)]\\n        for i,j in richer:\\n            lst[j].append(i)\\n        # print(lst)\\n        ans=[i for i in range(n)]\\n        value=[quiet[i] for i in range(n)]\\n        for i in range(n):\\n            if visited[i]==0:\\n                self.dfs(i,visited,ans,value,lst)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982738,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N+length of richer)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*length of richer)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n=len(quiet)\\n        indegree=[0]*n\\n        lst=[[] for i in range(n)]\\n        for i,j in richer:\\n            lst[i].append(j)\\n            indegree[j]+=1\\n        ans=[i for i in range(n)]\\n        value=[quiet[i] for i in range(n)]\\n        st=[]\\n        for i in range(n):\\n            if indegree[i]==0:\\n                st.append(i)\\n        while st:\\n            x=st.pop(0)\\n            for i in lst[x]:\\n                indegree[i]-=1\\n                if value[x]<value[i]:\\n                    ans[i]=ans[x]\\n                    value[i]=value[x]\\n                if indegree[i]==0:\\n                    st.append(i)\\n        return ans\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n=len(quiet)\\n        indegree=[0]*n\\n        lst=[[] for i in range(n)]\\n        for i,j in richer:\\n            lst[i].append(j)\\n            indegree[j]+=1\\n        ans=[i for i in range(n)]\\n        value=[quiet[i] for i in range(n)]\\n        st=[]\\n        for i in range(n):\\n            if indegree[i]==0:\\n                st.append(i)\\n        while st:\\n            x=st.pop(0)\\n            for i in lst[x]:\\n                indegree[i]-=1\\n                if value[x]<value[i]:\\n                    ans[i]=ans[x]\\n                    value[i]=value[x]\\n                if indegree[i]==0:\\n                    st.append(i)\\n        return ans\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919252,
                "title": "dfs-memoization-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(int node, vector<int> adjList[], vector<int> &quiet, unordered_map<int, pair<int, int>> &Map) {\\n        \\n        if(Map.count(node) == 1) return Map[node];\\n        \\n        pair<int, int> ans = {node, quiet[node]}; \\n        \\n        for(auto &iter : adjList[node]) {\\n            pair<int, int> temp = dfs(iter, adjList, quiet, Map);\\n            \\n            if(temp.second <= ans.second) {\\n                ans = temp;\\n            }\\n        }\\n        \\n        return Map[node] = ans;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n], ans(n);\\n        \\n        for(int i = 0; i < richer.size(); i++) {\\n            int v = richer[i][0];\\n            int u = richer[i][1];\\n            \\n            adjList[u].push_back(v);\\n        }\\n        \\n        unordered_map<int, pair<int, int>> Map;\\n\\n        for(int i = 0; i < n; i++) {\\n            pair<int, int> curr = dfs(i, adjList, quiet, Map);\\n            \\n            ans[i] = curr.first;\\n        }\\n        \\n        return ans;\\n    } \\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    pair<int, int> dfs(int node, vector<int> adjList[], vector<int> &quiet, unordered_map<int, pair<int, int>> &Map) {\\n        \\n        if(Map.count(node) == 1) return Map[node];\\n        \\n        pair<int, int> ans = {node, quiet[node]}",
                "codeTag": "Java"
            },
            {
                "id": 2895828,
                "title": "loud-and-rich-using-dfs-and-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int ans[];\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    int temp[]=new int[0];\\n    int curr_node=0;\\n    List<Integer> vis=new ArrayList<Integer>();\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        ans=new int[quiet.length];\\n        for(int i=0;i<=richer.length;i++){\\n            \\n            if(!map.containsKey(i)){\\n                map.put(i,new ArrayList());\\n            }\\n            if(i<richer.length && !map.containsKey(richer[i][0])){\\n                map.put(richer[i][0],new ArrayList());\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n            else if(i<richer.length){\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n        }\\n        \\n        Comparator<pair> comp=new Comparator<pair>(){\\n            public int compare(pair p1,pair p2){\\n                if(p1.cost>p2.cost){\\n                    return 1;\\n                }\\n                else{\\n                    return -1;\\n                }\\n\\n            }\\n        };\\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\\n        for(int i=0;i<quiet.length;i++){\\n            ans[i]=-1;\\n            pq.add(new pair(i,quiet[i]));\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair top=pq.poll();\\n            //System.out.println(top.node+\" \"+top.cost);\\n            curr_node=top.node;\\n            if(!vis.contains(top.node)){\\n            dfs(top.node);\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n    public void dfs(int node){\\n        //System.out.println(node);\\n        if(ans[node]==-1){\\n            ans[node]=curr_node;\\n        }\\n        if(!vis.contains(node) && map.containsKey(node)){\\n            vis.add(node);\\n             \\n            for(int i : map.get(node)){\\n            dfs(i);\\n        \\n        }\\n        }\\n            \\n    }\\n}\\n\\nclass pair{\\n    int node,cost;\\n    pair(int node,int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans[];\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    int temp[]=new int[0];\\n    int curr_node=0;\\n    List<Integer> vis=new ArrayList<Integer>();\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        ans=new int[quiet.length];\\n        for(int i=0;i<=richer.length;i++){\\n            \\n            if(!map.containsKey(i)){\\n                map.put(i,new ArrayList());\\n            }\\n            if(i<richer.length && !map.containsKey(richer[i][0])){\\n                map.put(richer[i][0],new ArrayList());\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n            else if(i<richer.length){\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n        }\\n        \\n        Comparator<pair> comp=new Comparator<pair>(){\\n            public int compare(pair p1,pair p2){\\n                if(p1.cost>p2.cost){\\n                    return 1;\\n                }\\n                else{\\n                    return -1;\\n                }\\n\\n            }\\n        };\\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\\n        for(int i=0;i<quiet.length;i++){\\n            ans[i]=-1;\\n            pq.add(new pair(i,quiet[i]));\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair top=pq.poll();\\n            //System.out.println(top.node+\" \"+top.cost);\\n            curr_node=top.node;\\n            if(!vis.contains(top.node)){\\n            dfs(top.node);\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n    public void dfs(int node){\\n        //System.out.println(node);\\n        if(ans[node]==-1){\\n            ans[node]=curr_node;\\n        }\\n        if(!vis.contains(node) && map.containsKey(node)){\\n            vis.add(node);\\n             \\n            for(int i : map.get(node)){\\n            dfs(i);\\n        \\n        }\\n        }\\n            \\n    }\\n}\\n\\nclass pair{\\n    int node,cost;\\n    pair(int node,int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506190,
                "title": "java-bfs-o-v-e-topological-sort",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int n = quiet.length;\\n        for(int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        \\n        int[] inDegree = new int[n];\\n        for(int[] edge : richer) {\\n            graph.get(edge[0]).add(edge[1]);\\n            inDegree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer> queue = new ArrayDeque<>();\\n        int[] result = new int[n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n            result[i] = i;\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            Integer curr = queue.poll();\\n            for(Integer neighbour : graph.get(curr)) {\\n                inDegree[neighbour]--;\\n                if(inDegree[neighbour] == 0) {\\n                    queue.offer(neighbour);\\n                }\\n                \\n                if(quiet[result[neighbour]] > quiet[result[curr]]) {\\n                    result[neighbour] = result[curr];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int n = quiet.length;\\n        for(int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        \\n        int[] inDegree = new int[n];\\n        for(int[] edge : richer) {\\n            graph.get(edge[0]).add(edge[1]);\\n            inDegree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer> queue = new ArrayDeque<>();\\n        int[] result = new int[n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n            result[i] = i;\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            Integer curr = queue.poll();\\n            for(Integer neighbour : graph.get(curr)) {\\n                inDegree[neighbour]--;\\n                if(inDegree[neighbour] == 0) {\\n                    queue.offer(neighbour);\\n                }\\n                \\n                if(quiet[result[neighbour]] > quiet[result[curr]]) {\\n                    result[neighbour] = result[curr];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305768,
                "title": "c-simple-dfs",
                "content": "\\t```\\n\\tint dfs(int src, vector<int>& vis, vector<int>& quiet, vector<int> adj[], vector<int>& ans)  {\\n        vis[src] = 1;\\n        ans[src] = src;\\n        for(auto child : adj[src])\\n        {\\n            if(!vis[child])\\n            {\\n                int y = dfs(child,vis,quiet,adj,ans);\\n                if(quiet[y] < quiet[ans[src]])\\n                    ans[src] = y;\\n            }\\n            else\\n            {\\n                if(quiet[ans[child]] < quiet[ans[src]])\\n                    ans[src] = ans[child];\\n            }\\n        }\\n       return ans[src];\\n    }\\n\\tvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans(n,0), vis(n,0),  adj[n];\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n                dfs(i,vis,quiet,adj,ans);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tint dfs(int src, vector<int>& vis, vector<int>& quiet, vector<int> adj[], vector<int>& ans)  {\\n        vis[src] = 1;\\n        ans[src] = src;\\n        for(auto child : adj[src])\\n        {\\n            if(!vis[child])\\n            {\\n                int y = dfs(child,vis,quiet,adj,ans);\\n                if(quiet[y] < quiet[ans[src]])\\n                    ans[src] = y;\\n            }\\n            else\\n            {\\n                if(quiet[ans[child]] < quiet[ans[src]])\\n                    ans[src] = ans[child];\\n            }\\n        }\\n       return ans[src];\\n    }\\n\\tvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans(n,0), vis(n,0),  adj[n];\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n                dfs(i,vis,quiet,adj,ans);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2185754,
                "title": "easy-c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void check(int x,vector<vector<int>> &adj,vector<int>&ans,vector<int>& quiet,int min,int n){\\n        int res=x;\\n        vector<int> vis(n,0);\\n        vis[x]=1;\\n        queue<int> q;\\n        q.push(x);\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n                if(vis[it]==0){\\n                    vis[it]=1;\\n                    if(quiet[it]<min){\\n                        min=quiet[it];\\n                        res=it;\\n                    }\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        ans.push_back(res);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto it:richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            check(i,adj,ans,quiet,quiet[i],n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(int x,vector<vector<int>> &adj,vector<int>&ans,vector<int>& quiet,int min,int n){\\n        int res=x;\\n        vector<int> vis(n,0);\\n        vis[x]=1;\\n        queue<int> q;\\n        q.push(x);\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n                if(vis[it]==0){\\n                    vis[it]=1;\\n                    if(quiet[it]<min){\\n                        min=quiet[it];\\n                        res=it;\\n                    }\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        ans.push_back(res);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto it:richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            check(i,adj,ans,quiet,quiet[i],n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162438,
                "title": "kahn-s-algorithm-c-code",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\t\\n        int n = quiet.size(); \\n        vector<int> indegree(n,0);\\n        vector<int> ans(n,0);\\n        vector<vector<int>> adj(n);\\n        queue<int> q;\\n        \\n        for(auto it: richer)\\n        {\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            indegree[v]++;\\n        }\\n        \\n        \\n        for(int i =0;i<n;i++)\\n        {\\n            ans[i]=i;\\n            if(indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it: adj[node])\\n            {\\n                if(quiet[ans[it]]>quiet[ans[node]])\\n                {\\n                    ans[it]= ans[node];\\n                }\\n                    \\n                indegree[it]--;\\n                \\n                if(indegree[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\t\\n        int n = quiet.size(); \\n        vector<int> indegree(n,0);\\n        vector<int> ans(n,0);\\n        vector<vector<int>> adj(n);\\n        queue<int> q;\\n        \\n        for(auto it: richer)\\n        {\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            indegree[v]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2157804,
                "title": "c-code-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[505];\\n    vector<int> ans;\\n    \\n    void dfs(int node,int parent,vector<int> &q){\\n        if (parent!=-1 && q[node]>q[parent]){\\n            q[node]=q[parent];\\n            ans[node]=ans[parent];\\n        }\\n        else if (parent!=-1){\\n            return;\\n        }\\n       \\n        for (auto it: adj[node]){\\n            if (it!=parent){\\n                dfs(it,node,q);\\n            }\\n        }\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& v, vector<int>& q) {\\n        int i;\\n        int n=v.size();\\n        \\n        for (i=0; i<n; i++){\\n            adj[v[i][0]].push_back(v[i][1]);\\n        }\\n        for (i=0; i<q.size(); i++){\\n            ans.push_back(i);\\n        }\\n        \\n        for (i=0; i<q.size(); i++){\\n            dfs(i,-1,q);\\n        }\\n        \\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[505];\\n    vector<int> ans;\\n    \\n    void dfs(int node,int parent,vector<int> &q){\\n        if (parent!=-1 && q[node]>q[parent]){\\n            q[node]=q[parent];\\n            ans[node]=ans[parent];\\n        }\\n        else if (parent!=-1){\\n            return;\\n        }\\n       \\n        for (auto it: adj[node]){\\n            if (it!=parent){\\n                dfs(it,node,q);\\n            }\\n        }\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& v, vector<int>& q) {\\n        int i;\\n        int n=v.size();\\n        \\n        for (i=0; i<n; i++){\\n            adj[v[i][0]].push_back(v[i][1]);\\n        }\\n        for (i=0; i<q.size(); i++){\\n            ans.push_back(i);\\n        }\\n        \\n        for (i=0; i<q.size(); i++){\\n            dfs(i,-1,q);\\n        }\\n        \\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112749,
                "title": "c-dfs-topological-sort",
                "content": "Step 1: Create graph with edge in direction of increasing Richness.\\nStep 2: Run DFS on all 0 indegree nodes.\\nStep 3: Return min value node from dfs method comparing current node quietness value with all child nodes.\\nStep 4: Use the result array to reduce reprocessing (DP) if the node is already visited.\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> quiet;\\n    vector<vector<int>> adjList;\\n    vector<bool> isVisited;\\n    vector<int> result;\\n    \\n    int dfs(int curr) {\\n        isVisited[curr] = true;\\n        int minV = curr;\\n        \\n        for (int i : adjList[curr]) {\\n            if (!isVisited[i]) {\\n                int temp = dfs(i);\\n                if (quiet[minV] > quiet[temp]) {\\n                    minV = temp;\\n                }\\n            } else {\\n                if (quiet[minV] > quiet[result[i]]) {\\n                    minV = result[i];\\n                }\\n            }\\n        }\\n        \\n        result[curr] = minV;\\n        return minV;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        n = quiet.size();\\n        result.assign(n, 0);\\n        adjList.assign(n, vector<int>(0));\\n        isVisited.assign(n, false);\\n        this->quiet = quiet;\\n        \\n        for (vector<int> edge : richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        for (int i=0 ; i<n ; i++) {\\n            if (!isVisited[i])\\n                dfs(i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> quiet;\\n    vector<vector<int>> adjList;\\n    vector<bool> isVisited;\\n    vector<int> result;\\n    \\n    int dfs(int curr) {\\n        isVisited[curr] = true;\\n        int minV = curr;\\n        \\n        for (int i : adjList[curr]) {\\n            if (!isVisited[i]) {\\n                int temp = dfs(i);\\n                if (quiet[minV] > quiet[temp]) {\\n                    minV = temp;\\n                }\\n            } else {\\n                if (quiet[minV] > quiet[result[i]]) {\\n                    minV = result[i];\\n                }\\n            }\\n        }\\n        \\n        result[curr] = minV;\\n        return minV;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        n = quiet.size();\\n        result.assign(n, 0);\\n        adjList.assign(n, vector<int>(0));\\n        isVisited.assign(n, false);\\n        this->quiet = quiet;\\n        \\n        for (vector<int> edge : richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        for (int i=0 ; i<n ; i++) {\\n            if (!isVisited[i])\\n                dfs(i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054250,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(const int &node,unordered_map<int,vector<int>> &edges,vector<int> &quiet,vector<int> &ans){\\n        ans[node] = node;  \\n        for(const int &i:edges[node]){\\n            if(ans[i] == -1) dfs(i,edges,quiet,ans);\\n            if(quiet[node] > quiet[i]){\\n                quiet[node] = quiet[i];\\n                ans[node] = ans[i];\\n            }\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>> edges;\\n        const int n = quiet.size();\\n        vector<int> ans(n,-1);\\n        for(auto const &it:richer) edges[it[1]].emplace_back(it[0]);\\n        for(int i = 0;i<n;i++){\\n            if(ans[i] == -1) dfs(i,edges,quiet,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(const int &node,unordered_map<int,vector<int>> &edges,vector<int> &quiet,vector<int> &ans){\\n        ans[node] = node;  \\n        for(const int &i:edges[node]){\\n            if(ans[i] == -1) dfs(i,edges,quiet,ans);\\n            if(quiet[node] > quiet[i]){\\n                quiet[node] = quiet[i];\\n                ans[node] = ans[i];\\n            }\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>> edges;\\n        const int n = quiet.size();\\n        vector<int> ans(n,-1);\\n        for(auto const &it:richer) edges[it[1]].emplace_back(it[0]);\\n        for(int i = 0;i<n;i++){\\n            if(ans[i] == -1) dfs(i,edges,quiet,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812925,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/90319328-3390-4713-9eca-898e38f9c32a_1646224652.1311088.png)\\n\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \"\"\" O(N^2)TS \"\"\"\\n        nodes = list(range(len(quiet)))\\n        grid = {n: [] for n in nodes}\\n        [grid[b].append(a) for a, b in richer]\\n\\n        @functools.cache\\n        def fn(node):\\n            return min([node] + [fn(kid) for kid in grid[node]], key=lambda n: quiet[n])\\n\\n        return map(fn, nodes)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/90319328-3390-4713-9eca-898e38f9c32a_1646224652.1311088.png)\\n\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \"\"\" O(N^2)TS \"\"\"\\n        nodes = list(range(len(quiet)))\\n        grid = {n: [] for n in nodes}\\n        [grid[b].append(a) for a, b in richer]\\n\\n        @functools.cache\\n        def fn(node):\\n            return min([node] + [fn(kid) for kid in grid[node]], key=lambda n: quiet[n])\\n\\n        return map(fn, nodes)",
                "codeTag": "Python3"
            },
            {
                "id": 1799395,
                "title": "c-dfs-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int, vector<int>> richerMap;\\n        vector<int> res = vector<int> (quiet.size(), -1);\\n        for (auto v : richer) richerMap[v[1]].push_back(v[0]);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet, richerMap, res);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet, unordered_map<int, vector<int>>& richerMap, vector<int>& res) {\\n        if (res[i] >= 0) \\n            return res[i];\\n        res[i] = i;\\n        for (int j : richerMap[i]) if (quiet[res[i]] > quiet[dfs(j, quiet, richerMap, res)]) res[i] = res[j];\\n        return res[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int, vector<int>> richerMap;\\n        vector<int> res = vector<int> (quiet.size(), -1);\\n        for (auto v : richer) richerMap[v[1]].push_back(v[0]);\\n        for (int i = 0; i < quiet.size(); i++) dfs(i, quiet, richerMap, res);\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& quiet, unordered_map<int, vector<int>>& richerMap, vector<int>& res) {\\n        if (res[i] >= 0) \\n            return res[i];\\n        res[i] = i;\\n        for (int j : richerMap[i]) if (quiet[res[i]] > quiet[dfs(j, quiet, richerMap, res)]) res[i] = res[j];\\n        return res[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734814,
                "title": "dp-intuitive-postorder",
                "content": "```\\nclass Solution {\\npublic:\\n    //Simple Postorder Classical Dp \\n    vector<int> dp;\\n    int dfs(vector<vector<int>>& g,int i,vector<int>&q){\\n        if(dp[i]!=-1) return dp[i];\\n        int mini=i;\\n        for(auto nbr:g[i]){\\n            int a=dfs(g,nbr,q);\\n            if(q[mini]>q[a]) mini=a;\\n        }\\n        return dp[i]=mini;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& q) {\\n        int n=q.size();\\n        vector<vector<int>> g(n);\\n        for(auto i:richer){\\n            g[i[1]].push_back(i[0]);\\n        }\\n        dp=vector<int>(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==-1) dp[i]=dfs(g,i,q);\\n        }\\n        \\n        return dp;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    //Simple Postorder Classical Dp \\n    vector<int> dp;\\n    int dfs(vector<vector<int>>& g,int i,vector<int>&q){\\n        if(dp[i]!=-1) return dp[i];\\n        int mini=i;\\n        for(auto nbr:g[i]){\\n            int a=dfs(g,nbr,q);\\n            if(q[mini]>q[a]) mini=a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1630491,
                "title": "c-o-v-e-linear",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> graph(n);\\n        for(auto e:richer) graph[e[1]].push_back(e[0]);\\n        vector<bool> visited(n,false);\\n        vector<int> loud(n);\\n        for(int i=0;i<n;i++) dfs(graph,i,visited,loud,quiet);  \\n        return loud;\\n    }\\n    \\n    int dfs(vector<vector<int>>& graph,int node,vector<bool>& visited,vector<int>& loud,vector<int>& quiet) {\\n        if(visited[node]) return loud[node];\\n        visited[node]=true;\\n        int loudIdx=node;\\n        for(int adj:graph[node]) {\\n            int dfsIdx=dfs(graph,adj,visited,loud,quiet);\\n            if(quiet[dfsIdx]<quiet[loudIdx]) loudIdx=dfsIdx;\\n        }\\n        return loud[node]=loudIdx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> graph(n);\\n        for(auto e:richer) graph[e[1]].push_back(e[0]);\\n        vector<bool> visited(n,false);\\n        vector<int> loud(n);\\n        for(int i=0;i<n;i++) dfs(graph,i,visited,loud,quiet);  \\n        return loud;\\n    }\\n    \\n    int dfs(vector<vector<int>>& graph,int node,vector<bool>& visited,vector<int>& loud,vector<int>& quiet) {\\n        if(visited[node]) return loud[node];\\n        visited[node]=true;\\n        int loudIdx=node;\\n        for(int adj:graph[node]) {\\n            int dfsIdx=dfs(graph,adj,visited,loud,quiet);\\n            if(quiet[dfsIdx]<quiet[loudIdx]) loudIdx=dfsIdx;\\n        }\\n        return loud[node]=loudIdx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395206,
                "title": "python-dfs-directed-graph-beats-95",
                "content": "Idea is considering the richer people as parents and having directed edges to poorer ones and then fact that quiter people can effect themselves and poorer people than them.\\n\\nThe order of processing the nodes is quiter to louder people and updating the answer. The answer also acts a visited array meaning we don\\'t need to update a quiter person that was already updated.\\n\\n```\\nclass Solution:\\n    def dfs(self, adj_list, ans, node, par):\\n        ans[node] = par\\n        \\n        for neig in adj_list[node]:\\n            if ans[neig] == -1:\\n                self.dfs(adj_list, ans, neig, par)\\n        \\n    \\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        order = [(quietness, idx) for idx, quietness in enumerate(quiet)]\\n        order.sort()\\n        n = len(quiet)\\n        \\n        # form adj list\\n        adj_list = collections.defaultdict(lambda: [])\\n        for par, child in richer:\\n            adj_list[par].append(child)\\n             \\n        ans = [-1]*n\\n        while order:\\n            _, node = order.pop(0)\\n            \\n            # update all possible child for the node using dfs\\n            # if not updated yet\\n            # no need of visited since there would be no cycles\\n            if ans[node] == -1:\\n                self.dfs(adj_list, ans, node, node)\\n                \\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, adj_list, ans, node, par):\\n        ans[node] = par\\n        \\n        for neig in adj_list[node]:\\n            if ans[neig] == -1:\\n                self.dfs(adj_list, ans, neig, par)\\n        \\n    \\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        order = [(quietness, idx) for idx, quietness in enumerate(quiet)]\\n        order.sort()\\n        n = len(quiet)\\n        \\n        # form adj list\\n        adj_list = collections.defaultdict(lambda: [])\\n        for par, child in richer:\\n            adj_list[par].append(child)\\n             \\n        ans = [-1]*n\\n        while order:\\n            _, node = order.pop(0)\\n            \\n            # update all possible child for the node using dfs\\n            # if not updated yet\\n            # no need of visited since there would be no cycles\\n            if ans[node] == -1:\\n                self.dfs(adj_list, ans, node, node)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362662,
                "title": "c-using-kahn-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) \\n    {\\n        int n = quiet.size();\\n        vector<int> indegree(n,0),ans(n);\\n        vector<vector<int>> g(n);\\n        queue<int> leaves;\\n        \\n        for (auto& x:richer)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n        \\n        for (int i=0;i<n;i++)\\n        {\\n            if (indegree[i]==0)\\n                leaves.push(i);\\n            ans[i]=i;\\n        }\\n        \\n        while (!leaves.empty())\\n        {\\n            int sz=leaves.size();\\n            for (int i=0;i<sz;i++)\\n            {\\n                int x = leaves.front();\\n                leaves.pop();\\n                \\n                for (auto& neighbour:g[x])\\n                {\\n                    indegree[neighbour]--;\\n                    if (quiet[ans[neighbour]]>quiet[ans[x]])\\n                        ans[neighbour]=ans[x];\\n                    if (indegree[neighbour]==0)\\n                        leaves.push(neighbour);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) \\n    {\\n        int n = quiet.size();\\n        vector<int> indegree(n,0),ans(n);\\n        vector<vector<int>> g(n);\\n        queue<int> leaves;\\n        \\n        for (auto& x:richer)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n        \\n        for (int i=0;i<n;i++)\\n        {\\n            if (indegree[i]==0)\\n                leaves.push(i);\\n            ans[i]=i;\\n        }\\n        \\n        while (!leaves.empty())\\n        {\\n            int sz=leaves.size();\\n            for (int i=0;i<sz;i++)\\n            {\\n                int x = leaves.front();\\n                leaves.pop();\\n                \\n                for (auto& neighbour:g[x])\\n                {\\n                    indegree[neighbour]--;\\n                    if (quiet[ans[neighbour]]>quiet[ans[x]])\\n                        ans[neighbour]=ans[x];\\n                    if (indegree[neighbour]==0)\\n                        leaves.push(neighbour);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256998,
                "title": "c-dfs-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    unordered_map<int,int>visited,SILENT;\\n    \\n    \\n    int dfs(unordered_map<int,vector<int>>&graph,vector<int>& quiet,int i)\\n    {\\n        int a=INT_MAX;\\n        \\n        for(auto x:graph[i])\\n        {\\n            if(!visited[x])\\n            {\\n               a=std::min(a,dfs(graph,quiet,x));\\n            }\\n            else\\n            {\\n                a=std::min(a,visited[x]);\\n            }\\n            \\n        }\\n        \\n        return visited[i]=std::min(a,quiet[i]+1);\\n        \\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        vector<int>ans;\\n        unordered_map<int,vector<int>>graph;\\n        \\n        \\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            SILENT[quiet[i]]=i;\\n        }\\n        \\n        \\n        for(auto x:richer)\\n        {\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            if(!visited[i])\\n            {\\n                visited[i]=dfs(graph,quiet,i);\\n            }\\n            ans.push_back(SILENT[visited[i]-1]);\\n        }\\n        return ans;\\n   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    unordered_map<int,int>visited,SILENT;\\n    \\n    \\n    int dfs(unordered_map<int,vector<int>>&graph,vector<int>& quiet,int i)\\n    {\\n        int a=INT_MAX;\\n        \\n        for(auto x:graph[i])\\n        {\\n            if(!visited[x])\\n            {\\n               a=std::min(a,dfs(graph,quiet,x));\\n            }\\n            else\\n            {\\n                a=std::min(a,visited[x]);\\n            }\\n            \\n        }\\n        \\n        return visited[i]=std::min(a,quiet[i]+1);\\n        \\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        vector<int>ans;\\n        unordered_map<int,vector<int>>graph;\\n        \\n        \\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            SILENT[quiet[i]]=i;\\n        }\\n        \\n        \\n        for(auto x:richer)\\n        {\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            if(!visited[i])\\n            {\\n                visited[i]=dfs(graph,quiet,i);\\n            }\\n            ans.push_back(SILENT[visited[i]-1]);\\n        }\\n        return ans;\\n   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202619,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&rich, vector<int>&ans, vector<int>&quiet, int&i){\\n        if(ans[i]==-1){\\n            if(rich[i].size()==0) ans[i] = i;\\n            else{\\n                int temp = ans[i] = i;\\n                for(int j = 0;j<rich[i].size();j++){\\n                    temp = dfs(rich, ans, quiet, rich[i][j]);\\n                    if(quiet[ans[i]]>quiet[temp]) ans[i] = temp;\\n                }\\n            }\\n        }\\n        return ans[i];\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<vector<int>> rich(quiet.size());\\n        vector<int> ans(quiet.size(),-1);\\n        for(int i = 0;i<richer.size();i++){\\n            rich[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i = 0;i<quiet.size();i++){\\n            if(ans[i]==-1){\\n                if(rich[i].size()==0) ans[i] = i;\\n                else{\\n                    int temp = ans[i] = i;\\n                    for(int j = 0;j<rich[i].size();j++){\\n                        temp = dfs(rich, ans, quiet, rich[i][j]);\\n                        if(quiet[ans[i]]>quiet[temp]) ans[i] = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&rich, vector<int>&ans, vector<int>&quiet, int&i){\\n        if(ans[i]==-1){\\n            if(rich[i].size()==0) ans[i] = i;\\n            else{\\n                int temp = ans[i] = i;\\n                for(int j = 0;j<rich[i].size();j++){\\n                    temp = dfs(rich, ans, quiet, rich[i][j]);\\n                    if(quiet[ans[i]]>quiet[temp]) ans[i] = temp;\\n                }\\n            }\\n        }\\n        return ans[i];\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<vector<int>> rich(quiet.size());\\n        vector<int> ans(quiet.size(),-1);\\n        for(int i = 0;i<richer.size();i++){\\n            rich[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        for(int i = 0;i<quiet.size();i++){\\n            if(ans[i]==-1){\\n                if(rich[i].size()==0) ans[i] = i;\\n                else{\\n                    int temp = ans[i] = i;\\n                    for(int j = 0;j<rich[i].size();j++){\\n                        temp = dfs(rich, ans, quiet, rich[i][j]);\\n                        if(quiet[ans[i]]>quiet[temp]) ans[i] = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045369,
                "title": "c-dfs-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[],vector<bool>& visited,vector<int>& quiet,vector<int>& answer,int node){\\n        answer[node]=node;\\n        visited[node]=true;\\n        for(auto u:adj[node]){\\n            if(!visited[u]){\\n                if(answer[u]==-1)\\n                    dfs(adj,visited,quiet,answer,u);\\n                if(quiet[answer[u]]<quiet[answer[node]])\\n                    answer[node]=answer[u];\\n            }\\n        }\\n        visited[node]=false;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool> visited(n,false);\\n        vector<int> answer(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i])\\n                dfs(adj,visited,quiet,answer,i);\\n        }\\n        return answer;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(vector<int> adj[],vector<bool>& visited,vector<int>& quiet,vector<int>& answer,int node){\\n        answer[node]=node;\\n        visited[node]=true;\\n        for(auto u:adj[node]){\\n            if(!visited[u]){\\n                if(answer[u]==-1)\\n                    dfs(adj,visited,quiet,answer,u);\\n                if(quiet[answer[u]]<quiet[answer[node]])\\n                    answer[node]=answer[u];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1035948,
                "title": "solution-using-topological-traversal",
                "content": "\\t// time complexity : O(e+v)\\n\\t/*  approach : using topological traversal\\n\\t\\t  --> we know that no node is richer than the leaf nodes(or nodes having indegree==0) , so ans for those nodes is node themself\\n\\t\\t  --> do a topological traversal , which ensures we visit node more richer nodes first \\n\\t\\t  --> if we find that the quitness level of its parent is < quitness level of neighbour node , \\n\\t\\t\\t\\t  we update the quitness level of neighbour node and the ans for neighbour node is = ans of parent node.\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\t\\t\\tList<List<Integer>> adj = new ArrayList<>();\\n\\t\\t\\tint n = quiet.length;\\n\\t\\t\\tint[] inDegree = new int[n];\\n\\t\\t\\tfor(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n\\t\\t\\tfor(int [] ele : richer){\\n\\t\\t\\t\\tinDegree[ele[1]]++;\\n\\t\\t\\t\\tadj.get(ele[0]).add(ele[1]);\\n\\t\\t\\t}\\n\\t\\t\\tint[] res = new int[n];\\n\\t\\t\\tQueue<Integer> q = new LinkedList<>();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t res[i] = i;\\n\\t\\t\\t\\tif(inDegree[i]==0)\\n\\t\\t\\t\\t\\tq.add(i);\\n\\t\\t\\t}\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tint x = q.poll();\\n\\t\\t\\t\\tfor(int neig : adj.get(x)){\\n\\t\\t\\t\\t\\tif(--inDegree[neig]==0)q.add(neig);\\n\\t\\t\\t\\t\\tif(quiet[neig]>quiet[res[x]]){\\n\\t\\t\\t\\t\\t\\tres[neig] = res[x];\\n\\t\\t\\t\\t\\t\\tquiet[neig] = quiet[res[x]];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\t\\t\\tList<List<Integer>> adj = new ArrayList<>();\\n\\t\\t\\tint n = quiet.length;\\n\\t\\t\\tint[] inDegree = new int[n];\\n\\t\\t\\tfor(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n\\t\\t\\tfor(int [] ele : richer){\\n\\t\\t\\t\\tinDegree[ele[1]]++;\\n\\t\\t\\t\\tadj.get(ele[0]).add(ele[1]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 939564,
                "title": "python3-memoized-dfs-o-n",
                "content": "Algo \\nIt is not hard to identify that the problem represents a digraph. Given `x, y` in `richer`, a edge points from `y` to `x`. For any given node `y`, we need to collect the richer and loudest people in a sub-tree rooted at `y`. A DFS does that. To avoid repeating the same traversal, we memoize the value for nodes that we\\'ve traversed. \\n\\nImplementation \\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = {} # graph as adjacency list \\n        for x, y in richer: graph.setdefault(y, []).append(x)\\n        \\n        @lru_cache(None)\\n        def fn(x): \\n            \"\"\"Return richer & loudest person given person.\"\"\"\\n            ans = x\\n            for xx in graph.get(x, []): \\n                if quiet[fn(xx)] < quiet[ans]: ans = fn(xx)\\n            return ans \\n        \\n        return [fn(x) for x in range(len(quiet))]\\n```\\n\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = {} # graph as adjacency list \\n        for x, y in richer: graph.setdefault(y, []).append(x)\\n        \\n        @lru_cache(None)\\n        def fn(x): \\n            \"\"\"Return richer & loudest person given person.\"\"\"\\n            ans = x\\n            for xx in graph.get(x, []): \\n                if quiet[fn(xx)] < quiet[ans]: ans = fn(xx)\\n            return ans \\n        \\n        return [fn(x) for x in range(len(quiet))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704323,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int i, const vector<int>& qs, vector<int>& dp, const vector<vector<int>>& r) {\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int result = i; \\n        for(int j : r[i]){\\n            int tmp = f(j,qs,dp,r);\\n            if(qs[tmp]<qs[result]) {\\n                result = tmp; \\n            }\\n        }\\n        return dp[i] = result;       \\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int> dp(quiet.size(),-1);\\n        vector<vector<int>> r(quiet.size());\\n        for(auto& x: richer){\\n            r[x[1]].push_back(x[0]);\\n        }\\n        for(int i =0;i<dp.size();i++){\\n            f(i,quiet,dp,r);\\n        }\\n        return dp; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, const vector<int>& qs, vector<int>& dp, const vector<vector<int>>& r) {\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int result = i; \\n        for(int j : r[i]){\\n            int tmp = f(j,qs,dp,r);\\n            if(qs[tmp]<qs[result]) {\\n                result = tmp; \\n            }\\n        }\\n        return dp[i] = result;       \\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int> dp(quiet.size(),-1);\\n        vector<vector<int>> r(quiet.size());\\n        for(auto& x: richer){\\n            r[x[1]].push_back(x[0]);\\n        }\\n        for(int i =0;i<dp.size();i++){\\n            f(i,quiet,dp,r);\\n        }\\n        return dp; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371189,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph;\\n    int[] ans;\\n    boolean[] seen;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        graph = new HashMap<>();\\n        ans = new int[quiet.length];\\n        seen = new boolean[quiet.length];\\n        for(int n = 0; n < quiet.length; n++){\\n            ans[n] = n;\\n        }\\n        for(int[] rich: richer){\\n            graph.putIfAbsent(rich[1], new ArrayList<>());\\n            graph.get(rich[1]).add(rich[0]);\\n        }\\n        for(int i = 0; i < quiet.length; i++){\\n            dfs(i, quiet);\\n        }\\n        return ans;\\n    }\\n    \\n    public void dfs(int node, int[] quiet){\\n        if(seen[node]) return;\\n        if(graph.containsKey(node)){\\n            List<Integer> cur = graph.get(node);\\n            int size = cur.size();\\n            for(int i = 0; i < size; i++){\\n                dfs(cur.get(i), quiet);\\n                ans[node] = quiet[ans[cur.get(i)]] < quiet[ans[node]]? ans[cur.get(i)] : ans[node];\\n            }\\n            // System.out.println(node + \" \" + ans[node]);\\n        }\\n        else{\\n            ans[node] = node;\\n            // System.out.println(node + \" \" + ans[node]);\\n        }\\n        seen[node] = true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph;\\n    int[] ans;\\n    boolean[] seen;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        graph = new HashMap<>();\\n        ans = new int[quiet.length];\\n        seen = new boolean[quiet.length];\\n        for(int n = 0; n < quiet.length; n++){\\n            ans[n] = n;\\n        }\\n        for(int[] rich: richer){\\n            graph.putIfAbsent(rich[1], new ArrayList<>());\\n            graph.get(rich[1]).add(rich[0]);\\n        }\\n        for(int i = 0; i < quiet.length; i++){\\n            dfs(i, quiet);\\n        }\\n        return ans;\\n    }\\n    \\n    public void dfs(int node, int[] quiet){\\n        if(seen[node]) return;\\n        if(graph.containsKey(node)){\\n            List<Integer> cur = graph.get(node);\\n            int size = cur.size();\\n            for(int i = 0; i < size; i++){\\n                dfs(cur.get(i), quiet);\\n                ans[node] = quiet[ans[cur.get(i)]] < quiet[ans[node]]? ans[cur.get(i)] : ans[node];\\n            }\\n            // System.out.println(node + \" \" + ans[node]);\\n        }\\n        else{\\n            ans[node] = node;\\n            // System.out.println(node + \" \" + ans[node]);\\n        }\\n        seen[node] = true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348418,
                "title": "dfs-python",
                "content": "```python\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        N = len(quiet)\\n        if richer == []:\\n            return [i for i in range(N)]\\n        g = [[] for _ in range(N)]\\n        ans = [-1] * N\\n        stack = []\\n        for k in richer:\\n            g[k[1]].append(k[0])\\n        def dfs(i):\\n            if ans[i] == -1:\\n                ans[i] = i\\n                for r in g[i]:\\n                    cand = dfs(r)\\n                    if quiet[cand] < quiet[ans[i]]:\\n                        ans[i] = cand\\n            return ans[i]\\n        return [dfs(i) for i in range(N)]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        N = len(quiet)\\n        if richer == []:\\n            return [i for i in range(N)]\\n        g = [[] for _ in range(N)]\\n        ans = [-1] * N\\n        stack = []\\n        for k in richer:\\n            g[k[1]].append(k[0])\\n        def dfs(i):\\n            if ans[i] == -1:\\n                ans[i] = i\\n                for r in g[i]:\\n                    cand = dfs(r)\\n                    if quiet[cand] < quiet[ans[i]]:\\n                        ans[i] = cand\\n            return ans[i]\\n        return [dfs(i) for i in range(N)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138773,
                "title": "straightforward-c-dfs-solution-with-explanation",
                "content": "Create a ```G```raph of child/parents where the child is richer than or equally rich as the parent.  Perform DFS on this graph.  DFS is performed for for all unprocessed nodes by checking if any ```cand```idate ```nei```ghbor of ```i``` is quieter than the current ```A```nswer for ```i```.  The quietest person is stored and returned in the ```A```nswer for each ```i```.\\n\\nNote: unprocessed nodes are represented in ```A``` with the value ```-1```.\\n\\n```\\nusing VI=vector<int>;\\nusing VVI=vector<VI>;\\nclass Solution {\\npublic:\\n    VI loudAndRich(VVI& R, VI& Q) {\\n        int N=(int)Q.size(); VVI G=VVI(N,VI{}); VI A=VI(N,-1);\\n        for (const auto& richer: R){\\n            int more=richer[0], less=richer[1];\\n            G[less].push_back(more);\\n        }\\n        for (int i=0; i<N; ++i)\\n            dfs(G,Q,A,i);\\n        return A;\\n    }\\nprivate:\\n    int dfs(const VVI& G, const VI& Q, VI& A, int i){\\n        if (A[i]>=0) return A[i]; else A[i]=i;\\n        for (const auto nei: G[i]){\\n            int cand=dfs(G,Q,A,nei);\\n            if (Q[cand] < Q[A[i]])\\n                A[i]=cand;\\n        }\\n        return A[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```G```\n```cand```\n```nei```\n```i```\n```A```\n```i```\n```A```\n```i```\n```A```\n```-1```\n```\\nusing VI=vector<int>;\\nusing VVI=vector<VI>;\\nclass Solution {\\npublic:\\n    VI loudAndRich(VVI& R, VI& Q) {\\n        int N=(int)Q.size(); VVI G=VVI(N,VI{}); VI A=VI(N,-1);\\n        for (const auto& richer: R){\\n            int more=richer[0], less=richer[1];\\n            G[less].push_back(more);\\n        }\\n        for (int i=0; i<N; ++i)\\n            dfs(G,Q,A,i);\\n        return A;\\n    }\\nprivate:\\n    int dfs(const VVI& G, const VI& Q, VI& A, int i){\\n        if (A[i]>=0) return A[i]; else A[i]=i;\\n        for (const auto nei: G[i]){\\n            int cand=dfs(G,Q,A,nei);\\n            if (Q[cand] < Q[A[i]])\\n                A[i]=cand;\\n        }\\n        return A[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138062,
                "title": "python-12-lines-dfs-w-memoization-108-ms",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        edges, memo, res = collections.defaultdict(list), {}, [i for i in range(len(quiet))]\\n        for r, p in richer: edges[p].append(r)\\n        def explore(i):\\n            if i in memo: return memo[i]\\n            cur_min = i\\n            for v in edges[i]:\\n                cur = explore(v)\\n                if quiet[cur] < quiet[cur_min]: cur_min = cur\\n            res[i] = memo[i] = cur_min\\n            return cur_min\\n        for i in range(len(quiet)): explore(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer, quiet):\\n        edges, memo, res = collections.defaultdict(list), {}, [i for i in range(len(quiet))]\\n        for r, p in richer: edges[p].append(r)\\n        def explore(i):\\n            if i in memo: return memo[i]\\n            cur_min = i\\n            for v in edges[i]:\\n                cur = explore(v)\\n                if quiet[cur] < quiet[cur_min]: cur_min = cur\\n            res[i] = memo[i] = cur_min\\n            return cur_min\\n        for i in range(len(quiet)): explore(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137987,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        // construct \"adjacent list\" , record richer people \\n        List<List<Integer>> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            list.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < richer.length; i++) {\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        \\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            // no one is richer than i\\n            if (list.get(i).size() == 0) {\\n                result[i] = i;\\n                continue;\\n            }\\n            // otherwise,do BFS\\n            result[i] = bfs(list, quiet, i);\\n        }\\n        \\n        return result;\\n    }\\n    private int bfs(List<List<Integer>> list, int[] quiet, int index) {\\n        int result = index;\\n        int q = Integer.MAX_VALUE; // least quiet\\n        boolean[] visited = new boolean[quiet.length];\\n        Queue<Integer> queue = new LinkedList<>();\\n        visited[index] = true;\\n        queue.offer(index);\\n        \\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (quiet[curr] < q) {\\n                q = quiet[curr];\\n                result = curr;\\n            }\\n            if (list.get(curr).size() != 0) {\\n                for (int next : list.get(curr)) {\\n                    if (visited[next]) {\\n                        continue;\\n                    }\\n                    queue.offer(next);\\n                    visited[next] = true;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        // construct \"adjacent list\" , record richer people \\n        List<List<Integer>> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            list.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < richer.length; i++) {\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        \\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            // no one is richer than i\\n            if (list.get(i).size() == 0) {\\n                result[i] = i;\\n                continue;\\n            }\\n            // otherwise,do BFS\\n            result[i] = bfs(list, quiet, i);\\n        }\\n        \\n        return result;\\n    }\\n    private int bfs(List<List<Integer>> list, int[] quiet, int index) {\\n        int result = index;\\n        int q = Integer.MAX_VALUE; // least quiet\\n        boolean[] visited = new boolean[quiet.length];\\n        Queue<Integer> queue = new LinkedList<>();\\n        visited[index] = true;\\n        queue.offer(index);\\n        \\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (quiet[curr] < q) {\\n                q = quiet[curr];\\n                result = curr;\\n            }\\n            if (list.get(curr).size() != 0) {\\n                for (int next : list.get(curr)) {\\n                    if (visited[next]) {\\n                        continue;\\n                    }\\n                    queue.offer(next);\\n                    visited[next] = true;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137923,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int N = quiet.length;\\n        int[][] graph = new int[N][N];\\n        for (int[] r : richer) {\\n            graph[r[1]][r[0]] = 1;\\n        }\\n        int[] result = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            result[i] = -1;\\n        }\\n        for (int i = 0; i < N; i++) {\\n            dfs(graph, quiet, result, i);\\n        }\\n        return result;\\n    }\\n    private int dfs(int[][] graph, int[] quiet, int[] result, int index) {\\n        if (result[index] > -1) {\\n            return result[index];\\n        }\\n        int r = index;\\n        for (int i = 0; i < quiet.length; i++) {\\n            if (graph[index][i] == 1) {\\n                int temp = dfs(graph, quiet, result, i);\\n                if (quiet[temp] < quiet[r]) {\\n                    r = temp;\\n                }\\n            }\\n        }\\n        result[index] = r;\\n        return result[index];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int N = quiet.length;\\n        int[][] graph = new int[N][N];\\n        for (int[] r : richer) {\\n            graph[r[1]][r[0]] = 1;\\n        }\\n        int[] result = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            result[i] = -1;\\n        }\\n        for (int i = 0; i < N; i++) {\\n            dfs(graph, quiet, result, i);\\n        }\\n        return result;\\n    }\\n    private int dfs(int[][] graph, int[] quiet, int[] result, int index) {\\n        if (result[index] > -1) {\\n            return result[index];\\n        }\\n        int r = index;\\n        for (int i = 0; i < quiet.length; i++) {\\n            if (graph[index][i] == 1) {\\n                int temp = dfs(graph, quiet, result, i);\\n                if (quiet[temp] < quiet[r]) {\\n                    r = temp;\\n                }\\n            }\\n        }\\n        result[index] = r;\\n        return result[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093344,
                "title": "java-easy-to-understand-10ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\n        int n = quiet.length;\\n        int[] ans = new int[n];\\n        int[] inDegree = new int[n];\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            ans[i] = i;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            inDegree[i] = 0;\\n        }\\n        for(int i = 0; i < n ; i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n\\n\\n        for(int i = 0; i < richer.length; i++){\\n            adj.get(richer[i][0]).add(richer[i][1]);\\n            inDegree[richer[i][1]]++;\\n        }\\n\\n        \\n\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n\\n        for(int i = 0; i < n; i++){\\n            if(inDegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n\\n        while(!q.isEmpty()){\\n         \\n            int s = q.size();\\n            int cur = q.poll();\\n         \\n            for(Integer it : adj.get(cur)){\\n           \\n                inDegree[it]--;\\n                if(quiet[ans[cur]] < quiet[ans[it]]){\\n                  \\n                    ans[it] = ans[cur];\\n                }\\n                if(inDegree[it] ==  0){\\n                    q.add(it);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n\\n        int n = quiet.length;\\n        int[] ans = new int[n];\\n        int[] inDegree = new int[n];\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            ans[i] = i;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            inDegree[i] = 0;\\n        }\\n        for(int i = 0; i < n ; i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n\\n\\n        for(int i = 0; i < richer.length; i++){\\n            adj.get(richer[i][0]).add(richer[i][1]);\\n            inDegree[richer[i][1]]++;\\n        }\\n\\n        \\n\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n\\n        for(int i = 0; i < n; i++){\\n            if(inDegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n\\n        while(!q.isEmpty()){\\n         \\n            int s = q.size();\\n            int cur = q.poll();\\n         \\n            for(Integer it : adj.get(cur)){\\n           \\n                inDegree[it]--;\\n                if(quiet[ans[cur]] < quiet[ans[it]]){\\n                  \\n                    ans[it] = ans[cur];\\n                }\\n                if(inDegree[it] ==  0){\\n                    q.add(it);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062226,
                "title": "c-toposort-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<bool>&visited, vector<int>adj[], stack<int>&st) {\\n        visited[node] = true;\\n        for (auto child : adj[node]) {\\n            if (visited[child])\\n                continue;\\n            dfs(child, visited, adj, st);\\n        }\\n        st.push(node);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int>ans(n, 0);\\n        stack<int>order;\\n        vector<int>adj[n];\\n\\n        for (int i = 0; i < n; i++)\\n            ans[i] = i;\\n\\n        for (auto vec : richer) {\\n            adj[vec[0]].push_back(vec[1]);\\n        }\\n\\n        vector<bool>visited(n, false);\\n        for (int i = 0; i < n; i++)\\n            if (!visited[i])\\n                dfs(i, visited, adj, order);\\n\\n        while (!order.empty()) {\\n            int node = order.top();\\n            order.pop();\\n            for (auto child : adj[node]) {\\n                if (quiet[ans[child]] > quiet[ans[node]])\\n                    ans[child] = ans[node];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<bool>&visited, vector<int>adj[], stack<int>&st) {\\n        visited[node] = true;\\n        for (auto child : adj[node]) {\\n            if (visited[child])\\n                continue;\\n            dfs(child, visited, adj, st);\\n        }\\n        st.push(node);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int>ans(n, 0);\\n        stack<int>order;\\n        vector<int>adj[n];\\n\\n        for (int i = 0; i < n; i++)\\n            ans[i] = i;\\n\\n        for (auto vec : richer) {\\n            adj[vec[0]].push_back(vec[1]);\\n        }\\n\\n        vector<bool>visited(n, false);\\n        for (int i = 0; i < n; i++)\\n            if (!visited[i])\\n                dfs(i, visited, adj, order);\\n\\n        while (!order.empty()) {\\n            int node = order.top();\\n            order.pop();\\n            for (auto child : adj[node]) {\\n                if (quiet[ans[child]] > quiet[ans[node]])\\n                    ans[child] = ans[node];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059897,
                "title": "c-topoligcal-sorting-easy-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReverse the edges and do topological sorting. At each step update the\\nquitest of every next people.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBelow part of code update quitest every time when we pop queue\\n```\\nif(quiet[quitest[x]] > quiet[quitest[u]])\\n                quitest[x] = quitest[u];\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        vector<int> outdegree(n, 0);\\n        vector<int> quitest(n);\\n        for(auto x: richer){\\n            adj[x[0]].push_back(x[1]);\\n            outdegree[x[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0; i < n; i++){\\n            quitest[i] = i;\\n            if(outdegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(q.empty() == false){\\n            int u = q.front();\\n            q.pop();\\n            cout<<u<<\": \";\\n            for(int x: adj[u]){\\n                outdegree[x]--;\\n                if(quiet[quitest[x]] > quiet[quitest[u]])\\n                quitest[x] = quitest[u];\\n                if(outdegree[x] == 0){\\n                    q.push(x);\\n                }\\n            }\\n            // for(int i = 0; i < n; i++)\\n            // cout<<quitest[i]<<\" \";\\n            // cout<<\" ## \";\\n        }\\n        return quitest;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(quiet[quitest[x]] > quiet[quitest[u]])\\n                quitest[x] = quitest[u];\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        vector<int> outdegree(n, 0);\\n        vector<int> quitest(n);\\n        for(auto x: richer){\\n            adj[x[0]].push_back(x[1]);\\n            outdegree[x[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0; i < n; i++){\\n            quitest[i] = i;\\n            if(outdegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(q.empty() == false){\\n            int u = q.front();\\n            q.pop();\\n            cout<<u<<\": \";\\n            for(int x: adj[u]){\\n                outdegree[x]--;\\n                if(quiet[quitest[x]] > quiet[quitest[u]])\\n                quitest[x] = quitest[u];\\n                if(outdegree[x] == 0){\\n                    q.push(x);\\n                }\\n            }\\n            // for(int i = 0; i < n; i++)\\n            // cout<<quitest[i]<<\" \";\\n            // cout<<\" ## \";\\n        }\\n        return quitest;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4056936,
                "title": "python3-simple-dfs-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        N = len(quiet)\\n        graph = collections.defaultdict(list)\\n        for e in richer:\\n            pre = e[1]\\n            next = e[0]\\n            graph[pre].append(next)\\n\\n        @cache\\n        def dfs(root):\\n            ret = quiet[root]\\n            for next in graph[root]:\\n                ret = min(ret, dfs(next))\\n            return ret\\n\\n        hm = dict()\\n        for i, e in enumerate(quiet):\\n            hm[e] = i\\n\\n        ans = []\\n        for i in range(N):\\n            ans.append(hm[dfs(i)])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        N = len(quiet)\\n        graph = collections.defaultdict(list)\\n        for e in richer:\\n            pre = e[1]\\n            next = e[0]\\n            graph[pre].append(next)\\n\\n        @cache\\n        def dfs(root):\\n            ret = quiet[root]\\n            for next in graph[root]:\\n                ret = min(ret, dfs(next))\\n            return ret\\n\\n        hm = dict()\\n        for i, e in enumerate(quiet):\\n            hm[e] = i\\n\\n        ans = []\\n        for i in range(N):\\n            ans.append(hm[dfs(i)])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050854,
                "title": "c-solution-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n=quiet.size();\\n        \\n        vector<int> res(n);\\n        \\n        iota(res.begin(), res.end(), 0);\\n        vector<int> indegree(n, 0);\\n        vector<int> graph[n];\\n        \\n        for(auto elem:richer){\\n            indegree[elem[1]]++;\\n            graph[elem[0]].push_back(elem[1]);\\n        }\\n        queue<int> q;\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr=q.front();\\n            q.pop();\\n            \\n            for(auto u:graph[curr]){\\n                if(quiet[res[u]]>quiet[res[curr]]){\\n                    res[u]=res[curr];\\n                }\\n                indegree[u]--;\\n                if(indegree[u]==0)\\n                    q.push(u);\\n                \\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```\\n\\nPlease uvote if you liked the solution",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n=quiet.size();\\n        \\n        vector<int> res(n);\\n        \\n        iota(res.begin(), res.end(), 0);\\n        vector<int> indegree(n, 0);\\n        vector<int> graph[n];\\n        \\n        for(auto elem:richer){\\n            indegree[elem[1]]++;\\n            graph[elem[0]].push_back(elem[1]);\\n        }\\n        queue<int> q;\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int curr=q.front();\\n            q.pop();\\n            \\n            for(auto u:graph[curr]){\\n                if(quiet[res[u]]>quiet[res[curr]]){\\n                    res[u]=res[curr];\\n                }\\n                indegree[u]--;\\n                if(indegree[u]==0)\\n                    q.push(u);\\n                \\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046878,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int ans[] = new int[quiet.length];\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++){\\n            list.add(new ArrayList<>());\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.length;i++){\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        boolean vis[] = new boolean[quiet.length];\\n        for(int i=0;i<quiet.length;i++){\\n            if(vis[i]==false){\\n                dfs(i,list,vis,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(int node ,ArrayList<ArrayList<Integer>> list ,boolean vis[] ,int ans[],int quiet[] ){\\n         vis[node]=true;\\n         for(int j:list.get(node)){\\n             if(vis[j]==false){\\n                 dfs(j,list,vis,ans,quiet);\\n                 if(quiet[node]>quiet[j]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }else{\\n                 if(quiet[j]<quiet[ans[node]]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }\\n         }\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<int>*adj,vector<bool>&visited,vector<int>&ans,vector<int>&quiet){\\n        visited[s]=true;\\n        int min=s;\\n        for(int x:adj[s]){\\n            if(!visited[x])\\n            dfs(x,adj,visited,ans,quiet);\\n            if(quiet[ans[x]]<quiet[min])\\n            min=ans[x];\\n        }\\n        ans[s]=min;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>adj[quiet.size()];\\n        vector<int>ans(quiet.size(),false);\\n        //creation of graph\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool>visited(quiet.size(),false);\\n        for(int i=0;i<quiet.size();i++){\\n            if(!visited[i])\\n            dfs(i,adj,visited,ans,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int ans[] = new int[quiet.length];\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++){\\n            list.add(new ArrayList<>());\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.length;i++){\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        boolean vis[] = new boolean[quiet.length];\\n        for(int i=0;i<quiet.length;i++){\\n            if(vis[i]==false){\\n                dfs(i,list,vis,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(int node ,ArrayList<ArrayList<Integer>> list ,boolean vis[] ,int ans[],int quiet[] ){\\n         vis[node]=true;\\n         for(int j:list.get(node)){\\n             if(vis[j]==false){\\n                 dfs(j,list,vis,ans,quiet);\\n                 if(quiet[node]>quiet[j]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }else{\\n                 if(quiet[j]<quiet[ans[node]]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }\\n         }\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<int>*adj,vector<bool>&visited,vector<int>&ans,vector<int>&quiet){\\n        visited[s]=true;\\n        int min=s;\\n        for(int x:adj[s]){\\n            if(!visited[x])\\n            dfs(x,adj,visited,ans,quiet);\\n            if(quiet[ans[x]]<quiet[min])\\n            min=ans[x];\\n        }\\n        ans[s]=min;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>adj[quiet.size()];\\n        vector<int>ans(quiet.size(),false);\\n        //creation of graph\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool>visited(quiet.size(),false);\\n        for(int i=0;i<quiet.size();i++){\\n            if(!visited[i])\\n            dfs(i,adj,visited,ans,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046772,
                "title": "easy-java-solution",
                "content": "# Intuition\\nUnderstanding the relationship between people based on the amount of money can be visualized as a graph. In this graph, a directed edge from person i to person j indicates that i is richer than j. We want to traverse this graph to find the least quiet person for each individual. The first intuition is to represent richer relationships in the form of an adjacency list and traverse it.\\n\\n# Approach\\n1. Adjacency List Representation: Represent the richer relationships using an adjacency list. For each relationship [i, j], add i to the list of j indicating that i is richer than j.\\n\\n2. Depth First Search (DFS): Start DFS traversal for each person. The purpose of this traversal is to find the quietest person amongst all the people richer than the current person, including themselves.\\n\\n3. Memoization: Store already computed results for each person in the answer array. This avoids redundant calculations and prevents us from running into infinite loops. If we\\'ve already computed the quietest richer person for a particular person, we just return the stored result.\\n\\n4. Updating Quietest Person: During the DFS traversal, at each step, compare the quietness of the current person with the quietness of the DFS result for the richer person. Update the quietest person accordingly.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < richer.length; i++) {\\n            adj.get(richer[i][1]).add(richer[i][0]); \\n        }\\n\\n        int[] answer = new int[n];\\n        Arrays.fill(answer, -1); \\n\\n        for (int i = 0; i < n; i++) {\\n            dfs(i, adj, quiet, answer);\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int dfs(int person,  ArrayList<ArrayList<Integer>> adj, int[] quiet, int[] answer) {\\n        if (answer[person] != -1) {\\n            return answer[person];\\n        }\\n\\n        int minQuietPerson = person; \\n        for (int richerPerson : adj.get(person)) {\\n            int quietPerson = dfs(richerPerson, adj, quiet, answer);\\n            if (quiet[quietPerson] < quiet[minQuietPerson]) {\\n                minQuietPerson = quietPerson;\\n            }\\n        }\\n\\n        answer[person] = minQuietPerson;\\n        return minQuietPerson;\\n    }\\n}\\n\\n```\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/b08811e9-c195-4626-9c79-1d9c9eb85ffc_1694761956.513607.webp)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < richer.length; i++) {\\n            adj.get(richer[i][1]).add(richer[i][0]); \\n        }\\n\\n        int[] answer = new int[n];\\n        Arrays.fill(answer, -1); \\n\\n        for (int i = 0; i < n; i++) {\\n            dfs(i, adj, quiet, answer);\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int dfs(int person,  ArrayList<ArrayList<Integer>> adj, int[] quiet, int[] answer) {\\n        if (answer[person] != -1) {\\n            return answer[person];\\n        }\\n\\n        int minQuietPerson = person; \\n        for (int richerPerson : adj.get(person)) {\\n            int quietPerson = dfs(richerPerson, adj, quiet, answer);\\n            if (quiet[quietPerson] < quiet[minQuietPerson]) {\\n                minQuietPerson = quietPerson;\\n            }\\n        }\\n\\n        answer[person] = minQuietPerson;\\n        return minQuietPerson;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044865,
                "title": "c-dp-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node,unordered_map<int,vector<int>> &adj,vector<int>& quiet,vector<int>& dp)\\n    {\\n        if(dp[node]!=-1) return dp[node];\\n        int mini = quiet[node];\\n        for(auto it:adj[node])\\n        {\\n            mini = min(mini,dfs(it,adj,quiet,dp));\\n        }\\n        return dp[node] = mini;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //so this is a one directional graph.\\n        unordered_map<int,vector<int>> adj;\\n        int n = richer.size();\\n        int m = quiet.size();\\n        unordered_map<int,int> store;\\n        for(int i = 0;i<m;i++)\\n        {\\n            store[quiet[i]] = i;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int> ans(m);\\n        vector<int> vis(m);\\n        vector<int> dp(500,-1);\\n        for(int i = 0;i<m;i++)\\n        {\\n            dp.clear();\\n            int k = dfs(i,adj,quiet,dp);\\n            ans[i] = store[k];\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node,unordered_map<int,vector<int>> &adj,vector<int>& quiet,vector<int>& dp)\\n    {\\n        if(dp[node]!=-1) return dp[node];\\n        int mini = quiet[node];\\n        for(auto it:adj[node])\\n        {\\n            mini = min(mini,dfs(it,adj,quiet,dp));\\n        }\\n        return dp[node] = mini;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //so this is a one directional graph.\\n        unordered_map<int,vector<int>> adj;\\n        int n = richer.size();\\n        int m = quiet.size();\\n        unordered_map<int,int> store;\\n        for(int i = 0;i<m;i++)\\n        {\\n            store[quiet[i]] = i;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int> ans(m);\\n        vector<int> vis(m);\\n        vector<int> dp(500,-1);\\n        for(int i = 0;i<m;i++)\\n        {\\n            dp.clear();\\n            int k = dfs(i,adj,quiet,dp);\\n            ans[i] = store[k];\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039822,
                "title": "loud-and-rich-graph-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhy did we think of graph at the first place ?? Because for every person(node) there can be many other persons (nodes) who are richer, and somehow if we can store all the richer persons and then do a traversal to find the quietest one among them our job will be done. Now we might think if we know 1,2,3 are richer than 0 then we can just traverse on them(0,1,2,3) and then find quietest among them but what if 5,6 are richer than 1 and also quieter than 1. This indicates need for a DFS search, a graph like structure.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCoding a DFS solution is pretty easy, but will we traverse for each node seperately ? What if a particular subgraph is common among two nodes. Yes, we can just memoize it which will also ensure that our complexity stays O(n) that is each node is visited once.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as each node will be visited only once since we are memoizing the result\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        //graph + dp based question\\n        // we will create a directed graph where subgraph of each node will consist of members which are richer than the current node\\n        // we will also have a visited dp array whch will be initially filled with -1, it will serve 2 purposes firstly it will indicate whether node is visited or not and secondly it will also store the quietest person for the subgraph if each index\\n        int n=quiet.length;\\n        ArrayList<Integer> [] graph=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n        for(int[] rich : richer){\\n            int a=rich[0];\\n            int b=rich[1];\\n            graph[b].add(a);\\n        }\\n        int[] dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==-1){\\n                //not visited\\n                dfs(i,graph,dp,quiet);\\n            }\\n        }\\n        return dp;\\n    }\\n    public int dfs(int src,ArrayList<Integer> []graph,int[] dp,int[] quiet){\\n        if(dp[src]!=-1){\\n            return dp[src];\\n        }\\n        int minQuiet=quiet[src];\\n        int minIdx=src;\\n        for(int nbr : graph[src]){\\n            int rvIdx=dfs(nbr,graph,dp,quiet);\\n            if(quiet[rvIdx]<minQuiet){\\n                minQuiet=quiet[rvIdx];\\n                minIdx=rvIdx;\\n            }\\n        }\\n        return dp[src]=minIdx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        //graph + dp based question\\n        // we will create a directed graph where subgraph of each node will consist of members which are richer than the current node\\n        // we will also have a visited dp array whch will be initially filled with -1, it will serve 2 purposes firstly it will indicate whether node is visited or not and secondly it will also store the quietest person for the subgraph if each index\\n        int n=quiet.length;\\n        ArrayList<Integer> [] graph=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n        for(int[] rich : richer){\\n            int a=rich[0];\\n            int b=rich[1];\\n            graph[b].add(a);\\n        }\\n        int[] dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==-1){\\n                //not visited\\n                dfs(i,graph,dp,quiet);\\n            }\\n        }\\n        return dp;\\n    }\\n    public int dfs(int src,ArrayList<Integer> []graph,int[] dp,int[] quiet){\\n        if(dp[src]!=-1){\\n            return dp[src];\\n        }\\n        int minQuiet=quiet[src];\\n        int minIdx=src;\\n        for(int nbr : graph[src]){\\n            int rvIdx=dfs(nbr,graph,dp,quiet);\\n            if(quiet[rvIdx]<minQuiet){\\n                minQuiet=quiet[rvIdx];\\n                minIdx=rvIdx;\\n            }\\n        }\\n        return dp[src]=minIdx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035860,
                "title": "cpp-easy-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    int dfs(int u,vector<int>*adj,vector<int>&quiet){\\n         int ans=u;\\n        int mini=quiet[u];\\n        if(dp[u]!=-1) return dp[u];\\n         for(auto v:adj[u]){\\n             int t=dfs(v,adj,quiet);\\n             if(mini>quiet[t]){\\n                 mini=quiet[t];\\n                 ans=t;\\n                 \\n             }\\n         }\\n        return dp[u]=ans;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>ans;\\n        vector<int>adj[501];\\n        int maxi=-1;\\n        for(auto vec:richer){\\n            adj[vec[1]].push_back(vec[0]);\\n        }\\n        for(auto x:quiet)\\n            maxi=max(maxi,x);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=maxi;i++){\\n            int t=dfs(i,adj,quiet);\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[501];\\n    int dfs(int u,vector<int>*adj,vector<int>&quiet){\\n         int ans=u;\\n        int mini=quiet[u];\\n        if(dp[u]!=-1) return dp[u];\\n         for(auto v:adj[u]){\\n             int t=dfs(v,adj,quiet);\\n             if(mini>quiet[t]){\\n                 mini=quiet[t];\\n                 ans=t;\\n                 \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 4035608,
                "title": "very-basic-dfs-approach",
                "content": "# Intuition\\nJust create a simple graph in which thier is a directed edge from   \\nj -> i.\\n\\n# Approach\\nSimply do a dfs and update the ans vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<int>*adj,vector<bool>&visited,vector<int>&ans,vector<int>&quiet){\\n        visited[s]=true;\\n        int min=s;\\n        for(int x:adj[s]){\\n            if(!visited[x])\\n            dfs(x,adj,visited,ans,quiet);\\n            if(quiet[ans[x]]<quiet[min])\\n            min=ans[x];\\n        }\\n        ans[s]=min;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>adj[quiet.size()];\\n        vector<int>ans(quiet.size(),false);\\n        //creation of graph\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool>visited(quiet.size(),false);\\n        for(int i=0;i<quiet.size();i++){\\n            if(!visited[i])\\n            dfs(i,adj,visited,ans,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<int>*adj,vector<bool>&visited,vector<int>&ans,vector<int>&quiet){\\n        visited[s]=true;\\n        int min=s;\\n        for(int x:adj[s]){\\n            if(!visited[x])\\n            dfs(x,adj,visited,ans,quiet);\\n            if(quiet[ans[x]]<quiet[min])\\n            min=ans[x];\\n        }\\n        ans[s]=min;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int>adj[quiet.size()];\\n        vector<int>ans(quiet.size(),false);\\n        //creation of graph\\n        for(int i=0;i<richer.size();i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<bool>visited(quiet.size(),false);\\n        for(int i=0;i<quiet.size();i++){\\n            if(!visited[i])\\n            dfs(i,adj,visited,ans,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031203,
                "title": "1-dfs-brute-force-tle-2-dfs-dp-effective-solution-beats-90",
                "content": "# Code :-   DFS(brute force)\\n```\\nclass Solution {\\n    int node,mn;\\npublic:\\n    void solve(int i,vector<vector<int>>& v,vector<int>& b)\\n    {\\n        for(auto& x:v[i])\\n        {\\n            if(mn>=b[x])\\n            {\\n                mn=b[x];\\n                node=x;\\n            }\\n            solve(x,v,b);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& a, vector<int>& b) \\n    {\\n        int n=b.size();\\n        vector<vector<int>> v(n);\\n        vector<int> g(n,0);\\n        for(int i=0;i<a.size();i++)\\n            v[a[i][1]].push_back(a[i][0]);\\n        vector<int> vis(n,0);\\n        vector<int> ans(n),c;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=b[i];\\n            node=i;\\n            solve(i,v,b);\\n            ans[i]=node;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code :-   DFS+DP(effective solution)\\n```\\nclass Solution {\\n    int node,mn;\\npublic:\\n    void solve(int i,vector<vector<int>>& v,vector<int>& b,vector<int>& ans)\\n    {\\n        if(ans[i]!=-1)\\n        {\\n            if(mn>b[ans[i]])\\n            {\\n                node=ans[i];\\n                mn=b[ans[i]];\\n            }\\n            return;\\n        }\\n        for(auto& x:v[i])\\n        {\\n            if(mn>=b[x])\\n            {\\n                mn=b[x];\\n                node=x;\\n            }\\n            solve(x,v,b,ans);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& a, vector<int>& b) \\n    {\\n        int n=b.size();\\n        vector<vector<int>> v(n);\\n        vector<int> g(n,0);\\n        for(int i=0;i<a.size();i++)\\n            v[a[i][1]].push_back(a[i][0]);\\n        vector<int> vis(n,0);\\n        vector<int> ans(n,-1),c;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=b[i];\\n            node=i;\\n            solve(i,v,b,ans);\\n            ans[i]=node;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int node,mn;\\npublic:\\n    void solve(int i,vector<vector<int>>& v,vector<int>& b)\\n    {\\n        for(auto& x:v[i])\\n        {\\n            if(mn>=b[x])\\n            {\\n                mn=b[x];\\n                node=x;\\n            }\\n            solve(x,v,b);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& a, vector<int>& b) \\n    {\\n        int n=b.size();\\n        vector<vector<int>> v(n);\\n        vector<int> g(n,0);\\n        for(int i=0;i<a.size();i++)\\n            v[a[i][1]].push_back(a[i][0]);\\n        vector<int> vis(n,0);\\n        vector<int> ans(n),c;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=b[i];\\n            node=i;\\n            solve(i,v,b);\\n            ans[i]=node;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int node,mn;\\npublic:\\n    void solve(int i,vector<vector<int>>& v,vector<int>& b,vector<int>& ans)\\n    {\\n        if(ans[i]!=-1)\\n        {\\n            if(mn>b[ans[i]])\\n            {\\n                node=ans[i];\\n                mn=b[ans[i]];\\n            }\\n            return;\\n        }\\n        for(auto& x:v[i])\\n        {\\n            if(mn>=b[x])\\n            {\\n                mn=b[x];\\n                node=x;\\n            }\\n            solve(x,v,b,ans);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& a, vector<int>& b) \\n    {\\n        int n=b.size();\\n        vector<vector<int>> v(n);\\n        vector<int> g(n,0);\\n        for(int i=0;i<a.size();i++)\\n            v[a[i][1]].push_back(a[i][0]);\\n        vector<int> vis(n,0);\\n        vector<int> ans(n,-1),c;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=b[i];\\n            node=i;\\n            solve(i,v,b,ans);\\n            ans[i]=node;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018239,
                "title": "easy-dfs-memozation",
                "content": "It\\'s just directed graph problem with dfs \\nthe richer aray is nothing but directed edge infomation and quiter array is let\\'s say node values and it\\'s unique (a plus point)\\nso what we are asked is that find minimum value(quiter value) in among all the nodes in it\\'s subtree where current node is least rich and all it\\'s sub child is greater or equal rich\\nand we have to do this for each i in (0 to n) so we can memoize the results for future access \\n```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    vector<int> a;\\n    vector<vector<int>> g;\\n    int dfs(int s)\\n    {\\n        if(dp[s]!=-1) return dp[s];\\n        int ans= a[s];\\n        \\n        for(auto i: g[s])\\n        {\\n            ans= min(ans, dfs(i));\\n        }\\n        \\n        return dp[s]= ans;\\n        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) \\n    {\\n        a=q;\\n        int n=q.size();\\n        g.resize(n);\\n        unordered_map<int,int> m;\\n        \\n        for(int i=0; i<n; i++) m[a[i]]=i;\\n        for(auto i: r) g[i[1]].push_back(i[0]);\\n        \\n        vector<int> ans(n,0);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0; i<n; i++) \\n        {\\n            int val=dfs(i);\\n            ans[i]= m[val];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    vector<int> a;\\n    vector<vector<int>> g;\\n    int dfs(int s)\\n    {\\n        if(dp[s]!=-1) return dp[s];\\n        int ans= a[s];\\n        \\n        for(auto i: g[s])\\n        {\\n            ans= min(ans, dfs(i));\\n        }\\n        \\n        return dp[s]= ans;\\n        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) \\n    {\\n        a=q;\\n        int n=q.size();\\n        g.resize(n);\\n        unordered_map<int,int> m;\\n        \\n        for(int i=0; i<n; i++) m[a[i]]=i;\\n        for(auto i: r) g[i[1]].push_back(i[0]);\\n        \\n        vector<int> ans(n,0);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0; i<n; i++) \\n        {\\n            int val=dfs(i);\\n            ans[i]= m[val];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015818,
                "title": "python3-topological-sort-dfs",
                "content": "# Intuition\\n- Create a graph with the edges given to understand the neigbhors \\n- Post that if you do topological sort you will arrive to list of richer people now get the quietest among them\\n\\n# Approach\\n- Topo Sort whilee keeping track of the quietest\\n\\n# Complexity\\n- Time complexity:\\n- O(V*N+E)\\n- n because of the loop in stack\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n\\n        def solve(richer,quiet):\\n            graph = defaultdict(list)\\n\\n            for i in range(len(richer)):\\n                graph[richer[i][1]].append(richer[i][0])\\n            vis = [False for _ in range(len(quiet))]\\n            pathVis = [False for _ in range(len(quiet))]\\n\\n\\n            ans = {}\\n            for i in range(len(quiet)):\\n                ans[i] = i\\n\\n\\n            def topoSort(v,stack):\\n                vis[v] = True\\n                pathVis[v] = True\\n                for n in graph[v]:\\n                    if vis[n] == False and pathVis[n] == False:\\n                        topoSort(n,stack+[v])\\n                    elif vis[n] == True:\\n                        if quiet[ans[n]] < quiet[ans[v]]:\\n                            ans[v] = ans[n]\\n\\n                if len(graph[v]) == 0:\\n                    stack.append(v)\\n                    for i in range(len(stack)-2,-1,-1):\\n                        if quiet[ans[stack[i]]] > quiet[ans[stack[i+1]]]:\\n                            ans[stack[i]] = ans[stack[i+1]]\\n                if len(stack) !=0:\\n                    stack.pop()    \\n                pathVis[v] = False\\n\\n            stack = []\\n            for i in range(len(vis)):\\n                if vis[i]==False:\\n                    topoSort(i,stack)\\n\\n            result = [None for _ in range(len(quiet))]\\n            for key in ans:\\n                result[key] = ans[key]\\n            return result\\n        return solve(richer,quiet)\\n        # return [2]\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def loudAndRich(self, richer, quiet):\\n        \"\"\"\\n        :type richer: List[List[int]]\\n        :type quiet: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n\\n        def solve(richer,quiet):\\n            graph = defaultdict(list)\\n\\n            for i in range(len(richer)):\\n                graph[richer[i][1]].append(richer[i][0])\\n            vis = [False for _ in range(len(quiet))]\\n            pathVis = [False for _ in range(len(quiet))]\\n\\n\\n            ans = {}\\n            for i in range(len(quiet)):\\n                ans[i] = i\\n\\n\\n            def topoSort(v,stack):\\n                vis[v] = True\\n                pathVis[v] = True\\n                for n in graph[v]:\\n                    if vis[n] == False and pathVis[n] == False:\\n                        topoSort(n,stack+[v])\\n                    elif vis[n] == True:\\n                        if quiet[ans[n]] < quiet[ans[v]]:\\n                            ans[v] = ans[n]\\n\\n                if len(graph[v]) == 0:\\n                    stack.append(v)\\n                    for i in range(len(stack)-2,-1,-1):\\n                        if quiet[ans[stack[i]]] > quiet[ans[stack[i+1]]]:\\n                            ans[stack[i]] = ans[stack[i+1]]\\n                if len(stack) !=0:\\n                    stack.pop()    \\n                pathVis[v] = False\\n\\n            stack = []\\n            for i in range(len(vis)):\\n                if vis[i]==False:\\n                    topoSort(i,stack)\\n\\n            result = [None for _ in range(len(quiet))]\\n            for key in ans:\\n                result[key] = ans[key]\\n            return result\\n        return solve(richer,quiet)\\n        # return [2]\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996845,
                "title": "begineer-friendly-solution-c-dfs-o-n",
                "content": "\\n\\n# Approach\\nCreate adjacency list of directed graph.\\nif there is a edge a->b , it means b is richer than a.\\nSteps:\\n1)Visit a node ,check its quitness and declare it with mini.\\n2)Now check its neighbours quitness via a recursive call.\\n3)compare quitness of neighbour and the current node and update its value in ans array.\\n\\n          \\n    \\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    unordered_map<int,vector<int>>adj;\\n\\n    int dfs(int node, vector<int>& quiet){\\n\\n        if(ans[node] != (-1)){return ans[node];} //caching \\n      \\n         <!-- step2 -->\\n        int mini = node;\\n        <!-- step3 -->\\n        for(auto it : adj[node]){\\n            \\n            if(quiet[dfs(it,quiet)] < quiet[mini]){\\n               \\n               mini = dfs(it,quiet);\\n          \\n            }\\n         \\n\\n        }\\n       \\n        ans[node] = mini;\\n        return mini;\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n =  quiet.size();\\n        ans.resize(n,-1);\\n        <!-- step1 -->\\n        for(auto it : richer ){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            if(ans[i] == -1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    unordered_map<int,vector<int>>adj;\\n\\n    int dfs(int node, vector<int>& quiet){\\n\\n        if(ans[node] != (-1)){return ans[node];} //caching \\n      \\n         <!-- step2 -->\\n        int mini = node;\\n        <!-- step3 -->\\n        for(auto it : adj[node]){\\n            \\n            if(quiet[dfs(it,quiet)] < quiet[mini]){\\n               \\n               mini = dfs(it,quiet);\\n          \\n            }\\n         \\n\\n        }\\n       \\n        ans[node] = mini;\\n        return mini;\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n =  quiet.size();\\n        ans.resize(n,-1);\\n        <!-- step1 -->\\n        for(auto it : richer ){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            if(ans[i] == -1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978243,
                "title": "easy-c-topological-sort-3-line-code-logic",
                "content": "# Intuition\\nProblem Statement clearly states its a topological sort, all we need to do is add a logic to get the desired output.\\n\\nanswer[x] = y the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.\\n\\n```\\n//Suppose a is richer than b and b is richer than c , now quietness so\\n\\nanswer[a] = a (richest)\\nanswer[b] = min(quiet[a],quiet[b])   (more or equal money)\\nanswer[c] = min(quiet[c],quiet[b]) \\n```\\n**ONLY THIS INTUITION WAS REQUIRED**\\n\\n\\n# Approach\\n\\n```cpp\\nif(quiet[ans[b]]>quiet[ans[a]]) // we need the number of the person\\n{\\n    ans[b]=ans[a];\\n}\\n\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans(n);\\n        \\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n\\n        for(auto r : richer) {\\n            adj[r[0]].push_back(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        vector<pair<int,int>> sorted;\\n        queue<int> q;\\n\\n        for(int i=0;i<n;i++) {\\n             ans[i]=i;\\n            if(indegree[i]==0) {\\n             q.push(i);\\n\\n            }\\n        }\\n        \\n        int k=0;\\n        while(!q.empty()){\\n                int u = q.front();\\n\\t            q.pop();\\n\\t            \\n\\t            for(auto v : adj[u]){\\n\\t                indegree[v]--;\\n                    if(quiet[ans[v]]>quiet[ans[u]]){\\n                        ans[v]=ans[u];\\n                    }\\n\\t                if(indegree[v]==0) q.push(v);\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n//Suppose a is richer than b and b is richer than c , now quietness so\\n\\nanswer[a] = a (richest)\\nanswer[b] = min(quiet[a],quiet[b])   (more or equal money)\\nanswer[c] = min(quiet[c],quiet[b]) \\n```\n```cpp\\nif(quiet[ans[b]]>quiet[ans[a]]) // we need the number of the person\\n{\\n    ans[b]=ans[a];\\n}\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans(n);\\n        \\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n\\n        for(auto r : richer) {\\n            adj[r[0]].push_back(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        vector<pair<int,int>> sorted;\\n        queue<int> q;\\n\\n        for(int i=0;i<n;i++) {\\n             ans[i]=i;\\n            if(indegree[i]==0) {\\n             q.push(i);\\n\\n            }\\n        }\\n        \\n        int k=0;\\n        while(!q.empty()){\\n                int u = q.front();\\n\\t            q.pop();\\n\\t            \\n\\t            for(auto v : adj[u]){\\n\\t                indegree[v]--;\\n                    if(quiet[ans[v]]>quiet[ans[u]]){\\n                        ans[v]=ans[u];\\n                    }\\n\\t                if(indegree[v]==0) q.push(v);\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969882,
                "title": "extended-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n\\n        vector<int> in(n,-1) ;\\n\\n        vector<int> adj[n];\\n\\n        for(auto i:richer)\\n        {\\n            int u = i [0] ;\\n            int v = i [1] ;\\n\\n            adj [u].push_back(v);\\n\\n            if(in[u]==-1)in[u]=0;\\n            if(in [v]==-1)in [v]=0;\\n            in [v]++;\\n        }\\n        \\n         vector<int>m(n);\\n         queue<int>q;\\n         for(int i=0;i<n;i++)\\n         {\\n             if(in[i]==0)q.push(i);\\n             m[quiet[i]]=i;\\n         }\\n         while(q.size())\\n         {\\n              int t= q.front();\\n              q.pop() ;\\n\\n              for( auto i :adj[t])\\n              {\\n                  if(--in[i]==0)\\n                  q.push(i);\\n\\n                  quiet[i]=min(quiet[i],quiet[t]);\\n              }\\n         }\\n         for(int i=0; i< n; i++)\\n         {\\n            \\n                 quiet[i]=m[quiet[i]];\\n            //  }\\n            //  else\\n            //  quiet[i]=i;\\n         }\\n        \\n        return quiet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n\\n        vector<int> in(n,-1) ;\\n\\n        vector<int> adj[n];\\n\\n        for(auto i:richer)\\n        {\\n            int u = i [0] ;\\n            int v = i [1] ;\\n\\n            adj [u].push_back(v);\\n\\n            if(in[u]==-1)in[u]=0;\\n            if(in [v]==-1)in [v]=0;\\n            in [v]++;\\n        }\\n        \\n         vector<int>m(n);\\n         queue<int>q;\\n         for(int i=0;i<n;i++)\\n         {\\n             if(in[i]==0)q.push(i);\\n             m[quiet[i]]=i;\\n         }\\n         while(q.size())\\n         {\\n              int t= q.front();\\n              q.pop() ;\\n\\n              for( auto i :adj[t])\\n              {\\n                  if(--in[i]==0)\\n                  q.push(i);\\n\\n                  quiet[i]=min(quiet[i],quiet[t]);\\n              }\\n         }\\n         for(int i=0; i< n; i++)\\n         {\\n            \\n                 quiet[i]=m[quiet[i]];\\n            //  }\\n            //  else\\n            //  quiet[i]=i;\\n         }\\n        \\n        return quiet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969191,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    void dfs(int curr, vector<int> adjList[], vector<bool> &visited, vector<int>& quiet) {\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        for(int next: adjList[curr]) {\\n            dfs(next, adjList, visited, quiet);\\n            quiet[curr] = min(quiet[curr], quiet[next]); \\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n];\\n        for(vector<int> edge: richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        unordered_map<int, int> index;\\n        for(int i = 0; i < n; i++) index[quiet[i]] = i;\\n        vector<bool> visited(n);\\n        for(int i = 0; i < n; i++) {\\n            dfs(i, adjList, visited, quiet);\\n        }\\n        for(int i = 0; i < n; i++) quiet[i] = index[quiet[i]];\\n        return quiet;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\n    void dfs(int curr, vector<int> adjList[], vector<bool> &visited, vector<int>& quiet, vector<int>& ans) {\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        for(int next: adjList[curr]) {\\n            dfs(next, adjList, visited, quiet, ans);\\n            if(quiet[ans[next]] < quiet[ans[curr]])\\n                ans[curr] = ans[next];\\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n], ans(n);\\n        for(vector<int> edge: richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        iota(ans.begin(), ans.end(), 0);\\n        vector<bool> visited(n);\\n        for(int i = 0; i < n; i++) {\\n            dfs(i, adjList, visited, quiet, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int curr, vector<int> adjList[], vector<bool> &visited, vector<int>& quiet) {\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        for(int next: adjList[curr]) {\\n            dfs(next, adjList, visited, quiet);\\n            quiet[curr] = min(quiet[curr], quiet[next]); \\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n];\\n        for(vector<int> edge: richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        unordered_map<int, int> index;\\n        for(int i = 0; i < n; i++) index[quiet[i]] = i;\\n        vector<bool> visited(n);\\n        for(int i = 0; i < n; i++) {\\n            dfs(i, adjList, visited, quiet);\\n        }\\n        for(int i = 0; i < n; i++) quiet[i] = index[quiet[i]];\\n        return quiet;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\n    void dfs(int curr, vector<int> adjList[], vector<bool> &visited, vector<int>& quiet, vector<int>& ans) {\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        for(int next: adjList[curr]) {\\n            dfs(next, adjList, visited, quiet, ans);\\n            if(quiet[ans[next]] < quiet[ans[curr]])\\n                ans[curr] = ans[next];\\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adjList[n], ans(n);\\n        for(vector<int> edge: richer) {\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        iota(ans.begin(), ans.end(), 0);\\n        vector<bool> visited(n);\\n        for(int i = 0; i < n; i++) {\\n            dfs(i, adjList, visited, quiet, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963872,
                "title": "dfs-beats-100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere I have used DFS approach and constructed a directed graph like richer[i]=[a,b] then there is a edge from b-> a that will tell about who are more richer people than the node.\\nanswer[i]=min(quiet[i],quietness of all child)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(edges+vertices)\\nas its a dfs approach\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<int>& quiet,vector<bool> &visited, vector<vector<int>> &v,vector<int> &answer){\\n        if(visited[node]){\\n            return answer[node];\\n        }\\n        visited[node]=true;\\n\\n        int value=node;\\n        for(int i=0;i<v[node].size();i++){\\n//checking if there is any node in child tree that has low quiet value by calling dfs on every child\\n            int p=dfs(v[node][i],quiet,visited,v,answer);\\n            if(quiet[value]>quiet[p]){\\n                value=p;\\n            }\\n        }\\n        return answer[node]=value;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++){\\n            answer[i]=i;\\n        }\\n        vector<vector<int>> v(n);\\n        vector<int> indegree(n,0);\\n//indegree is used here to know from which node dfs can be started its not always neccasry that 0 is starting point\\n        for(int i=0;i<richer.size();i++){\\n            indegree[richer[i][0]]++;\\n            v[richer[i][1]].push_back(richer[i][0]);\\n        }\\n      \\n        vector<bool> visited(n,false);\\n        for(int i=0;i<n;i++){\\n            if(visited[i]==false && indegree[i]==0){\\n                dfs(i,quiet,visited,v,answer);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<int>& quiet,vector<bool> &visited, vector<vector<int>> &v,vector<int> &answer){\\n        if(visited[node]){\\n            return answer[node];\\n        }\\n        visited[node]=true;\\n\\n        int value=node;\\n        for(int i=0;i<v[node].size();i++){\\n//checking if there is any node in child tree that has low quiet value by calling dfs on every child\\n            int p=dfs(v[node][i],quiet,visited,v,answer);\\n            if(quiet[value]>quiet[p]){\\n                value=p;\\n            }\\n        }\\n        return answer[node]=value;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++){\\n            answer[i]=i;\\n        }\\n        vector<vector<int>> v(n);\\n        vector<int> indegree(n,0);\\n//indegree is used here to know from which node dfs can be started its not always neccasry that 0 is starting point\\n        for(int i=0;i<richer.size();i++){\\n            indegree[richer[i][0]]++;\\n            v[richer[i][1]].push_back(richer[i][0]);\\n        }\\n      \\n        vector<bool> visited(n,false);\\n        for(int i=0;i<n;i++){\\n            if(visited[i]==false && indegree[i]==0){\\n                dfs(i,quiet,visited,v,answer);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962955,
                "title": "python-clean-and-simple-topological-solution",
                "content": "```\\nfrom collections import defaultdict\\nfrom functools import cache\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:\\n        n = len(quiet)\\n\\n        g = self.create_graph(richer)\\n\\n        @cache\\n        def dfs(u: int) -> tuple[int, int]:\\n            \"\"\"\\n            finds the least quiet person having money more than or equal to person \"u\" \\n            and returns tuple containing the quietness and corresponding person index \\n            with that quietness \\n            :param u: \\n            :return:  \\n            \"\"\"\\n            return min(\\n                chain(\\n                    map(dfs, g[u]),\\n                    ((quiet[u], u),)\\n                )\\n            )\\n\\n        return [dfs(i)[1] for i in range(n)]\\n\\n    @staticmethod\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for a, b in edges:\\n            g[b].append(a)\\n\\n        return g\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import cache\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:\\n        n = len(quiet)\\n\\n        g = self.create_graph(richer)\\n\\n        @cache\\n        def dfs(u: int) -> tuple[int, int]:\\n            \"\"\"\\n            finds the least quiet person having money more than or equal to person \"u\" \\n            and returns tuple containing the quietness and corresponding person index \\n            with that quietness \\n            :param u: \\n            :return:  \\n            \"\"\"\\n            return min(\\n                chain(\\n                    map(dfs, g[u]),\\n                    ((quiet[u], u),)\\n                )\\n            )\\n\\n        return [dfs(i)[1] for i in range(n)]\\n\\n    @staticmethod\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for a, b in edges:\\n            g[b].append(a)\\n\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955095,
                "title": "java-dfs-traversal-on-poor-directed-graph",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        return dfsApproach(richer, quiet);\\n    }\\n    \\n    /*\\n    Algo:\\n        Create graph for showing poor relationship\\n        graph = {k: richer[1], v: list(richer[0])}\\n\\n        run dfs and get node with min quietness for each node\\n    */\\n\\n    private int[] dfsApproach(int[][] richer, int[] quiet) {\\n        Map<Integer, Set<Integer>> graph = Arrays.stream(richer).collect(Collectors.groupingBy(rich -> rich[1], Collectors.mapping(rich -> rich[0], Collectors.toSet())));\\n        \\n        int n = quiet.length;\\n        int[] result = IntStream.generate(() -> -1).limit(n).toArray();\\n        \\n        IntStream.range(0, n).forEach(u -> dfsApproach(u, graph, quiet, result));\\n        \\n        return result;\\n    }\\n    private int dfsApproach(int u, Map<Integer, Set<Integer>> graph, int[] quiet, int[] result) {\\n        if(result[u] != -1) return result[u];\\n\\n        Set<Integer> neighbors = graph.getOrDefault(u, Set.of());\\n        \\n        return result[u] = neighbors.stream().mapToInt(v -> dfsApproach(v, graph, quiet, result)).reduce(u, (minNode, v) -> quiet[minNode] < quiet[v] ? minNode : v);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        return dfsApproach(richer, quiet);\\n    }\\n    \\n    /*\\n    Algo:\\n        Create graph for showing poor relationship\\n        graph = {k: richer[1], v: list(richer[0])}\\n\\n        run dfs and get node with min quietness for each node\\n    */\\n\\n    private int[] dfsApproach(int[][] richer, int[] quiet) {\\n        Map<Integer, Set<Integer>> graph = Arrays.stream(richer).collect(Collectors.groupingBy(rich -> rich[1], Collectors.mapping(rich -> rich[0], Collectors.toSet())));\\n        \\n        int n = quiet.length;\\n        int[] result = IntStream.generate(() -> -1).limit(n).toArray();\\n        \\n        IntStream.range(0, n).forEach(u -> dfsApproach(u, graph, quiet, result));\\n        \\n        return result;\\n    }\\n    private int dfsApproach(int u, Map<Integer, Set<Integer>> graph, int[] quiet, int[] result) {\\n        if(result[u] != -1) return result[u];\\n\\n        Set<Integer> neighbors = graph.getOrDefault(u, Set.of());\\n        \\n        return result[u] = neighbors.stream().mapToInt(v -> dfsApproach(v, graph, quiet, result)).reduce(u, (minNode, v) -> quiet[minNode] < quiet[v] ? minNode : v);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937900,
                "title": "python-3-simple-topologcal-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        # create an indegree array and adjList from rich to poor\\n        adjList = defaultdict(list)\\n        indegree = [0] * len(quiet)\\n        for u, v in richer:\\n            adjList[u].append(v)\\n            indegree[v] += 1\\n\\n        # store the index of the least quiteness for each indegree reduction\\n        q = deque()\\n        leastQuiet = [i for i in range(len(quiet))]\\n        for i in range(len(quiet)):\\n            if not indegree[i]:\\n                q.append(i)\\n\\n        res = [0] * len(quiet)\\n        # starting from the src; rich\\n            # bfs-topological sort\\n        while q:\\n            node = q.popleft()\\n            res[node] = leastQuiet[node]\\n\\n            for nei in adjList[node]:\\n                indegree[nei] -= 1\\n\\n                # update the index of the least quiet stored in the nei\\n                    # when visiting from the source\\n                if quiet[leastQuiet[nei]] > quiet[leastQuiet[node]]:\\n                    leastQuiet[nei] = leastQuiet[node]\\n                if not indegree[nei]:\\n                    q.append(nei)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        # create an indegree array and adjList from rich to poor\\n        adjList = defaultdict(list)\\n        indegree = [0] * len(quiet)\\n        for u, v in richer:\\n            adjList[u].append(v)\\n            indegree[v] += 1\\n\\n        # store the index of the least quiteness for each indegree reduction\\n        q = deque()\\n        leastQuiet = [i for i in range(len(quiet))]\\n        for i in range(len(quiet)):\\n            if not indegree[i]:\\n                q.append(i)\\n\\n        res = [0] * len(quiet)\\n        # starting from the src; rich\\n            # bfs-topological sort\\n        while q:\\n            node = q.popleft()\\n            res[node] = leastQuiet[node]\\n\\n            for nei in adjList[node]:\\n                indegree[nei] -= 1\\n\\n                # update the index of the least quiet stored in the nei\\n                    # when visiting from the source\\n                if quiet[leastQuiet[nei]] > quiet[leastQuiet[node]]:\\n                    leastQuiet[nei] = leastQuiet[node]\\n                if not indegree[nei]:\\n                    q.append(nei)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937550,
                "title": "concise-and-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> ans(n, INT_MAX);\\n        vector<int> indegree(n, 0);\\n        queue<int> q;\\n            for (const auto& relation : richer) {\\n            int source = relation[0];\\n            int target = relation[1];\\n            adj[source].push_back(target);\\n            indegree[target]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = i;\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for (int neighbor : adj[node]) {\\n                if (ans[neighbor] == INT_MAX || quiet[ans[neighbor]] > quiet[ans[node]]) {\\n                    ans[neighbor] = ans[node];\\n                }\\n                indegree[neighbor]--;\\n                if (indegree[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> ans(n, INT_MAX);\\n        vector<int> indegree(n, 0);\\n        queue<int> q;\\n            for (const auto& relation : richer) {\\n            int source = relation[0];\\n            int target = relation[1];\\n            adj[source].push_back(target);\\n            indegree[target]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = i;\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for (int neighbor : adj[node]) {\\n                if (ans[neighbor] == INT_MAX || quiet[ans[neighbor]] > quiet[ans[node]]) {\\n                    ans[neighbor] = ans[node];\\n                }\\n                indegree[neighbor]--;\\n                if (indegree[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933684,
                "title": "dynamic-programming-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dp[501];\\n    int dfs(map<int,vector<int>>&adj, vector<int>& quiet,int node){\\n        int num=node;\\n        if(dp[node]!=-1) return dp[node];\\n        for(int i=0; i<adj[node].size(); i++){\\n            \\n            int temp = dfs(adj,quiet,adj[node][i]);\\n            if(quiet[num]>quiet[temp])\\n            num = temp;\\n        }\\n        \\n        if(quiet[node] < quiet[num])\\n        return dp[node] = node;\\n        return dp[node] = num;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        map<int, vector<int>>adj;\\n        for(int i=0; i<richer.size(); i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);   \\n        }\\n        vector<int> ans;\\n        for(int i=0; i<501; i++){\\n            dp[i] = -1;\\n        }\\n        for(int i=0; i<quiet.size(); i++){\\n            ans.push_back(dfs(adj,quiet,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[501];\\n    int dfs(map<int,vector<int>>&adj, vector<int>& quiet,int node){\\n        int num=node;\\n        if(dp[node]!=-1) return dp[node];\\n        for(int i=0; i<adj[node].size(); i++){\\n            \\n            int temp = dfs(adj,quiet,adj[node][i]);\\n            if(quiet[num]>quiet[temp])\\n            num = temp;\\n        }\\n        \\n        if(quiet[node] < quiet[num])\\n        return dp[node] = node;\\n        return dp[node] = num;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        map<int, vector<int>>adj;\\n        for(int i=0; i<richer.size(); i++){\\n            adj[richer[i][1]].push_back(richer[i][0]);   \\n        }\\n        vector<int> ans;\\n        for(int i=0; i<501; i++){\\n            dp[i] = -1;\\n        }\\n        for(int i=0; i<quiet.size(); i++){\\n            ans.push_back(dfs(adj,quiet,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926449,
                "title": "simple-cpp-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int,vector<int>>&graph,int v,vector<int>&visited, vector<int>& quiet,int& idx){\\n\\n        visited[v] = 1;\\n\\n        for(auto node:graph[v]){\\n\\n            if(!visited[node]){\\n                if(quiet[node]<quiet[idx]){\\n                    idx = node;\\n                }\\n                dfs(graph,node,visited,quiet,idx);\\n            }\\n        }\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n\\n        map<int,vector<int>> graph;\\n        vector<int> ans;\\n\\n        for(auto v:richer){\\n            graph[v[1]].push_back(v[0]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n\\n            int minQuiet = i;\\n            vector<int>vis(n,0);\\n            dfs(graph,i,vis,quiet,minQuiet);\\n            ans.push_back(minQuiet);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int,vector<int>>&graph,int v,vector<int>&visited, vector<int>& quiet,int& idx){\\n\\n        visited[v] = 1;\\n\\n        for(auto node:graph[v]){\\n\\n            if(!visited[node]){\\n                if(quiet[node]<quiet[idx]){\\n                    idx = node;\\n                }\\n                dfs(graph,node,visited,quiet,idx);\\n            }\\n        }\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        int n = quiet.size();\\n\\n        map<int,vector<int>> graph;\\n        vector<int> ans;\\n\\n        for(auto v:richer){\\n            graph[v[1]].push_back(v[0]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n\\n            int minQuiet = i;\\n            vector<int>vis(n,0);\\n            dfs(graph,i,vis,quiet,minQuiet);\\n            ans.push_back(minQuiet);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889227,
                "title": "c-dfs-approach",
                "content": "# Intuition\\nThe main thing would be here is to construct the adjacency list as it only provides the way forward to traverse through the richer people than the current people and find the quietest among them.\\n\\nIn order to construct the adjacency matrix we have to relate them reverse so that someone who is poor is always having the richer person in the adjacency list in order for him to traverse and find the richer people than him.\\n\\n`adj[richer[i][1]].push_back(richer[i][0])`\\n\\n# Approach\\nOnce after creating the adjacency list we can actually traverse by using DFS for each index and if we have already found the answer during the previous search then we simply return the answer and fill the answer array.\\nThis approach is also called as Hashing the DFS such that we might not move through the already found answer instead if we have the answer already hashed we simply return it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int idx, vector<int> &ans, vector<int> adj[], vector<int> &quiet) {\\n        if(ans[idx] == -1) {\\n            ans[idx] = idx;\\n            for(auto &it:adj[idx]) {\\n                int quietest = dfs(it, ans, adj, quiet);\\n                if(quiet[quietest] < quiet[ans[idx]]) {\\n                    ans[idx] = quietest;\\n                }\\n            }\\n        }\\n        return ans[idx];\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        for(auto &it : richer) {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans(n, -1);\\n        for(int i=0;i<n;i++) {\\n            dfs(i, ans, adj, quiet);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int idx, vector<int> &ans, vector<int> adj[], vector<int> &quiet) {\\n        if(ans[idx] == -1) {\\n            ans[idx] = idx;\\n            for(auto &it:adj[idx]) {\\n                int quietest = dfs(it, ans, adj, quiet);\\n                if(quiet[quietest] < quiet[ans[idx]]) {\\n                    ans[idx] = quietest;\\n                }\\n            }\\n        }\\n        return ans[idx];\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> adj[n];\\n        for(auto &it : richer) {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans(n, -1);\\n        for(int i=0;i<n;i++) {\\n            dfs(i, ans, adj, quiet);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885008,
                "title": "c-topological-sorting-graph",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //topological sort can help me in iterating over all the persons who are richer than child so basically i can compare everytime and fill the right person there\\n        int n=quiet.size();\\n        vector<int> indegree(n,0), ans(n,0);\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)ans[i]=i;//assume i is itself the ans which is true in some cases\\n        for(auto vec:richer){\\n            adj[vec[0]].push_back(vec[1]);\\n            indegree[vec[1]]++;\\n        }\\n        // push all the richest persons in the queue\\n        queue<int> pending;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)pending.push(i);\\n        }\\n        //topo sort\\n        while(!pending.empty()){\\n            int u=pending.front();\\n            pending.pop();\\n            for(auto child : adj[u]){\\n                indegree[child]--;//dependency removal from parent\\n                if(indegree[child]==0)pending.push(child);//all the richer are explored\\n                if(quiet[ans[child]]>quiet[ans[u]]){// ans[u] is the person least quiet person than u being the richer or equal than it\\n                    ans[child]=ans[u];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        //topological sort can help me in iterating over all the persons who are richer than child so basically i can compare everytime and fill the right person there\\n        int n=quiet.size();\\n        vector<int> indegree(n,0), ans(n,0);\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)ans[i]=i;//assume i is itself the ans which is true in some cases\\n        for(auto vec:richer){\\n            adj[vec[0]].push_back(vec[1]);\\n            indegree[vec[1]]++;\\n        }\\n        // push all the richest persons in the queue\\n        queue<int> pending;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)pending.push(i);\\n        }\\n        //topo sort\\n        while(!pending.empty()){\\n            int u=pending.front();\\n            pending.pop();\\n            for(auto child : adj[u]){\\n                indegree[child]--;//dependency removal from parent\\n                if(indegree[child]==0)pending.push(child);//all the richer are explored\\n                if(quiet[ans[child]]>quiet[ans[u]]){// ans[u] is the person least quiet person than u being the richer or equal than it\\n                    ans[child]=ans[u];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872531,
                "title": "python-dfs-solution-beats-100",
                "content": "Build graph in reverse way let\\'s say we are given [x,y], then build graph like there is an edge from y to x and not vice-versa. Use dfs to compute min value of all the children and also maintain the index of min value child, also check for min with self also. update the min value computed for both ans and quiet. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n      n = len(quiet) \\n      g,ans,mark = [[] for _ in range(n)],[i for i in range(n)],[False]*n\\n      for x,y in richer : g[y].append(x) \\n\\n      def dfs(x):\\n        mark[x] = True \\n        for i in g[x]:\\n          if not mark[i] : dfs(i) \\n          if quiet[x] > quiet[i] : \\n            quiet[x] = quiet[i] # taking min of all the parent values \\n            ans[x] = ans[i]  # taking index which has min value\\n      \\n      for i in range(n): \\n        if not mark[i] : \\n          dfs(i) \\n        \\n      return ans \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n      n = len(quiet) \\n      g,ans,mark = [[] for _ in range(n)],[i for i in range(n)],[False]*n\\n      for x,y in richer : g[y].append(x) \\n\\n      def dfs(x):\\n        mark[x] = True \\n        for i in g[x]:\\n          if not mark[i] : dfs(i) \\n          if quiet[x] > quiet[i] : \\n            quiet[x] = quiet[i] # taking min of all the parent values \\n            ans[x] = ans[i]  # taking index which has min value\\n      \\n      for i in range(n): \\n        if not mark[i] : \\n          dfs(i) \\n        \\n      return ans \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849717,
                "title": "c-topological-sort-solution-using-result-array-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<vector<int>> adjL(quiet.size(), vector<int>());\\n        vector<int> indegree(quiet.size(), 0);\\n\\n        for (auto rich : richer) {\\n            adjL[rich[0]].push_back(rich[1]);\\n            indegree[rich[1]]++;\\n        }\\n\\n        queue<int> q;\\n\\n        for (int i = 0; i < indegree.size(); i++) {\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> result(quiet.size());\\n\\n        for (int i = 0; i < result.size(); i++) {\\n            result[i] = i;\\n        }\\n    \\n        while (!q.empty()) {\\n            int front = q.front();\\n            \\n            q.pop();\\n\\n            for (int v : adjL[front]) {\\n                if (quiet[result[v]] > quiet[result[front]]) {\\n                    result[v] = result[front];\\n                }\\n\\n                if (--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<vector<int>> adjL(quiet.size(), vector<int>());\\n        vector<int> indegree(quiet.size(), 0);\\n\\n        for (auto rich : richer) {\\n            adjL[rich[0]].push_back(rich[1]);\\n            indegree[rich[1]]++;\\n        }\\n\\n        queue<int> q;\\n\\n        for (int i = 0; i < indegree.size(); i++) {\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> result(quiet.size());\\n\\n        for (int i = 0; i < result.size(); i++) {\\n            result[i] = i;\\n        }\\n    \\n        while (!q.empty()) {\\n            int front = q.front();\\n            \\n            q.pop();\\n\\n            for (int v : adjL[front]) {\\n                if (quiet[result[v]] > quiet[result[front]]) {\\n                    result[v] = result[front];\\n                }\\n\\n                if (--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833511,
                "title": "c-graphs-dfs",
                "content": "~~~\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector <vector <int>> g(n);\\n        for (int i=0; i<richer.size(); i++)\\n            g[richer[i][1]].push_back(richer[i][0]);\\n        \\n        vector <int> ans(n);\\n        for (int i=0; i<n; i++)\\n            ans[i] = i;\\n        \\n        vector <int> vis(n, 0);\\n        for (int i=0; i<n; i++)\\n            dfs (i, g, vis, ans, quiet);\\n        \\n        return ans;\\n    }\\n    \\n    void dfs (int v, vector <vector <int>>& g, vector <int>& vis, vector <int>& ans, vector <int>& q)\\n    {\\n        if (vis[v])\\n            return;\\n        \\n        vis[v] = 1;\\n        for (int i=0; i<g[v].size(); i++)\\n        {\\n            dfs (g[v][i], g, vis, ans, q);\\n            if (q[ans[g[v][i]]]<q[ans[v]])\\n                ans[v] = ans[g[v][i]];\\n        }\\n    }\\n};\\n~~~",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector <vector <int>> g(n);\\n        for (int i=0; i<richer.size(); i++)\\n            g[richer[i][1]].push_back(richer[i][0]);\\n        \\n        vector <int> ans(n);\\n        for (int i=0; i<n; i++)\\n            ans[i] = i;\\n        \\n        vector <int> vis(n, 0);\\n        for (int i=0; i<n; i++)\\n            dfs (i, g, vis, ans, quiet);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3829015,
                "title": "khan-s-algorithm-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to return an answer array where each index represents a person from 0 to N-1. The value of a particular index would be a special person who is least quiet among all the persons having equal or more money than the index(person).\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(V+E)$$ \\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int N = quiet.size();\\n        vector<int> indegree(N,0);\\n        vector<int> adj[N];\\n        for(auto x: richer){\\n            adj[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0; i<N; i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> answer(N);\\n        iota(answer.begin(),answer.end(),0);    \\n        \\n        while(!q.empty()){\\n            int personX = q.front();\\n            q.pop();\\n            for(auto personY: adj[personX]){\\n                if(quiet[answer[personY]] > quiet[answer[personX]]){\\n                    answer[personY]=answer[personX];\\n                }\\n                indegree[personY]--;\\n                if(indegree[personY]==0){\\n                    q.push(personY);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int N = quiet.size();\\n        vector<int> indegree(N,0);\\n        vector<int> adj[N];\\n        for(auto x: richer){\\n            adj[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0; i<N; i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> answer(N);\\n        iota(answer.begin(),answer.end(),0);    \\n        \\n        while(!q.empty()){\\n            int personX = q.front();\\n            q.pop();\\n            for(auto personY: adj[personX]){\\n                if(quiet[answer[personY]] > quiet[answer[personX]]){\\n                    answer[personY]=answer[personX];\\n                }\\n                indegree[personY]--;\\n                if(indegree[personY]==0){\\n                    q.push(personY);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821524,
                "title": "python-simple-bfs-beats-100",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/a9b1640f-ce0b-41ec-bee0-71001ad366d7_1690423946.9974694.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = defaultdict(list)\\n        for a,b in richer:\\n            graph[a].append(b)\\n        \\n        order = deque(quiet)\\n        \\n        # print(graph)\\n\\n        out = list(range(len(quiet)))\\n\\n        while order:\\n            i = order.popleft()\\n            # print(out, i, graph[i])\\n\\n            for nxt in graph[i]:\\n                # self.dfs(graph, quiet, nxt, i, out, visited)\\n                if quiet[out[i]] < quiet[out[nxt]]:\\n                    out[nxt] = out[i]\\n                    order.append(nxt)\\n\\n        return out\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        graph = defaultdict(list)\\n        for a,b in richer:\\n            graph[a].append(b)\\n        \\n        order = deque(quiet)\\n        \\n        # print(graph)\\n\\n        out = list(range(len(quiet)))\\n\\n        while order:\\n            i = order.popleft()\\n            # print(out, i, graph[i])\\n\\n            for nxt in graph[i]:\\n                # self.dfs(graph, quiet, nxt, i, out, visited)\\n                if quiet[out[i]] < quiet[out[nxt]]:\\n                    out[nxt] = out[i]\\n                    order.append(nxt)\\n\\n        return out\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820415,
                "title": "python-bfs-topo-sort",
                "content": "\\n# Code\\n```\\nfrom collections import defaultdict,deque\\n\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        graph,revg = defaultdict(list),defaultdict(list)\\n        n = len(quiet)\\n        ind = [0 for i in range(n)]\\n\\n        for x,y in richer:\\n            graph[x].append(y)\\n            revg[y].append(x)\\n            ind[y]+=1\\n\\n        q = deque()\\n\\n        for i,x in enumerate(ind):\\n            if x==0:\\n                q.append(i)\\n\\n        ans = [0 for i in range(n)]\\n        while q:\\n            cs = len(q)\\n            for i in range(cs):\\n                ele = q.popleft()\\n                ans[ele] = ele\\n                cq = quiet[ele]\\n\\n                for anc in revg[ele]:\\n                    if quiet[ans[anc]]<cq:\\n                        cq = quiet[ans[anc]]\\n                        ans[ele]=ans[anc]\\n\\n                for neigh in graph[ele]:\\n                    ind[neigh]-=1\\n                    if ind[neigh]==0:\\n                        q.append(neigh)\\n\\n        return ans\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict,deque\\n\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n\\n        graph,revg = defaultdict(list),defaultdict(list)\\n        n = len(quiet)\\n        ind = [0 for i in range(n)]\\n\\n        for x,y in richer:\\n            graph[x].append(y)\\n            revg[y].append(x)\\n            ind[y]+=1\\n\\n        q = deque()\\n\\n        for i,x in enumerate(ind):\\n            if x==0:\\n                q.append(i)\\n\\n        ans = [0 for i in range(n)]\\n        while q:\\n            cs = len(q)\\n            for i in range(cs):\\n                ele = q.popleft()\\n                ans[ele] = ele\\n                cq = quiet[ele]\\n\\n                for anc in revg[ele]:\\n                    if quiet[ans[anc]]<cq:\\n                        cq = quiet[ans[anc]]\\n                        ans[ele]=ans[anc]\\n\\n                for neigh in graph[ele]:\\n                    ind[neigh]-=1\\n                    if ind[neigh]==0:\\n                        q.append(neigh)\\n\\n        return ans\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820202,
                "title": "100-beats-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    DFS and Dynamic Programming\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Finding the minimum quiet of all the neighbours( all the indices that are richer than the index considered ).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\n    List<Integer> lis[];\\n    int n;\\n    int dp[];\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        n=quiet.length;\\n        dp=new int[n];\\n        lis=new ArrayList[n];\\n        Arrays.fill(dp,-1);\\n        int res[]=new int[n];\\n        for(int i=0;i<n;i++)\\n            lis[i]=new ArrayList<>();\\n        for(int i[] : richer)\\n        {\\n            lis[i[1]].add(i[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=dfs(i,quiet);\\n        }\\n        return res;\\n    }\\n    public int dfs(int ind,int []quiet)\\n    {\\n        if(dp[ind]!=-1) return dp[ind];\\n        int minIndex=ind,minQuiet=quiet[ind];\\n        for(int i : lis[ind])\\n        {\\n            int min=dfs(i,quiet);\\n            if(quiet[min]<minQuiet)\\n            {\\n                minQuiet=quiet[min];\\n                minIndex=min;\\n            }\\n        }\\n        return dp[ind]=minIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> lis[];\\n    int n;\\n    int dp[];\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        n=quiet.length;\\n        dp=new int[n];\\n        lis=new ArrayList[n];\\n        Arrays.fill(dp,-1);\\n        int res[]=new int[n];\\n        for(int i=0;i<n;i++)\\n            lis[i]=new ArrayList<>();\\n        for(int i[] : richer)\\n        {\\n            lis[i[1]].add(i[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=dfs(i,quiet);\\n        }\\n        return res;\\n    }\\n    public int dfs(int ind,int []quiet)\\n    {\\n        if(dp[ind]!=-1) return dp[ind];\\n        int minIndex=ind,minQuiet=quiet[ind];\\n        for(int i : lis[ind])\\n        {\\n            int min=dfs(i,quiet);\\n            if(quiet[min]<minQuiet)\\n            {\\n                minQuiet=quiet[min];\\n                minIndex=min;\\n            }\\n        }\\n        return dp[ind]=minIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798374,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] LoudAndRich(int[][] richer, int[] quiet) {\\n        var dict = new Dictionary<int, IList<int>>();\\n        for (int i = 0; i < richer.Length; i++)\\n        {\\n            if (!dict.ContainsKey(richer[i][1]))\\n                dict[richer[i][1]] = new List<int>();\\n            dict[richer[i][1]].Add(richer[i][0]);\\n        }\\n        int[] res = new int[quiet.Length];\\n        for (int i = 0; i < res.Length; i++) res[i] = -1;\\n        for (int i = 0; i < quiet.Length; i++)\\n            Helper(i, dict, quiet, res);\\n        return res;\\n    }\\n    void Helper(int index, Dictionary<int, IList<int>> dict, int[] quiet, int[] res)\\n    {\\n        if (res[index] > -1) return;\\n        res[index] = index;\\n        if (dict.ContainsKey(index))\\n        {\\n            foreach(var item in dict[index])\\n            {\\n                Helper(item, dict, quiet, res);\\n                if (quiet[res[item]] < quiet[res[index]])\\n                    res[index] = res[item];\\n            }           \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] LoudAndRich(int[][] richer, int[] quiet) {\\n        var dict = new Dictionary<int, IList<int>>();\\n        for (int i = 0; i < richer.Length; i++)\\n        {\\n            if (!dict.ContainsKey(richer[i][1]))\\n                dict[richer[i][1]] = new List<int>();\\n            dict[richer[i][1]].Add(richer[i][0]);\\n        }\\n        int[] res = new int[quiet.Length];\\n        for (int i = 0; i < res.Length; i++) res[i] = -1;\\n        for (int i = 0; i < quiet.Length; i++)\\n            Helper(i, dict, quiet, res);\\n        return res;\\n    }\\n    void Helper(int index, Dictionary<int, IList<int>> dict, int[] quiet, int[] res)\\n    {\\n        if (res[index] > -1) return;\\n        res[index] = index;\\n        if (dict.ContainsKey(index))\\n        {\\n            foreach(var item in dict[index])\\n            {\\n                Helper(item, dict, quiet, res);\\n                if (quiet[res[item]] < quiet[res[index]])\\n                    res[index] = res[item];\\n            }           \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781877,
                "title": "c-beat-92-5-in-tc-beat-70-in-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>&ans,vector<vector<int>>&adj,vector<int>&vis,vector<int>& q)\\n    {\\n        vis[node]=1;\\n    //    cout<<node<<endl;\\n        for(auto i:adj[node])\\n        {\\n            if(vis[i]==0)\\n            {\\n                 dfs(i,ans,adj,vis,q);\\n                 \\n            }\\n            ans[node]=min(ans[node],ans[i]);\\n        }\\n        // cout<<node<<\" \"<<ans[node]<<endl;\\n       return;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        int n=q.size();\\n        vector<int>ans(n);\\n        vector<vector<int>>adj(n);\\n\\n        for(auto &i:r)\\n        {\\n            // cout<<i[0]<<\" \"<<i[1]<<endl;\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[q[i]]=i;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=q[i];\\n        } \\n\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n              if(vis[i]==0)\\n              {\\n                  dfs(i,ans,adj,vis,q);\\n              }\\n        }\\n\\n       for(auto &i:ans)\\n       {\\n           i=mp[i];\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>&ans,vector<vector<int>>&adj,vector<int>&vis,vector<int>& q)\\n    {\\n        vis[node]=1;\\n    //    cout<<node<<endl;\\n        for(auto i:adj[node])\\n        {\\n            if(vis[i]==0)\\n            {\\n                 dfs(i,ans,adj,vis,q);\\n                 \\n            }\\n            ans[node]=min(ans[node],ans[i]);\\n        }\\n        // cout<<node<<\" \"<<ans[node]<<endl;\\n       return;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        int n=q.size();\\n        vector<int>ans(n);\\n        vector<vector<int>>adj(n);\\n\\n        for(auto &i:r)\\n        {\\n            // cout<<i[0]<<\" \"<<i[1]<<endl;\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[q[i]]=i;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=q[i];\\n        } \\n\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n              if(vis[i]==0)\\n              {\\n                  dfs(i,ans,adj,vis,q);\\n              }\\n        }\\n\\n       for(auto &i:ans)\\n       {\\n           i=mp[i];\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3766961,
                "title": "esay-java-dfs-loud-and-rich",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        ArrayList<Integer> arr[] = new ArrayList[quiet.length];\\n        boolean[] visited =  new boolean[quiet.length];\\n        int[] ans=new int[quiet.length];\\n        Arrays.fill(ans,-1);\\n\\n        for(int i=0;i<quiet.length;i++){\\n            arr[i]=new ArrayList<>();\\n        }\\n         for(int i=0;i<richer.length;i++){\\n            arr[richer[i][1]].add(richer[i][0]);\\n        }\\n\\n\\n        for(int i=0;i<visited.length;i++){\\n            if(!visited[i]){\\n                dfs(i,visited,ans,quiet,arr);\\n            }\\n        }\\n        return ans;\\n    }\\n \\n    int[] dfs( int source , boolean[] visited , int[] ans ,  int[] quite ,  ArrayList<Integer> arr[]){\\n        visited[source]=true;\\n        int[] currmen= { source , quite[source] };\\n        for( int negibours : arr[source] ){\\n            if( ans[negibours] != -1 ){\\n                if( quite[ans[negibours]] < currmen[1] ) {\\n                    currmen[1]=quite[ans[negibours]];\\n                    currmen[0]=ans[negibours];\\n                }\\n            }\\n            else {\\n                int[] negiboursArray=dfs( negibours,visited,ans,quite,arr );\\n                if( negiboursArray[1] < currmen[1] ) {\\n                    currmen[1]=negiboursArray[1];\\n                    currmen[0]=negiboursArray[0];\\n                }\\n\\n            }\\n        }\\n        ans[source]=currmen[0];\\n        return currmen;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        ArrayList<Integer> arr[] = new ArrayList[quiet.length];\\n        boolean[] visited =  new boolean[quiet.length];\\n        int[] ans=new int[quiet.length];\\n        Arrays.fill(ans,-1);\\n\\n        for(int i=0;i<quiet.length;i++){\\n            arr[i]=new ArrayList<>();\\n        }\\n         for(int i=0;i<richer.length;i++){\\n            arr[richer[i][1]].add(richer[i][0]);\\n        }\\n\\n\\n        for(int i=0;i<visited.length;i++){\\n            if(!visited[i]){\\n                dfs(i,visited,ans,quiet,arr);\\n            }\\n        }\\n        return ans;\\n    }\\n \\n    int[] dfs( int source , boolean[] visited , int[] ans ,  int[] quite ,  ArrayList<Integer> arr[]){\\n        visited[source]=true;\\n        int[] currmen= { source , quite[source] };\\n        for( int negibours : arr[source] ){\\n            if( ans[negibours] != -1 ){\\n                if( quite[ans[negibours]] < currmen[1] ) {\\n                    currmen[1]=quite[ans[negibours]];\\n                    currmen[0]=ans[negibours];\\n                }\\n            }\\n            else {\\n                int[] negiboursArray=dfs( negibours,visited,ans,quite,arr );\\n                if( negiboursArray[1] < currmen[1] ) {\\n                    currmen[1]=negiboursArray[1];\\n                    currmen[0]=negiboursArray[0];\\n                }\\n\\n            }\\n        }\\n        ans[source]=currmen[0];\\n        return currmen;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741030,
                "title": "javascript-dfs-with-memoization",
                "content": "```\\n/**\\n * @param {number[][]} richer\\n * @param {number[]} quiet\\n * @return {number[]}\\n */\\nvar loudAndRich = function(richer, quiet) {\\n  const list = [];\\n  const output = [];\\n  const memo = {};\\n\\n  richer.forEach(([u,v]) => !list[v] ? list[v] = [u] : list[v].push(u));\\n\\n  for (let i = 0; i < quiet.length; i++) {\\n    output.push(dfs(i));\\n  }\\n\\n  return output;\\n  \\n  // dfs with memo DP\\n  function dfs(node) {\\n    if (node in memo) return memo[node];\\n    if (!list[node]) {\\n      memo[node] = node;\\n      return node;\\n    }\\n    let quiestNode = node;\\n    let quiestLevel = quiet[node];\\n\\n    for (const next of list[node]) {\\n      const result = dfs(next);\\n      if (quiet[result] < quiestLevel) {\\n        quiestNode = result;\\n        quiestLevel = quiet[result];\\n      }\\n    }\\n\\n    memo[node] = quiestNode;\\n    return memo[node];  \\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} richer\\n * @param {number[]} quiet\\n * @return {number[]}\\n */\\nvar loudAndRich = function(richer, quiet) {\\n  const list = [];\\n  const output = [];\\n  const memo = {};\\n\\n  richer.forEach(([u,v]) => !list[v] ? list[v] = [u] : list[v].push(u));\\n\\n  for (let i = 0; i < quiet.length; i++) {\\n    output.push(dfs(i));\\n  }\\n\\n  return output;\\n  \\n  // dfs with memo DP\\n  function dfs(node) {\\n    if (node in memo) return memo[node];\\n    if (!list[node]) {\\n      memo[node] = node;\\n      return node;\\n    }\\n    let quiestNode = node;\\n    let quiestLevel = quiet[node];\\n\\n    for (const next of list[node]) {\\n      const result = dfs(next);\\n      if (quiet[result] < quiestLevel) {\\n        quiestNode = result;\\n        quiestLevel = quiet[result];\\n      }\\n    }\\n\\n    memo[node] = quiestNode;\\n    return memo[node];  \\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738183,
                "title": "very-easy-c-kahn-s-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>ans(n);\\n        vector<int>adj[n];\\n        vector<int>indegree(n);\\n        for(int i=0;i<richer.size();i++){\\n           adj[richer[i][0]].push_back(richer[i][1]);\\n           indegree[richer[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)q.push(i);\\n            ans[i]=i;\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n//here we are looking to make poor person \"quiet\" low from rich\\n//\"node->it\" -Here \"node\" is rich and \"it\" is denoting poor\\n                if(quiet[ans[it]]>quiet[ans[node]])\\n                ans[it]=ans[node];\\n                indegree[it]--;\\n                if(indegree[it]==0)q.push(it);\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>ans(n);\\n        vector<int>adj[n];\\n        vector<int>indegree(n);\\n        for(int i=0;i<richer.size();i++){\\n           adj[richer[i][0]].push_back(richer[i][1]);\\n           indegree[richer[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)q.push(i);\\n            ans[i]=i;\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n//here we are looking to make poor person \"quiet\" low from rich\\n//\"node->it\" -Here \"node\" is rich and \"it\" is denoting poor\\n                if(quiet[ans[it]]>quiet[ans[node]])\\n                ans[it]=ans[node];\\n                indegree[it]--;\\n                if(indegree[it]==0)q.push(it);\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735386,
                "title": "dfs-approach-c",
                "content": "# Intuition and approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have used the approach where graph is directed a->b such that b is richer than a. We have to find all the nodes which are richer than the current node and store the answer in answer vector where answer[i] = -1 indicates that there has been no answer filled.\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(vector<vector<int>>& graph,int node,vector<int>& quiet,vector<int>& answer)\\n    {\\n        if(answer[node] == -1)\\n        {\\n            answer[node] = node; //Initializing the answer of the node by the node itself as for nodes which have no nodes greater than it (no children), node itself is the answer.\\n            for(int i=0;i<graph[node].size();i++)\\n            {\\n                dfs(graph,graph[node][i],quiet,answer);\\n                if(quiet[answer[node]] > quiet[answer[graph[node][i]]])\\n                {\\n                    answer[node] = answer[graph[node][i]]; //comparing all the answers from child nodes( nodes which are richer ).\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>>graph(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            graph[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int>answer(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(answer[i] == -1)\\n            {\\n                dfs(graph,i,quiet,answer);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<vector<int>>& graph,int node,vector<int>& quiet,vector<int>& answer)\\n    {\\n        if(answer[node] == -1)\\n        {\\n            answer[node] = node; //Initializing the answer of the node by the node itself as for nodes which have no nodes greater than it (no children), node itself is the answer.\\n            for(int i=0;i<graph[node].size();i++)\\n            {\\n                dfs(graph,graph[node][i],quiet,answer);\\n                if(quiet[answer[node]] > quiet[answer[graph[node][i]]])\\n                {\\n                    answer[node] = answer[graph[node][i]]; //comparing all the answers from child nodes( nodes which are richer ).\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>>graph(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            graph[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        vector<int>answer(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(answer[i] == -1)\\n            {\\n                dfs(graph,i,quiet,answer);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709712,
                "title": "toposort-bfs-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n    int v=quiet.size();\\n    vector<int>adj[v];\\n    vector<int>ans(v,INT_MAX);\\n    for(int i=0;i<richer.size();i++)\\n    {\\n        int s=richer[i][0];\\n        int t=richer[i][1];\\n        adj[s].push_back(t);\\n\\n    }\\n\\n    //vector<int>vis(v,0);\\n    vector<int>indegree(v,0);\\n    queue<int>q;\\n    for(int i=0;i<v;i++)\\n    {\\n        for(auto it:adj[i])\\n        {\\n            indegree[it]++;\\n        }\\n    }\\n    for(int i=0;i<v;i++)\\n    {\\n        ans[i]=i;\\n        if(indegree[i]==0)\\n        {\\n              q.push(i);\\n        }\\n    }\\n    vector<int>topo;\\n    while(!q.empty())\\n    {\\n        int node=q.front();\\n        q.pop();\\n       // topo.push_back(node);\\n        for(auto it:adj[node])\\n        {\\n            if(ans[it]==INT_MAX||quiet[ans[it]]>quiet[ans[node]])\\n            {\\n                ans[it]=ans[node];\\n            }\\n            indegree[it]--;\\n            if(indegree[it]==0)\\n            {\\n                q.push(it);\\n            }\\n        }\\n    }\\n    return ans;\\n    \\n        \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n    int v=quiet.size();\\n    vector<int>adj[v];\\n    vector<int>ans(v,INT_MAX);\\n    for(int i=0;i<richer.size();i++)\\n    {\\n        int s=richer[i][0];\\n        int t=richer[i][1];\\n        adj[s].push_back(t);\\n\\n    }\\n\\n    //vector<int>vis(v,0);\\n    vector<int>indegree(v,0);\\n    queue<int>q;\\n    for(int i=0;i<v;i++)\\n    {\\n        for(auto it:adj[i])\\n        {\\n            indegree[it]++;\\n        }\\n    }\\n    for(int i=0;i<v;i++)\\n    {\\n        ans[i]=i;\\n        if(indegree[i]==0)\\n        {\\n              q.push(i);\\n        }\\n    }\\n    vector<int>topo;\\n    while(!q.empty())\\n    {\\n        int node=q.front();\\n        q.pop();\\n       // topo.push_back(node);\\n        for(auto it:adj[node])\\n        {\\n            if(ans[it]==INT_MAX||quiet[ans[it]]>quiet[ans[node]])\\n            {\\n                ans[it]=ans[node];\\n            }\\n            indegree[it]--;\\n            if(indegree[it]==0)\\n            {\\n                q.push(it);\\n            }\\n        }\\n    }\\n    return ans;\\n    \\n        \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703000,
                "title": "c-clean-code-graph-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t(int i,vector<vector<int>>& v,vector<int>& q,vector<int>& dp)\\n    {\\n        if(dp[i]!=-1) return dp[i];\\n        int m=q[i];\\n        for(auto j : v[i])\\n          m=min(m,t(j,v,q,dp));\\n        \\n        return dp[i]=m;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        vector<vector<int>> v(q.size());\\n        for(auto i : r)\\n        v[i[1]].push_back(i[0]);\\n\\n        map<int,int> p;\\n        for(int i=0;i<q.size();i++)\\n        p[q[i]]=i;\\n\\n        vector<int> dp(q.size(),-1);\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        ans.push_back(p[t(i,v,q,dp)]);\\n          \\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t(int i,vector<vector<int>>& v,vector<int>& q,vector<int>& dp)\\n    {\\n        if(dp[i]!=-1) return dp[i];\\n        int m=q[i];\\n        for(auto j : v[i])\\n          m=min(m,t(j,v,q,dp));\\n        \\n        return dp[i]=m;\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        vector<vector<int>> v(q.size());\\n        for(auto i : r)\\n        v[i[1]].push_back(i[0]);\\n\\n        map<int,int> p;\\n        for(int i=0;i<q.size();i++)\\n        p[q[i]]=i;\\n\\n        vector<int> dp(q.size(),-1);\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        ans.push_back(p[t(i,v,q,dp)]);\\n          \\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698936,
                "title": "easy-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int dfs(int node, vector<int> adj[], vector<int>& quiet, vector<int> &vis ){\\n        if(vis[node]!=0)return ans[node];\\n\\n        vis[node]=1;\\n        ans[node]=quiet[node];\\n        for(auto child : adj[node]){\\n            ans[node] = min(ans[node], dfs(child, adj, quiet, vis));\\n        }\\n        return ans[node];\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n\\n        vector<int> adj[n];\\n        for(auto r:richer){\\n            adj[r[1]].push_back(r[0]);\\n        }\\n        ans.resize(n);\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++){\\n            if(vis[i]==0){\\n                dfs(i, adj, quiet, vis);\\n            }\\n        }\\n        unordered_map<int , int> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[quiet[i]]=i;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i]=mp[ans[i]];\\n\\n        }\\n        return ans;\\n        // return vis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int dfs(int node, vector<int> adj[], vector<int>& quiet, vector<int> &vis ){\\n        if(vis[node]!=0)return ans[node];\\n\\n        vis[node]=1;\\n        ans[node]=quiet[node];\\n        for(auto child : adj[node]){\\n            ans[node] = min(ans[node], dfs(child, adj, quiet, vis));\\n        }\\n        return ans[node];\\n\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n\\n        vector<int> adj[n];\\n        for(auto r:richer){\\n            adj[r[1]].push_back(r[0]);\\n        }\\n        ans.resize(n);\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++){\\n            if(vis[i]==0){\\n                dfs(i, adj, quiet, vis);\\n            }\\n        }\\n        unordered_map<int , int> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[quiet[i]]=i;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i]=mp[ans[i]];\\n\\n        }\\n        return ans;\\n        // return vis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687928,
                "title": "c-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<int> &quiet, vector<vector<int>> &adj, map<int, int> &mp){\\n        if(mp[node]) return mp[node];\\n        int ans = node;\\n        for(auto it : adj[node]){\\n            int x = dfs(it, quiet, adj, mp);\\n            if(quiet[ans] >= quiet[x]) ans = x;\\n        }\\n        mp[node] = ans;\\n        return ans;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto it : richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            if(adj[i].size()) ans.push_back(dfs(i, quiet, adj, mp));\\n            else ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<int> &quiet, vector<vector<int>> &adj, map<int, int> &mp){\\n        if(mp[node]) return mp[node];\\n        int ans = node;\\n        for(auto it : adj[node]){\\n            int x = dfs(it, quiet, adj, mp);\\n            if(quiet[ans] >= quiet[x]) ans = x;\\n        }\\n        mp[node] = ans;\\n        return ans;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto it : richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            if(adj[i].size()) ans.push_back(dfs(i, quiet, adj, mp));\\n            else ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686258,
                "title": "kahn-s-algorithm-efficient-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\n        vector<vector<int>> adj(quiet.size());\\n        vector<int> indegree(quiet.size(),0);\\n        //create adjacency list\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][0]].push_back(richer[i][1]);\\n            indegree[richer[i][1]]++;\\n        }\\n        //all quiteness will be measured with int max initially for cases if there is no relation of richness given\\n        vector<int> ans(quiet.size(),INT_MAX);\\n        queue<int> q;\\n        for(int i=0;i<quiet.size();i++)\\n        {  \\n            ans[i]=i;//as that number will definately be equal in terms of richness\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int cur=q.front();\\n            // toposorted.push_back(cur);            \\n            q.pop();\\n\\n            for(auto it:adj[cur])\\n            {\\n                if(ans[it]==INT_MAX|| quiet[ans[it]]>quiet[ans[cur]])   ans[it]=ans[cur];\\n                indegree[it]--;\\n                if(indegree[it]==0) q.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n\\n        vector<vector<int>> adj(quiet.size());\\n        vector<int> indegree(quiet.size(),0);\\n        //create adjacency list\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][0]].push_back(richer[i][1]);\\n            indegree[richer[i][1]]++;\\n        }\\n        //all quiteness will be measured with int max initially for cases if there is no relation of richness given\\n        vector<int> ans(quiet.size(),INT_MAX);\\n        queue<int> q;\\n        for(int i=0;i<quiet.size();i++)\\n        {  \\n            ans[i]=i;//as that number will definately be equal in terms of richness\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int cur=q.front();\\n            // toposorted.push_back(cur);            \\n            q.pop();\\n\\n            for(auto it:adj[cur])\\n            {\\n                if(ans[it]==INT_MAX|| quiet[ans[it]]>quiet[ans[cur]])   ans[it]=ans[cur];\\n                indegree[it]--;\\n                if(indegree[it]==0) q.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676738,
                "title": "java-solution-topologicalsort",
                "content": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List<List<Integer>> lt = new ArrayList<>();\\n        int[] inDegree = new int[quiet.length];\\n        int[] ans = new int[quiet.length];\\n        Queue<Integer> q = new LinkedList<>();\\n        int  min = Integer.MAX_VALUE;\\n        for(int i=0; i<quiet.length; i++){\\n            lt.add(new ArrayList<>());\\n        }\\n        \\n        for( int[] arr : richer){\\n            lt.get(arr[0]).add(arr[1]);\\n            inDegree[arr[1]]++;\\n        }\\n        int z=1;\\n        for(int i=0; i<quiet.length; i++){\\n            ans[i] = i;\\n            if(inDegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        while( !q.isEmpty() ){\\n            int node = q.poll();\\n            \\n            for( int n : lt.get(node)){\\n                inDegree[n]--;\\n                if( quiet[ans[node]] < quiet[ans[n]]  ){\\n                     ans[n] = ans[node];\\n                }\\n                if( inDegree[n] == 0 )\\n                    q.add(n);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "class Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List<List<Integer>> lt = new ArrayList<>();\\n        int[] inDegree = new int[quiet.length];\\n        int[] ans = new int[quiet.length];\\n        Queue<Integer> q = new LinkedList<>();\\n        int  min = Integer.MAX_VALUE;\\n        for(int i=0; i<quiet.length; i++){\\n            lt.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3647050,
                "title": "python-dfs-solution-direct-checking-without-return-value",
                "content": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \\n        \"\"\"\\n        0->1->2\\n         ->1->3->4  \\n         ->7->3->5\\n              3->6\\n        \"\"\"\\n        answer = []\\n        visited = set() \\n        graph = collections.defaultdict(list)\\n        def prepareGraph():\\n            \\n            for richEntry in richer:\\n                graph[richEntry[1]].append(richEntry[0])\\n        \\n        def dfs(node):\\n            \\n            visited.add(node)\\n            \\n            for entry in graph[node]:\\n                if entry not in visited:\\n                    dfs(entry)\\n                # while calling dfs, comparing the child node to the root node and replace if quiteness is minimum\\n                if quiet[answer[entry]]< quiet[answer[node]]:\\n                    answer[node] = answer[entry]\\n        \\n        prepareGraph()\\n        answer = [i for i in range(len(quiet))]\\n        \\n        for key in range(len(quiet)):\\n            dfs(key)\\n        return answer\\n            \\n            \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        \\n        \"\"\"\\n        0->1->2\\n         ->1->3->4  \\n         ->7->3->5\\n              3->6\\n        \"\"\"\\n        answer = []\\n        visited = set() \\n        graph = collections.defaultdict(list)\\n        def prepareGraph():\\n            \\n            for richEntry in richer:\\n                graph[richEntry[1]].append(richEntry[0])\\n        \\n        def dfs(node):\\n            \\n            visited.add(node)\\n            \\n            for entry in graph[node]:\\n                if entry not in visited:\\n                    dfs(entry)\\n                # while calling dfs, comparing the child node to the root node and replace if quiteness is minimum\\n                if quiet[answer[entry]]< quiet[answer[node]]:\\n                    answer[node] = answer[entry]\\n        \\n        prepareGraph()\\n        answer = [i for i in range(len(quiet))]\\n        \\n        for key in range(len(quiet)):\\n            dfs(key)\\n        return answer\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642897,
                "title": "c-solution-dfs-based",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int src , vector<int> adj[] , unordered_map<int,int>&mp , vector<int>&answer , vector<int>& quiet)\\n    {\\n        if(answer[src] != -1) return quiet[answer[src]];\\n\\n        if(adj[src].size() == 0)\\n        {\\n            answer[src] = src;\\n            return quiet[src];\\n        }\\n        int result = quiet[src];\\n        for(auto node : adj[src])\\n        {\\n            result = min(result , dfs(node , adj , mp , answer , quiet));\\n        }\\n        answer[src] = mp[result];\\n        return result;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n         int n = quiet.size();\\n         unordered_map<int , int> mp;\\n         for(int i = 0 ; i < quiet.size() ; i++)mp[quiet[i]] = i;\\n         vector<int> adj[n];\\n         for(int i = 0 ; i < richer.size() ; i++)\\n         {\\n             int u = richer[i][0];\\n             int v = richer[i][1];\\n\\n             adj[v].push_back(u);\\n         }\\n         vector<int> answer(n , -1);\\n         for(int i = 0 ; i < n ; i++)\\n         {\\n             if(answer[i] == -1)\\n             {\\n                 dfs(i , adj , mp , answer , quiet);\\n             }\\n         }\\n         return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int src , vector<int> adj[] , unordered_map<int,int>&mp , vector<int>&answer , vector<int>& quiet)\\n    {\\n        if(answer[src] != -1) return quiet[answer[src]];\\n\\n        if(adj[src].size() == 0)\\n        {\\n            answer[src] = src;\\n            return quiet[src];\\n        }\\n        int result = quiet[src];\\n        for(auto node : adj[src])\\n        {\\n            result = min(result , dfs(node , adj , mp , answer , quiet));\\n        }\\n        answer[src] = mp[result];\\n        return result;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n         int n = quiet.size();\\n         unordered_map<int , int> mp;\\n         for(int i = 0 ; i < quiet.size() ; i++)mp[quiet[i]] = i;\\n         vector<int> adj[n];\\n         for(int i = 0 ; i < richer.size() ; i++)\\n         {\\n             int u = richer[i][0];\\n             int v = richer[i][1];\\n\\n             adj[v].push_back(u);\\n         }\\n         vector<int> answer(n , -1);\\n         for(int i = 0 ; i < n ; i++)\\n         {\\n             if(answer[i] == -1)\\n             {\\n                 dfs(i , adj , mp , answer , quiet);\\n             }\\n         }\\n         return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621677,
                "title": "similar-to-bellman-ford-algo-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can think it as a graph with richer as edges vector. \\n\\n# Approach\\nI thought of solving it similar to bellman ford algorithm which is used to calculate the shortest path. Update the quiet matrix and maintain another matrix \"ans\" whenever some update happens.\\n\\n# Complexity\\n- Time complexity:\\nO(n.m) , where n is total number of peoples(vertex) and m is size of richer.(edges) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size() ;\\n        vector<int> ans(n) ;\\n        for(int i=0;i<n;i++) ans[i] = i ;  \\n        for(int i=0 ;i<n ; i++){\\n            bool change = false;  \\n            for(auto e : richer){\\n                if(quiet[e[0]] < quiet[e[1]]){\\n                    quiet[e[1]] = quiet[e[0]] ;\\n                    ans[e[1]] = ans[e[0]] ; \\n                    change = true ; \\n                }\\n            }\\n            if(change == false) break;  \\n        }\\n\\n        return ans ; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size() ;\\n        vector<int> ans(n) ;\\n        for(int i=0;i<n;i++) ans[i] = i ;  \\n        for(int i=0 ;i<n ; i++){\\n            bool change = false;  \\n            for(auto e : richer){\\n                if(quiet[e[0]] < quiet[e[1]]){\\n                    quiet[e[1]] = quiet[e[0]] ;\\n                    ans[e[1]] = ans[e[0]] ; \\n                    change = true ; \\n                }\\n            }\\n            if(change == false) break;  \\n        }\\n\\n        return ans ; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619701,
                "title": "bfs-t-o-m-n-s-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        //cc \\n        if (richer == null) return new int[0];\\n\\n        int n = quiet.length;\\n        int[] res = new int[n];\\n\\n        // richer and more quiet people add to the result\\n\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        int[] indeg = new int[n];\\n\\n        for (int[] rich : richer) {\\n            graph.get(rich[0]).add(rich[1]);\\n            indeg[rich[1]]++;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indeg[i] == 0) queue.offer(i);\\n            res[i] = i;\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll(); //richer\\n\\n            for (int next : graph.get(curr)) {\\n                indeg[next]--;\\n\\n                if (quiet[res[next]] > quiet[res[curr]]) {\\n                    res[next] = res[curr];\\n                }\\n\\n                if (indeg[next] == 0) queue.offer(next);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n//T:O(m + n) S:O(m + n)\\n// n -- number of people\\n// m -- number of richer people\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        //cc \\n        if (richer == null) return new int[0];\\n\\n        int n = quiet.length;\\n        int[] res = new int[n];\\n\\n        // richer and more quiet people add to the result\\n\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        int[] indeg = new int[n];\\n\\n        for (int[] rich : richer) {\\n            graph.get(rich[0]).add(rich[1]);\\n            indeg[rich[1]]++;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indeg[i] == 0) queue.offer(i);\\n            res[i] = i;\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll(); //richer\\n\\n            for (int next : graph.get(curr)) {\\n                indeg[next]--;\\n\\n                if (quiet[res[next]] > quiet[res[curr]]) {\\n                    res[next] = res[curr];\\n                }\\n\\n                if (indeg[next] == 0) queue.offer(next);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n//T:O(m + n) S:O(m + n)\\n// n -- number of people\\n// m -- number of richer people\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618082,
                "title": "indegree-dfs-best-and-most-intuitive-solution-imp-general-trick-discussed",
                "content": "If indegree of any node is zero , it means they are the richest among the people they are connected to. To the people they are not connected to , we cannot say anything so their quiet values are their quiet values themselves. \\nFor the people who do not have indegree zero , we reverse the edges so that their indegree becomes zero and we do a dfs. After the dfs , the nodes they can reach are the people who are richer than them. Hence we have solved the problem\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int node , vector<int> &a , map<int,bool> &vis , map<int,vector<int>> &m_rev)\\n    {\\n        vis[node] = true;\\n        a.push_back(node);\\n        for(auto it : m_rev[node])\\n        {\\n            if(vis[it]!=true) solve(it,a,vis,m_rev);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int> ans(quiet.size() , -1);   \\n        map<int,vector<int>> m;\\n        map<int,vector<int>> m_rev;\\n        for(int i = 0 ; i < richer.size() ; i++)\\n        {\\n            m[richer[i][0]].push_back(richer[i][1]);\\n            m_rev[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        \\n        vector<int> indegree(quiet.size() , 0);\\n        for(auto it : m)\\n        {\\n            for(auto it1 : it.second) indegree[it1]++;\\n        }\\n        \\n        for(int i = 0 ; i < indegree.size() ; i++)\\n        {\\n            if(indegree[i]==0) ans[i] = i;\\n        }\\n        vector<int> a;\\n        map<int,bool> vis;\\n        for(int i = 0 ; i < indegree.size() ; i++)\\n        {\\n            if(indegree[i]!=0)\\n            {\\n                solve(i,a,vis,m_rev);\\n                int temp_ans = 0;\\n                int mine = INT_MAX;\\n                for(int i = 0 ; i < a.size() ; i++)\\n                {\\n                    if(mine > quiet[a[i]])\\n                    {\\n                        mine = quiet[a[i]];\\n                        temp_ans = a[i];\\n                    }\\n                }\\n                ans[i] = temp_ans;\\n                a.clear();\\n                vis.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(int node , vector<int> &a , map<int,bool> &vis , map<int,vector<int>> &m_rev)\\n    {\\n        vis[node] = true;\\n        a.push_back(node);\\n        for(auto it : m_rev[node])\\n        {\\n            if(vis[it]!=true) solve(it,a,vis,m_rev);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        vector<int> ans(quiet.size() , -1);   \\n        map<int,vector<int>> m;\\n        map<int,vector<int>> m_rev;\\n        for(int i = 0 ; i < richer.size() ; i++)\\n        {\\n            m[richer[i][0]].push_back(richer[i][1]);\\n            m_rev[richer[i][1]].push_back(richer[i][0]);\\n        }\\n        \\n        vector<int> indegree(quiet.size() , 0);\\n        for(auto it : m)\\n        {\\n            for(auto it1 : it.second) indegree[it1]++;\\n        }\\n        \\n        for(int i = 0 ; i < indegree.size() ; i++)\\n        {\\n            if(indegree[i]==0) ans[i] = i;\\n        }\\n        vector<int> a;\\n        map<int,bool> vis;\\n        for(int i = 0 ; i < indegree.size() ; i++)\\n        {\\n            if(indegree[i]!=0)\\n            {\\n                solve(i,a,vis,m_rev);\\n                int temp_ans = 0;\\n                int mine = INT_MAX;\\n                for(int i = 0 ; i < a.size() ; i++)\\n                {\\n                    if(mine > quiet[a[i]])\\n                    {\\n                        mine = quiet[a[i]];\\n                        temp_ans = a[i];\\n                    }\\n                }\\n                ans[i] = temp_ans;\\n                a.clear();\\n                vis.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602316,
                "title": "very-easy-code-bfs-kahn-s-algo-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(auto v:richer){\\n            adj[v[0]].push_back(v[1]); // v[0] -> v[1] => indegree is for v[1]\\n            indegree[v[1]]++;\\n        }\\n        queue<int> q;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n            q.push(i);\\n            ans[i]=i;\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto child:adj[node]){\\n                if(quiet[node]<quiet[child]){ // if child quiet is less than parent quiet then update quiet arr of child and also update the ans arr value \\n                    quiet[child]=quiet[node];\\n                    ans[child]=ans[node];\\n                }\\n                indegree[child]--;\\n                if(indegree[child]==0)\\n                q.push(child);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(auto v:richer){\\n            adj[v[0]].push_back(v[1]); // v[0] -> v[1] => indegree is for v[1]\\n            indegree[v[1]]++;\\n        }\\n        queue<int> q;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n            q.push(i);\\n            ans[i]=i;\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto child:adj[node]){\\n                if(quiet[node]<quiet[child]){ // if child quiet is less than parent quiet then update quiet arr of child and also update the ans arr value \\n                    quiet[child]=quiet[node];\\n                    ans[child]=ans[node];\\n                }\\n                indegree[child]--;\\n                if(indegree[child]==0)\\n                q.push(child);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588246,
                "title": "dfs-solution-explained",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code starts by building an adjacency list representation of the richer relationships. Each person is represented as a node, and an edge exists between two nodes if the person corresponding to the destination node is richer than the person corresponding to the source node.\\n\\n2. The code initializes an answer array with -1. This array will store the answer for each person, representing the least quiet person among all the people who definitely have equal to or more money than that person.\\n\\n3. The code defines a depth-first search (DFS) function called dfs. This function takes a person node, the adjacency list, the quietness array, and the answer array as parameters.\\n\\n4. Within the dfs function, the code checks if the answer for the current person node is already computed. If so, it returns the cached answer.\\n\\n5. Otherwise, the code initializes the answer for the current person node with the node itself.\\n\\n6. The code then iterates over all the neighbors of the current person node in the adjacency list and recursively calls the dfs function for each neighbor.\\n\\n7. For each neighbor, the code checks if the quietness of the candidate person is lower than the quietness of the current answer for the node. If so, it updates the answer with the candidate person, representing a quieter person who definitely has equal to or more money.\\n\\n8. Finally, the dfs function returns the answer for the current person node.\\n\\n9. The main function loudAndRich iterates over all the person nodes and calls the dfs function for each person to compute the answer.\\n\\n10. The resulting answer array is returned as the output.\\n\\nIn summary, the code uses a depth-first search (DFS) approach to traverse the richer relationships between people and find the least quiet person among all the people who definitely have equal to or more money. The answer for each person is cached to avoid redundant computations.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   int dfs(int node, vector<vector<int>>& graph, vector<int>& quiet, vector<int>& answer) {\\n    if (answer[node] >= 0) {\\n        return answer[node]; // Return the cached answer if available\\n    }\\n    \\n    answer[node] = node; // Initialize the answer with the current node\\n    \\n    for (int neighbor : graph[node]) {\\n        int candidate = dfs(neighbor, graph, quiet, answer); // Recursive DFS call\\n        \\n        if (quiet[candidate] < quiet[answer[node]]) {\\n            answer[node] = candidate; // Update the answer if a quieter person is found\\n        }\\n    }\\n    \\n    return answer[node];\\n}\\n\\nvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n    int n = quiet.size();\\n    \\n    // Build the adjacency list\\n    vector<vector<int>> graph(n);\\n    for (const vector<int>& edge : richer) {\\n        graph[edge[1]].push_back(edge[0]);\\n    }\\n    \\n    // Initialize the answer array with -1\\n    vector<int> answer(n, -1);\\n    \\n    // Perform a depth-first search (DFS) for each person\\n    for (int i = 0; i < n; i++) {\\n        dfs(i, graph, quiet, answer);\\n    }\\n    \\n    return answer;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   int dfs(int node, vector<vector<int>>& graph, vector<int>& quiet, vector<int>& answer) {\\n    if (answer[node] >= 0) {\\n        return answer[node]; // Return the cached answer if available\\n    }\\n    \\n    answer[node] = node; // Initialize the answer with the current node\\n    \\n    for (int neighbor : graph[node]) {\\n        int candidate = dfs(neighbor, graph, quiet, answer); // Recursive DFS call\\n        \\n        if (quiet[candidate] < quiet[answer[node]]) {\\n            answer[node] = candidate; // Update the answer if a quieter person is found\\n        }\\n    }\\n    \\n    return answer[node];\\n}\\n\\nvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n    int n = quiet.size();\\n    \\n    // Build the adjacency list\\n    vector<vector<int>> graph(n);\\n    for (const vector<int>& edge : richer) {\\n        graph[edge[1]].push_back(edge[0]);\\n    }\\n    \\n    // Initialize the answer array with -1\\n    vector<int> answer(n, -1);\\n    \\n    // Perform a depth-first search (DFS) for each person\\n    for (int i = 0; i < n; i++) {\\n        dfs(i, graph, quiet, answer);\\n    }\\n    \\n    return answer;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583845,
                "title": "simple-c-dfs-solution-by-sorting-the-quiet-array-o-n-tc",
                "content": "O(N) TC DFS solution.\\n\\ncreating a directed graph. with richer => less richer\\n\\nfor all guys we are traversing the graph and changing the minQuiet guy.\\n\\nWith a help of set we can sort quieter guys.\\n\\nand as we going from least quiet guy to louder guy we don\\'t traverse again and again. check traverse() method for more clarification\\n\\nif we encounter a guy that is more quiet than me that means all his subordinates also will have same value(minQ guy will be useless)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void traverse(vector<vector<int>>& graph,int guy,vector<int> &ans,int minQ,vector<int>& quiet){\\n        \\n        if(ans[guy]!=-1&&quiet[ans[guy]]<=quiet[minQ])return;\\n        if(quiet[guy]<quiet[minQ])minQ = guy;\\n\\n        if(ans[guy]==-1||quiet[minQ]<quiet[ans[guy]])ans[guy] = minQ;\\n\\n        for(auto nextGuy: graph[guy]){\\n            traverse(graph,nextGuy,ans,minQ,quiet);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        // make a graph and it will be a tree.\\n        // richest person at top and follows\\n        // make a directed graph\\n        // run dfs and carry the quiter guy \\n\\n        int guys = quiet.size();\\n        vector<vector<int>> graph(guys);\\n        //no need to maintain visited array as it is directed graph and there is no cycle\\n        //x > y and y > z then x > z definetely not z > x (therefore no cycles)\\n\\n        for(int ind = 0; ind < richer.size(); ind++){\\n            int guy1 = richer[ind][0];\\n            int guy2 = richer[ind][1];\\n\\n            graph[guy1].push_back(guy2);\\n        }\\n\\n        vector<int> ans(guys,-1);\\n        set<pair<int,int>> sguys;\\n        for(int ind = 0; ind < guys; ind++){\\n            sguys.insert({quiet[ind],ind});\\n        }\\n        for(auto guy: sguys){\\n            traverse(graph,guy.second,ans,guy.second,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverse(vector<vector<int>>& graph,int guy,vector<int> &ans,int minQ,vector<int>& quiet){\\n        \\n        if(ans[guy]!=-1&&quiet[ans[guy]]<=quiet[minQ])return;\\n        if(quiet[guy]<quiet[minQ])minQ = guy;\\n\\n        if(ans[guy]==-1||quiet[minQ]<quiet[ans[guy]])ans[guy] = minQ;\\n\\n        for(auto nextGuy: graph[guy]){\\n            traverse(graph,nextGuy,ans,minQ,quiet);\\n        }\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        // make a graph and it will be a tree.\\n        // richest person at top and follows\\n        // make a directed graph\\n        // run dfs and carry the quiter guy \\n\\n        int guys = quiet.size();\\n        vector<vector<int>> graph(guys);\\n        //no need to maintain visited array as it is directed graph and there is no cycle\\n        //x > y and y > z then x > z definetely not z > x (therefore no cycles)\\n\\n        for(int ind = 0; ind < richer.size(); ind++){\\n            int guy1 = richer[ind][0];\\n            int guy2 = richer[ind][1];\\n\\n            graph[guy1].push_back(guy2);\\n        }\\n\\n        vector<int> ans(guys,-1);\\n        set<pair<int,int>> sguys;\\n        for(int ind = 0; ind < guys; ind++){\\n            sguys.insert({quiet[ind],ind});\\n        }\\n        for(auto guy: sguys){\\n            traverse(graph,guy.second,ans,guy.second,quiet);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581251,
                "title": "solution-using-dfs-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int i, int parent, vector<int> &vis, vector<vector<int>> &edges, vector<vector<int>> &ansc)\\n    {\\n        vis[i]=1;\\n\\n        for(auto x: edges[i])\\n        {\\n            if(!vis[x])\\n            {\\n                dfs(x, parent, vis, edges, ansc);\\n            }\\n        }\\n\\n        if(i!=parent)\\n        {\\n            ansc[i].push_back(parent);\\n        }\\n\\n\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        vector<int> ans(n);\\n        vector<vector<int>> edges(n), ansc(n);\\n\\n        for(auto x: richer)\\n        {   \\n            edges[x[0]].push_back(x[1]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int>visited(n,0);\\n            dfs(i, i, visited, edges, ansc);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int mini= quiet[i]; int a=i;\\n            for(auto ele : ansc[i]){\\n                if(mini >= quiet[ele]){\\n                    a = ele;\\n                    mini = quiet[ele];\\n\\n        }\\n         \\n     }\\n      ans[i]=a;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int i, int parent, vector<int> &vis, vector<vector<int>> &edges, vector<vector<int>> &ansc)\\n    {\\n        vis[i]=1;\\n\\n        for(auto x: edges[i])\\n        {\\n            if(!vis[x])\\n            {\\n                dfs(x, parent, vis, edges, ansc);\\n            }\\n        }\\n\\n        if(i!=parent)\\n        {\\n            ansc[i].push_back(parent);\\n        }\\n\\n\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        vector<int> ans(n);\\n        vector<vector<int>> edges(n), ansc(n);\\n\\n        for(auto x: richer)\\n        {   \\n            edges[x[0]].push_back(x[1]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int>visited(n,0);\\n            dfs(i, i, visited, edges, ansc);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int mini= quiet[i]; int a=i;\\n            for(auto ele : ansc[i]){\\n                if(mini >= quiet[ele]){\\n                    a = ele;\\n                    mini = quiet[ele];\\n\\n        }\\n         \\n     }\\n      ans[i]=a;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566731,
                "title": "easy-explanation-with-detailed-approach-c-solution-using-bfs-topological-sort",
                "content": "# Intuition\\nFor any person, we look for all the person who is equally rich or richer than them and then we select the quietest among these set of richer people.\\n\\n# Approach\\nHere, we use **topological sort** to find the least quiet person among all people who definitely have equal to or more money than the person.\\n\\n![WhatsApp Image 2023-05-27 at 10.21.47.jpg](https://assets.leetcode.com/users/images/ea093f1d-efc2-4b18-af15-7828d17cd019_1685163806.2208238.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(V+E), since it is directed graph.\\n\\n- Space complexity:\\nO(3V)~O(V), since we have queue, indegree array and ans array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>ans(n);\\n        vector<int>indeg(n,0);\\n        vector<int>adj[n];\\n\\n        for(auto it:richer){ \\n            //adjacentcy list for matrix richer\\n            adj[it[0]].push_back(it[1]);\\n            indeg[it[1]]++;\\n        }\\n\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            //assigning all ans[i] to i which will be updated later after comparision, we can also assign it to some negative number.\\n            ans[i]=i;\\n\\n            // for each i, if indegree is 0 push it into q;\\n            if(indeg[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto it:adj[node]){\\n                //comparing the values of adjacent node values and current node in quiet array and upadting it.\\n                if(quiet[ans[node]]<quiet[ans[it]]){\\n                    ans[it]=ans[node];\\n                }\\n                \\n                indeg[it]--;\\n                if(indeg[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>ans(n);\\n        vector<int>indeg(n,0);\\n        vector<int>adj[n];\\n\\n        for(auto it:richer){ \\n            //adjacentcy list for matrix richer\\n            adj[it[0]].push_back(it[1]);\\n            indeg[it[1]]++;\\n        }\\n\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            //assigning all ans[i] to i which will be updated later after comparision, we can also assign it to some negative number.\\n            ans[i]=i;\\n\\n            // for each i, if indegree is 0 push it into q;\\n            if(indeg[i]==0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto it:adj[node]){\\n                //comparing the values of adjacent node values and current node in quiet array and upadting it.\\n                if(quiet[ans[node]]<quiet[ans[it]]){\\n                    ans[it]=ans[node];\\n                }\\n                \\n                indeg[it]--;\\n                if(indeg[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563107,
                "title": "dfs-dp-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&adj,vector<int>& quiet,vector<int>&ans,int node,vector<int>&vis)\\n    {\\n        if(vis[node])return ans[node];\\n        vis[node]=1;\\n        int ind=node;\\n        for(auto it:adj[node])\\n        {\\n            int k=dfs(adj,quiet,ans,it,vis);\\n            if(quiet[ind]>quiet[k])ind=k;\\n        }\\n        return ans[node]=ind;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>>adj(n);\\n        for(auto it:richer)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<int>ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,quiet,ans,i,vis);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&adj,vector<int>& quiet,vector<int>&ans,int node,vector<int>&vis)\\n    {\\n        if(vis[node])return ans[node];\\n        vis[node]=1;\\n        int ind=node;\\n        for(auto it:adj[node])\\n        {\\n            int k=dfs(adj,quiet,ans,it,vis);\\n            if(quiet[ind]>quiet[k])ind=k;\\n        }\\n        return ans[node]=ind;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>>adj(n);\\n        for(auto it:richer)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<int>ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,quiet,ans,i,vis);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551153,
                "title": "java-dfs-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int ans[] = new int[quiet.length];\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++){\\n            list.add(new ArrayList<>());\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.length;i++){\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        boolean vis[] = new boolean[quiet.length];\\n        for(int i=0;i<quiet.length;i++){\\n            if(vis[i]==false){\\n                dfs(i,list,vis,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(int node ,ArrayList<ArrayList<Integer>> list ,boolean vis[] ,int ans[],int quiet[] ){\\n         vis[node]=true;\\n         for(int j:list.get(node)){\\n             if(vis[j]==false){\\n                 dfs(j,list,vis,ans,quiet);\\n                 if(quiet[node]>quiet[j]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }else{\\n                 if(quiet[j]<quiet[ans[node]]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }\\n         }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int ans[] = new int[quiet.length];\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++){\\n            list.add(new ArrayList<>());\\n            ans[i]=i;\\n        }\\n        for(int i=0;i<richer.length;i++){\\n            list.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        boolean vis[] = new boolean[quiet.length];\\n        for(int i=0;i<quiet.length;i++){\\n            if(vis[i]==false){\\n                dfs(i,list,vis,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(int node ,ArrayList<ArrayList<Integer>> list ,boolean vis[] ,int ans[],int quiet[] ){\\n         vis[node]=true;\\n         for(int j:list.get(node)){\\n             if(vis[j]==false){\\n                 dfs(j,list,vis,ans,quiet);\\n                 if(quiet[node]>quiet[j]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }else{\\n                 if(quiet[j]<quiet[ans[node]]){\\n                     ans[node]=ans[j];\\n                     quiet[node]=quiet[j];\\n                 }\\n             }\\n         }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530939,
                "title": "dfs-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& adj, vector<bool>& vis, int v, int& res, vector<int>& quiet){\\n        if(vis[v])\\n        return;\\n\\n        vis[v] =true;\\n        if(quiet[v] < quiet[res])\\n        {\\n            res = v;\\n        }\\n\\n        for(auto u : adj[v])\\n        {\\n            if(!vis[u])\\n            dfs(adj, vis, u, res, quiet);\\n        }\\n\\n        return;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n\\n        for(auto e : richer)\\n        {\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        int res ;\\n        for(int i=0; i<n; i++)\\n        {\\n            res = i;\\n           dfs(adj, vis,i, res, quiet );\\n           ans.push_back(res);\\n\\n           vis.assign(n, false);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& adj, vector<bool>& vis, int v, int& res, vector<int>& quiet){\\n        if(vis[v])\\n        return;\\n\\n        vis[v] =true;\\n        if(quiet[v] < quiet[res])\\n        {\\n            res = v;\\n        }\\n\\n        for(auto u : adj[v])\\n        {\\n            if(!vis[u])\\n            dfs(adj, vis, u, res, quiet);\\n        }\\n\\n        return;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n\\n        for(auto e : richer)\\n        {\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        int res ;\\n        for(int i=0; i<n; i++)\\n        {\\n            res = i;\\n           dfs(adj, vis,i, res, quiet );\\n           ans.push_back(res);\\n\\n           vis.assign(n, false);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528822,
                "title": "java",
                "content": "Take the lowest in topological orders (roots/poorest) and dfs from them up updating each node on the way, and on the way back from the recursion we update the poorer knowing already the quiet and richer amoung his topological father tree.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List[] richerThanI = new  List[quiet.length], poorerThanI = new List[quiet.length];\\n        for (int i=0;i<quiet.length;i++)  {\\n            richerThanI[i]=new ArrayList<Integer>();\\n            poorerThanI[i]=new ArrayList<Integer>();\\n        }\\n        for (int[] edge: richer) {\\n            richerThanI[edge[1]].add(edge[0]);\\n            poorerThanI[edge[0]].add(edge[1]);\\n        }\\n\\n        int[] sol = new int [quiet.length];\\n\\n        Set<Integer> visited = new HashSet();\\n\\n        for (int i=0;i<quiet.length;i++) sol[i] = i;\\n\\n        for (int i=0;i<quiet.length;i++)\\n            if (poorerThanI[i].size() == 0) visitDfs(i, richerThanI ,sol, visited ,quiet);\\n        \\n        return sol;\\n    }\\n\\n    public void visitDfs(int poor, List[] richerThanI, int[] sol, Set<Integer> visited, int[] quiet){\\n        int min = poor;\\n        for (int richer: (List<Integer>) richerThanI[poor]) {\\n            if (!visited.contains(richer)) visitDfs(richer, richerThanI ,sol, visited ,quiet);\\n            if (quiet[sol[richer]]<quiet[min]) min = sol[richer];\\n        }\\n        visited.add(poor);\\n        sol[poor] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List[] richerThanI = new  List[quiet.length], poorerThanI = new List[quiet.length];\\n        for (int i=0;i<quiet.length;i++)  {\\n            richerThanI[i]=new ArrayList<Integer>();\\n            poorerThanI[i]=new ArrayList<Integer>();\\n        }\\n        for (int[] edge: richer) {\\n            richerThanI[edge[1]].add(edge[0]);\\n            poorerThanI[edge[0]].add(edge[1]);\\n        }\\n\\n        int[] sol = new int [quiet.length];\\n\\n        Set<Integer> visited = new HashSet();\\n\\n        for (int i=0;i<quiet.length;i++) sol[i] = i;\\n\\n        for (int i=0;i<quiet.length;i++)\\n            if (poorerThanI[i].size() == 0) visitDfs(i, richerThanI ,sol, visited ,quiet);\\n        \\n        return sol;\\n    }\\n\\n    public void visitDfs(int poor, List[] richerThanI, int[] sol, Set<Integer> visited, int[] quiet){\\n        int min = poor;\\n        for (int richer: (List<Integer>) richerThanI[poor]) {\\n            if (!visited.contains(richer)) visitDfs(richer, richerThanI ,sol, visited ,quiet);\\n            if (quiet[sol[richer]]<quiet[min]) min = sol[richer];\\n        }\\n        visited.add(poor);\\n        sol[poor] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513653,
                "title": "c-topologicall-sorting-with-explanation",
                "content": "# Intuition\\nThe problem statement requires us to find the quietest person in the group who is richer than each person in the group. We can represent the relationships between people and their wealth as a directed graph, where each node represents a person and each edge represents a richer-than relationship.\\n\\nSince the graph is acyclic, we can use a topological sorting approach to traverse the graph and find the answer for each person. Our aim is to sort the people in their wealth and for every person in the group, we need to find the richest person that is quieter than them.\\n\\n# Approach\\nWe start by building a graph from the richer array, where an edge is directed from a richer person to a poorer person. We also count the indegree of each node in the graph.\\n\\nNext, we initialize the answer array to contain the index of each person. We then use a queue to perform a topological sort on the graph. We start by adding all nodes with an indegree of zero to the queue.\\n\\nAt each iteration, we remove a node from the queue and update the answer for each of its adjacent nodes. If the current person is quieter than the adjacent person\\'s current answer, the adjacent person\\'s answer is updated to the current person\\'s answer. Finally, the indegree of each adjacent node is decremented, and if it becomes zero, it is added to the queue.\\n\\nWe continue this process until the queue is empty, and the answer array contains the index of the quietest person that is richer than each person in the group.\\n\\n# Complexity\\nTime complexity: O(n + E), where n is the number of people and E is the number of edges in the graph. In the worst-case scenario, the number of edges can be n*(n-1)/2, which is O(n^2). However, in practice, the number of edges is likely to be much smaller.\\nSpace complexity: O(n), which is used to store the indegree and answer arrays.\\n\\nCode\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n);\\n        vector<int> answer(n);\\n        \\n        for (auto & edge: richer)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n\\n        for (int i = 0; i < n; i++) answer[i] = i;\\n        \\n        queue<int> Q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (indegree[i] == 0)\\n                Q.push(i);\\n        }\\n\\n        while (!Q.empty())\\n        {\\n            int current = Q.front();\\n            Q.pop();\\n\\n            for (int adj : graph[current])\\n            {\\n                if (quiet[answer[current]] < quiet[answer[adj]])\\n                    answer[adj] = answer[current];\\n\\n                if (--indegree[adj] == 0)\\n                    Q.push(adj);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n);\\n        vector<int> answer(n);\\n        \\n        for (auto & edge: richer)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n\\n        for (int i = 0; i < n; i++) answer[i] = i;\\n        \\n        queue<int> Q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (indegree[i] == 0)\\n                Q.push(i);\\n        }\\n\\n        while (!Q.empty())\\n        {\\n            int current = Q.front();\\n            Q.pop();\\n\\n            for (int adj : graph[current])\\n            {\\n                if (quiet[answer[current]] < quiet[answer[adj]])\\n                    answer[adj] = answer[current];\\n\\n                if (--indegree[adj] == 0)\\n                    Q.push(adj);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511077,
                "title": "c-solution-dfs-memoization-o-n-2",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(V+E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> g,vector<int>& quiet,vector<int>& result,int node){\\n        int x = node;\\n        for (int v : g[node]){\\n            if (result[v]!=-1){\\n                if (quiet[x] > quiet[result[v]])\\n                    x = result[v];\\n            }\\n            else{\\n                int y = dfs(g,quiet,result,v);\\n                if (quiet[x] > quiet[y])\\n                    x = y;\\n            }\\n        }\\n        return result[node] = x;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> g(n);\\n        for (auto r : richer)\\n            g[r[1]].push_back(r[0]);\\n        vector<int> result(n,-1);\\n        for (int i=0;i<n;i++){\\n            if (result[i]==-1)\\n                result[i] = dfs(g,quiet,result,i);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> g,vector<int>& quiet,vector<int>& result,int node){\\n        int x = node;\\n        for (int v : g[node]){\\n            if (result[v]!=-1){\\n                if (quiet[x] > quiet[result[v]])\\n                    x = result[v];\\n            }\\n            else{\\n                int y = dfs(g,quiet,result,v);\\n                if (quiet[x] > quiet[y])\\n                    x = y;\\n            }\\n        }\\n        return result[node] = x;\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        vector<vector<int>> g(n);\\n        for (auto r : richer)\\n            g[r[1]].push_back(r[0]);\\n        vector<int> result(n,-1);\\n        for (int i=0;i<n;i++){\\n            if (result[i]==-1)\\n                result[i] = dfs(g,quiet,result,i);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473721,
                "title": "dfs-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhard part: quiet[res[dfs(nei)]] < quiet[res[i]]\\n- res[i] is memo, it\\'s not i, i is the ith node, res[i] is the current lowest quiet node, it can be anyone, i is the parent of nei, dfs(nei) return a value of res[nei] is another node, if this is lower than res[i], then:\\nres[i] = res[nei]\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n, g = len(quiet), defaultdict(list)\\n        res = [-1] * n\\n        for rich, poor in richer:\\n            g[poor].append(rich)\\n\\n        def dfs(i):\\n            if res[i] != -1: \\n                return res[i]\\n            res[i] = i # first init i, then compare to find lower if possible\\n            for nei in g[i]:\\n                if quiet[res[dfs(nei)]] < quiet[res[i]]:\\n                    res[i] = res[nei]\\n            return res[i]\\n            \\n        for i in range(n):\\n            dfs(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        n, g = len(quiet), defaultdict(list)\\n        res = [-1] * n\\n        for rich, poor in richer:\\n            g[poor].append(rich)\\n\\n        def dfs(i):\\n            if res[i] != -1: \\n                return res[i]\\n            res[i] = i # first init i, then compare to find lower if possible\\n            for nei in g[i]:\\n                if quiet[res[dfs(nei)]] < quiet[res[i]]:\\n                    res[i] = res[nei]\\n            return res[i]\\n            \\n        for i in range(n):\\n            dfs(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452821,
                "title": "kahn-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        \\n        int n = q.size();\\n        vector<vector<int>>adj(n);\\n        vector<int>ind(n, 0);\\n        for(auto it : r){\\n            adj[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int>qu;\\n        vector<int>ans(n);\\n        for(int i = 0; i<n; i++){\\n            ans[i] = i;\\n            if(ind[i] == 0)\\n            qu.push(i);\\n        }\\n\\n\\n        while(!qu.empty()){\\n            int u = qu.front();\\n            qu.pop();\\n            for(auto v : adj[u]){\\n                if(q[ans[u]]  < q[ans[v]]){\\n                    ans[v] = ans[u];\\n                }\\n                --ind[v];\\n                if(ind[v] == 0)\\n                qu.push(v);\\n            }\\n        }\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& r, vector<int>& q) {\\n        \\n        int n = q.size();\\n        vector<vector<int>>adj(n);\\n        vector<int>ind(n, 0);\\n        for(auto it : r){\\n            adj[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int>qu;\\n        vector<int>ans(n);\\n        for(int i = 0; i<n; i++){\\n            ans[i] = i;\\n            if(ind[i] == 0)\\n            qu.push(i);\\n        }\\n\\n\\n        while(!qu.empty()){\\n            int u = qu.front();\\n            qu.pop();\\n            for(auto v : adj[u]){\\n                if(q[ans[u]]  < q[ans[v]]){\\n                    ans[v] = ans[u];\\n                }\\n                --ind[v];\\n                if(ind[v] == 0)\\n                qu.push(v);\\n            }\\n        }\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430268,
                "title": "topological-sorting-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nnodes will affect the results of their outgoing neighbors \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. count the in degrees of nodes\\n2. travel by tological order and update results\\n# Complexity\\n- Time complexity: $$O(m)$$ where $$m$$ is the number of edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m+n)$$ where $$n$$ is the number of vertices\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        unordered_map<int,vector<int>> e;\\n        unordered_map<int,int> ind;\\n        for(auto&v:richer){\\n            e[v[0]].emplace_back(v[1]);\\n            ind[v[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(ind[i]) continue;\\n            q.push(i);\\n        }\\n        vector<int> result(n);\\n        iota(result.begin(),result.end(),0);\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:e[u]){\\n                if(quiet[result[u]]<quiet[result[v]]){\\n                    result[v]=result[u];\\n                }\\n                if(--ind[v]==0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        unordered_map<int,vector<int>> e;\\n        unordered_map<int,int> ind;\\n        for(auto&v:richer){\\n            e[v[0]].emplace_back(v[1]);\\n            ind[v[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(ind[i]) continue;\\n            q.push(i);\\n        }\\n        vector<int> result(n);\\n        iota(result.begin(),result.end(),0);\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:e[u]){\\n                if(quiet[result[u]]<quiet[result[v]]){\\n                    result[v]=result[u];\\n                }\\n                if(--ind[v]==0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415644,
                "title": "java-easy-solution-with-dfs",
                "content": "# Approach\\nForming the adjacency list-\\nricher[i][0]----1\\nricher[i][1]----2\\nsince 1 is richer than 2 we can form a directed edge from 2 to 1\\nIn this way we can get the directed graph\\n\\nNow we can calculate the dfs traversal from each of the vertices and store the vertices traversed in an arraylist\\n\\nIf the arraylist is empty then we add the vertex itself to the ans array\\nelse\\nwe find out that number for which quiet[number] is the least, we add that number to the ans array\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        ArrayList<ArrayList<Integer>>l=new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++)\\n        {\\n            l.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<richer.length;i++)\\n        {\\n            l.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        ArrayList<Integer>a=new ArrayList<>();\\n        int ans[]=new int[quiet.length];\\n        for(int i=0;i<quiet.length;i++)\\n        {\\n            a=new ArrayList<>();\\n            int v[]=new int[quiet.length];\\n            dfs(i,l,v,a);\\n            int min=i;\\n            //System.out.println(i+\" \"+a);\\n            \\n            if(a.isEmpty()==true)\\n            {\\n                ans[i]=i;\\n                continue;\\n            }\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(quiet[a.get(j)]<quiet[min])min=a.get(j);\\n            }\\n            ans[i]=min;\\n\\n        }\\n        return ans;\\n\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<Integer>>l,int v[],ArrayList<Integer>a)\\n    {\\n        v[node]=1;\\n        for(Integer it:l.get(node))\\n        {\\n            if(v[it]==0)\\n            {\\n                a.add(it);\\n                dfs(it,l,v,a);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        ArrayList<ArrayList<Integer>>l=new ArrayList<>();\\n        for(int i=0;i<quiet.length;i++)\\n        {\\n            l.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<richer.length;i++)\\n        {\\n            l.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        ArrayList<Integer>a=new ArrayList<>();\\n        int ans[]=new int[quiet.length];\\n        for(int i=0;i<quiet.length;i++)\\n        {\\n            a=new ArrayList<>();\\n            int v[]=new int[quiet.length];\\n            dfs(i,l,v,a);\\n            int min=i;\\n            //System.out.println(i+\" \"+a);\\n            \\n            if(a.isEmpty()==true)\\n            {\\n                ans[i]=i;\\n                continue;\\n            }\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(quiet[a.get(j)]<quiet[min])min=a.get(j);\\n            }\\n            ans[i]=min;\\n\\n        }\\n        return ans;\\n\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<Integer>>l,int v[],ArrayList<Integer>a)\\n    {\\n        v[node]=1;\\n        for(Integer it:l.get(node))\\n        {\\n            if(v[it]==0)\\n            {\\n                a.add(it);\\n                dfs(it,l,v,a);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405908,
                "title": "c-simple-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlet me clear you one thing guys here adjacent list has been created such that u->v edge is representing that u person is poorer than v\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(E+V)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(E+v) adjacency list + ans array\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int node,vector<vector<int>>& adj,vector<int>& ans,vector<int>& quiet){\\n    int res=node;\\n    int mini=quiet[node];\\n    for(int& i: adj[node]){\\n        if(ans[i]==-1){\\n            dfs(i,adj,ans,quiet);\\n        }\\n        if(mini>quiet[ans[i]]){\\n            mini=quiet[ans[i]];\\n            res=ans[i];\\n        }\\n    }\\n    ans[node]=res;\\n}\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto& ele: richer){\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==-1){\\n                dfs(i,adj,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int node,vector<vector<int>>& adj,vector<int>& ans,vector<int>& quiet){\\n    int res=node;\\n    int mini=quiet[node];\\n    for(int& i: adj[node]){\\n        if(ans[i]==-1){\\n            dfs(i,adj,ans,quiet);\\n        }\\n        if(mini>quiet[ans[i]]){\\n            mini=quiet[ans[i]];\\n            res=ans[i];\\n        }\\n    }\\n    ans[node]=res;\\n}\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>> adj(n);\\n        for(auto& ele: richer){\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==-1){\\n                dfs(i,adj,ans,quiet);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400625,
                "title": "java-topo-sort-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a adjacentry matrix in such a that a node contains all the nodes whose quiet value \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce you are done with adjacentry matrix than what can u do is u can create a ans array and for every index do a topos sort that will give u all the elements whose richer value is greater than than value than among those value find the one elements whose value is less than all other than place it return ans arrary .\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution \\n{\\n\\n    public int[] loudAndRich(int[][] richer, int[] quiet) \\n    {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        int n=quiet.length;\\n        for(int i=0;i<n;i++)\\n        {\\n          adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<richer.length;i++)\\n        {\\n          adj.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        int ans[]=new int[n];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans[i]==Integer.MAX_VALUE)\\n            {\\n             int vis[]=new int[n];\\n             Stack<Integer>stk=new Stack<Integer>();\\n             topo(i,adj,vis,stk);\\n             while(!stk.isEmpty())\\n             {\\n                 int node=stk.peek();\\n                 stk.pop();\\n                 if(ans[i]==Integer.MAX_VALUE)\\n                 {\\n                     ans[i]=node;\\n                 }\\n                 else if(quiet[node]<quiet[ans[i]])\\n                 {\\n                     ans[i]=node;\\n                 }\\n             }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    private void topo(int node,ArrayList<ArrayList<Integer>>adj,int vis[],Stack<Integer>stk)\\n    {\\n        vis[node]=1;\\n        for(int i:adj.get(node))\\n        {\\n            if(vis[i]==0)\\n             {\\n                 topo(i,adj,vis,stk);\\n             }\\n        }\\n        stk.push(node);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution \\n{\\n\\n    public int[] loudAndRich(int[][] richer, int[] quiet) \\n    {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        int n=quiet.length;\\n        for(int i=0;i<n;i++)\\n        {\\n          adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<richer.length;i++)\\n        {\\n          adj.get(richer[i][1]).add(richer[i][0]);\\n        }\\n        int ans[]=new int[n];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans[i]==Integer.MAX_VALUE)\\n            {\\n             int vis[]=new int[n];\\n             Stack<Integer>stk=new Stack<Integer>();\\n             topo(i,adj,vis,stk);\\n             while(!stk.isEmpty())\\n             {\\n                 int node=stk.peek();\\n                 stk.pop();\\n                 if(ans[i]==Integer.MAX_VALUE)\\n                 {\\n                     ans[i]=node;\\n                 }\\n                 else if(quiet[node]<quiet[ans[i]])\\n                 {\\n                     ans[i]=node;\\n                 }\\n             }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    private void topo(int node,ArrayList<ArrayList<Integer>>adj,int vis[],Stack<Integer>stk)\\n    {\\n        vis[node]=1;\\n        for(int i:adj.get(node))\\n        {\\n            if(vis[i]==0)\\n             {\\n                 topo(i,adj,vis,stk);\\n             }\\n        }\\n        stk.push(node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380545,
                "title": "simple-solution-using-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>graph;\\n    void add_edge(int u,int v){graph[v].push_back(u);}\\n    void dfs(vector<bool>&vis,int i,vector<int>&temp)\\n    {\\n        vis[i]=true;\\n        for(auto x:graph[i])\\n        {\\n            if(vis[x]==false)\\n            {\\n                dfs(vis,x,temp);\\n            }\\n        }\\n        temp.push_back(i);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>>ans;\\n        for(int i=0;i<richer.size();i++) add_edge(richer[i][0],richer[i][1]);\\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            vector<bool>vis(quiet.size(),false);\\n            vector<int>temp;\\n            dfs(vis,i,temp);\\n            ans[i]=temp;\\n            temp.clear();\\n        }\\n        vector<int>rslt(quiet.size());\\n        for(auto x:ans)\\n        {\\n            int mini=x.first;\\n            for(int i=0;i<x.second.size();i++)\\n            {\\n                if(quiet[mini]>quiet[x.second[i]])\\n                {\\n                    mini=x.second[i];\\n                }\\n            }\\n            rslt[x.first]=mini;\\n        }\\n        return rslt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>graph;\\n    void add_edge(int u,int v){graph[v].push_back(u);}\\n    void dfs(vector<bool>&vis,int i,vector<int>&temp)\\n    {\\n        vis[i]=true;\\n        for(auto x:graph[i])\\n        {\\n            if(vis[x]==false)\\n            {\\n                dfs(vis,x,temp);\\n            }\\n        }\\n        temp.push_back(i);\\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        unordered_map<int,vector<int>>ans;\\n        for(int i=0;i<richer.size();i++) add_edge(richer[i][0],richer[i][1]);\\n        for(int i=0;i<quiet.size();i++)\\n        {\\n            vector<bool>vis(quiet.size(),false);\\n            vector<int>temp;\\n            dfs(vis,i,temp);\\n            ans[i]=temp;\\n            temp.clear();\\n        }\\n        vector<int>rslt(quiet.size());\\n        for(auto x:ans)\\n        {\\n            int mini=x.first;\\n            for(int i=0;i<x.second.size();i++)\\n            {\\n                if(quiet[mini]>quiet[x.second[i]])\\n                {\\n                    mini=x.second[i];\\n                }\\n            }\\n            rslt[x.first]=mini;\\n        }\\n        return rslt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379357,
                "title": "simple-memoization-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRight after looking the problem I knew that this was about DFS as we have to iterate all the nodes(people) which have more money. So, first of all ,I have created a graph where edges will be directed from poor person to rich which enables us to reach nodes which are only richer than the current one. I have used memoization to store node values which have least quiet value and more money that current node to avoid overlapping subproblems. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a graph (adjacency list) in which edges will be directed from poor person to richer. Then for each node traverse to richer nodes(i.e adjacent nodes) and find the node which has least quiet value in traversal. Store the node value instead of quieteness value as we ultimately need nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nImplementation is just as normal DFS, so time complexity is O(V+E) where V is number of vertices and E is number of edges.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V) for one dimensional dp vector and O(E) for recursion stack space as DFS will be called E number of times. So overall space complexity is O(V+E).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],vector<int>&quiet,int i,vector<int>&dp) {\\n        if(dp[i]!=-1)return dp[i];\\n        \\n        dp[i]=i;\\n        for(auto it:adj[i]){\\n            int idx=dfs(adj,quiet,it,dp);\\n            if(quiet[idx]<quiet[dp[i]]){\\n                dp[i]=idx;\\n            }\\n        }\\n        return dp[i];\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>dp(n,-1);\\n        vector<int>adj[n];\\n\\n        for(auto it:richer)adj[it[1]].push_back(it[0]);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==-1)\\n            {\\n                dp[i]=dfs(adj,quiet,i,dp);\\n            }\\n        }\\n\\n        return dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],vector<int>&quiet,int i,vector<int>&dp) {\\n        if(dp[i]!=-1)return dp[i];\\n        \\n        dp[i]=i;\\n        for(auto it:adj[i]){\\n            int idx=dfs(adj,quiet,it,dp);\\n            if(quiet[idx]<quiet[dp[i]]){\\n                dp[i]=idx;\\n            }\\n        }\\n        return dp[i];\\n    }\\n\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int>dp(n,-1);\\n        vector<int>adj[n];\\n\\n        for(auto it:richer)adj[it[1]].push_back(it[0]);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==-1)\\n            {\\n                dp[i]=dfs(adj,quiet,i,dp);\\n            }\\n        }\\n\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373920,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func loudAndRich(_ richer: [[Int]], _ quiet: [Int]) -> [Int] {\\n\\n        let i = quiet\\n            .enumerated()\\n            .sorted { $0.element < $1.element }\\n            .map { $0.offset }\\n\\n        let p = richer.reduce(into: Array(repeating: [Int](), count: i.count)) {\\n            $0[$1[1]].append($1[0])\\n        }\\n        \\n        var res: [Int?] = Array(repeating: nil, count: i.count)\\n\\n        func more(_ i: Int) -> Int {\\n            if let r = res[i] {\\n                return r\\n            }\\n            else {\\n                var r = quiet[i]\\n                for x in p[i] {\\n                    r = min(r, more(x))\\n                }\\n                res[i] = r\\n                return r\\n            }\\n        }\\n\\n        for i in res.indices where res[i] == nil {\\n            more(i)\\n        }\\n\\n        return res.map { i[$0!] }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func loudAndRich(_ richer: [[Int]], _ quiet: [Int]) -> [Int] {\\n\\n        let i = quiet\\n            .enumerated()\\n            .sorted { $0.element < $1.element }\\n            .map { $0.offset }\\n\\n        let p = richer.reduce(into: Array(repeating: [Int](), count: i.count)) {\\n            $0[$1[1]].append($1[0])\\n        }\\n        \\n        var res: [Int?] = Array(repeating: nil, count: i.count)\\n\\n        func more(_ i: Int) -> Int {\\n            if let r = res[i] {\\n                return r\\n            }\\n            else {\\n                var r = quiet[i]\\n                for x in p[i] {\\n                    r = min(r, more(x))\\n                }\\n                res[i] = r\\n                return r\\n            }\\n        }\\n\\n        for i in res.indices where res[i] == nil {\\n            more(i)\\n        }\\n\\n        return res.map { i[$0!] }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360373,
                "title": "c-dfs-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int start,unordered_map<int,vector<int>>&ourmap,unordered_map<int,bool>&visited,vector<int>&quiet,int&mini,int&minnode){\\n        \\n        visited[start]=true;\\n        if(quiet[start]<mini){\\n            mini=quiet[start];\\n            minnode=start;\\n        }\\n        vector<int> temp=ourmap[start];\\n        for(int i=0;i<temp.size();i++){\\n            if(visited[temp[i]]!=true){\\n                dfs(temp[i],ourmap,visited,quiet,mini,minnode);\\n            }\\n        }\\n        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        \\n        unordered_map<int,vector<int>>ourmap;\\n        for(int i=0;i<richer.size();i++){\\n            int a=richer[i][0];\\n            int b=richer[i][1];\\n            ourmap[b].push_back(a);\\n        }\\n        int n=quiet.size();\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,bool> visited(false);\\n            int mini=quiet[i];\\n            int minnode=i;\\n            dfs(i,ourmap,visited,quiet,mini,minnode);\\n            ans[i]=minnode;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(int start,unordered_map<int,vector<int>>&ourmap,unordered_map<int,bool>&visited,vector<int>&quiet,int&mini,int&minnode){\\n        \\n        visited[start]=true;\\n        if(quiet[start]<mini){\\n            mini=quiet[start];\\n            minnode=start;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3354720,
                "title": "easy-understanding-java-solution-graph-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<Integer>>graph= new ArrayList<>();\\n    int [] output;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n=quiet.length;\\n        for(int i=0; i<n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int pair[] : richer){\\n            int u= pair[1];\\n            int v= pair[0];\\n\\n            graph.get(u).add(v);\\n        \\n\\n        }\\n        output=new int[n];\\n        Arrays.fill(output,-1);\\n        for(int i=0; i<n; i++){\\n            if(output[i]==-1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return output;\\n    }\\n    public int dfs(int person ,int[]quiet){\\n        if(output[person]!=-1) \\n        return output[person];\\n\\n        int least_quiet_person=person;\\n        int least_quietness= quiet[person];\\n        for(int nbr: graph.get(person)){\\n            int newPerson= dfs(nbr,quiet);\\n            if(quiet[newPerson]<least_quietness){\\n                least_quietness= quiet[newPerson];\\n                least_quiet_person= newPerson;\\n            }\\n        }\\n        output[person]=least_quiet_person;\\n        return least_quiet_person;\\n    }\\n}\\n```\" UPVOTE IF YOU LIKE THIS SOLUTION!!!\"",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>>graph= new ArrayList<>();\\n    int [] output;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n=quiet.length;\\n        for(int i=0; i<n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int pair[] : richer){\\n            int u= pair[1];\\n            int v= pair[0];\\n\\n            graph.get(u).add(v);\\n        \\n\\n        }\\n        output=new int[n];\\n        Arrays.fill(output,-1);\\n        for(int i=0; i<n; i++){\\n            if(output[i]==-1){\\n                dfs(i,quiet);\\n            }\\n        }\\n        return output;\\n    }\\n    public int dfs(int person ,int[]quiet){\\n        if(output[person]!=-1) \\n        return output[person];\\n\\n        int least_quiet_person=person;\\n        int least_quietness= quiet[person];\\n        for(int nbr: graph.get(person)){\\n            int newPerson= dfs(nbr,quiet);\\n            if(quiet[newPerson]<least_quietness){\\n                least_quietness= quiet[newPerson];\\n                least_quiet_person= newPerson;\\n            }\\n        }\\n        output[person]=least_quiet_person;\\n        return least_quiet_person;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341621,
                "title": "simple-java-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] ans;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List<List<Integer>> adj = createGraph(quiet.length, richer);\\n        ans = new int[quiet.length];\\n        Arrays.fill(ans, -1);\\n\\n        for(int i=0;i<quiet.length;i++) {\\n            ans[i] = dfs(adj, i, quiet)[0];\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int[] dfs(List<List<Integer>> adj, int start, int[] quiet) {\\n        if(ans[start]>-1) { \\n            int[] qVal = {ans[start], quiet[ans[start]]};\\n            return qVal;\\n        }\\n\\n        List<Integer> neighbors = adj.get(start);\\n        int[] qVal = {start, quiet[start]};\\n        \\n        for(int nei: neighbors) {\\n            int[] val = dfs(adj, nei, quiet);\\n            if(val[1]<qVal[1]) {\\n                qVal = val;\\n            }\\n        }\\n\\n        ans[start] = qVal[0];\\n        \\n        return qVal;\\n    }\\n\\n    public List<List<Integer>> createGraph(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<Integer>());\\n        for(int[] e: edges) {\\n            graph.get(e[1]).add(e[0]);\\n        }\\n        return graph;\\n    }\\n\\n    public void printGraph(List<List<Integer>> adj) {\\n        int index = 0;\\n        for(List<Integer> i: adj) {\\n            System.out.print( index + \": \" );\\n            for(int j: i) {\\n                System.out.print(j + \",\");\\n            }\\n            index++;\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] ans;\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        List<List<Integer>> adj = createGraph(quiet.length, richer);\\n        ans = new int[quiet.length];\\n        Arrays.fill(ans, -1);\\n\\n        for(int i=0;i<quiet.length;i++) {\\n            ans[i] = dfs(adj, i, quiet)[0];\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int[] dfs(List<List<Integer>> adj, int start, int[] quiet) {\\n        if(ans[start]>-1) { \\n            int[] qVal = {ans[start], quiet[ans[start]]};\\n            return qVal;\\n        }\\n\\n        List<Integer> neighbors = adj.get(start);\\n        int[] qVal = {start, quiet[start]};\\n        \\n        for(int nei: neighbors) {\\n            int[] val = dfs(adj, nei, quiet);\\n            if(val[1]<qVal[1]) {\\n                qVal = val;\\n            }\\n        }\\n\\n        ans[start] = qVal[0];\\n        \\n        return qVal;\\n    }\\n\\n    public List<List<Integer>> createGraph(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<Integer>());\\n        for(int[] e: edges) {\\n            graph.get(e[1]).add(e[0]);\\n        }\\n        return graph;\\n    }\\n\\n    public void printGraph(List<List<Integer>> adj) {\\n        int index = 0;\\n        for(List<Integer> i: adj) {\\n            System.out.print( index + \": \" );\\n            for(int j: i) {\\n                System.out.print(j + \",\");\\n            }\\n            index++;\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339631,
                "title": "simple-bfs-solution-c",
                "content": "class Solution {\\npublic:\\n    \\n    int bfs(vector<vector<pair<int,int>>>& adj,int u,vector<int>& quiet)\\n    {\\n        queue<pair<int,int>> q;\\n        vector<bool> visited(quiet.size(),false);\\n        \\n        q.push({u,quiet[u]});\\n        \\n        int currquiet= quiet[u];\\n        int ans= u;\\n        \\n        while(!q.empty())\\n        {\\n            auto p= q.front();\\n            q.pop();\\n            \\n            visited[p.first]= true;\\n            int val= p.second;\\n            \\n            if(val<=currquiet)\\n            {\\n                 currquiet=val;\\n                 ans= p.first;\\n            }\\n            \\n            for(auto el: adj[p.first])\\n            {\\n                if(!visited[el.first])\\n                    q.push({el.first,el.second});\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n= quiet.size();\\n        \\n        vector<vector<pair<int,int>>> adj(n);\\n        \\n        for(auto el: richer)\\n        {\\n            int u= el[1];\\n            int v= el[0];\\n            \\n            adj[u].push_back({v,quiet[v]});\\n        }\\n        \\n        vector<int> ans(n,-1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int h= bfs(adj,i,quiet);\\n            ans[i]= h;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int bfs(vector<vector<pair<int,int>>>& adj,int u,vector<int>& quiet)\\n    {\\n        queue<pair<int,int>> q;\\n        vector<bool> visited(quiet.size(),false);\\n        \\n        q.push({u,quiet[u]}",
                "codeTag": "Java"
            },
            {
                "id": 3338271,
                "title": "c-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> indeg(n,0),ans(n);\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][0]].push_back(richer[i][1]);\\n            indeg[richer[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=i;\\n            if(indeg[i]==0)\\n            q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int temp=q.front();\\n            q.pop();\\n            for(int i:adj[temp])\\n            {\\n                if(quiet[ans[i]]>=quiet[ans[temp]])\\n                ans[i]=ans[temp];\\n                if(--indeg[i]==0)\\n                q.push(i);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<int> indeg(n,0),ans(n);\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<richer.size();i++)\\n        {\\n            adj[richer[i][0]].push_back(richer[i][1]);\\n            indeg[richer[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=i;\\n            if(indeg[i]==0)\\n            q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int temp=q.front();\\n            q.pop();\\n            for(int i:adj[temp])\\n            {\\n                if(quiet[ans[i]]>=quiet[ans[temp]])\\n                ans[i]=ans[temp];\\n                if(--indeg[i]==0)\\n                q.push(i);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1708769,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1565078,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1569845,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1968557,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1830030,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1854187,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1635588,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1932106,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1879280,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1879202,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1708769,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1565078,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1569845,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1968557,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1830030,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1854187,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1635588,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1932106,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1879280,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            },
            {
                "id": 1879202,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I don\\'t quiet get it !"
                    },
                    {
                        "username": "vkumarra",
                        "content": "Can someone please explain how is this possible:\\n\\n\"answer[7] = 7.\\nThere isn\\'t anyone who definitely has more money than person 7, so the person who definitely has\\nequal to or more money than person 7 is just person 7.\"\\n\\nGiven [3, 7] entry in richer, we know for sure that atleaset 3 has more money that 7.\\n\\nCan someone please explain it."
                    },
                    {
                        "username": "adis176",
                        "content": "[@2811guin](/2811guin) Actually we take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "RjChamp99",
                        "content": " 4 persons have equal or more money than 7 ->(7,3,4,5). among these 7 has the least quietness of 0. hence answer[7] = 7"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Consider the condition, Richness[p1] = Richness[p2] only when p1=p2;\\nwhere p1 and p2 are persons."
                    },
                    {
                        "username": "2811guin",
                        "content": "I think answer of 7 would be 5 because : their are 4 person richer than 7 they are 3,4,5,6 with quietness 4,6,1,7. So answer is index 5 because of less quietness."
                    },
                    {
                        "username": "user1424z",
                        "content": "\"least quiet person (that is, the person y with the smallest value of quiet[y])\"\\n\\nWell, if \"quiet[y]\" is how quiet the person is, shouldn\\'t the least quiet person have the largest \"quietness\" value?\\n\\nWhy don\\'t they just call it \"loudness\" and say \"the loudest person\"?"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nDraw the graph, `richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]`\n\nWho's richer?\n`0 -> [0, 1, 2, 3, 4, 5, 6]` Why `0`? `0` is richer then himself so included. Why not `7`? no direct relationship.\n`1 -> [1,2,3,4,5,6]`\n`2 -> [2]`\n`3 -> [3, 4, 5, 6]`\n`4 -> [4]`\n`5 -> [5]`\n`6 -> [6]`\n`7 -> [7, 3, 4, 5, 6]`\n\nNow take the minimum quietness for all the node. For example,\n(index, quietness)\n` 0 -> [(0, 3), (1, 2), (2, 5), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `1` at `5`. So, answer for` 0 -> 5`.\n\nOne more test:\n`7 -> [(7, 0), (3, 4), (4, 6), (5, 1), (6, 7)]`\nmin quietness is `0` at `7`. So, answer for `7->7`.\n\nI hope this make sense!"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "yesterday solved it using bfs , today came to see the dfs solution , now   unable to intuit the bfs solution also ."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "This is one of the more frustrating problems on leetcode. Just trying to understand the question and coming up with an idea of the solution itself will be a big challenge."
                    },
                    {
                        "username": "hrak109",
                        "content": "I would also agree the question should have worded things better. Least quiet == loud can confuse some people.\nShould have said noiseLevel[] or something better.\nAlso, you can't tell if persons x and y are equally loud, since the relations given are relative. I assume the author wrote equal for the self case.\nAlso, should have mentioned that if there isn't anyone richer that's louder, then person itself is the loudest. The current wording implies that we need to find other person aside from x.\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "can\\'t understand the problem .. testcase is very confusing\\n\\nWhy normal topologic sort will not work?"
                    },
                    {
                        "username": "adis176",
                        "content": "Guys, I would say the question is frame a little bit ambiguously, still it is quite a good question. Some intuition and assumption can lead you to understand the question, map it out on a piece of paper.\\n\\nThe only thing that is framed improperly would be the quietness values, since we generally term everything(pertaining to sound) in decibels, hence it does not fit in our minds when we see the least quiet person having the lowest value.\\n\\nAlso for the first test case, many people are confused by the \\'7\\' value: \\n We take comparisons of people who have money \\'EQUAL TO\\' or more than us, hence the person himself is counted too.\\nThen we compare their quietness, take the minimum out of it.\\nThus for 7, people with equal or more money are: 3, 4, 5, 6, 7\\nOut of these five people, \\'7\\' itself has the lowest quietness."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "So in example 1, answer[2] = 2 is because for 2, we don\\'t have information about who is richer than 2 in ricker array. So is it that we first consider the richness . if no information is present about who is richer than the person, then we stop there and don\\'t look at the quietness. Like for 2 there is no info about richer people than 2, so we stop there and pick 2 as answer. Similarly for 4 and 6."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "Example 1: why answer[2] = 2, not 5"
                    }
                ]
            }
        ]
    },
    {
        "title": "Tiling a Rectangle with the Fewest Squares",
        "question_content": "<p>Given a rectangle of size <code>n</code> x <code>m</code>, return <em>the minimum number of integer-sided squares that tile the rectangle</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/17/sample_11_1592.png\" style=\"width: 154px; height: 106px;\" /></p>\n\n<pre>\n<strong>Input:</strong> n = 2, m = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> <code>3</code> squares are necessary to cover the rectangle.\n<code>2</code> (squares of <code>1x1</code>)\n<code>1</code> (square of <code>2x2</code>)</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/17/sample_22_1592.png\" style=\"width: 224px; height: 126px;\" /></p>\n\n<pre>\n<strong>Input:</strong> n = 5, m = 8\n<strong>Output:</strong> 5\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/17/sample_33_1592.png\" style=\"width: 224px; height: 189px;\" /></p>\n\n<pre>\n<strong>Input:</strong> n = 11, m = 13\n<strong>Output:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, m &lt;= 13</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 414804,
                "title": "a-review-why-this-problem-is-a-tip-of-the-iceberg",
                "content": "**Algorithm Review**\\n\\n* Credits to all leetcoders who discussed here. \\uD83D\\uDE0A\\n* Denote the solution of (n, m) as s(n, m). Obviously, s(n, m) = s(m, n).\\n* (Conjecture 1) Let F_n be the Fibonacci sequence(1, 1, 2, 3, 5, 8...). We purpose that s(F_k, F_(k+1)) = k where k is a positive integer. If that is true, the greedy algorithm does output the correct answer in this special case. (Currently we have checked the rectangles up to 380 * 380 and no counterexamples have been found.)\\n\\t* s(5, 8) = s(F_5, F_6) = 5\\n\\t![image](https://assets.leetcode.com/users/orangezeit/image_1572212430.png)\\n* Too-specific solution: Hard-code a 13 * 13 table of results pre-calculated by others\\n* Specific (and essentially wrong) solutions: Due to the input scale, we can adapt DP or greedy by handling special cases.\\n\\t* If we adapt (naive) DP (i.e., only storing information of tiling squares in the sub-problems), we only need to deal with one special case 11 * 13 (or equivalently 13 * 11) where the DP answer does not agree with the correct one.\\n\\t* If we adapt (naive) greedy (i.e. always cutting off the largest possible square), we need to deal with much more special cases compared with DP. I will argue the pros and cons of two methods in the following code block.\\n\\t\\n\\t```cpp\\n    // (Wrong!) DP, must handle special cases and cannot generalize to any (n, m)\\n    // Credit: [@xiaogugu](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/\\n\\t// discuss/414246/Java-Straightforward-DP%3A-Top-Down-and-Bottom-up), with modifications\\n\\t// Time Complexity: O(mn * max(m, n))\\n\\t// Space Complexity: O(mn)\\n\\t\\n    int tilingRectangle(int n, int m) {\\n        if ((n == 11 && m == 13) || (m == 11 && n == 13))\\n\\t\\t\\treturn 6; // DP answer is 8\\n        int dp[n + 1][m + 1] = {};\\n        \\n        for (int i = 1; i <= n; i++)\\n            for (int j = 1; j <= m; j++){\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                dp[i][j] = i * j;\\n                for (int k = 1; k <= i / 2; k++)\\n                    dp[i][j] = min(dp[i][j], dp[i - k][j] + dp[k][j]);\\n                for (int k = 1; k <= j / 2; k++)\\n                    dp[i][j] = min(dp[i][j], dp[i][j - k] + dp[i][k]);\\n            }\\n        \\n        return dp[n][m];\\n    }\\n\\t\\n\\t// (Wrong!) greedy, must handle much more special cases and cannot generalize to any (n, m)\\n\\t// You may wonder why I still apply seemingly less efficient algorithm.\\n\\t// Since naive DP and greedy are both wrong, we can only\\n\\t// use them as the upper bounds of the true answers in pruning DFS later.\\n\\t// DP generates more accurate upper bounds in a slower rate, and\\n\\t// greedy generates less accurate upper bounds in a faster rate. Here is the trade-off.\\n\\t\\n\\t// Hint: The Euclidean Algorithm\\n\\t// Time Complexity: O(log(min(m, n)))\\n\\t// Space Complexity: O(log(min(m, n)))\\n\\t\\n    int tilingRectangle(int n, int m) {\\n\\t\\tif (n > m) swap(m, n);\\n\\t\\tif (n == 5 && m == 6)   return 5;   // greedy answer is 6\\n\\t\\tif (n == 5 && m == 11)  return 6;   // greedy answer is 7\\n\\t\\tif (n == 6 && m == 7)   return 5;   // greedy answer is 7\\n\\t\\tif (n == 6 && m == 11)  return 6;   // greedy answer is 7\\n\\t\\tif (n == 6 && m == 13)              // ... You get the point.\\n\\t\\n        return m == n ? 1 : tilingRectangle(n, m - n) + 1;\\n\\t}\\n\\t```\\n\\t* (Conjecture 2) For any positive integers m and n, we further denote the result generated by DP as dp(m, n) and the result generated by greedy as gd(m, n). We purpose that s(m, n) <= dp(m, n) <= gd(m, n) always holds. It is pretty intuitive but I don\\'t know how to prove.\\n\\t* **[Updated]** It might be tempted to construct a **more sophisticated DP / greedy** (i.e.  consider rectangles and L-shapes besides squares). This method will **eventually fail** if you test larger m and n. (Chanllenge me if I am wrong.)\\n\\t\\t* Take case 16 * 17 for example. If you draw the tiles, you will realize that there is a \"double-L-shape\" (Your method might still work with the detailed categories of L-shapes but this is the signal). Needless to say, as m and n increase, there would be more complex shapes that cannot be filled into any category you designed at first (and that\\'s usually when DP and greedy fail), but that is just my intuition.\\n\\t\\t![image](https://assets.leetcode.com/users/orangezeit/image_1572481565.png)\\n\\t\\t\\n\\t\\t* If you are lucky and your codes passed case 16 * 17 (the correct answer is 8), it probabily won\\'t pass 82 * 83 (the correct answer is 10). The **lowest-order simple squared square figure** below also visualizes the complex relations of the squares.\\n\\t\\t* (Conjecture 3) This problem cannot be solved by DP or greedy alone.\\n* General (true) solution: use DFS / backtracking, start stacking squares from any of the four corners, could be improved by A* search.\\n\\t* Pruning 1: Try largest possible squares first to prune DFS.\\n\\t* Pruning 2: Use results generated by (naive) DP or greedy discussed above as smaller upper bounds of true answers.\\n\\t* After actual testing up to 30 * 30, DP upper bounds work better.\\n\\t* Visualization of heights\\n\\t* ![image](https://assets.leetcode.com/users/orangezeit/image_1577235083.png)\\n\\n\\t```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint tilingRectangle(int n, int m) {\\n\\t\\t\\tif (n == m) return 1;\\n\\t\\t\\tif (n > m) swap(n, m);\\n\\t\\t\\tint heights[n] = {};\\n\\n\\t\\t\\tint dp[n + 1][m + 1] = {};\\n\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t\\tfor (int j = 1; j <= m; j++){\\n\\t\\t\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 1;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][j] = i * j;\\n\\t\\t\\t\\t\\tfor (int k = 1; k <= i / 2; k++)\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[i - k][j] + dp[k][j]);\\n\\t\\t\\t\\t\\tfor (int k = 1; k <= j / 2; k++)\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[i][j - k] + dp[i][k]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tint res(dp[n][m]);\\n\\t\\t\\tdfs(n, m, heights, 0, res);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Credit: [@Charles000](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/\\n\\t\\t// discuss/414260/8ms-Memorized-Backtrack-Solution-without-special-case!), with modifications\\n\\t\\t// (a) add DP upper bound\\n\\t\\t// (b) use backtracking and pass array by reference to be memory efficient\\n\\t\\t// (c) other minor changes such as removing redundant variables & rewriting conditions\\n\\t\\t// (d) does not include the skyline record since it does not reduce time complexity significantly in tests\\n\\t\\t// Time Complexity: O(m^n)\\n\\t\\t// Space Complexity: O(n)\\n\\t\\t\\n\\t\\tvoid dfs(const int& n, const int& m, int heights[], int cnt, int& res) {\\n\\t\\t\\tif (cnt >= res) return;\\n\\n\\t\\t\\tint left(0), min_height(m);\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tif (heights[i] < min_height)\\n\\t\\t\\t\\t\\tmin_height = heights[left = i];\\n\\n\\t\\t\\tif (min_height == m) {\\n\\t\\t\\t\\tres = min(cnt, res);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint right(left);\\n\\t\\t\\twhile (right < n && heights[left] == heights[right] && right - left + min_height < m) right++;\\n\\t\\t\\t/*\\n\\t\\t\\tfor (int i = right; i > left; --i) {\\n\\t\\t\\t\\tfor (int j = left; j < i; ++j)\\n\\t\\t\\t\\t\\theights[j] += i - left;\\n\\t\\t\\t\\tdfs(n, m, heights, cnt + 1, res);\\n\\t\\t\\t\\tfor (int j = left; j < i; ++j)\\n\\t\\t\\t\\t\\theights[j] -= i - left;\\n\\t\\t\\t}\\n\\t\\t\\t*/\\n\\t\\t\\t// Credit: @revaluation\\n\\t\\t\\t// plot the biggest possible square to the rectangle\\n\\t\\t\\tfor (int i = left; i < right; i++)\\n\\t\\t\\t\\theights[i] += right - left;\\n\\n\\t\\t\\tfor (int size = right - left; size >= 1; size--) {\\n\\t\\t\\t\\tdfs(n, m, heights, cnt + 1, res);\\n\\n\\t\\t\\t\\t// update the rectangle to contain the next smaller square\\n\\t\\t\\t\\tfor (int i = left; i < left + size - 1; i++)\\n\\t\\t\\t\\t\\theights[i]--;\\n\\t\\t\\t\\theights[left + size - 1] -= size;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t```\\n\\n**Suggestions on Code Review**\\n* [Cheat Table](http://int-e.eu/~bf3/squares/young.txt) from [@lee215](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414160/Cheat)\\'s post\\n\\n* Focus on **basic solutions** in the cheat table\\n\\n**Mathematical Review**\\n\\n*WARNING: LOTS OF DEFINITIONS!*\\n\\nThis problem is just a special case of a group of problems studied by mathematicians. The first (most classic one) is **squaring the square**, which means we want to partition a square into several (possibly unique, i.e. use every kind of square only once) squares. If we require the uniqueness, it is a **simple (or perfect) squared square**, otherwise it is a **compound squared square**. As for this programming problem, we are **squaring the rectangle**. Since the uniqueness is not required, we try to make a **compound squared rectangle**. Since we can always make one, we are interested in finding the minimum number of squares.\\n\\nWatch the following video for a nice visualization of squaring squares.\\n\\nhttps://www.youtube.com/watch?v=NoRjwZomUK0\\n\\n**Transformation**\\n\\nBetween 1936 to 1938 at Cambridge University, Brooks, Smith, Stone and Tutte transformed the square tiling into an **equivalent electrical circuit** (also known as **Smith diagram**). From the perspective of computer science, it is equivalent to a **directed acyclic graph with more requirements**. (Maybe there is a jargon that I don\\'t know to describe that graph, but I just call it a flowchart.) There are three types of nodes. The first type only has the outflows (denoted as +). The second type only has the inflows (denoted as -). The third type has both outflows and inflows.\\n\\n![image](https://assets.leetcode.com/users/orangezeit/image_1572211864.png)\\n\\nFor the examples in this programming problem, we can draw similar graphs / flowcharts.\\n\\n![image](https://assets.leetcode.com/users/orangezeit/image_1572271808.png)\\n\\n**Several key observations in the graph**\\n\\n* The edges represent the squares. (@Prezes) The nodes represent the contiguities of the squares.\\n* The sum of the outflows of the node (+) / the sum of the inflows of the node (-) is equal to one side of the rectangle.\\n* For each of the nodes in between, the sum of the inflows is equal to the sum of the outflows.\\n* For each path from node (+) to node (-), the sum of them is equal to the other side of the rectangle.\\n\\nMaybe someone who aces in graph theory can apply those properties in actual coding, but that is beyond my programming ability.\\n\\n**HELL-LEVEL Follow-Ups**\\n\\n* Could be used as contest problems (in professional ones such as CODE JAM, NOT in Leetcode weekly contests)\\n* Solving them may not be impossible because DFS always works. The hardness comes from how we improve the efficiency.\\n* Extension 0: (Compound tilting - Count & Display) The compound tilting always exists given any positive integers m and n. More specifically, the number of squares ranges from s(n, m) to (m * n) inclusively. How many unique solutions are there? Return int. Also display them as list[list[int]] where int is the size length of squares. (Hint: count at the end of DFS + skip duplicated ones after rotations)\\n* Extension 1: What if we require uniqueness (i.e. each kind can be only used once) , or some degree of uniqueness (i.e. each kind can be used at most k times, we refer that as **semi-simple squaring / cubing / hypercubing** in the following text informally) ?\\n\\t - Q1.1: (Existence) Given m, n, does there exist a solution? Return true or false. As you are probably aware, unlike the compound tilting, the simple or semi-simple one does not always have a solution. (Hint: DFS + hashset if simple or hashmap if semi-simple)\\n\\t\\t - The (only) lowest-order simple squared square\\n\\n\\t![image](https://assets.leetcode.com/users/orangezeit/image_1572213053.png)\\n\\n\\t- Q1.2: (Count & Display) Given m, n and suppose at least one solution exists, how many unique solutions are there? Return int. Also display them as list[list[int]] where int is the size length of squares. ([OEIS A006983](https://oeis.org/A006983)) (Hint: count at the end of DFS + skip duplicated ones after rotations)\\n* Extension 2: What if we generalize the problem to 3 dimensions (**Cubing the cube** or **Cubing the cuboid**) or even higher dimensions (**Hypercubing the hypercube** or **Hypercubing the hypercuboid** \\u2013 not sure if that is a legitimate word)? It has been proved that simple cubing cubes and simple hypercubing hypercubes are impossible. What about other situations? Show whether they exist. Count and display them if they exist.\\n\\n| Existence  | simple  |  semi-simple  | compound |\\n|:-:|:-:|:-:|:-:|\\n| (hyper)cube  | Impossible  |  Indeterminate  | Definite |\\n| (hyper)cuboid  | Indeterminate  | Indeterminate  | Definite |\\n\\n| Count & Display  | simple  |  semi-simple  | compound |\\n|:-:|:-:|:-:|:-:|\\n| (hyper)cube  | NA  |  ?  | ? |\\n| (hyper)cuboid  | ?  | ?  | ? |\\n\\n**[Updated] Sample Solutions to Follow-Ups**\\n\\nFeel free to run the program at [here](https://repl.it/@YunfeiLuo/tilingrectanglescuboids)\\n\\n```cpp\\n#include <algorithm>\\n#include <cstring>\\n#include <iostream>\\n#include <map>\\n#include <numeric>\\n#include <set>\\n#include <vector>\\n\\n\\nclass Tiles {\\nprivate:\\n    std::map<int, int> record;\\n    std::set<std::vector<std::pair<int, int>>> rect_collections;\\n    int res;\\n  \\n    const int dpUpperBound2D(const int& x, const int& y) {\\n        int dp[x + 1][y + 1];\\n        memset(dp, 0, (x + 1) * (y + 1) * sizeof(int));\\n\\n        for (int i = 1; i <= x; ++i)\\n            for (int j = 1; j <= y; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                dp[i][j] = i * j;\\n                for (int k = 1; k <= i / 2; ++k)\\n                    dp[i][j] = std::min(dp[i][j], dp[i - k][j] + dp[k][j]);\\n                for (int k = 1; k <= j / 2; ++k)\\n                    dp[i][j] = std::min(dp[i][j], dp[i][j - k] + dp[i][k]);\\n            }\\n\\n        return dp[x][y];\\n    }\\n\\n    const int dpUpperBound3D(const int& x, const int& y, const int& z) {\\n        int dp[x + 1][y + 1][z + 1];\\n        memset(dp, 0, (x + 1) * (y + 1) * (z + 1) * sizeof(int));\\n\\n        for (int i = 1; i <= x; ++i)\\n            for (int j = 1; j <= y; ++j)\\n                for (int k = 1; k <= z; ++k) {\\n                    if (i == j && j == k) {\\n                        dp[i][j][k] = 1;\\n                        continue;\\n                    }\\n                    dp[i][j][k] = i * j * k;\\n                    for (int n = 1; n <= i / 2; ++n)\\n                        dp[i][j][k] = std::min(dp[i][j][k], dp[i - n][j][k] + dp[n][j][k]);\\n                    for (int n = 1; n <= j / 2; ++n)\\n                        dp[i][j][k] = std::min(dp[i][j][k], dp[i][j - n][k] + dp[i][n][k]);\\n                    for (int n = 1; n <= k / 2; ++n)\\n                        dp[i][j][k] = std::min(dp[i][j][k], dp[i][j][k - n] + dp[i][j][n]);\\n                }\\n\\n        return dp[x][y][z];\\n    }\\n\\n    void dfs2D(const int& x, const int& y, const int& n, int *heights, int cnt, int& ub, const bool& minTiles) {\\n\\t\\t\\n        if (cnt > ub) return;\\n\\n\\t\\tint left(0), min_height(y);\\n\\t\\tfor (int i = 0; i < x; i++)\\n\\t\\t\\tif (heights[i] < min_height)\\n\\t\\t\\t\\tmin_height = *(heights + (left = i));\\n\\n\\t\\tif (min_height == y) {\\n            if (cnt <= ub) {\\n                int i(0);\\n                std::vector< std::pair<int, int> > squares(record.size());\\n                for (const auto& p: record)\\n                    squares[i++] = std::make_pair(p.first, p.second);\\n                if (minTiles) rect_collections.clear();\\n                rect_collections.insert(squares);\\n            }\\n            res = std::min(res, cnt);\\n            if (minTiles) ub = std::min(ub, cnt);\\n            return;\\n\\t\\t}\\n\\n\\t\\tint right(left);\\n\\t\\twhile (right < x && *(heights + left) == *(heights + right) && right - left + min_height < y) right++;\\n\\n\\t\\tfor (int i = right; i > left; --i) {\\n            if (n && record.count(i - left) && record[i - left] == n)\\n                continue;\\n            for (int j = left; j < i; ++j)\\n                *(heights + j) += i - left;\\n            record[i - left]++;\\n            dfs2D(x, y, n, heights, cnt + 1, ub, minTiles);\\n            for (int j = left; j < i; ++j)\\n                *(heights + j) -= i - left;\\n            if (!(--record[i - left]))\\n                record.erase(i - left);\\n\\t\\t}\\n\\t}\\n\\n    void dfs3D(const int& x, const int& y, const int& z, const int& n, int *heights, int cnt, int& ub, const bool& minTiles) {\\n\\n        if (cnt > ub) return;\\n\\n        int left(0), top(0), min_height(z);\\n        for (int i = 0; i < x; ++i)\\n            for (int j = 0; j < y; ++j)\\n                if (*(heights + i * y + j) < min_height)\\n                    min_height = *(heights + (left = i) * y + (top = j));\\n\\n        if (min_height == z) {\\n            if (cnt <= ub) {\\n                int m(0);\\n                std::vector< std::pair<int, int> > cubes(record.size());\\n                for (const auto& p: record)\\n                    cubes[m++] = std::make_pair(p.first, p.second);\\n                if (minTiles) rect_collections.clear();\\n                rect_collections.insert(cubes);\\n            }\\n            res = std::min(res, cnt);\\n            if (minTiles) ub = std::min(ub, cnt);\\n            return;\\n        }\\n\\n        int right(left), bottom(top);\\n        while (right < x && bottom < y &&\\n               *(heights + left * y + top) == *(heights + right * y + top) && *(heights + left * y + top) == *(heights + left * y + bottom) &&\\n               right - left + min_height < z && bottom - top + min_height < z) {\\n            \\n            right++;\\n            bottom++;\\n            bool notSame(false);\\n            for (int i = left + 1; i < right; ++i) {\\n                for (int j = top + 1; j < bottom; ++j)\\n                    if (*(heights + i * y + j) != *(heights + left * y + top)) {\\n                        notSame = true;\\n                        break;\\n                    }\\n                if (notSame) break;\\n            }\\n\\n            if (notSame) {\\n                right--;\\n                bottom--;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = right; i > left; --i) {\\n            if (n && record.count(i - left) && record[i - left] == n)\\n                continue;\\n            for (int j = left; j < i; ++j)\\n                for (int k = top; k < top + i - left; ++k)\\n                    *(heights + j * y + k) += i - left;\\n            record[i - left]++;\\n            dfs3D(x, y, z, n, heights, cnt + 1, ub, minTiles);\\n            for (int j = left; j < i; ++j)\\n                for (int k = top; k < top + i - left; ++k)\\n                    *(heights + j * y + k) -= i - left;\\n            if (!(--record[i - left]))\\n                record.erase(i - left);\\n        }\\n    }\\n\\npublic:\\n    // d: dimension\\n    // arr[]: lengths of dimensions\\n    // n: the maximum number of each kind of square / cube to be used\\n    //    if n == 0: compound tiling\\n    //    if n > 0: semi-simple tiling (simple / perfect tiling if n == 1)\\n    // minTile: true if to find the tiles whose number is minimum, false if to find all tiles\\n\\tvoid tilingRectangleCuboid(int arr[], size_t d, const int n, const bool minTiles) {\\n        res = std::accumulate(arr, arr + d, 1, std::multiplies<int>());\\n\\t\\tstd::sort(arr, arr + d);\\n\\n        if (d == 2) {\\n            int ub(minTiles ? dpUpperBound2D(arr[0], arr[1]) : res), heights[arr[0]];\\n            memset(heights, 0, arr[0] * sizeof(int));\\n            dfs2D(arr[0], arr[1], n, (int *)heights, 0, ub, minTiles);\\n        } else {\\n            int ub(minTiles ? dpUpperBound3D(arr[0], arr[1], arr[2]) : res), heights[arr[0]][arr[1]];\\n            memset(heights, 0, arr[0] * arr[1] * sizeof(int));\\n            dfs3D(arr[0], arr[1], arr[2], n, (int *)heights, 0, ub, minTiles);\\n        }\\n\\n        if (rect_collections.empty()) {\\n            std::cout << \"No solutions with such requirements.\\\\n\";\\n        } else {\\n            \\n            for (const auto& rect: rect_collections) {\\n                for (const auto& p: rect)\\n                    std::cout << p.first << \": \" << p.second << \"\\\\n\";\\n                std::cout << \"--------\\\\n\";\\n            }\\n            std::cout << \"The minimum number of \" << (d == 2 ? \"squares\" : \"cubes\") << \" is \" << res << \"\\\\n\";\\n        }\\n\\t}\\n};\\n\\nint main() {\\n    Tiles t;\\n    int d[2] = {112, 112};\\n    t.tilingRectangleCuboid(d, 2, 1, false);\\n}\\n```\\n\\n**References**\\n\\n[Wikipedia - Squaring the squares](https://en.wikipedia.org/wiki/Squaring_the_square)\\n[Wolfram Math World - Perfect Square Dissection](http://mathworld.wolfram.com/PerfectSquareDissection.html)\\n[Squaring the Plane](http://math.smith.edu/~jhenle/stp/stp.pdf)",
                "solutionTags": [
                    "Math",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\n    // (Wrong!) DP, must handle special cases and cannot generalize to any (n, m)\\n    // Credit: [@xiaogugu](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/\\n\\t// discuss/414246/Java-Straightforward-DP%3A-Top-Down-and-Bottom-up), with modifications\\n\\t// Time Complexity: O(mn * max(m, n))\\n\\t// Space Complexity: O(mn)\\n\\t\\n    int tilingRectangle(int n, int m) {\\n        if ((n == 11 && m == 13) || (m == 11 && n == 13))\\n\\t\\t\\treturn 6; // DP answer is 8\\n        int dp[n + 1][m + 1] = {};\\n        \\n        for (int i = 1; i <= n; i++)\\n            for (int j = 1; j <= m; j++){\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                dp[i][j] = i * j;\\n                for (int k = 1; k <= i / 2; k++)\\n                    dp[i][j] = min(dp[i][j], dp[i - k][j] + dp[k][j]);\\n                for (int k = 1; k <= j / 2; k++)\\n                    dp[i][j] = min(dp[i][j], dp[i][j - k] + dp[i][k]);\\n            }\\n        \\n        return dp[n][m];\\n    }\\n\\t\\n\\t// (Wrong!) greedy, must handle much more special cases and cannot generalize to any (n, m)\\n\\t// You may wonder why I still apply seemingly less efficient algorithm.\\n\\t// Since naive DP and greedy are both wrong, we can only\\n\\t// use them as the upper bounds of the true answers in pruning DFS later.\\n\\t// DP generates more accurate upper bounds in a slower rate, and\\n\\t// greedy generates less accurate upper bounds in a faster rate. Here is the trade-off.\\n\\t\\n\\t// Hint: The Euclidean Algorithm\\n\\t// Time Complexity: O(log(min(m, n)))\\n\\t// Space Complexity: O(log(min(m, n)))\\n\\t\\n    int tilingRectangle(int n, int m) {\\n\\t\\tif (n > m) swap(m, n);\\n\\t\\tif (n == 5 && m == 6)   return 5;   // greedy answer is 6\\n\\t\\tif (n == 5 && m == 11)  return 6;   // greedy answer is 7\\n\\t\\tif (n == 6 && m == 7)   return 5;   // greedy answer is 7\\n\\t\\tif (n == 6 && m == 11)  return 6;   // greedy answer is 7\\n\\t\\tif (n == 6 && m == 13)              // ... You get the point.\\n\\t\\n        return m == n ? 1 : tilingRectangle(n, m - n) + 1;\\n\\t}\\n\\t```\n```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint tilingRectangle(int n, int m) {\\n\\t\\t\\tif (n == m) return 1;\\n\\t\\t\\tif (n > m) swap(n, m);\\n\\t\\t\\tint heights[n] = {};\\n\\n\\t\\t\\tint dp[n + 1][m + 1] = {};\\n\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t\\tfor (int j = 1; j <= m; j++){\\n\\t\\t\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 1;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][j] = i * j;\\n\\t\\t\\t\\t\\tfor (int k = 1; k <= i / 2; k++)\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[i - k][j] + dp[k][j]);\\n\\t\\t\\t\\t\\tfor (int k = 1; k <= j / 2; k++)\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[i][j - k] + dp[i][k]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tint res(dp[n][m]);\\n\\t\\t\\tdfs(n, m, heights, 0, res);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Credit: [@Charles000](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/\\n\\t\\t// discuss/414260/8ms-Memorized-Backtrack-Solution-without-special-case!), with modifications\\n\\t\\t// (a) add DP upper bound\\n\\t\\t// (b) use backtracking and pass array by reference to be memory efficient\\n\\t\\t// (c) other minor changes such as removing redundant variables & rewriting conditions\\n\\t\\t// (d) does not include the skyline record since it does not reduce time complexity significantly in tests\\n\\t\\t// Time Complexity: O(m^n)\\n\\t\\t// Space Complexity: O(n)\\n\\t\\t\\n\\t\\tvoid dfs(const int& n, const int& m, int heights[], int cnt, int& res) {\\n\\t\\t\\tif (cnt >= res) return;\\n\\n\\t\\t\\tint left(0), min_height(m);\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tif (heights[i] < min_height)\\n\\t\\t\\t\\t\\tmin_height = heights[left = i];\\n\\n\\t\\t\\tif (min_height == m) {\\n\\t\\t\\t\\tres = min(cnt, res);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint right(left);\\n\\t\\t\\twhile (right < n && heights[left] == heights[right] && right - left + min_height < m) right++;\\n\\t\\t\\t/*\\n\\t\\t\\tfor (int i = right; i > left; --i) {\\n\\t\\t\\t\\tfor (int j = left; j < i; ++j)\\n\\t\\t\\t\\t\\theights[j] += i - left;\\n\\t\\t\\t\\tdfs(n, m, heights, cnt + 1, res);\\n\\t\\t\\t\\tfor (int j = left; j < i; ++j)\\n\\t\\t\\t\\t\\theights[j] -= i - left;\\n\\t\\t\\t}\\n\\t\\t\\t*/\\n\\t\\t\\t// Credit: @revaluation\\n\\t\\t\\t// plot the biggest possible square to the rectangle\\n\\t\\t\\tfor (int i = left; i < right; i++)\\n\\t\\t\\t\\theights[i] += right - left;\\n\\n\\t\\t\\tfor (int size = right - left; size >= 1; size--) {\\n\\t\\t\\t\\tdfs(n, m, heights, cnt + 1, res);\\n\\n\\t\\t\\t\\t// update the rectangle to contain the next smaller square\\n\\t\\t\\t\\tfor (int i = left; i < left + size - 1; i++)\\n\\t\\t\\t\\t\\theights[i]--;\\n\\t\\t\\t\\theights[left + size - 1] -= size;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t```\n```cpp\\n#include <algorithm>\\n#include <cstring>\\n#include <iostream>\\n#include <map>\\n#include <numeric>\\n#include <set>\\n#include <vector>\\n\\n\\nclass Tiles {\\nprivate:\\n    std::map<int, int> record;\\n    std::set<std::vector<std::pair<int, int>>> rect_collections;\\n    int res;\\n  \\n    const int dpUpperBound2D(const int& x, const int& y) {\\n        int dp[x + 1][y + 1];\\n        memset(dp, 0, (x + 1) * (y + 1) * sizeof(int));\\n\\n        for (int i = 1; i <= x; ++i)\\n            for (int j = 1; j <= y; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                dp[i][j] = i * j;\\n                for (int k = 1; k <= i / 2; ++k)\\n                    dp[i][j] = std::min(dp[i][j], dp[i - k][j] + dp[k][j]);\\n                for (int k = 1; k <= j / 2; ++k)\\n                    dp[i][j] = std::min(dp[i][j], dp[i][j - k] + dp[i][k]);\\n            }\\n\\n        return dp[x][y];\\n    }\\n\\n    const int dpUpperBound3D(const int& x, const int& y, const int& z) {\\n        int dp[x + 1][y + 1][z + 1];\\n        memset(dp, 0, (x + 1) * (y + 1) * (z + 1) * sizeof(int));\\n\\n        for (int i = 1; i <= x; ++i)\\n            for (int j = 1; j <= y; ++j)\\n                for (int k = 1; k <= z; ++k) {\\n                    if (i == j && j == k) {\\n                        dp[i][j][k] = 1;\\n                        continue;\\n                    }\\n                    dp[i][j][k] = i * j * k;\\n                    for (int n = 1; n <= i / 2; ++n)\\n                        dp[i][j][k] = std::min(dp[i][j][k], dp[i - n][j][k] + dp[n][j][k]);\\n                    for (int n = 1; n <= j / 2; ++n)\\n                        dp[i][j][k] = std::min(dp[i][j][k], dp[i][j - n][k] + dp[i][n][k]);\\n                    for (int n = 1; n <= k / 2; ++n)\\n                        dp[i][j][k] = std::min(dp[i][j][k], dp[i][j][k - n] + dp[i][j][n]);\\n                }\\n\\n        return dp[x][y][z];\\n    }\\n\\n    void dfs2D(const int& x, const int& y, const int& n, int *heights, int cnt, int& ub, const bool& minTiles) {\\n\\t\\t\\n        if (cnt > ub) return;\\n\\n\\t\\tint left(0), min_height(y);\\n\\t\\tfor (int i = 0; i < x; i++)\\n\\t\\t\\tif (heights[i] < min_height)\\n\\t\\t\\t\\tmin_height = *(heights + (left = i));\\n\\n\\t\\tif (min_height == y) {\\n            if (cnt <= ub) {\\n                int i(0);\\n                std::vector< std::pair<int, int> > squares(record.size());\\n                for (const auto& p: record)\\n                    squares[i++] = std::make_pair(p.first, p.second);\\n                if (minTiles) rect_collections.clear();\\n                rect_collections.insert(squares);\\n            }\\n            res = std::min(res, cnt);\\n            if (minTiles) ub = std::min(ub, cnt);\\n            return;\\n\\t\\t}\\n\\n\\t\\tint right(left);\\n\\t\\twhile (right < x && *(heights + left) == *(heights + right) && right - left + min_height < y) right++;\\n\\n\\t\\tfor (int i = right; i > left; --i) {\\n            if (n && record.count(i - left) && record[i - left] == n)\\n                continue;\\n            for (int j = left; j < i; ++j)\\n                *(heights + j) += i - left;\\n            record[i - left]++;\\n            dfs2D(x, y, n, heights, cnt + 1, ub, minTiles);\\n            for (int j = left; j < i; ++j)\\n                *(heights + j) -= i - left;\\n            if (!(--record[i - left]))\\n                record.erase(i - left);\\n\\t\\t}\\n\\t}\\n\\n    void dfs3D(const int& x, const int& y, const int& z, const int& n, int *heights, int cnt, int& ub, const bool& minTiles) {\\n\\n        if (cnt > ub) return;\\n\\n        int left(0), top(0), min_height(z);\\n        for (int i = 0; i < x; ++i)\\n            for (int j = 0; j < y; ++j)\\n                if (*(heights + i * y + j) < min_height)\\n                    min_height = *(heights + (left = i) * y + (top = j));\\n\\n        if (min_height == z) {\\n            if (cnt <= ub) {\\n                int m(0);\\n                std::vector< std::pair<int, int> > cubes(record.size());\\n                for (const auto& p: record)\\n                    cubes[m++] = std::make_pair(p.first, p.second);\\n                if (minTiles) rect_collections.clear();\\n                rect_collections.insert(cubes);\\n            }\\n            res = std::min(res, cnt);\\n            if (minTiles) ub = std::min(ub, cnt);\\n            return;\\n        }\\n\\n        int right(left), bottom(top);\\n        while (right < x && bottom < y &&\\n               *(heights + left * y + top) == *(heights + right * y + top) && *(heights + left * y + top) == *(heights + left * y + bottom) &&\\n               right - left + min_height < z && bottom - top + min_height < z) {\\n            \\n            right++;\\n            bottom++;\\n            bool notSame(false);\\n            for (int i = left + 1; i < right; ++i) {\\n                for (int j = top + 1; j < bottom; ++j)\\n                    if (*(heights + i * y + j) != *(heights + left * y + top)) {\\n                        notSame = true;\\n                        break;\\n                    }\\n                if (notSame) break;\\n            }\\n\\n            if (notSame) {\\n                right--;\\n                bottom--;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = right; i > left; --i) {\\n            if (n && record.count(i - left) && record[i - left] == n)\\n                continue;\\n            for (int j = left; j < i; ++j)\\n                for (int k = top; k < top + i - left; ++k)\\n                    *(heights + j * y + k) += i - left;\\n            record[i - left]++;\\n            dfs3D(x, y, z, n, heights, cnt + 1, ub, minTiles);\\n            for (int j = left; j < i; ++j)\\n                for (int k = top; k < top + i - left; ++k)\\n                    *(heights + j * y + k) -= i - left;\\n            if (!(--record[i - left]))\\n                record.erase(i - left);\\n        }\\n    }\\n\\npublic:\\n    // d: dimension\\n    // arr[]: lengths of dimensions\\n    // n: the maximum number of each kind of square / cube to be used\\n    //    if n == 0: compound tiling\\n    //    if n > 0: semi-simple tiling (simple / perfect tiling if n == 1)\\n    // minTile: true if to find the tiles whose number is minimum, false if to find all tiles\\n\\tvoid tilingRectangleCuboid(int arr[], size_t d, const int n, const bool minTiles) {\\n        res = std::accumulate(arr, arr + d, 1, std::multiplies<int>());\\n\\t\\tstd::sort(arr, arr + d);\\n\\n        if (d == 2) {\\n            int ub(minTiles ? dpUpperBound2D(arr[0], arr[1]) : res), heights[arr[0]];\\n            memset(heights, 0, arr[0] * sizeof(int));\\n            dfs2D(arr[0], arr[1], n, (int *)heights, 0, ub, minTiles);\\n        } else {\\n            int ub(minTiles ? dpUpperBound3D(arr[0], arr[1], arr[2]) : res), heights[arr[0]][arr[1]];\\n            memset(heights, 0, arr[0] * arr[1] * sizeof(int));\\n            dfs3D(arr[0], arr[1], arr[2], n, (int *)heights, 0, ub, minTiles);\\n        }\\n\\n        if (rect_collections.empty()) {\\n            std::cout << \"No solutions with such requirements.\\\\n\";\\n        } else {\\n            \\n            for (const auto& rect: rect_collections) {\\n                for (const auto& p: rect)\\n                    std::cout << p.first << \": \" << p.second << \"\\\\n\";\\n                std::cout << \"--------\\\\n\";\\n            }\\n            std::cout << \"The minimum number of \" << (d == 2 ? \"squares\" : \"cubes\") << \" is \" << res << \"\\\\n\";\\n        }\\n\\t}\\n};\\n\\nint main() {\\n    Tiles t;\\n    int d[2] = {112, 112};\\n    t.tilingRectangleCuboid(d, 2, 1, false);\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 414260,
                "title": "8ms-memorized-backtrack-solution-without-special-case",
                "content": "The basic idea is to fill the entire block bottom up. In every step, find the lowest left unfilled square first, and select a square with different possible sizes to fill it. We maintain a height array (skyline) with length n while dfs. This skyline is the identity of the state. The final result we ask for is the minimum number of squares for the state [m, m, m, m, m, m, m] (The length of this array is n). Of course, backtrack without optimization will have a huge time complexity, but it can be pruned or optimized by the following three methods.\\n1. When the current cnt (that is, the number of squares) of this skyline has exceeded the value of the current global optimal solution, then return directly.\\n2. When the current skyline has been traversed, and the previous cnt is smaller than the current cnt, then return directly.\\n3. When we find the empty square in the lowest left corner, we pick larger size for the next square first. This can make the program converge quickly. (It is a very important optimization)\\n\\n```\\nclass Solution {\\n    Map<Long, Integer> set = new HashMap<>();\\n    int res = Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        if (n == m) return 1;\\n        if (n > m) {\\n            int temp = n;\\n            n = m;\\n            m = temp;\\n        }\\n        dfs(n, m, new int[n + 1], 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int n, int m, int[] h, int cnt) {\\n        if (cnt >= res) return;\\n        boolean isFull = true;\\n        int pos = -1, minH = Integer.MAX_VALUE;\\n        for (int i = 1; i <= n; i++) {\\n            if (h[i] < m) isFull = false;\\n            if (h[i] < minH) {\\n                pos = i;\\n                minH = h[i];\\n            }\\n        }\\n        if (isFull) {\\n            res = Math.min(cnt, res);\\n            return;\\n        }\\n        \\n        long key = 0, base = m + 1;\\n        for (int i = 1; i <= n; i++) {\\n            key += h[i] * base;\\n            base *= m + 1;\\n        }\\n        if (set.containsKey(key) && set.get(key) <= cnt) return;\\n        set.put(key, cnt);\\n        \\n        int end = pos;\\n        while (end + 1 <= n && h[end + 1] == h[pos] && (end + 1 - pos + 1 + minH) <= m) end++;\\n        for (int j = end; j >= pos; j--) {\\n            int curH = j - pos + 1;\\n            \\n            int[] next  = Arrays.copyOf(h, n + 1);\\n            for (int k = pos; k <= j; k++) {\\n                next[k] += curH;\\n            }\\n            dfs(n, m, next, cnt + 1);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Long, Integer> set = new HashMap<>();\\n    int res = Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        if (n == m) return 1;\\n        if (n > m) {\\n            int temp = n;\\n            n = m;\\n            m = temp;\\n        }\\n        dfs(n, m, new int[n + 1], 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int n, int m, int[] h, int cnt) {\\n        if (cnt >= res) return;\\n        boolean isFull = true;\\n        int pos = -1, minH = Integer.MAX_VALUE;\\n        for (int i = 1; i <= n; i++) {\\n            if (h[i] < m) isFull = false;\\n            if (h[i] < minH) {\\n                pos = i;\\n                minH = h[i];\\n            }\\n        }\\n        if (isFull) {\\n            res = Math.min(cnt, res);\\n            return;\\n        }\\n        \\n        long key = 0, base = m + 1;\\n        for (int i = 1; i <= n; i++) {\\n            key += h[i] * base;\\n            base *= m + 1;\\n        }\\n        if (set.containsKey(key) && set.get(key) <= cnt) return;\\n        set.put(key, cnt);\\n        \\n        int end = pos;\\n        while (end + 1 <= n && h[end + 1] == h[pos] && (end + 1 - pos + 1 + minH) <= m) end++;\\n        for (int j = end; j >= pos; j--) {\\n            int curH = j - pos + 1;\\n            \\n            int[] next  = Arrays.copyOf(h, n + 1);\\n            for (int k = pos; k <= j; k++) {\\n                next[k] += curH;\\n            }\\n            dfs(n, m, next, cnt + 1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414979,
                "title": "java-back-tracking-solution",
                "content": "Based on @uwi\\'s solution in the contest, I add some explantion here.\\n1. Go through every point in the rectangle, starting from (0,0), (0,1), ..., (n, m).\\n2. If ```rect[r,..., r+k][c, ..., c+k]``` is an available area, then cover a ```k*k``` square starting at point ```(r,c)```.\\n3. Try every possible size of square ```k * k```, where ```k = min(n-r, m-c)```.\\n4. Optimzation: If ```cnt``` >= ```ans```, then stop.\\n![image](https://assets.leetcode.com/users/motorix/image_1572226905.png)\\n\\nJava:\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        dfs(0, 0, new boolean[n][m], 0);\\n        return ans;\\n    }\\n    // (r, c) is the starting point for selecting a square\\n    // rect records the status of current rectangle\\n    // cnt is the number of squares we have covered\\n    private void dfs(int r, int c, boolean[][] rect, int cnt) {\\n        int n = rect.length, m = rect[0].length;\\n        // optimization 1: The current cnt >= the current answer\\n        if (cnt >= ans) return;\\n        \\n        // Successfully cover the whole rectangle\\n        if (r >= n) {\\n            ans = cnt; \\n            return;\\n        }\\n        \\n        // Successfully cover the area [0, ..., n][0, ..., c] => Move to next row\\n        if (c >= m) {\\n            dfs(r+1, 0, rect, cnt); \\n            return;\\n        }\\n        \\n        // If (r, c) is already covered => move to next point (r, c+1)\\n        if (rect[r][c]) {\\n            dfs(r, c+1, rect, cnt);\\n            return;\\n        }\\n        \\n        // Try all the possible size of squares starting from (r, c)\\n        for (int k = Math.min(n-r, m-c); k >= 1 && isAvailable(rect, r, c, k); k--) {\\n            cover(rect, r, c, k);\\n            dfs(r, c+1, rect, cnt+1);\\n            uncover(rect, r, c, k);\\n        }\\n    }\\n    // Check if the area [r, ..., r+k][c, ..., c+k] is alreadc covered\\n    private boolean isAvailable(boolean[][] rect, int r, int c, int k) {\\n        for (int i = 0; i < k; i++){\\n            for(int j = 0; j < k; j++){\\n                if(rect[r+i][c+j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    // Cover the area [r, ..., r+k][c, ..., c+k] with a k * k square\\n    private void cover(boolean[][] rect, int r, int c, int k) {\\n        for(int i = 0; i < k; i++){\\n            for(int j = 0; j < k; j++){\\n                rect[r+i][c+j] = true;\\n            }\\n        }\\n    }\\n    // Uncover the area [r, ..., r+k][c, ..., c+k]\\n    private void uncover(boolean[][] rect, int r, int c, int k) {\\n        for(int i = 0; i < k; i++){\\n            for(int j = 0; j < k; j++){\\n                rect[r+i][c+j] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rect[r,..., r+k][c, ..., c+k]```\n```k*k```\n```(r,c)```\n```k * k```\n```k = min(n-r, m-c)```\n```cnt```\n```ans```\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        dfs(0, 0, new boolean[n][m], 0);\\n        return ans;\\n    }\\n    // (r, c) is the starting point for selecting a square\\n    // rect records the status of current rectangle\\n    // cnt is the number of squares we have covered\\n    private void dfs(int r, int c, boolean[][] rect, int cnt) {\\n        int n = rect.length, m = rect[0].length;\\n        // optimization 1: The current cnt >= the current answer\\n        if (cnt >= ans) return;\\n        \\n        // Successfully cover the whole rectangle\\n        if (r >= n) {\\n            ans = cnt; \\n            return;\\n        }\\n        \\n        // Successfully cover the area [0, ..., n][0, ..., c] => Move to next row\\n        if (c >= m) {\\n            dfs(r+1, 0, rect, cnt); \\n            return;\\n        }\\n        \\n        // If (r, c) is already covered => move to next point (r, c+1)\\n        if (rect[r][c]) {\\n            dfs(r, c+1, rect, cnt);\\n            return;\\n        }\\n        \\n        // Try all the possible size of squares starting from (r, c)\\n        for (int k = Math.min(n-r, m-c); k >= 1 && isAvailable(rect, r, c, k); k--) {\\n            cover(rect, r, c, k);\\n            dfs(r, c+1, rect, cnt+1);\\n            uncover(rect, r, c, k);\\n        }\\n    }\\n    // Check if the area [r, ..., r+k][c, ..., c+k] is alreadc covered\\n    private boolean isAvailable(boolean[][] rect, int r, int c, int k) {\\n        for (int i = 0; i < k; i++){\\n            for(int j = 0; j < k; j++){\\n                if(rect[r+i][c+j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    // Cover the area [r, ..., r+k][c, ..., c+k] with a k * k square\\n    private void cover(boolean[][] rect, int r, int c, int k) {\\n        for(int i = 0; i < k; i++){\\n            for(int j = 0; j < k; j++){\\n                rect[r+i][c+j] = true;\\n            }\\n        }\\n    }\\n    // Uncover the area [r, ..., r+k][c, ..., c+k]\\n    private void uncover(boolean[][] rect, int r, int c, int k) {\\n        for(int i = 0; i < k; i++){\\n            for(int j = 0; j < k; j++){\\n                rect[r+i][c+j] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414716,
                "title": "python-two-solutions-backtracking-a-search",
                "content": "Two strategies are presented here: backtracking and A* search. They are both based on the following principle:\\n* Place squares in the order of bottom to top and left to right; all possible tilings can form such unique ordering to avoid searching redundant cases.\\n\\nAfter fixing the incorrect filling boundary (thanks to @Prezes and @StrongerXi), now both methods run at about the same speed (A* search: 124 ms; backtracking: 128 ms). With [StrongerXi\\'s better heuristic](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/415423/No-magic-a-dfs-solution-with-heuristic), A* search can further achieve 72 ms.\\n\\nBacktracking:\\n```python\\ndef tilingRectangle(self, n: int, m: int) -> int:\\n\\tself.best = m * n    \\n\\n\\tdef dfs(height, moves):\\n\\t\\tif all(h == n for h in height):\\n\\t\\t\\tself.best = min(self.best, moves)\\n\\t\\t\\treturn\\n\\t\\tif moves >= self.best:\\n\\t\\t\\treturn\\n\\t\\tmin_height = min(height)\\n\\t\\tidx = height.index(min_height)\\n\\t\\tridx = idx + 1\\n\\t\\twhile ridx < m and height[ridx] == min_height:\\n\\t\\t\\tridx += 1\\n\\t\\tfor i in range(min(ridx - idx, n - min_height), 0, -1):\\n\\t\\t\\tnew_height = height[:]\\n\\t\\t\\tfor j in range(i):\\n\\t\\t\\t\\tnew_height[idx + j] += i\\n\\t\\t\\tdfs(new_height, moves + 1) \\n\\n\\tdfs([0] * m, 0)\\n\\treturn self.best\\n```\\n\\nA* search:\\n\\nA* search is similar to Dijkstra algorithm except for using an additional heuristic function to accelerate searching. I use the number of distinct heights smaller than n as the lower bound of the optimal cost for filling the rest of the rectangle.\\n\\nWith this simple heuristic, it reduces time from 1400 ms to 124 ms comparing to standard BFS.\\n```python\\ndef tilingRectangle(self, n: int, m: int) -> int:\\n\\theight = [0] * m\\n\\tq = []\\n\\tfor i in range(min(m, n), 0, -1):\\n\\t\\t# Push to heap: (guess, moves, -size, height)\\n\\t\\theapq.heappush(q, (1, 1, -i, height))\\n\\n\\twhile q:\\n\\t\\tguess, moves, neg_size, height = heapq.heappop(q)\\n\\t\\tsize = -neg_size\\n\\t\\tidx = height.index(min(height))\\n\\t\\theight = height[:]\\n\\t\\tfor i in range(size):\\n\\t\\t\\theight[idx + i] += size\\n\\t\\tif all(h == n for h in height):\\n\\t\\t\\treturn moves\\n\\t\\tmin_height = min(height)\\n\\t\\tidx = height.index(min_height)\\n\\t\\tridx = idx + 1\\n\\t\\twhile ridx < m and height[ridx] == min_height:\\n\\t\\t\\tridx += 1\\n\\t\\tfor i in range(min(ridx - idx, n - min_height), 0, -1):\\n\\t\\t\\theapq.heappush(q, (moves + 1 + len(set(h for h in height if h < n)), \\n\\t\\t\\t\\t\\t\\t\\t   moves + 1, -i, height))\\n```\\n\\nWith [@StrongerXi](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/415423/No-magic-a-dfs-solution-with-heuristic)\\'s tighter lower bound using the least number of squares to fill up the remaining area, A* search can achieve 72 ms as follows.\\n\\n```python\\ndef tilingRectangle(self, n: int, m: int) -> int:\\n\\t# Credits to StrongerXi\\n\\t# Use the least number of squares to fill up the remaining area as a lower bound.\\n\\ttotal_area = m * n\\n\\tdp = [0] * (total_area + 1)\\n\\tfor i in range(1, total_area + 1):\\n\\t\\tdp[i] = 1 + min(dp[i - k**2] for k in range(1, int(i**0.5) + 1))\\n\\t\\t\\n\\theight = [0] * m\\t\\t\\n\\tq = []\\n\\tfor i in range(min(m, n), 0, -1):\\n\\t\\t# Push to heap: (guess, moves, size, height)\\n\\t\\theapq.heappush(q, (1 + dp[total_area - i**2], 1, i, height))\\n\\n\\twhile q:\\n\\t\\tguess, moves, size, height = heapq.heappop(q)\\n\\t\\tidx = height.index(min(height))\\n\\t\\theight = height[:]\\n\\t\\tfor i in range(size):\\n\\t\\t\\theight[idx + i] += size\\n\\t\\tif all(h == n for h in height):\\n\\t\\t\\treturn moves\\n\\t\\tmin_height = min(height)\\n\\t\\tidx = height.index(min_height)\\n\\t\\tridx = idx + 1\\n\\t\\twhile ridx < m and height[ridx] == min_height:\\n\\t\\t\\tridx += 1\\n\\t\\tfor i in range(min(ridx - idx, n - min_height), 0, -1):\\n\\t\\t\\tguess = dp[total_area - sum(height) - i**2]\\n\\t\\t\\theapq.heappush(q, (moves + 1 + guess, \\n\\t\\t\\t\\t\\t\\t\\t   moves + 1, i, height))\\n```",
                "solutionTags": [],
                "code": "```python\\ndef tilingRectangle(self, n: int, m: int) -> int:\\n\\tself.best = m * n    \\n\\n\\tdef dfs(height, moves):\\n\\t\\tif all(h == n for h in height):\\n\\t\\t\\tself.best = min(self.best, moves)\\n\\t\\t\\treturn\\n\\t\\tif moves >= self.best:\\n\\t\\t\\treturn\\n\\t\\tmin_height = min(height)\\n\\t\\tidx = height.index(min_height)\\n\\t\\tridx = idx + 1\\n\\t\\twhile ridx < m and height[ridx] == min_height:\\n\\t\\t\\tridx += 1\\n\\t\\tfor i in range(min(ridx - idx, n - min_height), 0, -1):\\n\\t\\t\\tnew_height = height[:]\\n\\t\\t\\tfor j in range(i):\\n\\t\\t\\t\\tnew_height[idx + j] += i\\n\\t\\t\\tdfs(new_height, moves + 1) \\n\\n\\tdfs([0] * m, 0)\\n\\treturn self.best\\n```\n```python\\ndef tilingRectangle(self, n: int, m: int) -> int:\\n\\theight = [0] * m\\n\\tq = []\\n\\tfor i in range(min(m, n), 0, -1):\\n\\t\\t# Push to heap: (guess, moves, -size, height)\\n\\t\\theapq.heappush(q, (1, 1, -i, height))\\n\\n\\twhile q:\\n\\t\\tguess, moves, neg_size, height = heapq.heappop(q)\\n\\t\\tsize = -neg_size\\n\\t\\tidx = height.index(min(height))\\n\\t\\theight = height[:]\\n\\t\\tfor i in range(size):\\n\\t\\t\\theight[idx + i] += size\\n\\t\\tif all(h == n for h in height):\\n\\t\\t\\treturn moves\\n\\t\\tmin_height = min(height)\\n\\t\\tidx = height.index(min_height)\\n\\t\\tridx = idx + 1\\n\\t\\twhile ridx < m and height[ridx] == min_height:\\n\\t\\t\\tridx += 1\\n\\t\\tfor i in range(min(ridx - idx, n - min_height), 0, -1):\\n\\t\\t\\theapq.heappush(q, (moves + 1 + len(set(h for h in height if h < n)), \\n\\t\\t\\t\\t\\t\\t\\t   moves + 1, -i, height))\\n```\n```python\\ndef tilingRectangle(self, n: int, m: int) -> int:\\n\\t# Credits to StrongerXi\\n\\t# Use the least number of squares to fill up the remaining area as a lower bound.\\n\\ttotal_area = m * n\\n\\tdp = [0] * (total_area + 1)\\n\\tfor i in range(1, total_area + 1):\\n\\t\\tdp[i] = 1 + min(dp[i - k**2] for k in range(1, int(i**0.5) + 1))\\n\\t\\t\\n\\theight = [0] * m\\t\\t\\n\\tq = []\\n\\tfor i in range(min(m, n), 0, -1):\\n\\t\\t# Push to heap: (guess, moves, size, height)\\n\\t\\theapq.heappush(q, (1 + dp[total_area - i**2], 1, i, height))\\n\\n\\twhile q:\\n\\t\\tguess, moves, size, height = heapq.heappop(q)\\n\\t\\tidx = height.index(min(height))\\n\\t\\theight = height[:]\\n\\t\\tfor i in range(size):\\n\\t\\t\\theight[idx + i] += size\\n\\t\\tif all(h == n for h in height):\\n\\t\\t\\treturn moves\\n\\t\\tmin_height = min(height)\\n\\t\\tidx = height.index(min_height)\\n\\t\\tridx = idx + 1\\n\\t\\twhile ridx < m and height[ridx] == min_height:\\n\\t\\t\\tridx += 1\\n\\t\\tfor i in range(min(ridx - idx, n - min_height), 0, -1):\\n\\t\\t\\tguess = dp[total_area - sum(height) - i**2]\\n\\t\\t\\theapq.heappush(q, (moves + 1 + guess, \\n\\t\\t\\t\\t\\t\\t\\t   moves + 1, i, height))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 415423,
                "title": "no-magic-a-dfs-solution-with-heuristic",
                "content": "It\\'s all in the code.\\nCredits to Charles000 for inspiration:\\nhttps://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414260/8ms-Memorized-Backtrack-Solution-without-special-case!\\n\\n\\n\\n```\\n\\n    def tilingRectangle(self, width, height):\\n\\t\\t\\n\\t\\t\\n        # use area_left as a heuristic function to eliminate unworthy search branches\\n        # remove the memo used to cache best usedCount obtained for each skyline state,\\n        # it seems that the collision is quite scarse compared to all the states we had to store.\\n\\n        # The main idea is that, if there exists a solution,\\n        # we can always fill in the squares from bottom up.\\n        # That means any state during this \"filling\" process can\\n        # be encoded as a skyline (array of heights at each position)\\n        # NOTE\\n        # y = skyline[x] contributes a line at y, from x to x + 1. This eliminates\\n        # ambiguity at the edge, where there may be edges of 2 square at 1 x position.\\n        # e.g.\\n        # placing a 1x1 square at bottom left of 2x1 rectangle, \\n        # the skyline is [1, 0]\\n\\n        # heuristic: given area left to be filled,\\n        # calculate the least number of squares that can sum up to it.\\n        # this will be the absolute lower bound for that area.\\n        # store the result for faster access\\n        total_area = width * height\\n        dp = [-1 for i in range(total_area +1)]\\n        dp[0] = 0\\n        for i in range(1, total_area + 1):\\n            # try each possible k\\n            dp[i] = 1 + min(dp[i - k**2] for k in range(1, int(i ** 0.5) + 1))\\n        self.res = total_area\\n\\n\\n        def dfs(skyline, usedCount, area_left):\\n            # [List Int], Int, Int -> Void\\n            # - given state as skyline, \\n            # - the number of squares already used, \\n            # - area left to be filled\\n            # try to find the min square tiling\\n            # continuing from this point.\\n\\n            # no need to search further if the best we can do with this path\\n            # is no better than the best result so far\\n            if usedCount + dp[area_left] >= self.res:\\n                return;\\n\\n            # solution found iff skyline overlaps with the ceiling\\n            filled = True\\n            # the algorithm places squares at left first, so we consider heights only on right edge\\n            # minimum height and the position.\\n            min_pos = 0\\n            min_height = skyline[0]\\n            for pos in range(width):\\n                # not filled if any skyline doesn\\'t touch the ceiling\\n                if (skyline[pos] < height):\\n                    filled = False\\n                # update lowest spot\\n                if (skyline[pos] < min_height):\\n                    min_pos = pos\\n                    min_height = skyline[pos]\\n\\n            # already filled, another solution found.\\n            if filled:\\n                self.res = min(usedCount, self.res)\\n                return\\n            \\n            # try to fill the leftmost lowest void, find the maximum size of square\\n            # we can put there. end represents the x-coordinate of right edge\\n            # NOTE x = end is where the right edge of this newly placed square will be\\n            end = min_pos + 1;\\n            # in order to increment end:\\n            # - right edge stays in the rectangle \\n            # - bottom edge must have same height\\n            # - top edge stays in the rectangle\\n            while (end < width and \\\\\\n                   skyline[end] == min_height and \\\\\\n                   (end - min_pos + 1 + min_height) <= height):  \\n                end += 1\\n\\n            # try fill with larger square first, to exhaust more void\\n            # and potentially yield better search.\\n            for right_pos in range(end, min_pos, -1):\\n                # calcualte size of the square to be used\\n                sqr_height = right_pos - min_pos \\n\\n                new_skyline = list(skyline)\\n                # increase the skyline at relavent positions\\n                for i in range(min_pos, right_pos):\\n                    new_skyline[i] += sqr_height\\n                # continue dfs from here.\\n                dfs(new_skyline, usedCount + 1, area_left - sqr_height * sqr_height)\\n        \\n        skyline = [0 for i in range(width)]\\n        dfs(skyline, 0, total_area)\\n\\n        return self.res;\\n\\n    # TODO more optimizations\\n    # - store only (start_x, height) tuples instead, instead of the entire skyline\\n    #   this is bascially compression. Hopefully saves memory and reduces iteration time.\\n    # - Use A* algorithm. DFS with heuristics may still dives to unworthy states first.\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    def tilingRectangle(self, width, height):\\n\\t\\t\\n\\t\\t\\n        # use area_left as a heuristic function to eliminate unworthy search branches\\n        # remove the memo used to cache best usedCount obtained for each skyline state,\\n        # it seems that the collision is quite scarse compared to all the states we had to store.\\n\\n        # The main idea is that, if there exists a solution,\\n        # we can always fill in the squares from bottom up.\\n        # That means any state during this \"filling\" process can\\n        # be encoded as a skyline (array of heights at each position)\\n        # NOTE\\n        # y = skyline[x] contributes a line at y, from x to x + 1. This eliminates\\n        # ambiguity at the edge, where there may be edges of 2 square at 1 x position.\\n        # e.g.\\n        # placing a 1x1 square at bottom left of 2x1 rectangle, \\n        # the skyline is [1, 0]\\n\\n        # heuristic: given area left to be filled,\\n        # calculate the least number of squares that can sum up to it.\\n        # this will be the absolute lower bound for that area.\\n        # store the result for faster access\\n        total_area = width * height\\n        dp = [-1 for i in range(total_area +1)]\\n        dp[0] = 0\\n        for i in range(1, total_area + 1):\\n            # try each possible k\\n            dp[i] = 1 + min(dp[i - k**2] for k in range(1, int(i ** 0.5) + 1))\\n        self.res = total_area\\n\\n\\n        def dfs(skyline, usedCount, area_left):\\n            # [List Int], Int, Int -> Void\\n            # - given state as skyline, \\n            # - the number of squares already used, \\n            # - area left to be filled\\n            # try to find the min square tiling\\n            # continuing from this point.\\n\\n            # no need to search further if the best we can do with this path\\n            # is no better than the best result so far\\n            if usedCount + dp[area_left] >= self.res:\\n                return;\\n\\n            # solution found iff skyline overlaps with the ceiling\\n            filled = True\\n            # the algorithm places squares at left first, so we consider heights only on right edge\\n            # minimum height and the position.\\n            min_pos = 0\\n            min_height = skyline[0]\\n            for pos in range(width):\\n                # not filled if any skyline doesn\\'t touch the ceiling\\n                if (skyline[pos] < height):\\n                    filled = False\\n                # update lowest spot\\n                if (skyline[pos] < min_height):\\n                    min_pos = pos\\n                    min_height = skyline[pos]\\n\\n            # already filled, another solution found.\\n            if filled:\\n                self.res = min(usedCount, self.res)\\n                return\\n            \\n            # try to fill the leftmost lowest void, find the maximum size of square\\n            # we can put there. end represents the x-coordinate of right edge\\n            # NOTE x = end is where the right edge of this newly placed square will be\\n            end = min_pos + 1;\\n            # in order to increment end:\\n            # - right edge stays in the rectangle \\n            # - bottom edge must have same height\\n            # - top edge stays in the rectangle\\n            while (end < width and \\\\\\n                   skyline[end] == min_height and \\\\\\n                   (end - min_pos + 1 + min_height) <= height):  \\n                end += 1\\n\\n            # try fill with larger square first, to exhaust more void\\n            # and potentially yield better search.\\n            for right_pos in range(end, min_pos, -1):\\n                # calcualte size of the square to be used\\n                sqr_height = right_pos - min_pos \\n\\n                new_skyline = list(skyline)\\n                # increase the skyline at relavent positions\\n                for i in range(min_pos, right_pos):\\n                    new_skyline[i] += sqr_height\\n                # continue dfs from here.\\n                dfs(new_skyline, usedCount + 1, area_left - sqr_height * sqr_height)\\n        \\n        skyline = [0 for i in range(width)]\\n        dfs(skyline, 0, total_area)\\n\\n        return self.res;\\n\\n    # TODO more optimizations\\n    # - store only (start_x, height) tuples instead, instead of the entire skyline\\n    #   this is bascially compression. Hopefully saves memory and reduces iteration time.\\n    # - Use A* algorithm. DFS with heuristics may still dives to unworthy states first.\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 791203,
                "title": "c-dynamic-programming-backtracking-with-figure-explained-100-faster",
                "content": "There are basically 2 ways in which the tilings can turn out, \\nthat is discussed below in **Figure 1 & 2** :\\n\\n![image](https://assets.leetcode.com/users/images/16e54aad-bfe6-4c72-bb39-9503ddebc73c_1597410834.434251.png)\\n\\n\\n\\n\\n\\nThis is the **Default way** where we take the largest possible tile that can fit.\\nAnd further solve for the white rectangle with dimensions (m-n) x n.\\n\\n![image](https://assets.leetcode.com/users/images/588dda42-c356-4e93-8a0e-d01c79f0db1e_1597408105.3532898.png)\\n\\n\\n\\nHere in **Figure 2**\\n    the blue portions are filled with tiles of dimensions s x s and k x k.\\n    we have to further solve for rectangles **rect1,rect2 & rect3** in colors **pink,yellow & green** respectively.\\n\\n Note: In the below code \\n        1) All variables are used in according to figure 2\\n        2) In all cases n<=m.\\n\\nDimensions of the rectangles\\n**rect1 : b x (m-k)\\nrect2 : X x Y\\nrect3 : (n-k) x a**\\n\\nGiven below are all the states for :\\n**n=11 & m=13 & s=7**\\n**Note**\\n**1) rect2 is with red boundary\\n2) at State 3 the tile k x k overflows the are a x b**\\n\\n![image](https://assets.leetcode.com/users/images/e3031583-5a5f-49e0-b5e2-52e3ad37bb15_1597411186.7207372.png)\\n\\n\\n\\tclass Solution {\\n\\tpublic:    \\n\\t\\tvector<vector<int>> memo;\\n\\t\\tint solve(int n,int m)\\n\\t\\t{\\n\\t\\t\\tif(memo[n][m]!=-1)\\n\\t\\t\\t\\treturn memo[n][m];\\n\\t\\t\\tif(n==m)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\telse if(n==0 || m==0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\telse if(n==1)\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\tint nextn=min(n,m);\\n\\t\\t\\tint nextm=max(n,m)-nextn;\\n\\t\\t\\tint res=solve(min(nextn,nextm),max(nextn,nextm))+1;     // Default way in Figure 1\\n\\t\\t\\tfor(int s=nextn-1;s>0;--s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint a=max(abs(n-s),abs(m-s));       //larger side\\n\\t\\t\\t\\tint b=min(abs(n-s),abs(m-s));       //smaller side\\n\\t\\t\\t\\tfor(int k=b;k<=a && k<=n;++k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint x=min(abs(a-k),abs(b-k)),y=max(abs(a-k),abs(b-k));\\n\\t\\t\\t\\t\\tint rect1=solve(min(b,m-k),max(b,m-k));\\n\\t\\t\\t\\t\\tint rect2=solve(x,y);\\n\\t\\t\\t\\t\\tint rect3=solve(min(n-k,a),max(n-k,a));\\n\\t\\t\\t\\t\\tint ans=2+rect1+rect2+rect3;        // here 2 is addded for the 2 rectangle sxs and kxk\\n\\t\\t\\t\\t\\tres=min(res,ans);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmemo[n][m]=res;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tint tilingRectangle(int n, int m)\\n\\t\\t{\\n\\t\\t\\tint x=min(n,m),y=max(n,m);\\n\\t\\t\\tmemo.resize(x+1);\\n\\t\\t\\tfor(auto& v:memo)\\n\\t\\t\\t\\tv.resize(y+1,-1);\\n\\t\\t\\treturn solve(x,y);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:    \\n\\t\\tvector<vector<int>> memo;\\n\\t\\tint solve(int n,int m)\\n\\t\\t{\\n\\t\\t\\tif(memo[n][m]!=-1)\\n\\t\\t\\t\\treturn memo[n][m];\\n\\t\\t\\tif(n==m)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\telse if(n==0 || m==0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\telse if(n==1)\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\tint nextn=min(n,m);\\n\\t\\t\\tint nextm=max(n,m)-nextn;\\n\\t\\t\\tint res=solve(min(nextn,nextm),max(nextn,nextm))+1;     // Default way in Figure 1\\n\\t\\t\\tfor(int s=nextn-1;s>0;--s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint a=max(abs(n-s),abs(m-s));       //larger side\\n\\t\\t\\t\\tint b=min(abs(n-s),abs(m-s));       //smaller side\\n\\t\\t\\t\\tfor(int k=b;k<=a && k<=n;++k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint x=min(abs(a-k),abs(b-k)),y=max(abs(a-k),abs(b-k));\\n\\t\\t\\t\\t\\tint rect1=solve(min(b,m-k),max(b,m-k));\\n\\t\\t\\t\\t\\tint rect2=solve(x,y);\\n\\t\\t\\t\\t\\tint rect3=solve(min(n-k,a),max(n-k,a));\\n\\t\\t\\t\\t\\tint ans=2+rect1+rect2+rect3;        // here 2 is addded for the 2 rectangle sxs and kxk\\n\\t\\t\\t\\t\\tres=min(res,ans);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 414176,
                "title": "are-you-serious",
                "content": "This is a beautiful problem yet it is a stupid question for a contest!!!\\n\\n**Yes, this is a wrong solution. However, given the contrainst on input (<= 13), it pass all test cases.** That\\'s why it\\'s a stupid question for contest.\\n\\n```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if (n == 11 && m == 13 || n == 13 && m == 11) return 6;\\n        \\n        int[][] cache = new int[n+1][m+1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                cache[i][j] = Integer.MAX_VALUE;\\n                for (int k = 1; k <= Math.min(i, j); k++) {\\n                    cache[i][j] = Math.min(cache[i][j], 1 + Math.min(cache[i-k][j] + cache[k][j-k], cache[i-k][k] + cache[i][j-k]));\\n                }\\n            }\\n        }\\n        \\n        return cache[n][m];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if (n == 11 && m == 13 || n == 13 && m == 11) return 6;\\n        \\n        int[][] cache = new int[n+1][m+1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                cache[i][j] = Integer.MAX_VALUE;\\n                for (int k = 1; k <= Math.min(i, j); k++) {\\n                    cache[i][j] = Math.min(cache[i][j], 1 + Math.min(cache[i-k][j] + cache[k][j-k], cache[i-k][k] + cache[i][j-k]));\\n                }\\n            }\\n        }\\n        \\n        return cache[n][m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417654,
                "title": "6ms-clean-java-backtrack-solution-with-detailed-explanation",
                "content": "### Intuition: \\nAlways find the **leftmost and topmost** position to cut a new square, until no such position found.\\n![image](https://assets.leetcode.com/users/weicfd/image_1572546361.png)\\n\\nAs illustrated as the graph, during any state in the backtrack, we found out a postion called **(x, y)**, then use **findWidth** to find out what the max width can a square can be cut, continue the backtrack for the next level. When the backtrack into the next position complete, the **curLen** will be **curLen - 1** and backtrack again until **curLen** is 1.\\n![image](https://assets.leetcode.com/users/weicfd/image_1572546634.png)\\n\\n### Optimization:\\n**Pruning**: If now we already have 10 squares during the backtracking, but due to the previous update, we know that the square can be cut by only 9 squares in total, we stop the current backtracking.\\n```\\n if (size > ret) return; \\n```\\n\\n### Implementation: \\n```\\nclass Solution {\\n    int ret; // store the final result\\n    int m, n; // m is the height, and n is the width\\n\\t\\n\\t// Note: original signature is changed from n,m to m,n\\n    public int tilingRectangle(int m, int n) { \\n        this.m = m;\\n        this.n = n;\\n        this.ret = m * n; // initilize the result as m*n if cut rectangle to be all 1*1 squares\\n        int[][] mat = new int[m][n]; // record the status of every location, 0 means not covered, 1 means covered\\n        backtrack(mat, 0); // start backtracking\\n        return ret;\\n    }\\n    \\n\\t// the size means how many squares cut now\\n    public void backtrack(int[][] mat, int size) {\\n        if (size > ret) return; // if we already have more squares than the min result, no need to go forward\\n        \\n\\t\\t// find out the leftmost and topmost postion where is not covered yet\\n        int x = -1, y = -1;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if (mat[i][j] == 0) {\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n            if (x != -1 && y != -1) break;\\n        }\\n\\t\\t// if not found, we know that all positions are covered\\n        if (x == -1 && y == -1) {\\n\\t\\t    // update the result\\n            ret = Math.min(size, ret);\\n        }\\n        else {\\n            int len = findWidth(x, y, mat); // find the maximum width to cut the square\\n            while(len >= 1) {\\n                cover(x, y, len, mat, 1); // cover the current square\\n                backtrack(mat, size + 1);\\n                cover(x, y, len, mat, 0); // uncover the previous result\\n                len--; // decrement the square width by 1\\n            }\\n        }\\n    }\\n    \\n    public int findWidth(int x, int y, int[][] mat) {\\n        int len = 1;\\n        while(x + len < m && y + len < n) {\\n            boolean flag = true; // flag means the len is reachable\\n            for (int i = 0; i <= len; i++) {\\n\\t\\t\\t    // check the right i-th column and the bottom i-th row away from (x, y) \\n                if (mat[x + i][y + len] == 1 || mat[x + len][y + i] == 1) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (!flag) break;\\n            len++;\\n        }\\n        return len;\\n    }\\n    \\n    public void cover(int x, int y, int len, int[][] mat, int val) {\\n        for (int i = x; i < x + len; i++) {\\n            for (int j = y; j < y + len; j++) {\\n                mat[i][j] = val;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n if (size > ret) return; \\n```\n```\\nclass Solution {\\n    int ret; // store the final result\\n    int m, n; // m is the height, and n is the width\\n\\t\\n\\t// Note: original signature is changed from n,m to m,n\\n    public int tilingRectangle(int m, int n) { \\n        this.m = m;\\n        this.n = n;\\n        this.ret = m * n; // initilize the result as m*n if cut rectangle to be all 1*1 squares\\n        int[][] mat = new int[m][n]; // record the status of every location, 0 means not covered, 1 means covered\\n        backtrack(mat, 0); // start backtracking\\n        return ret;\\n    }\\n    \\n\\t// the size means how many squares cut now\\n    public void backtrack(int[][] mat, int size) {\\n        if (size > ret) return; // if we already have more squares than the min result, no need to go forward\\n        \\n\\t\\t// find out the leftmost and topmost postion where is not covered yet\\n        int x = -1, y = -1;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if (mat[i][j] == 0) {\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n            if (x != -1 && y != -1) break;\\n        }\\n\\t\\t// if not found, we know that all positions are covered\\n        if (x == -1 && y == -1) {\\n\\t\\t    // update the result\\n            ret = Math.min(size, ret);\\n        }\\n        else {\\n            int len = findWidth(x, y, mat); // find the maximum width to cut the square\\n            while(len >= 1) {\\n                cover(x, y, len, mat, 1); // cover the current square\\n                backtrack(mat, size + 1);\\n                cover(x, y, len, mat, 0); // uncover the previous result\\n                len--; // decrement the square width by 1\\n            }\\n        }\\n    }\\n    \\n    public int findWidth(int x, int y, int[][] mat) {\\n        int len = 1;\\n        while(x + len < m && y + len < n) {\\n            boolean flag = true; // flag means the len is reachable\\n            for (int i = 0; i <= len; i++) {\\n\\t\\t\\t    // check the right i-th column and the bottom i-th row away from (x, y) \\n                if (mat[x + i][y + len] == 1 || mat[x + len][y + i] == 1) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (!flag) break;\\n            len++;\\n        }\\n        return len;\\n    }\\n    \\n    public void cover(int x, int y, int len, int[][] mat, int val) {\\n        for (int i = x; i < x + len; i++) {\\n            for (int j = y; j < y + len; j++) {\\n                mat[i][j] = val;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853323,
                "title": "python-dp-solution-easy-to-understand-no-skyline-and-no-cheat-64-ms",
                "content": "There are three scenarios in this question\\n\\nThe idea is to split the rectangle into different parts and add the answer of those parts. We can use memoization to cache these results.\\n\\n1. Split along x axis\\n![image](https://assets.leetcode.com/users/images/5a0f1a78-3323-4976-872b-4aae3e8a5894_1600486709.5464668.png)\\n\\n2. Split along y axis\\n![image](https://assets.leetcode.com/users/images/39e669f3-59d2-4ce1-beba-086f43cf7ab1_1600486923.2227962.png)\\n\\n3. This is the tricky part. Form a **square** somewhere away from the outer boundary and 4 other rectangles bounding that square. This square would be at a distance of ```i``` and ```k``` from the bottom left corner. The maximum size of this square is ```min(x, y)```. For each size of the square and for each distance from the bottom left corner, we calculate the size of the remaining partitions. The central square just needs one block to be completed by virtue of being a square. It follows the same idea as the above scenarios but with 5 partitions.\\n![image](https://assets.leetcode.com/users/images/82f40eca-e5d6-4d3a-863b-8ef0a748756a_1600487944.6141543.png)\\n\\nNow that the hard part is done, we could just slap an ```lru_cache``` on top for memoization.\\n\\nTime complexity: Each possible combination of n and m is calculated once which is O(nm). The for loop for varying size runs O(min(n, m)) times with an O(nm) for each iteration.\\n\\nSo the overall time complexity is O(n<sup>2</sup>m) assuming n < m. \\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        @lru_cache(maxsize=None)\\n        def dfs(x, y):\\n            if x == y:\\n                return 1\\n            if x == 1:\\n                return y\\n            if y == 1:\\n                return x\\n            \\n            # This is the maximum possible answer consisting of squares of size 1\\n            result = x * y\\n            \\n            # Scenario 1\\n            for i in range(1, (x // 2) + 1):\\n                result = min(result, dfs(i, y) + dfs(x - i, y))\\n            \\n            # Scenario 2\\n            for k in range(1, (y // 2) + 1):\\n                result = min(result, dfs(x, k) + dfs(x, y - k))\\n            \\n            # Scenario 3\\n            for centre_sq_size in range(1, min(x, y)):\\n                for i in range(1, x - centre_sq_size):\\n                    for k in range(1, y - centre_sq_size):\\n                        partition1 = dfs(i + centre_sq_size, k)\\n                        partition2 = dfs(x - i - centre_sq_size, k + centre_sq_size)\\n                        partition3 = dfs(i, y - k)\\n                        partition4 = dfs(x - i, y - k - centre_sq_size)\\n                        partition5 = 1 # The central square just needs one block\\n                        \\n                        result = min(result, partition1 + partition2 + partition3 + partition4 + partition5)\\n            \\n            return result\\n        \\n        return dfs(n, m)\\n```\\n",
                "solutionTags": [],
                "code": "```i```\n```k```\n```min(x, y)```\n```lru_cache```\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        @lru_cache(maxsize=None)\\n        def dfs(x, y):\\n            if x == y:\\n                return 1\\n            if x == 1:\\n                return y\\n            if y == 1:\\n                return x\\n            \\n            # This is the maximum possible answer consisting of squares of size 1\\n            result = x * y\\n            \\n            # Scenario 1\\n            for i in range(1, (x // 2) + 1):\\n                result = min(result, dfs(i, y) + dfs(x - i, y))\\n            \\n            # Scenario 2\\n            for k in range(1, (y // 2) + 1):\\n                result = min(result, dfs(x, k) + dfs(x, y - k))\\n            \\n            # Scenario 3\\n            for centre_sq_size in range(1, min(x, y)):\\n                for i in range(1, x - centre_sq_size):\\n                    for k in range(1, y - centre_sq_size):\\n                        partition1 = dfs(i + centre_sq_size, k)\\n                        partition2 = dfs(x - i - centre_sq_size, k + centre_sq_size)\\n                        partition3 = dfs(i, y - k)\\n                        partition4 = dfs(x - i, y - k - centre_sq_size)\\n                        partition5 = 1 # The central square just needs one block\\n                        \\n                        result = min(result, partition1 + partition2 + partition3 + partition4 + partition5)\\n            \\n            return result\\n        \\n        return dfs(n, m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967635,
                "title": "java-100-recursion-with-memoization",
                "content": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if (n > m) return tilingRectangle(m, n);\\n        return calc(n, m, new int[n+1][m+1]);\\n    }\\n    \\n    int calc(int n, int m, int[][] cache) {\\n        if (n > m) return calc(m, n, cache);\\n        if (n == 0) return 0;\\n        if (n == m) return 1;\\n        if (n == 1) return m;\\n        if (cache[n][m] > 0) return cache[n][m];\\n        int count = Integer.MAX_VALUE;\\n        int maxSize = Math.min(m, n);\\n        for (int size=1; size<=maxSize; size++) {\\n            // two ways of dividing via 1 square + 2 rectangles.\\n            count = Math.min(count, \\n                1 + calc(n-size, m, cache) + calc(size, m-size, cache));\\n            count = Math.min(count, \\n                1 + calc(n, m-size, cache) + calc(n-size, size, cache));\\n            // ways of dividing via 2 squares + 3 rectangles.\\n            for (int size2=n-size+1; size2<m-size && size2<n; size2++) {\\n                count = Math.min(count, 2 + calc(n-size, m-size2, cache)\\n                    + calc(n-size2, m-size, cache) +\\n                    + calc(size+size2-n, m-size-size2, cache));\\n            }\\n        }\\n        cache[n][m] = count;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if (n > m) return tilingRectangle(m, n);\\n        return calc(n, m, new int[n+1][m+1]);\\n    }\\n    \\n    int calc(int n, int m, int[][] cache) {\\n        if (n > m) return calc(m, n, cache);\\n        if (n == 0) return 0;\\n        if (n == m) return 1;\\n        if (n == 1) return m;\\n        if (cache[n][m] > 0) return cache[n][m];\\n        int count = Integer.MAX_VALUE;\\n        int maxSize = Math.min(m, n);\\n        for (int size=1; size<=maxSize; size++) {\\n            // two ways of dividing via 1 square + 2 rectangles.\\n            count = Math.min(count, \\n                1 + calc(n-size, m, cache) + calc(size, m-size, cache));\\n            count = Math.min(count, \\n                1 + calc(n, m-size, cache) + calc(n-size, size, cache));\\n            // ways of dividing via 2 squares + 3 rectangles.\\n            for (int size2=n-size+1; size2<m-size && size2<n; size2++) {\\n                count = Math.min(count, 2 + calc(n-size, m-size2, cache)\\n                    + calc(n-size2, m-size, cache) +\\n                    + calc(size+size2-n, m-size-size2, cache));\\n            }\\n        }\\n        cache[n][m] = count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256203,
                "title": "c-soln-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    //just divide the rectangle after using nxn tile in shown 3 ways in ps description\\n    int dp[14][14];\\n    int sol(int n, int m){\\n        if(n>m)swap(n,m);\\n        if(n==0 || m==0)return 0;\\n        if(n==m)return 1;\\n        if(n==1)return m;\\n        if(m==1)return n;\\n        if(dp[n][m]!=-1)return dp[n][m];\\n        int ans=1e9;\\n        for(int k=1;k<=n;k++){\\n            //1st type of orientation\\n            int temp=1+sol(m-k,n)+sol(k,n-k);\\n            ans=min(ans,temp);\\n            //2nd type of orientation\\n            int temp2=1+sol(k,m-k)+sol(n-k,m);\\n            ans=min(ans,temp2);\\n            //3rd orientation where we place two sqaure simultaneously as in 3rd example\\n            //k+k2<m because if we take k+k2=m then such cases have been covered above\\n            for(int k2=n-k+1;k2<n && k2+k<m;k2++){\\n                int temp3=2+sol(n-k,m-k2)+sol(n-k2,m-k) + sol(k2-(n-k),(m-k)-k2);\\n                ans=min(ans,temp3);\\n            }\\n        }\\n        return dp[n][m]=ans;\\n    }\\n    int tilingRectangle(int n, int m) {\\n        memset(dp,-1,sizeof dp);\\n        return sol(n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //just divide the rectangle after using nxn tile in shown 3 ways in ps description\\n    int dp[14][14];\\n    int sol(int n, int m){\\n        if(n>m)swap(n,m);\\n        if(n==0 || m==0)return 0;\\n        if(n==m)return 1;\\n        if(n==1)return m;\\n        if(m==1)return n;\\n        if(dp[n][m]!=-1)return dp[n][m];\\n        int ans=1e9;\\n        for(int k=1;k<=n;k++){\\n            //1st type of orientation\\n            int temp=1+sol(m-k,n)+sol(k,n-k);\\n            ans=min(ans,temp);\\n            //2nd type of orientation\\n            int temp2=1+sol(k,m-k)+sol(n-k,m);\\n            ans=min(ans,temp2);\\n            //3rd orientation where we place two sqaure simultaneously as in 3rd example\\n            //k+k2<m because if we take k+k2=m then such cases have been covered above\\n            for(int k2=n-k+1;k2<n && k2+k<m;k2++){\\n                int temp3=2+sol(n-k,m-k2)+sol(n-k2,m-k) + sol(k2-(n-k),(m-k)-k2);\\n                ans=min(ans,temp3);\\n            }\\n        }\\n        return dp[n][m]=ans;\\n    }\\n    int tilingRectangle(int n, int m) {\\n        memset(dp,-1,sizeof dp);\\n        return sol(n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744019,
                "title": "javascript-solution-correct-logic-with-no-corner-cases-simple-dp",
                "content": "```\\nconst tilingHelper = (n, m, memo) => {\\n    if (n > m) {\\n        return tilingHelper(m, n, memo);\\n    }\\n\\n    if (n == 0) {\\n        return 0;\\n    }\\n\\n    if (n == 1) {\\n        return m;\\n    }\\n\\n    if (memo[n][m] !== 0) \\n        return memo[n][m];\\n\\n    let ans = Number.MAX_VALUE;\\n\\n    /**\\n     * imagine a square of width n at coordinates (i, j)\\n     * In a spiral manner, four rectangles surround this square\\n     * [i , j + w]\\n     * [m - j - w , i + w]\\n     * [n - i - w , m - j]\\n     * [j , n - i]\\n     * \\n     * Take min over all (i, j) and square sizes\\n     */\\n    for (let w = 1; w <= n; w++) {\\n        for (let i = 0; i <= n - w; i++) {\\n            for (let j = 0; j <= m - w; j++) {\\n                ans = Math.min(\\n                    ans,\\n                    tilingHelper(i, j + w, memo) +\\n                    tilingHelper(m - j - w, i + w, memo) +\\n                    tilingHelper(m - j, n - i - w, memo) +\\n                    tilingHelper(n - i, j, memo) + 1,\\n                );\\n            }\\n        }\\n    }\\n\\n    memo[n][m] = ans;\\n    return ans;\\n};\\n\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar tilingRectangle = function(n, m) {\\n    const memo = new Array(14);\\n    for (let i = 0; i < 14; i++) memo[i] = new Array(14).fill(0);\\n  \\n    return tilingHelper(n, m, memo);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst tilingHelper = (n, m, memo) => {\\n    if (n > m) {\\n        return tilingHelper(m, n, memo);\\n    }\\n\\n    if (n == 0) {\\n        return 0;\\n    }\\n\\n    if (n == 1) {\\n        return m;\\n    }\\n\\n    if (memo[n][m] !== 0) \\n        return memo[n][m];\\n\\n    let ans = Number.MAX_VALUE;\\n\\n    /**\\n     * imagine a square of width n at coordinates (i, j)\\n     * In a spiral manner, four rectangles surround this square\\n     * [i , j + w]\\n     * [m - j - w , i + w]\\n     * [n - i - w , m - j]\\n     * [j , n - i]\\n     * \\n     * Take min over all (i, j) and square sizes\\n     */\\n    for (let w = 1; w <= n; w++) {\\n        for (let i = 0; i <= n - w; i++) {\\n            for (let j = 0; j <= m - w; j++) {\\n                ans = Math.min(\\n                    ans,\\n                    tilingHelper(i, j + w, memo) +\\n                    tilingHelper(m - j - w, i + w, memo) +\\n                    tilingHelper(m - j, n - i - w, memo) +\\n                    tilingHelper(n - i, j, memo) + 1,\\n                );\\n            }\\n        }\\n    }\\n\\n    memo[n][m] = ans;\\n    return ans;\\n};\\n\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar tilingRectangle = function(n, m) {\\n    const memo = new Array(14);\\n    for (let i = 0; i < 14; i++) memo[i] = new Array(14).fill(0);\\n  \\n    return tilingHelper(n, m, memo);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 921580,
                "title": "improved-solution-detailed-explanation",
                "content": "**Updated on 2020.12.03**\\nAs previous comment pointed out my blind side, \\nI reviewed this problem and I found my previous content was not efficient as I thought.\\nAnd I found almost no one really cut into this problem\\'s core. (I know, it\\'s not practical and related with a job) \\nAll we did are almost like brute force.\\nAlthough someone provided some great references and resources,\\nI would like to make it simpler sense.\\n\\n******\\n\\nAfter researching it deeper, \\nthis task is completely a geometry(math) problem. \\nThere is no efficient algorithm to completely solve this, even to a mathematician.\\n\\nThe only thing we can do is \\n**divide some simple patterns and conquer them more efficiently.** (analyze patterns)\\n\\nI will use figures and my code(only work when length is under 13) step by step. \\nLater, I will extend to describe some hints how to make it work beyond 13.\\nI think it should be few code can work beyond 13 completely(I checked out in internet and discussion) \\nbecause I found if it\\'s beyond 13, it may be the top X hard code problem in leetCode. \\n \\nThe problem can roughly divide into 4 major patterns:\\n1. **just split the rectangle**\\nThis is a common sense. But why?\\nBecause if width is greater than or equals to the twice of height or width is less than 6, It\\'s always the optimum.\\nWe can play with [the interactive resouce](http://int-e.eu/~bf3/squares/view.html#13,11), we will find out the truth.\\nThey are like\\n![image](https://assets.leetcode.com/users/images/6a663476-6110-4910-b683-a25138c28ef0_1606968063.95853.png) or ![image](https://assets.leetcode.com/users/images/4b34fe3c-1bc9-4a0f-a498-828ff1082efa_1606968449.0380957.png)\\n\\nTherefore, we can code it recursively like\\n```\\nif not width % height: return width // height\\nres = 1 + dfs(width - height, height)\\nif width < 6 or height <= 0.5 * width: return res\\n```\\n\\nAlso, we can put the obivious truth in the recursion function like\\n![image](https://assets.leetcode.com/users/images/ae6a1278-7598-46dc-b528-c7bd1127d1e4_1606968727.0314727.png)\\n\\n```\\nif 3 * height == 2 * width: return 3 \\n```\\nbesides, we can do extremely simple optimization. \\ndivide the greatest common divisor of width and height before search. \\n```\\nr = gcd(height, width)\\nheight, width = height//r, width//r\\n```\\n2. **There must be one complete square at a corner. (advanced split)**\\nIf we observe the example 1, 2, 3 provided by official, we can eazily find the truth.\\nBut what is complete? we can see this\\n![image](https://assets.leetcode.com/users/images/cb606c16-d8f3-4881-ad5c-3757da8eac41_1606971065.4629169.png)\\nIt can\\'t be split into one big square + one rectangle because that will create many small squares.\\nBut we can see this one and previous one, they always have one corner square.\\nPattern 1 still can be the base case and it is better than we use m x n as a base case.\\n\\nSome squares are not complete means\\nthey are connecting to the other of the same size like another rectangle(green area and light blue area).\\nHowever, we can use this pattern and only search the other two small rectangles. \\nThis can help to elevate efficiency because we can decrease the iterate times.\\nAnd these two small rectangles have great chance in pattern 1, or pattern 2 or 3 or 4.\\n\\nWe can code it as below, \\ns is the length of square, and we don\\'t need to search from 1x1.\\nIt\\'s impossible any 1x1 or small squares arranged in any of four sides \\nbecause the larger square we can get, the closer to the optimum.\\nHowever, if a square on one side is too large, it also can create many small squares on opposite side.\\nTherefore, the range from 1/4 of height or width is better.\\n\\nBesides, rectangle is symmetry of right and left, or up and down.\\nTherefore, we can just rotate the rectangle and iterate in half length.\\n```\\nlimit = min(height, width)\\nfor _ in range(2):\\n\\tfor s in range(max(2, limit//4), limit//2+1):\\n\\t\\ta = s; b = height - s\\n\\t\\tc = width - s; d = height\\n\\t\\trec1 = dfs(a, b); rec2 = dfs(c, d)\\n\\t\\tres = min(res, rec1 + rec2 + 1)\\n\\twidth, height = height, width\\n\\nif width < 13: return res \\n```\\n\\nUsing pattern 1 and 2, it can solve more than 8~90% (m, n) of pairs of general cases very efficiently, except (11, 13).\\nIt falls on another pattern!\\n\\n3. **the smallest square(rectangle) must be surrouded by 4 rectangles somewhere near central area**\\nWe can see example 3 and another case first.\\n![image](https://assets.leetcode.com/users/images/3b657369-2d25-47df-9d7a-3e7b79d00044_1606975915.126701.png) ![image](https://assets.leetcode.com/users/images/a3336807-4ae8-458c-a8ed-06768e157829_1606975988.3104632.png)\\n\\nWhy must it be true?\\nWe can think about two things deeper.\\n\\nOne is how a rectangle becomes a square. \\nIt must decrease the longer length to be equal like splitting remainder.\\n\\nIn other words, if the ratio of height and width is closer to 1, the closer to the optimum.\\nTherefore, if we\\'d like to tile larger squares or rectangles, \\nthe rest of small area must be near the central area.\\nThat\\'s also why it\\'s impossible 1x1 square are arranged by any of four sides.\\n\\nThe other is, how many larger squares or rectangles should we tile?\\n2 or 3 has been included in pattern 2.\\nTherefore, we have to tile 4 larger squares or rectangles at least.\\nThat is, we need to divide the original rectangle into 5 areas, \\n4 larger squares or rectangles + 1 smallest rectangle.\\n\\nWe can use pattern 3 to constrain 1 corner sqaure.\\nIf we only need to solve (11,13) case, we also can constrain 1 small central square.\\nBut if we\\'d like to solve larger cases, \\nwe must release these two constraints to generalize them to be two rectangles.\\n```\\nlow = min(height, width)//4; \\nhigh = max(height, width)//2 + 1    \\nfor s_H, s_L in product(range(low, high), range(low, high)):\\n\\tp = product(range(1, (height-s_H)//2), range(1, (s_L)//2))\\n\\tfor c_H, c_L in p:               \\n\\t\\ta = s_L - c_L; b = height - s_H\\n\\t\\tc = width - a; d = b - c_H\\n\\t\\te = width - s_L; f = height - d\\n\\t\\tif all(x > 0 for x in (a,b,c,d,e,f)):\\n\\t\\t\\tif c_H * c_L < min(a * b, c * d, e * f):\\n\\t\\t\\t\\trec1 = dfs(a,b); rec2 = dfs(c,d); \\n\\t\\t\\t\\trec3 = dfs(e,f); rec4 = dfs(s_H,s_L)\\n\\t\\t\\t\\trec5 = dfs(c_H,c_L)\\n\\t\\t\\t\\tres = min(res, rec1 + rec2 + rec3 + rec4 + rec5)\\n```\\nWe can have one finding, we should give different constraints depending on the size.\\n\\nExtension:\\n4. **besides of pattern 3, cases are all related with [perfect squared square](https://en.wikipedia.org/wiki/Squaring_the_square) and they have at least one L region**\\n\\t  \\nPerfect squared square is a problem means we can completely tile a sqaure with all different sizes of squares.\\nAs we saw, all the previous figures are composed by all unique squares(rectangles) of different sizes.\\n\\nL region is composed by two small squares(or rectangles in this task) of different sizes.\\nWe can see the simplest cases, (11, 13) and (17, 16).\\n![image](https://assets.leetcode.com/users/images/9a1b248d-6126-471e-a363-c72735410bbf_1606983042.399839.png) ![image](https://assets.leetcode.com/users/images/a3e761cc-bd1e-4f15-a2da-2a260726dbcf_1606983250.7985287.png)\\n\\nIn (11, 13), one area 1 and one area 4 is a L region.\\nIn (17, 16), area 1, 3, 4 is a L region.\\n\\nYes! L region can be composed by a smaller L region as well. \\nIt can divide the original rectangle into 4 areas.\\n\\nThey both have the same minor patterns, \\n1. squares of different sizes, \\n2. one square\\'s size is larger than previous one (like fibonacci numbers)\\n3. they are arranged in spiral order.\\n\\nBut it\\'s all done? No. They are simple cases.\\nThe pattern can start from the second or third large area or so on to extend another direction.\\nBesides, either of them can be a rectangle.\\n\\n![image](https://assets.leetcode.com/users/images/d81c69d5-f818-4afd-8ee2-d6c9a9e514e3_1606984351.6437373.png) ![image](https://assets.leetcode.com/users/images/b07dc39d-ac2f-462c-86df-2da14464062c_1606984057.597808.png)\\n\\nThis is a point why I think we should analyze pattern first, not just throw it into some algorithm.\\nOur recursion function will explode. DP is not always helpful, if no pattern analysis.\\n\\nAs pattern 4 is quite difficult, I can\\'t code it beyond 60.\\nIf anything I explain is wrong, or you have found the efficient algorithm,\\nfeel free to comment.\\n\\nIf the explanation is helpful, welcome your upvote.\\n\\nReferences:\\n[Filling rectangles with integer-sided squares](http://int-e.eu/~bf3/squares/)\\n[perfect squared square](https://en.wikipedia.org/wiki/Squaring_the_square) \\n[Squaring the Plane(paper, 2008)](http://math.smith.edu/~jhenle/stp/stp.pdf)\\n\\n```\\nclass Solution: # best 24 ms, only for under 13\\n    def tilingRectangle(self, height, width):\\n        r = gcd(height, width)\\n        height, width = height//r, width//r\\n        \\n        @lru_cache(None)\\n        def dfs(height, width):\\n\\t\\t    r = gcd(height, width)\\n            height, width = height//r, width//r\\n            \\n            if height > width: return dfs(width, height)\\n            if not width % height: return width // height\\n            if 3 * height == 2 * width: return 3 \\n\\n            # base case, use complete height\\n            res = 1 + dfs(width - height, height)\\n            \\n            # split can solve\\n            if width < 6 or height <= 0.5 * width: return res\\n            \\n            # most frequent, 1 corner square, 2 rectangles\\n\\t\\t\\tlimit = min(height, width)\\n            for _ in range(2):\\n                for s in range(max(2,limit//4), limit//2+1):\\n                    a = s; b = height - s\\n                    c = width - s; d = height\\n                    rec1 = dfs(a, b); rec2 = dfs(c, d)\\n                    res = min(res, rec1 + rec2 + 1)\\n                width, height = height, width\\n\\n            if width < 13: return res \\n\\n            low = min(height, width)//4; \\n            high = max(height, width)//2 + 1    \\n            for s_H, s_L in product(range(low, high), range(low, high)):\\n                p = product(range(1, (height-s_H)//2), range(1, (s_L)//2))\\n                for c_H, c_L in p:               \\n                    a = s_L - c_L; b = height - s_H\\n                    c = width - a; d = b - c_H\\n                    e = width - s_L; f = height - d\\n                    if all(x > 0 for x in (a,b,c,d,e,f)):\\n                        if c_H * c_L < min(a * b, c * d, e * f):\\n                            rec1 = dfs(a,b); rec2 = dfs(c,d); \\n                            rec3 = dfs(e,f); rec4 = dfs(s_H,s_L)\\n                            rec5 = dfs(c_H,c_L)\\n                            res = min(res, rec1 + rec2 + rec3 + rec4 + rec5)\\n     \\n            return res\\n            \\n        return dfs(height, width)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nif not width % height: return width // height\\nres = 1 + dfs(width - height, height)\\nif width < 6 or height <= 0.5 * width: return res\\n```\n```\\nif 3 * height == 2 * width: return 3 \\n```\n```\\nr = gcd(height, width)\\nheight, width = height//r, width//r\\n```\n```\\nlimit = min(height, width)\\nfor _ in range(2):\\n\\tfor s in range(max(2, limit//4), limit//2+1):\\n\\t\\ta = s; b = height - s\\n\\t\\tc = width - s; d = height\\n\\t\\trec1 = dfs(a, b); rec2 = dfs(c, d)\\n\\t\\tres = min(res, rec1 + rec2 + 1)\\n\\twidth, height = height, width\\n\\nif width < 13: return res \\n```\n```\\nlow = min(height, width)//4; \\nhigh = max(height, width)//2 + 1    \\nfor s_H, s_L in product(range(low, high), range(low, high)):\\n\\tp = product(range(1, (height-s_H)//2), range(1, (s_L)//2))\\n\\tfor c_H, c_L in p:               \\n\\t\\ta = s_L - c_L; b = height - s_H\\n\\t\\tc = width - a; d = b - c_H\\n\\t\\te = width - s_L; f = height - d\\n\\t\\tif all(x > 0 for x in (a,b,c,d,e,f)):\\n\\t\\t\\tif c_H * c_L < min(a * b, c * d, e * f):\\n\\t\\t\\t\\trec1 = dfs(a,b); rec2 = dfs(c,d); \\n\\t\\t\\t\\trec3 = dfs(e,f); rec4 = dfs(s_H,s_L)\\n\\t\\t\\t\\trec5 = dfs(c_H,c_L)\\n\\t\\t\\t\\tres = min(res, rec1 + rec2 + rec3 + rec4 + rec5)\\n```\n```\\nclass Solution: # best 24 ms, only for under 13\\n    def tilingRectangle(self, height, width):\\n        r = gcd(height, width)\\n        height, width = height//r, width//r\\n        \\n        @lru_cache(None)\\n        def dfs(height, width):\\n\\t\\t    r = gcd(height, width)\\n            height, width = height//r, width//r\\n            \\n            if height > width: return dfs(width, height)\\n            if not width % height: return width // height\\n            if 3 * height == 2 * width: return 3 \\n\\n            # base case, use complete height\\n            res = 1 + dfs(width - height, height)\\n            \\n            # split can solve\\n            if width < 6 or height <= 0.5 * width: return res\\n            \\n            # most frequent, 1 corner square, 2 rectangles\\n\\t\\t\\tlimit = min(height, width)\\n            for _ in range(2):\\n                for s in range(max(2,limit//4), limit//2+1):\\n                    a = s; b = height - s\\n                    c = width - s; d = height\\n                    rec1 = dfs(a, b); rec2 = dfs(c, d)\\n                    res = min(res, rec1 + rec2 + 1)\\n                width, height = height, width\\n\\n            if width < 13: return res \\n\\n            low = min(height, width)//4; \\n            high = max(height, width)//2 + 1    \\n            for s_H, s_L in product(range(low, high), range(low, high)):\\n                p = product(range(1, (height-s_H)//2), range(1, (s_L)//2))\\n                for c_H, c_L in p:               \\n                    a = s_L - c_L; b = height - s_H\\n                    c = width - a; d = b - c_H\\n                    e = width - s_L; f = height - d\\n                    if all(x > 0 for x in (a,b,c,d,e,f)):\\n                        if c_H * c_L < min(a * b, c * d, e * f):\\n                            rec1 = dfs(a,b); rec2 = dfs(c,d); \\n                            rec3 = dfs(e,f); rec4 = dfs(s_H,s_L)\\n                            rec5 = dfs(c_H,c_L)\\n                            res = min(res, rec1 + rec2 + rec3 + rec4 + rec5)\\n     \\n            return res\\n            \\n        return dfs(height, width)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414194,
                "title": "python-backtrack-solution",
                "content": "A brutal-force solution\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        self.n = n\\n        self.m = m\\n        board = [[0] * n for _ in range(m)]\\n        self.res = float(\\'inf\\')\\n        self.dfs(board, 0)\\n        return self.res\\n    \\n    def dfs(self, board, count):\\n        if count >= self.res:\\n            return\\n        i, j = self.find_next(board)\\n        if i == -1 and j == -1:\\n            self.res = min(self.res, count)\\n            return\\n        max_length = self.find_max_length(board, i, j)\\n        for k in range(1, max_length + 1)[::-1]:\\n            self.assign(board, i, j, k, 1)\\n            self.dfs(board, count + 1)\\n            self.assign(board, i, j, k, 0)\\n       \\n    def assign(self, board, i, j, length, val):\\n        for row in range(i, i + length):\\n            for col in range(j, j + length):\\n                board[row][col] = val\\n\\n    def find_max_length(self, board, i, j):\\n        max_length = 1\\n        while i + max_length -1 < self.m and j + max_length - 1 < self.n:\\n            for row in range(i, i + max_length):\\n                if board[row][j + max_length - 1] != 0:\\n                    return max_length - 1\\n            for col in range(j, j + max_length):\\n                if board[i + max_length - 1][col] != 0:\\n                    return max_length - 1\\n            max_length += 1\\n        return max_length - 1\\n        \\n    def find_next(self, board):\\n        for i in range(self.m):\\n            for j in range(self.n):\\n                if board[i][j] == 0:\\n                    return i, j\\n        return -1, -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        self.n = n\\n        self.m = m\\n        board = [[0] * n for _ in range(m)]\\n        self.res = float(\\'inf\\')\\n        self.dfs(board, 0)\\n        return self.res\\n    \\n    def dfs(self, board, count):\\n        if count >= self.res:\\n            return\\n        i, j = self.find_next(board)\\n        if i == -1 and j == -1:\\n            self.res = min(self.res, count)\\n            return\\n        max_length = self.find_max_length(board, i, j)\\n        for k in range(1, max_length + 1)[::-1]:\\n            self.assign(board, i, j, k, 1)\\n            self.dfs(board, count + 1)\\n            self.assign(board, i, j, k, 0)\\n       \\n    def assign(self, board, i, j, length, val):\\n        for row in range(i, i + length):\\n            for col in range(j, j + length):\\n                board[row][col] = val\\n\\n    def find_max_length(self, board, i, j):\\n        max_length = 1\\n        while i + max_length -1 < self.m and j + max_length - 1 < self.n:\\n            for row in range(i, i + max_length):\\n                if board[row][j + max_length - 1] != 0:\\n                    return max_length - 1\\n            for col in range(j, j + max_length):\\n                if board[i + max_length - 1][col] != 0:\\n                    return max_length - 1\\n            max_length += 1\\n        return max_length - 1\\n        \\n    def find_next(self, board):\\n        for i in range(self.m):\\n            for j in range(self.n):\\n                if board[i][j] == 0:\\n                    return i, j\\n        return -1, -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416630,
                "title": "c-version-of-the-memorized-backtrack-solution-8ms",
                "content": "This is the C++ version of [Charles000\\'s answer](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414260/8ms-Memorized-Backtrack-Solution-without-special-case!).\\n\\n```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if(n > m) swap(n, m);\\n        vector<int> S;\\n        for(int i = 0; i < n; i++) { S.push_back(m); }\\n        maxDepth = max(n, m);\\n        dfs(S, 0);\\n        return maxDepth;\\n    }\\n    \\n    int maxDepth;\\n\\ttypedef long long Key;\\n    unordered_map<Key, int> dp;\\n    Key hash(vector<int>& vec) {\\n        Key r = 0;\\n        for(int n: vec) { r = (r << 4LL) + n; }\\n        return r;\\n    }\\n    \\n    void dfs(vector<int>& vec, int dfsDepth) {\\n        Key h = hash(vec);\\n        if(h == 0) {\\n            maxDepth = min(maxDepth, dfsDepth);\\n            return;\\n        }\\n        if(dfsDepth >= maxDepth or dp.count(h)) { return; }\\n        \\n        auto topLeft = max_element(vec.begin(), vec.end());\\n        int width = 1;\\n        for(auto top = topLeft + 1; top != vec.end() and *top == *topLeft; top++) {\\n            width++;\\n        }\\n        \\n        for(int w = min(width, *topLeft); w > 0; w--) {\\n            for(int i = 0; i < w; i++) { *(topLeft + i) -= w; }\\n            dfs(vec, dfsDepth + 1);\\n            for(int i = 0; i < w; i++) { *(topLeft + i) += w; }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if(n > m) swap(n, m);\\n        vector<int> S;\\n        for(int i = 0; i < n; i++) { S.push_back(m); }\\n        maxDepth = max(n, m);\\n        dfs(S, 0);\\n        return maxDepth;\\n    }\\n    \\n    int maxDepth;\\n\\ttypedef long long Key;\\n    unordered_map<Key, int> dp;\\n    Key hash(vector<int>& vec) {\\n        Key r = 0;\\n        for(int n: vec) { r = (r << 4LL) + n; }\\n        return r;\\n    }\\n    \\n    void dfs(vector<int>& vec, int dfsDepth) {\\n        Key h = hash(vec);\\n        if(h == 0) {\\n            maxDepth = min(maxDepth, dfsDepth);\\n            return;\\n        }\\n        if(dfsDepth >= maxDepth or dp.count(h)) { return; }\\n        \\n        auto topLeft = max_element(vec.begin(), vec.end());\\n        int width = 1;\\n        for(auto top = topLeft + 1; top != vec.end() and *top == *topLeft; top++) {\\n            width++;\\n        }\\n        \\n        for(int w = min(width, *topLeft); w > 0; w--) {\\n            for(int i = 0; i < w; i++) { *(topLeft + i) -= w; }\\n            dfs(vec, dfsDepth + 1);\\n            for(int i = 0; i < w; i++) { *(topLeft + i) += w; }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777304,
                "title": "javascript-no-special-case-72ms-comments-in-detail-and-image-to-explain-everything",
                "content": "Thanks to [@siddharth33](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/744019/JavaScript-Solution-Correct-logic-with-no-corner-cases-Simple-DP). That\\'s the best answer I have ever seen. For better understanding to myself for reviewing it in future, in case I forget it.\\n\\n![image](https://assets.leetcode.com/users/images/e2e5997e-5869-425d-b8ee-bf2d252f5442_1645070451.4072974.png)\\n\\nIn each w * w square, we assume there are four rectangles around it. The coordinate of the square w * w is marked as [i , j], and 0 <= i <= m - w, 0 <= j <= n - w. n is the shorter edge which has n < m; According to the assumption we have now, we can calculate the height and width of the four rectangles as rectangle = [height, width]\\nA = [j + w, i];\\nB = [n - j - w, i + w];\\nC = [n - j, m - i - w];\\nD = [j, m - i];\\n\\nSo now, we can do the loop to search the square from width = 1\\n```\\nfor (let w = 1; w <= n; w++) {\\n\\tfor (let i = 0; i <= m - w; i++) {\\n\\t\\tfor (let j = 0; j <= n - w; j++) {\\n\\t\\t\\tans = Math.min(ans, \\n\\t\\t\\t\\ttilingHelper(j + w, i, memo) + \\n\\t\\t\\t\\ttilingHelper(n - j - w, i + w, memo) + \\n\\t\\t\\t\\ttilingHelper(n - j, m - i - w, memo) + \\n\\t\\t\\t\\ttilingHelper(j, m - i, memo) + 1\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n}\\n```\\nI won\\'t attach my full script here to show my respect to the original author. You can refer to the link here:  [@siddharth33](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/744019/JavaScript-Solution-Correct-logic-with-no-corner-cases-Simple-DP). \\n![image](https://assets.leetcode.com/users/images/c548f458-9084-4312-8c6b-1f7d912613e9_1645071407.8913126.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor (let w = 1; w <= n; w++) {\\n\\tfor (let i = 0; i <= m - w; i++) {\\n\\t\\tfor (let j = 0; j <= n - w; j++) {\\n\\t\\t\\tans = Math.min(ans, \\n\\t\\t\\t\\ttilingHelper(j + w, i, memo) + \\n\\t\\t\\t\\ttilingHelper(n - j - w, i + w, memo) + \\n\\t\\t\\t\\ttilingHelper(n - j, m - i - w, memo) + \\n\\t\\t\\t\\ttilingHelper(j, m - i, memo) + 1\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 862038,
                "title": "c-bottom-up-dp",
                "content": "I\\'ve not seen many bottom-up solutions here, so I\\'m attaching my solution. The transision should be trivial if you look at the diagrams.\\n\\n**Disclaimer:** I\\'ve done numerous amount of transsision because I was not sure if just the *Possibility 0* would take care of everything. If any of you know the formal proof for reducing the number of possibilities, please post it down,\\nNote: The possibilties section does not cover all possible cuts. I tried to submit with just these possibilities, and it got accepted.\\n```\\nint dp[14][14];\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        for(int i = 0; i <= n; i++) for(int j = 0; j <=m; j++) {\\n            if(i == 0 or j == 0) dp[i][j] = 0;\\n            else dp[i][j] = 987654321;\\n        }\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= m; j++) {\\n                int& best = dp[i][j];\\n                for(int s = 1; s <= min(i, j); s++) {\\n                    for(int r = s; r <= i; r++) {\\n                        for(int c = s; c <= j; c++) {\\n                            // place a square of size s x s\\n                            // whose end point is at (r, c)\\n                            /*\\n                              ____________________________\\n                             |                            |\\n                             |         ____               |\\n                             |        |    |              |\\n                             |        |____|              |\\n                             |     (r-s,c)  (r,c)         |\\n                             |                            |\\n                             |____________________________|\\n                             Note: coordinates are of the form (y, x)\\n                            */ \\n\\n                            vector<int> possibilities;\\n                            /* Possibility 0:\\n                                  _____________________________    _\\n                                 |              |              |  | r - s\\n                                 |______________|              |  |_\\n                                 |        |     |              |  | s\\n                                 |        |_____|______________|  |_\\n                                 |        |                    |  |\\n                                 |        |                    |  | i - r\\n                                 |________|____________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][c] + dp[s+i-r][c-s] + dp[i-r][j+s-c] + dp[r][j-c] + 1);\\n                            \\n                            /* Possibility 1:\\n                                  _____________________________    _\\n                                 |        |     |              |  | r - s\\n                                 |        |_____|              |  |_\\n                                 |        |     |              |  | s\\n                                 |        |_____|              |  |_\\n                                 |        |     |              |  |\\n                                 |        |     |              |  | i - r\\n                                 |________|_____|______________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[i][c-s] + dp[i][j-c] + dp[r-s][s] + dp[i-r][s] + 1);\\n\\n                            /* Possibility 2:\\n                                  _____________________________    _\\n                                 |                             |  | r - s\\n                                 |_____________________________|  |_\\n                                 |        |     |              |  | s\\n                                 |________|_____|______________|  |_\\n                                 |                             |  |\\n                                 |                             |  | i - r\\n                                 |_____________________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][j] + dp[i-r][j] + dp[s][c-s] + dp[s][j-c] + 1);\\n\\n                            /* Possibility 3:\\n                                  _____________________________    _\\n                                 |              |              |  | r - s\\n                                 |______________|              |  |_\\n                                 |        |     |              |  | s\\n                                 |________|_____|______________|  |_\\n                                 |                             |  |\\n                                 |                             |  | i - r\\n                                 |_____________________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][c] + dp[i-r][j] + dp[s][c-s] + dp[r][j-c] + 1);\\n\\n                            /* Possibility 4:\\n                                  _____________________________    _\\n                                 |        |                    |  | r - s\\n                                 |        |____________________|  |_\\n                                 |        |     |              |  | s\\n                                 |________|_____|______________|  |_\\n                                 |                             |  |\\n                                 |                             |  | i - r\\n                                 |_____________________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][j-c+s] + dp[i-r][j] + dp[r][c-s] + dp[s][j-c] + 1);\\n\\n                            /* Possibility 5:\\n                                  _____________________________    _\\n                                 |        |     |              |  | r - s\\n                                 |        |_____|              |  |_\\n                                 |        |     |              |  | s\\n                                 |________|_____|______________|  |_\\n                                 |                             |  |\\n                                 |                             |  | i - r\\n                                 |_____________________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][s] + dp[i-r][j] + dp[r][c] + dp[r][j-c] + 1);\\n                            best = min(best, *min_element(possibilities.begin(), possibilities.end()));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint dp[14][14];\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        for(int i = 0; i <= n; i++) for(int j = 0; j <=m; j++) {\\n            if(i == 0 or j == 0) dp[i][j] = 0;\\n            else dp[i][j] = 987654321;\\n        }\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= m; j++) {\\n                int& best = dp[i][j];\\n                for(int s = 1; s <= min(i, j); s++) {\\n                    for(int r = s; r <= i; r++) {\\n                        for(int c = s; c <= j; c++) {\\n                            // place a square of size s x s\\n                            // whose end point is at (r, c)\\n                            /*\\n                              ____________________________\\n                             |                            |\\n                             |         ____               |\\n                             |        |    |              |\\n                             |        |____|              |\\n                             |     (r-s,c)  (r,c)         |\\n                             |                            |\\n                             |____________________________|\\n                             Note: coordinates are of the form (y, x)\\n                            */ \\n\\n                            vector<int> possibilities;\\n                            /* Possibility 0:\\n                                  _____________________________    _\\n                                 |              |              |  | r - s\\n                                 |______________|              |  |_\\n                                 |        |     |              |  | s\\n                                 |        |_____|______________|  |_\\n                                 |        |                    |  |\\n                                 |        |                    |  | i - r\\n                                 |________|____________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][c] + dp[s+i-r][c-s] + dp[i-r][j+s-c] + dp[r][j-c] + 1);\\n                            \\n                            /* Possibility 1:\\n                                  _____________________________    _\\n                                 |        |     |              |  | r - s\\n                                 |        |_____|              |  |_\\n                                 |        |     |              |  | s\\n                                 |        |_____|              |  |_\\n                                 |        |     |              |  |\\n                                 |        |     |              |  | i - r\\n                                 |________|_____|______________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[i][c-s] + dp[i][j-c] + dp[r-s][s] + dp[i-r][s] + 1);\\n\\n                            /* Possibility 2:\\n                                  _____________________________    _\\n                                 |                             |  | r - s\\n                                 |_____________________________|  |_\\n                                 |        |     |              |  | s\\n                                 |________|_____|______________|  |_\\n                                 |                             |  |\\n                                 |                             |  | i - r\\n                                 |_____________________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][j] + dp[i-r][j] + dp[s][c-s] + dp[s][j-c] + 1);\\n\\n                            /* Possibility 3:\\n                                  _____________________________    _\\n                                 |              |              |  | r - s\\n                                 |______________|              |  |_\\n                                 |        |     |              |  | s\\n                                 |________|_____|______________|  |_\\n                                 |                             |  |\\n                                 |                             |  | i - r\\n                                 |_____________________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][c] + dp[i-r][j] + dp[s][c-s] + dp[r][j-c] + 1);\\n\\n                            /* Possibility 4:\\n                                  _____________________________    _\\n                                 |        |                    |  | r - s\\n                                 |        |____________________|  |_\\n                                 |        |     |              |  | s\\n                                 |________|_____|______________|  |_\\n                                 |                             |  |\\n                                 |                             |  | i - r\\n                                 |_____________________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][j-c+s] + dp[i-r][j] + dp[r][c-s] + dp[s][j-c] + 1);\\n\\n                            /* Possibility 5:\\n                                  _____________________________    _\\n                                 |        |     |              |  | r - s\\n                                 |        |_____|              |  |_\\n                                 |        |     |              |  | s\\n                                 |________|_____|______________|  |_\\n                                 |                             |  |\\n                                 |                             |  | i - r\\n                                 |_____________________________|  |_\\n                                 <-(c-s)-><--s--><----(j-c)---->\\n                                 Note: coordinates are of the form (y, x)\\n                                */\\n                            possibilities.push_back(dp[r-s][s] + dp[i-r][j] + dp[r][c] + dp[r][j-c] + 1);\\n                            best = min(best, *min_element(possibilities.begin(), possibilities.end()));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745856,
                "title": "my-brain-melting-out-of-my-ears-100-i-need-therapy",
                "content": "```\\nclass Solution {\\n    int MAX = 500;\\n    int[][] dp;\\n    public int tilingRectangle(int n, int m) {\\n        if((n == 11 && m == 13) || (n==13 && m==11)) {\\n            return 6;\\n        }\\n        dp = new int[15][15];\\n        return rec(n,m);\\n    }\\n\\n    public int rec(int h, int w){\\n      if(h == w){\\n        return 1;\\n      }\\n      if(h <= 0 || w <= 0){\\n        return 0;\\n      }\\n      if(dp[h][w] != 0) return dp[h][w];\\n      int min = MAX;\\n      for(int i = 1 ; i <= Math.min(h,w); i++){\\n        int r2 = 1 + rec(h - i , w) + rec(i, w-i);\\n        int r3 = 1 + rec(h , w -i) + rec(h-i, i);\\n        min = Math.min(min,  Math.min(r2,r3));\\n      }\\n      return dp[h][w] = min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MAX = 500;\\n    int[][] dp;\\n    public int tilingRectangle(int n, int m) {\\n        if((n == 11 && m == 13) || (n==13 && m==11)) {\\n            return 6;\\n        }\\n        dp = new int[15][15];\\n        return rec(n,m);\\n    }\\n\\n    public int rec(int h, int w){\\n      if(h == w){\\n        return 1;\\n      }\\n      if(h <= 0 || w <= 0){\\n        return 0;\\n      }\\n      if(dp[h][w] != 0) return dp[h][w];\\n      int min = MAX;\\n      for(int i = 1 ; i <= Math.min(h,w); i++){\\n        int r2 = 1 + rec(h - i , w) + rec(i, w-i);\\n        int r3 = 1 + rec(h , w -i) + rec(h-i, i);\\n        min = Math.min(min,  Math.min(r2,r3));\\n      }\\n      return dp[h][w] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414190,
                "title": "c-top-down-dp-cheat",
                "content": "Within the given range we have only 1 special case, all other cases have optimal outputs when we solve subrectangles as subproblems. \\n\\n```\\nclass Solution {\\npublic:\\n    int dp[14][14];\\n    int helper(int n, int m){\\n        if(n<1 || m<1 || n>13 || m>13) return INT_MAX;\\n        if(n==m) return 1;\\n        \\n        if(dp[n][m] != -1) return dp[n][m];\\n        \\n        int a = INT_MAX, b = INT_MAX;\\n        for(int i=1; i<=n/2; i++){\\n            a = min(a, helper(i,m) + helper(n-i,m));\\n        }\\n        for(int j=1; j<=m/2; j++){\\n            b = min(b, helper(n,j) + helper(n,m-j));\\n        }\\n        \\n        return dp[n][m] = min(a,b);\\n    }\\n    int tilingRectangle(int n, int m) {\\n        memset(dp,-1,sizeof dp);\\n        if (n == 11 && m == 13 || n == 13 && m == 11) return 6;\\n        return helper(n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[14][14];\\n    int helper(int n, int m){\\n        if(n<1 || m<1 || n>13 || m>13) return INT_MAX;\\n        if(n==m) return 1;\\n        \\n        if(dp[n][m] != -1) return dp[n][m];\\n        \\n        int a = INT_MAX, b = INT_MAX;\\n        for(int i=1; i<=n/2; i++){\\n            a = min(a, helper(i,m) + helper(n-i,m));\\n        }\\n        for(int j=1; j<=m/2; j++){\\n            b = min(b, helper(n,j) + helper(n,m-j));\\n        }\\n        \\n        return dp[n][m] = min(a,b);\\n    }\\n    int tilingRectangle(int n, int m) {\\n        memset(dp,-1,sizeof dp);\\n        if (n == 11 && m == 13 || n == 13 && m == 11) return 6;\\n        return helper(n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654813,
                "title": "c-0ms-simple-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        vector<vector<int>> mem(14, vector<int>(14, 0));\\n        return cover(n, m, mem);\\n    }\\n    \\n    int cover(int n, int m, vector<vector<int>>& mem) {\\n        // simple special cases\\n        if(n > m) swap(n, m);\\n        if(n == 0) return 0;\\n        if(n == m) return 1;\\n        if(n == 1) return m;\\n        \\n        // use memory\\n        if(mem[n][m] > 0) return mem[n][m];\\n                \\n        // 1 square (s) + 1 rectangle (r)\\n        // sssrrrrr\\n        // sssrrrrr\\n        // sssrrrrr\\n        int mi = 1 + cover(n, m - n, mem);\\n        \\n        // 2 squares (b,s) + 3 rectangles (x,y,z) (big square size: i, small square size: m-i)\\n        // zzzzzyy\\n        // bbbbxyy\\n        // bbbbsss\\n        // bbbbsss\\n        // bbbbsss        \\n        for(int i = n - 1; i > 0 && m - i <= i; --i)\\n            for(int j = 0; j <= m - i; ++j)\\n                mi = min(mi, 2 + cover(2*i - m, j, mem) + cover(n - i, i + j, mem) + cover(n - m + i, m - i - j, mem));\\n        \\n        // memorize it\\n        mem[n][m] = mi;\\n        return mi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        vector<vector<int>> mem(14, vector<int>(14, 0));\\n        return cover(n, m, mem);\\n    }\\n    \\n    int cover(int n, int m, vector<vector<int>>& mem) {\\n        // simple special cases\\n        if(n > m) swap(n, m);\\n        if(n == 0) return 0;\\n        if(n == m) return 1;\\n        if(n == 1) return m;\\n        \\n        // use memory\\n        if(mem[n][m] > 0) return mem[n][m];\\n                \\n        // 1 square (s) + 1 rectangle (r)\\n        // sssrrrrr\\n        // sssrrrrr\\n        // sssrrrrr\\n        int mi = 1 + cover(n, m - n, mem);\\n        \\n        // 2 squares (b,s) + 3 rectangles (x,y,z) (big square size: i, small square size: m-i)\\n        // zzzzzyy\\n        // bbbbxyy\\n        // bbbbsss\\n        // bbbbsss\\n        // bbbbsss        \\n        for(int i = n - 1; i > 0 && m - i <= i; --i)\\n            for(int j = 0; j <= m - i; ++j)\\n                mi = min(mi, 2 + cover(2*i - m, j, mem) + cover(n - i, i + j, mem) + cover(n - m + i, m - i - j, mem));\\n        \\n        // memorize it\\n        mem[n][m] = mi;\\n        return mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539467,
                "title": "java-use-dfs-and-backtrackingg",
                "content": "Credit to [Charles000](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414260/8ms-Memorized-Backtrack-Solution-without-special-case!), but did minor change;\\nDid some minor change to make it concise.\\n1, combine some logic, say hash\\n2, removed boolean isFull\\n3, h[0] not used. so decreased length from n+1 to n;\\n4, replace swap by a recuirsion.\\n5, base start from 1;\\n```\\nclass Solution {\\n    Map<Long, Integer> map = new HashMap<>();\\n    int res = Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        if (n == m) return 1;\\n        if (n > m) return tilingRectangle(m, n);\\n        dfs(n, m, new int[n], 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int n, int m, int[] h, int cnt) {\\n        if (cnt >= res) return;\\n        int pos = -1, minH = Integer.MAX_VALUE;\\n        long key = 0, base = 1;\\n        for (int i = 0; i < n; i++) {\\n            key += h[i] * base;\\n            base *= m + 1;\\n            if (h[i] < minH) {\\n                pos = i;\\n                minH = h[i];\\n            }\\n        }\\n        if (minH == m) {\\n            res = Math.min(cnt, res);\\n            return;\\n        }\\n        if (map.containsKey(key) && map.get(key) <= cnt) return;\\n        map.put(key, cnt);\\n        int end = pos;\\n        while (end + 1 < n && h[end + 1] == h[pos] && (end + 1 - pos + 1 + minH) <= m) end++;\\n        for (int j = end; j >= pos; j--) {\\n            int[] next = h.clone();\\n            for (int k = pos; k <= j; k++) next[k] += j - pos + 1;  //mew added squre edge length\\n            dfs(n, m, next, cnt + 1);\\n        } \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Long, Integer> map = new HashMap<>();\\n    int res = Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        if (n == m) return 1;\\n        if (n > m) return tilingRectangle(m, n);\\n        dfs(n, m, new int[n], 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int n, int m, int[] h, int cnt) {\\n        if (cnt >= res) return;\\n        int pos = -1, minH = Integer.MAX_VALUE;\\n        long key = 0, base = 1;\\n        for (int i = 0; i < n; i++) {\\n            key += h[i] * base;\\n            base *= m + 1;\\n            if (h[i] < minH) {\\n                pos = i;\\n                minH = h[i];\\n            }\\n        }\\n        if (minH == m) {\\n            res = Math.min(cnt, res);\\n            return;\\n        }\\n        if (map.containsKey(key) && map.get(key) <= cnt) return;\\n        map.put(key, cnt);\\n        int end = pos;\\n        while (end + 1 < n && h[end + 1] == h[pos] && (end + 1 - pos + 1 + minH) <= m) end++;\\n        for (int j = end; j >= pos; j--) {\\n            int[] next = h.clone();\\n            for (int k = pos; k <= j; k++) next[k] += j - pos + 1;  //mew added squre edge length\\n            dfs(n, m, next, cnt + 1);\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415705,
                "title": "python-backtracking-explained",
                "content": "Place square from bottom->top. For each square, try to scan and find the current lowest point, add square there.\\nWhat if there is one big square that shadows one small square under it? Then that small square must be placed first because it has lower height. So this way of placement is always valid.\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        res=n*m\\n        def dfs(height,moves):\\n            nonlocal res\\n            if all(h==n for h in height):\\n                res=min(res,moves)\\n                return\\n            if moves>=res:\\n                return\\n            idx=height.index(min(height))\\n            idx2=idx\\n            while idx2<m and height[idx]==height[idx2]:\\n                idx2+=1\\n            maxl=min(idx2-idx,n-height[idx])\\n            for l in range(maxl,0,-1):\\n                height2=list(height)\\n                for j in range(l):\\n                    height2[idx+j]+=l\\n                dfs(height2,moves+1)\\n        dfs([0]*m,0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        res=n*m\\n        def dfs(height,moves):\\n            nonlocal res\\n            if all(h==n for h in height):\\n                res=min(res,moves)\\n                return\\n            if moves>=res:\\n                return\\n            idx=height.index(min(height))\\n            idx2=idx\\n            while idx2<m and height[idx]==height[idx2]:\\n                idx2+=1\\n            maxl=min(idx2-idx,n-height[idx])\\n            for l in range(maxl,0,-1):\\n                height2=list(height)\\n                for j in range(l):\\n                    height2[idx+j]+=l\\n                dfs(height2,moves+1)\\n        dfs([0]*m,0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075752,
                "title": "short-concise-python-implementation-with-memoization-beating-95",
                "content": "To reduce the number of cases, a key point is to handle the cases in the \"landscape\" (height <= width) direction only.  \\n\\n```\\nclass Solution:\\n    @cache\\n    def solve(self, x1, y1, x2, y2):\\n        if y2 > x2:                             # For the cases in the \"portrait\" direction,  \\n            return self.solve(y1, x1, y2, x2)   # always rotate them into the \"landscape\" direction\\n        elif x2 * y2 == 0:\\n            return 0\\n        elif x1 == 0 and y1 == 0 and x2 == y2:\\n            return 1\\n        elif y1 == y2:\\n            return self.solve(0, 0, x2 - x1, y2)\\n        elif x1 == y1 == 0:\\n            return min([self.solve(d, d, x2, y2) for d in range(1, y2 + 1)]) + 1\\n        elif x1 < y2 - y1 < x2:\\n            return self.solve(y2 - y1, (x2-x1) - (x2 - (y2-y1)), y2, x2-x1) + 1\\n        elif x1 == y2 - y1:\\n            return self.solve(0, 0, x2-x1, y2) + 1\\n        elif x1 > y2 - y1:\\n            return self.solve(x1 - (y2 - y1), y1, x2 - (y2 - y1), y2) + 1\\n            \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        return self.solve(0, 0, n, m)\\n        \\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "To reduce the number of cases, a key point is to handle the cases in the \"landscape\" (height <= width) direction only.  \\n\\n```\\nclass Solution:\\n    @cache\\n    def solve(self, x1, y1, x2, y2):\\n        if y2 > x2:                             # For the cases in the \"portrait\" direction,  \\n            return self.solve(y1, x1, y2, x2)   # always rotate them into the \"landscape\" direction\\n        elif x2 * y2 == 0:\\n            return 0\\n        elif x1 == 0 and y1 == 0 and x2 == y2:\\n            return 1\\n        elif y1 == y2:\\n            return self.solve(0, 0, x2 - x1, y2)\\n        elif x1 == y1 == 0:\\n            return min([self.solve(d, d, x2, y2) for d in range(1, y2 + 1)]) + 1\\n        elif x1 < y2 - y1 < x2:\\n            return self.solve(y2 - y1, (x2-x1) - (x2 - (y2-y1)), y2, x2-x1) + 1\\n        elif x1 == y2 - y1:\\n            return self.solve(0, 0, x2-x1, y2) + 1\\n        elif x1 > y2 - y1:\\n            return self.solve(x1 - (y2 - y1), y1, x2 - (y2 - y1), y2) + 1\\n            \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        return self.solve(0, 0, n, m)\\n        \\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 414246,
                "title": "java-straightforward-dp-top-down-and-bottom-up",
                "content": "Bottom up\\n```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if((n==11 && m==13) || (n==13 && m==11)) return 6;\\n        int[][] dp = new int[n+1][m+1];\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(i==j){\\n                    dp[i][j] = 1;\\n                }\\n                else{\\n                    dp[i][j] = Integer.MAX_VALUE;\\n                    for(int k=1;k<=i/2;k++){\\n                        dp[i][j] = Math.min(dp[i][j], dp[k][j]+dp[i-k][j]);\\n                    }\\n                    for(int k=1;k<=j/2;k++){\\n                        dp[i][j] = Math.min(dp[i][j], dp[i][k]+dp[i][j-k]);\\n                    }   \\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n}\\n```\\n\\nTop Down\\n```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if((n==11 && m==13) || (n==13 && m==11)) return 6;\\n        int[][] dp = new int[n+1][m+1];\\n        return minCut(n,m,dp);\\n    }\\n    \\n    public int minCut(int n, int m, int[][] dp){\\n        if(n==m) return 1;\\n        if(dp[n][m]!=0) return dp[n][m];\\n        int vertMin = Integer.MAX_VALUE;\\n        int horzMin = Integer.MAX_VALUE;\\n        for(int i=1;i<=n/2;i++){\\n            vertMin = Math.min(vertMin, minCut(i,m,dp)+minCut(n-i,m,dp));\\n        }\\n        for(int i=1;i<=m/2;i++){\\n            horzMin = Math.min(horzMin, minCut(n,i,dp)+minCut(n,m-i,dp));\\n        }\\n        dp[n][m] = Math.min(vertMin, horzMin);\\n        return dp[n][m];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if((n==11 && m==13) || (n==13 && m==11)) return 6;\\n        int[][] dp = new int[n+1][m+1];\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(i==j){\\n                    dp[i][j] = 1;\\n                }\\n                else{\\n                    dp[i][j] = Integer.MAX_VALUE;\\n                    for(int k=1;k<=i/2;k++){\\n                        dp[i][j] = Math.min(dp[i][j], dp[k][j]+dp[i-k][j]);\\n                    }\\n                    for(int k=1;k<=j/2;k++){\\n                        dp[i][j] = Math.min(dp[i][j], dp[i][k]+dp[i][j-k]);\\n                    }   \\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if((n==11 && m==13) || (n==13 && m==11)) return 6;\\n        int[][] dp = new int[n+1][m+1];\\n        return minCut(n,m,dp);\\n    }\\n    \\n    public int minCut(int n, int m, int[][] dp){\\n        if(n==m) return 1;\\n        if(dp[n][m]!=0) return dp[n][m];\\n        int vertMin = Integer.MAX_VALUE;\\n        int horzMin = Integer.MAX_VALUE;\\n        for(int i=1;i<=n/2;i++){\\n            vertMin = Math.min(vertMin, minCut(i,m,dp)+minCut(n-i,m,dp));\\n        }\\n        for(int i=1;i<=m/2;i++){\\n            horzMin = Math.min(horzMin, minCut(n,i,dp)+minCut(n,m-i,dp));\\n        }\\n        dp[n][m] = Math.min(vertMin, horzMin);\\n        return dp[n][m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269478,
                "title": "easy-understandable-code-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int n, int m, vector<vector<int>>& dp) {\\n        if(n<0 || m<0) return 0;\\n        if(m==n) return 1;\\n        \\n        // this is special case\\n        if((m==13 && n==11) || (m==11 && n==13)) return dp[n][m]=6;\\n        \\n        if(dp[n][m]!=0) return dp[n][m];\\n        \\n        int hz=1e9;\\n        for(int i=1;i<=n/2;i++) {\\n            hz = min(hz, solve(i,m,dp) + solve(n-i,m,dp));\\n        }\\n        \\n        int vert = 1e9;\\n        for(int i=1;i<=m/2;i++) {\\n            vert = min(vert, solve(n,m-i,dp) + solve(n,i,dp));\\n        }\\n        \\n        return dp[n][m] = min(hz,vert);\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        vector<vector<int>> dp (n+1,vector<int> (m+1,0));\\n        return solve(n,m,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, int m, vector<vector<int>>& dp) {\\n        if(n<0 || m<0) return 0;\\n        if(m==n) return 1;\\n        \\n        // this is special case\\n        if((m==13 && n==11) || (m==11 && n==13)) return dp[n][m]=6;\\n        \\n        if(dp[n][m]!=0) return dp[n][m];\\n        \\n        int hz=1e9;\\n        for(int i=1;i<=n/2;i++) {\\n            hz = min(hz, solve(i,m,dp) + solve(n-i,m,dp));\\n        }\\n        \\n        int vert = 1e9;\\n        for(int i=1;i<=m/2;i++) {\\n            vert = min(vert, solve(n,m-i,dp) + solve(n,i,dp));\\n        }\\n        \\n        return dp[n][m] = min(hz,vert);\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        vector<vector<int>> dp (n+1,vector<int> (m+1,0));\\n        return solve(n,m,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238518,
                "title": "python-memorization-with-a-l-shape-two-rectangles",
                "content": "A rectangle can be considered an L shape + a small rectangle.\\nThis small rectangle could be a square or zero sizes.\\n\\nDefine rectangle size as (m, n), small retangle size as (h, w).\\n![image](https://assets.leetcode.com/users/images/ae512bac-3812-4ead-95aa-2a16245ddfa4_1656968186.34657.png)\\n\\n\\nL shape could be dicribe as (m, n, h, w). A rectangle could be dicribe by L shape as (m, n, 0, 0)\\nL shape is defined as below picture\\n![image](https://assets.leetcode.com/users/images/121e3463-41d4-47f2-a1f0-da98ac23f8e3_1656969508.78159.png)\\n\\n        h1, h2 = m - h, h\\n        w1, w2 = w, n - w\\n\\n\\nSolution:\\n1. If the current shape is visited, return memorization the value \\n2. If the current shape is a rectangle, we remove a square from the top-left corner.\\n3. If the current shape is an L shape, we remove a square from 4 directions (top, bottom, left, right) if possible.\\n\\n![image](https://assets.leetcode.com/users/images/dd6c2208-247e-40a3-b8d4-752d17c9d736_1656986972.487491.png)\\n\\n![image](https://assets.leetcode.com/users/images/2be13e42-d873-49b1-add1-78df9aca3b90_1656987006.0783417.png)\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n\\n        self.memo = {}\\n        self.dp(m, n, 0, 0)\\n\\n        return self.memo[(m, n, 0, 0)]\\n\\n    def dp(self, m, n, h, w):\\n\\n        key = (m, n, h, w)        \\n        key_rev = (n, m, w, h)\\n\\n        if key in self.memo:\\n            return self.memo[key]\\n\\n        if key_rev in self.memo:\\n            return self.memo[key_rev]\\n\\n        if m == n and h == 0 and w == 0:\\n            self.memo[key] = 1\\n            return 1\\n\\n        if m == 0 or n == 0:\\n            self.memo[key] = 0\\n            return 0\\n\\n        res = m * n\\n        if h == 0 and w == 0:\\n            #  the current shape is a rectangle, we remove a square from the top-left corner.\\n            s = min(m, n)\\n            for d in range(1, s + 1):\\n                curr = 1 + self.dp(m, n, d, d)\\n                res = min(res, curr)\\n\\n            self.memo[key] = res\\n            self.memo[key_rev] = res\\n            return res\\n\\n        if m == 1:\\n            self.memo[key] = n\\n            return self.memo[key]\\n\\n        if n == 1:\\n            self.memo[key] = m\\n            return self.memo[key]\\n\\n        if m == h:\\n            self.memo[key] = self.dp(m, n - w, 0, 0)\\n            return self.memo[key]\\n\\n        if n == w:\\n            self.memo[key] = self.dp(m - h, n, 0, 0)\\n            return self.memo[key]\\n\\n        # the current shape is an L shape, we remove a square from 4 directions (top, bottom, left, right) if possible.\\n        h1, h2 = m - h, h\\n        w1, w2 = w, n - w\\n\\n        # Remove square from left\\n        if h1 <= n:\\n            if w1 == h1:\\n                cnt = 1 + self.dp(m, w2, 0, 0)\\n                res = min(res, cnt)\\n\\n            elif w1 > h1:\\n                cnt = 1 + self.dp(m, n - h1, h2, w1 - h1)\\n                res = min(res, cnt)\\n\\n            else:\\n\\t\\t\\t# Rotate the L shape to keep the small rectangle at top-left corner\\n                cnt = 1 + self.dp(w2, m, h1 - w1, h1)\\n                res = min(res, cnt)\\n\\n        # Remove square from top\\n        if w2 <= m:\\n            if h2 == w2:\\n                cnt = 1 + self.dp(h1, n, 0, 0)\\n                res = min(res, cnt)\\n\\n            elif h2 > w2:\\n                cnt = 1 + self.dp(m - w2, n, h2 - w2, w1)\\n                res = min(res, cnt)\\n\\n            else:\\n\\t\\t\\t# Flip the L shape to keep the small rectangle at the top-left corner\\n                cnt = 1 +self.dp(h1, n, w2 - h2, w2)\\n                res = min(res, cnt)\\n\\n        # Remove square from right\\n        if w2 > m:\\n            cnt = 1 + self.dp(m, n - m, h, w)\\n            res = min(res, cnt)\\n\\n        # Remove square from bottom\\n        if h1 > n:\\n            cnt = 1 + self.dp(m - n, n, h, w)\\n            res = min(res, cnt)\\n\\n        self.memo[key] = res\\n        self.memo[key_rev] = res\\n\\n        return res\\n\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n\\n        self.memo = {}\\n        self.dp(m, n, 0, 0)\\n\\n        return self.memo[(m, n, 0, 0)]\\n\\n    def dp(self, m, n, h, w):\\n\\n        key = (m, n, h, w)        \\n        key_rev = (n, m, w, h)\\n\\n        if key in self.memo:\\n            return self.memo[key]\\n\\n        if key_rev in self.memo:\\n            return self.memo[key_rev]\\n\\n        if m == n and h == 0 and w == 0:\\n            self.memo[key] = 1\\n            return 1\\n\\n        if m == 0 or n == 0:\\n            self.memo[key] = 0\\n            return 0\\n\\n        res = m * n\\n        if h == 0 and w == 0:\\n            #  the current shape is a rectangle, we remove a square from the top-left corner.\\n            s = min(m, n)\\n            for d in range(1, s + 1):\\n                curr = 1 + self.dp(m, n, d, d)\\n                res = min(res, curr)\\n\\n            self.memo[key] = res\\n            self.memo[key_rev] = res\\n            return res\\n\\n        if m == 1:\\n            self.memo[key] = n\\n            return self.memo[key]\\n\\n        if n == 1:\\n            self.memo[key] = m\\n            return self.memo[key]\\n\\n        if m == h:\\n            self.memo[key] = self.dp(m, n - w, 0, 0)\\n            return self.memo[key]\\n\\n        if n == w:\\n            self.memo[key] = self.dp(m - h, n, 0, 0)\\n            return self.memo[key]\\n\\n        # the current shape is an L shape, we remove a square from 4 directions (top, bottom, left, right) if possible.\\n        h1, h2 = m - h, h\\n        w1, w2 = w, n - w\\n\\n        # Remove square from left\\n        if h1 <= n:\\n            if w1 == h1:\\n                cnt = 1 + self.dp(m, w2, 0, 0)\\n                res = min(res, cnt)\\n\\n            elif w1 > h1:\\n                cnt = 1 + self.dp(m, n - h1, h2, w1 - h1)\\n                res = min(res, cnt)\\n\\n            else:\\n\\t\\t\\t# Rotate the L shape to keep the small rectangle at top-left corner\\n                cnt = 1 + self.dp(w2, m, h1 - w1, h1)\\n                res = min(res, cnt)\\n\\n        # Remove square from top\\n        if w2 <= m:\\n            if h2 == w2:\\n                cnt = 1 + self.dp(h1, n, 0, 0)\\n                res = min(res, cnt)\\n\\n            elif h2 > w2:\\n                cnt = 1 + self.dp(m - w2, n, h2 - w2, w1)\\n                res = min(res, cnt)\\n\\n            else:\\n\\t\\t\\t# Flip the L shape to keep the small rectangle at the top-left corner\\n                cnt = 1 +self.dp(h1, n, w2 - h2, w2)\\n                res = min(res, cnt)\\n\\n        # Remove square from right\\n        if w2 > m:\\n            cnt = 1 + self.dp(m, n - m, h, w)\\n            res = min(res, cnt)\\n\\n        # Remove square from bottom\\n        if h1 > n:\\n            cnt = 1 + self.dp(m - n, n, h, w)\\n            res = min(res, cnt)\\n\\n        self.memo[key] = res\\n        self.memo[key_rev] = res\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221772,
                "title": "c-top-down-backtracking-dp-no-cheat",
                "content": "The code is an `optimized version`( to reduce the number of recursive call ) of solution given by @motorix at the link https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414979/Java-back-tracking-solution.\\n\\n\\n```cpp\\nclass Solution {\\n    bool isAvailable( vector<vector<bool>>& dp, int r, int c, int k ) {\\n        int R = r+k, C = c+k;\\n        for( int r1=r; r1<R; r1++ )\\n            for( int c1 = c; c1<C; c1++ ) \\n                if( dp[r1][c1] == true )\\n                    return false;\\n        return true;\\n    }\\n\\n    void fillUp( vector<vector<bool>>& dp, int r, int c, int k, bool val ) {\\n        int R = r+k, C = c+k;\\n        for( int r1=r; r1<R; r1++ )\\n            for( int c1 = c; c1<C; c1++ ) \\n                dp[r1][c1] = val;\\n    }\\n    \\n    void computeRes( int r, int c, int& res, int curRes, vector<vector<bool>>& dp ) {\\n        int R = dp.size(), C = dp.front().size();\\n        if( curRes >= res )\\n            return;\\n        if( c >= C ) {       //  The condition should be c>=C, as we are skipping k cells as a part of optimisation-2.\\n            computeRes( r+1, 0, res, curRes, dp );\\n            return;\\n        }\\n        if( r == R ) {\\n            res = min( res, curRes );\\n            return;\\n        }\\n        if( dp[r][c] ) {\\n            while( c<C and dp[r][c] )   c++;    // Optimisation-1: Skip all the cells which are already filled.\\n            computeRes( r, c, res, curRes, dp );\\n            return;\\n        }\\n        for( int k=min(R-r,C-c); k>0; k-- ) {\\n            if( not isAvailable( dp, r, c, k ) )\\n                break;\\n            fillUp( dp, r, c, k, true );\\n            computeRes( r, c+k, res, curRes+1, dp );     // Optimisation-2: use c+k, instead of c+1\\n            fillUp( dp, r, c, k, false );\\n        }\\n    }\\npublic:\\n    int tilingRectangle(int R, int C) {\\n        int res = INT_MAX, curRes = 0;\\n        vector< vector<bool> > dp( R, vector<bool>(C,false) );\\n        computeRes( 0, 0, res, curRes, dp );\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\n    bool isAvailable( vector<vector<bool>>& dp, int r, int c, int k ) {\\n        int R = r+k, C = c+k;\\n        for( int r1=r; r1<R; r1++ )\\n            for( int c1 = c; c1<C; c1++ ) \\n                if( dp[r1][c1] == true )\\n                    return false;\\n        return true;\\n    }\\n\\n    void fillUp( vector<vector<bool>>& dp, int r, int c, int k, bool val ) {\\n        int R = r+k, C = c+k;\\n        for( int r1=r; r1<R; r1++ )\\n            for( int c1 = c; c1<C; c1++ ) \\n                dp[r1][c1] = val;\\n    }\\n    \\n    void computeRes( int r, int c, int& res, int curRes, vector<vector<bool>>& dp ) {\\n        int R = dp.size(), C = dp.front().size();\\n        if( curRes >= res )\\n            return;\\n        if( c >= C ) {       //  The condition should be c>=C, as we are skipping k cells as a part of optimisation-2.\\n            computeRes( r+1, 0, res, curRes, dp );\\n            return;\\n        }\\n        if( r == R ) {\\n            res = min( res, curRes );\\n            return;\\n        }\\n        if( dp[r][c] ) {\\n            while( c<C and dp[r][c] )   c++;    // Optimisation-1: Skip all the cells which are already filled.\\n            computeRes( r, c, res, curRes, dp );\\n            return;\\n        }\\n        for( int k=min(R-r,C-c); k>0; k-- ) {\\n            if( not isAvailable( dp, r, c, k ) )\\n                break;\\n            fillUp( dp, r, c, k, true );\\n            computeRes( r, c+k, res, curRes+1, dp );     // Optimisation-2: use c+k, instead of c+1\\n            fillUp( dp, r, c, k, false );\\n        }\\n    }\\npublic:\\n    int tilingRectangle(int R, int C) {\\n        int res = INT_MAX, curRes = 0;\\n        vector< vector<bool> > dp( R, vector<bool>(C,false) );\\n        computeRes( 0, 0, res, curRes, dp );\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856428,
                "title": "java-beats-100-simple-code",
                "content": "```\\nclass Solution {    \\n    private int trUtil(int n, int m, int[][] cache)\\n    {\\n        if (n > m)\\n        {\\n            int temp = n;\\n            n = m;\\n            m = temp;\\n        }\\n        \\n        if (cache[n][m] != 0)\\n            return cache[n][m];\\n        \\n        if (n == 0)\\n        {\\n            cache[0][m] = 0;\\n            return 0;\\n        }\\n        \\n        if (n == 1)\\n        {\\n            cache[n][m] = m;\\n            return m;\\n        }\\n        \\n        if (n == m)\\n        {\\n            cache[n][m] = 1;\\n            return 1;\\n        }\\n        \\n        if (m % n == 0)\\n        {\\n            cache[n][m] = m/n;\\n            return m/n;\\n        }\\n        \\n        if (m > 2 * n)\\n        {\\n            int num = (m / n) - 1;\\n            int newM = m - num*n;            \\n            cache[n][m] = num + trUtil(n, newM, cache);\\n            return cache[n][m];\\n        }\\n        \\n        cache[n][m] = 1 + trUtil(Math.min(n, m-n), Math.max(n, m-n), cache);\\n        \\n        // if 1 < n < m < 2n then we do the following\\n        // Let i be size of big square\\n        // Let j be size of horizontal extension beyond big square\\n        // Horizontal side is of len m, Vertical side is of len n\\n        // Bigger square is in bottom left corner, smaller sqaure attached to bigger\\n        // is in bottom right corner\\n        //\\n        /*  ---------------------------\\n            |                      *  |\\n            |                      *  |\\n            |--------i--------..j.>*  |\\n            |                |        |\\n            n                |        |\\n            |                |--------|\\n            |                |        |\\n            |                |        |\\n            --------------m------------\\n        */\\n        \\n        for (int i = (m+1)/2; i < n; i++)\\n        {\\n            for (int j = 0; j <= (m - i); j++)\\n            {\\n                cache[n][m] = Math.min(cache[n][m], 2 +\\n                                      trUtil(n-i, i+j, cache) +\\n                                      trUtil(n - (m-i), (m-i) - j, cache) +\\n                                      trUtil(j, i - (m-i), cache));\\n            }\\n        }\\n        \\n        return cache[n][m];\\n    }\\n    \\n    \\n    public int tilingRectangle(int n, int m) {\\n        int temp = Math.min(n, m);\\n        m = Math.max(n, m);\\n        n = temp;\\n        \\n        int[][] cache = new int[n+1][m+1];\\n        return trUtil(n, m, cache);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {    \\n    private int trUtil(int n, int m, int[][] cache)\\n    {\\n        if (n > m)\\n        {\\n            int temp = n;\\n            n = m;\\n            m = temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 841089,
                "title": "java-backtrack-binary-search-without-cheating-explanation",
                "content": "Idea:\\n1. we need at most m*n to fill the grid (if we use all 1)\\n2. Now the question is change to can we use fewer block to fill the grid?\\n3. We can binary search baseon on the available block we can use and check if we use this amount of blocks to fill the whole grid\\n4. We can backtrack to check, if we can finish the filling before we use all blocks, this mean the we can use less and so on so forth\\n\\n```\\nclass Solution {\\n    int res=Integer.MAX_VALUE;\\n    int max;int min;\\n    boolean finish=false;\\n    public int tilingRectangle(int n, int m) {\\n        int grid[][]=new int[n][m];\\n        max=Math.max(n,m);\\n        min=Math.min(n,m);\\n        \\n        int l=1,r=m*n;\\n        int res=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            finish=false;\\n            dfs(grid,0,0,mid);\\n            if(finish){\\n                res=mid;\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(int grid[][],int level,int sum,int maximum){\\n        if(sum==grid.length*grid[0].length){\\n            finish=true;\\n            return;\\n        }\\n        if(level>=maximum)return;\\n        if(finish)return;\\n        boolean found=false;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0)continue;\\n                for(int fill=1;fill<=max;fill++){\\n                    if(canfill(grid,i,j,fill)){\\n                        found=true;\\n                        color(grid,i,j,fill);\\n                        dfs(grid,level+1,sum+fill*fill,maximum);\\n                        reset(grid,i,j,fill);\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(found)break;\\n            }\\n            if(found)break;\\n        }\\n    }\\n    \\n    \\n    public boolean canfill(int grid[][],int i,int j,int len){\\n        if(i+len-1>=grid.length||j+len-1>=grid[0].length)return false;\\n        for(int r=i;r<=i+len-1;r++){\\n            for(int c=j;c<=j+len-1;c++){\\n                if(grid[r][c]!=0)return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public void reset(int grid[][],int i,int j,int len){\\n        for(int r=i;r<=i+len-1;r++){\\n            for(int c=j;c<=j+len-1;c++){\\n                grid[r][c]=0;\\n            }\\n        }\\n    }\\n    \\n     public void color(int grid[][],int i,int j,int len){\\n        for(int r=i;r<=i+len-1;r++){\\n            for(int c=j;c<=j+len-1;c++){\\n                grid[r][c]=len;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res=Integer.MAX_VALUE;\\n    int max;int min;\\n    boolean finish=false;\\n    public int tilingRectangle(int n, int m) {\\n        int grid[][]=new int[n][m];\\n        max=Math.max(n,m);\\n        min=Math.min(n,m);\\n        \\n        int l=1,r=m*n;\\n        int res=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            finish=false;\\n            dfs(grid,0,0,mid);\\n            if(finish){\\n                res=mid;\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(int grid[][],int level,int sum,int maximum){\\n        if(sum==grid.length*grid[0].length){\\n            finish=true;\\n            return;\\n        }\\n        if(level>=maximum)return;\\n        if(finish)return;\\n        boolean found=false;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0)continue;\\n                for(int fill=1;fill<=max;fill++){\\n                    if(canfill(grid,i,j,fill)){\\n                        found=true;\\n                        color(grid,i,j,fill);\\n                        dfs(grid,level+1,sum+fill*fill,maximum);\\n                        reset(grid,i,j,fill);\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(found)break;\\n            }\\n            if(found)break;\\n        }\\n    }\\n    \\n    \\n    public boolean canfill(int grid[][],int i,int j,int len){\\n        if(i+len-1>=grid.length||j+len-1>=grid[0].length)return false;\\n        for(int r=i;r<=i+len-1;r++){\\n            for(int c=j;c<=j+len-1;c++){\\n                if(grid[r][c]!=0)return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public void reset(int grid[][],int i,int j,int len){\\n        for(int r=i;r<=i+len-1;r++){\\n            for(int c=j;c<=j+len-1;c++){\\n                grid[r][c]=0;\\n            }\\n        }\\n    }\\n    \\n     public void color(int grid[][],int i,int j,int len){\\n        for(int r=i;r<=i+len-1;r++){\\n            for(int c=j;c<=j+len-1;c++){\\n                grid[r][c]=len;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414241,
                "title": "share-my-solution-for-the-general-problem-update-wrong-for-82-83",
                "content": "\\nI finished this problem after the contest time. The \"cut\" part took me some effort, and I got some wrong answers for that. \\n\\nThere are defintely optimizations to my code, and I appreciate if you have any suggestions to it. \\n\\nEdit: corrected a typo.\\n\\n```python \\nclass Solution:\\n    def __init__(self): \\n\\t\\tn = 15 \\n        self.dp2 = [[[[-1 for _ in range(n)] for _ in range(n)] for _ in range(n)] for _ in range(n)]\\n\\n        for i in range(n): \\n            self.dp2[i][i][0][0] = 1\\n    \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        return self.solve(m, n, 0, 0)\\n    \\n    # m, n, p, q is an L-shaped structure that we are going to solve \\n    #       m \\n    #    --------------\\n    #    |            |  n\\n    #    ------       |\\n    #  q       |      |\\n    #          --------\\n    #      p\\n\\n    def solve(self, m, n, p, q): \\n        # always let m >= n\\n        #print(m, n, p, q, \\'---\\')\\n\\n        if m <= 0 or n <= 0 or p < 0 or q < 0 or p > m or q > n: \\n            return 999\\n\\n        if n > m: \\n            return self.solve(n, m, q, p)\\n        \\n        if m == p: \\n            return self.solve(m, n-q, 0, 0)\\n        if n == q: \\n            return self.solve(m-p, n, 0, 0)\\n\\n        if self.dp2[m][n][p][q] > 0: \\n            return self.dp2[m][n][p][q]\\n        \\n        res = 999\\n        if p == 0 and q == 0: \\n            for i in range(n, 0, -1): \\n                res = min(res, self.solve(m, n, i, i)+1)\\n        else: \\n            cut = n-q\\n            if cut < p:\\n\\t\\t\\t\\tres = min(res, self.solve(m-cut, n, p-cut, q)+1) # corrected a typo here\\n            else: \\n                res = min(res, self.solve(m-p, n, cut-p, cut)+1)\\n\\n\\n            cut = m-p\\n            if cut < q: \\n                res = min(res, self.solve(m, n-cut, p, q-cut)+1)\\n            else: \\n                res = min(res, self.solve(m, n-q, cut, cut-q)+1)\\n\\n        \\n        #print(m, n, p, q, res)\\n        self.dp2[m][n][p][q] = res\\n        return res\\n\\n\\nr = Solution().tilingRectangle(11, 13)\\n#r = Solution().tilingRectangle(9, 7)\\n#r = Solution().solve(9, 5, 3, 1)\\nprint(r)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python \\nclass Solution:\\n    def __init__(self): \\n\\t\\tn = 15 \\n        self.dp2 = [[[[-1 for _ in range(n)] for _ in range(n)] for _ in range(n)] for _ in range(n)]\\n\\n        for i in range(n): \\n            self.dp2[i][i][0][0] = 1\\n    \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        return self.solve(m, n, 0, 0)\\n    \\n    # m, n, p, q is an L-shaped structure that we are going to solve \\n    #       m \\n    #    --------------\\n    #    |            |  n\\n    #    ------       |\\n    #  q       |      |\\n    #          --------\\n    #      p\\n\\n    def solve(self, m, n, p, q): \\n        # always let m >= n\\n        #print(m, n, p, q, \\'---\\')\\n\\n        if m <= 0 or n <= 0 or p < 0 or q < 0 or p > m or q > n: \\n            return 999\\n\\n        if n > m: \\n            return self.solve(n, m, q, p)\\n        \\n        if m == p: \\n            return self.solve(m, n-q, 0, 0)\\n        if n == q: \\n            return self.solve(m-p, n, 0, 0)\\n\\n        if self.dp2[m][n][p][q] > 0: \\n            return self.dp2[m][n][p][q]\\n        \\n        res = 999\\n        if p == 0 and q == 0: \\n            for i in range(n, 0, -1): \\n                res = min(res, self.solve(m, n, i, i)+1)\\n        else: \\n            cut = n-q\\n            if cut < p:\\n\\t\\t\\t\\tres = min(res, self.solve(m-cut, n, p-cut, q)+1) # corrected a typo here\\n            else: \\n                res = min(res, self.solve(m-p, n, cut-p, cut)+1)\\n\\n\\n            cut = m-p\\n            if cut < q: \\n                res = min(res, self.solve(m, n-cut, p, q-cut)+1)\\n            else: \\n                res = min(res, self.solve(m, n-q, cut, cut-q)+1)\\n\\n        \\n        #print(m, n, p, q, res)\\n        self.dp2[m][n][p][q] = res\\n        return res\\n\\n\\nr = Solution().tilingRectangle(11, 13)\\n#r = Solution().tilingRectangle(9, 7)\\n#r = Solution().solve(9, 5, 3, 1)\\nprint(r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414240,
                "title": "python3-dfs-with-optimizations",
                "content": "Reasonably fast for m & n up to low 20s\\n\\nThe idea is to DFS like playing Tetris + two optimizations. arr[i] stores the current height of column i.\\n1) try largest square possible first (improves time by a lot)\\n2) use greedy algorithm to get an upper bound\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        def sol(m, n):\\n            if m == n: return 1\\n            return sol(max(m, n) - min(m, n), min(m, n)) + 1\\n        ret = sol(m, n)\\n        \\n        arr = [0] * m\\n        def dfs(x, y, c):\\n            nonlocal ret\\n            if c >= ret: return\\n            if x < 0:\\n                ret = c\\n                return\\n            ny = y\\n            while ny < m and arr[ny] > 0:\\n                arr[ny] -= 1\\n                ny += 1\\n            \\n            if ny >= m:\\n                dfs(x - 1, 0, c)\\n            else:\\n                maxy = ny\\n                while maxy < min(m, ny + x + 1) and arr[maxy] == 0: maxy += 1\\n                for i in reversed(range(ny, maxy)):\\n                    z = i - ny\\n                    for j in range(ny, i + 1):\\n                        arr[j] = z\\n                    dfs(x, i + 1, c + 1)\\n                    arr[i] = 0\\n\\n            for i in range(y, ny):\\n                arr[i] += 1\\n\\n        dfs(n - 1, 0, 0)\\n        return ret",
                "solutionTags": [],
                "code": "Reasonably fast for m & n up to low 20s\\n\\nThe idea is to DFS like playing Tetris + two optimizations. arr[i] stores the current height of column i.\\n1) try largest square possible first (improves time by a lot)\\n2) use greedy algorithm to get an upper bound\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        def sol(m, n):\\n            if m == n: return 1\\n            return sol(max(m, n) - min(m, n), min(m, n)) + 1\\n        ret = sol(m, n)\\n        \\n        arr = [0] * m\\n        def dfs(x, y, c):\\n            nonlocal ret\\n            if c >= ret: return\\n            if x < 0:\\n                ret = c\\n                return\\n            ny = y\\n            while ny < m and arr[ny] > 0:\\n                arr[ny] -= 1\\n                ny += 1\\n            \\n            if ny >= m:\\n                dfs(x - 1, 0, c)\\n            else:\\n                maxy = ny\\n                while maxy < min(m, ny + x + 1) and arr[maxy] == 0: maxy += 1\\n                for i in reversed(range(ny, maxy)):\\n                    z = i - ny\\n                    for j in range(ny, i + 1):\\n                        arr[j] = z\\n                    dfs(x, i + 1, c + 1)\\n                    arr[i] = 0\\n\\n            for i in range(y, ny):\\n                arr[i] += 1\\n\\n        dfs(n - 1, 0, 0)\\n        return ret",
                "codeTag": "Java"
            },
            {
                "id": 414146,
                "title": "it-is-a-good-problem-but-m-n-are-too-small",
                "content": "\\n11 13  is the ONLY case below 14, that has similar structure like Exp.3 )\\n\\nHere is my solution in contest, without considering cases like Example.3\\nI \"solve\" this prblom in 5min.\\nIt will output 8 instead of 6 for case (11,13) without special check\\n\\n0.  Probably wrong for bigger mn. O(N^3)\\n```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if(n<m) swap(n,m);\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=1;i<=n;++i){\\n            dp[1][i]=dp[i][1]=i;\\n            dp[i][i]=1;\\n        }\\n        for(int i=2;i<=n;++i){\\n            for(int j=2;j<i;++j){\\n                if(i*11==j*13){\\n                    dp[i][j]=dp[j][i]=6;\\n                    continue;\\n                }\\n                int t=INT_MAX;\\n                for(int k=1;k<i;++k){\\n                    t=min(t,dp[k][j]+dp[i-k][j]);\\n                }\\n                for(int k=1;k<j;++k){\\n                    t=min(t,dp[i][k]+dp[i][j-k]);\\n                }\\n                dp[i][j]=dp[j][i]=t;\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\nWe can pass the probloem because m,n < 14 (actually m,n < 26). It feels like cheating.\\n\\nBut how to REALLY solve this?\\n\\n1. Search, with exp complexity.\\n Well, it is a solution. But I don\\'t think it much better than \"cheating\", because it can\\'t solve bigger cases as well.\\n\\n2. Correct our DP, let it fit cases like Example.3\\n\\nA possible way is to guess all the possible \"center\" part.\\nif we suppose the \"center part\" is a square, it\\'s simple to do O(N^5)   (I don\\'t know if it\\'s right)\\nOtherwise, O(N^6)\\n\\nBut it still feels too complex, do you have better ways?\\n\\n3.  Update later, maybe.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if(n<m) swap(n,m);\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=1;i<=n;++i){\\n            dp[1][i]=dp[i][1]=i;\\n            dp[i][i]=1;\\n        }\\n        for(int i=2;i<=n;++i){\\n            for(int j=2;j<i;++j){\\n                if(i*11==j*13){\\n                    dp[i][j]=dp[j][i]=6;\\n                    continue;\\n                }\\n                int t=INT_MAX;\\n                for(int k=1;k<i;++k){\\n                    t=min(t,dp[k][j]+dp[i-k][j]);\\n                }\\n                for(int k=1;k<j;++k){\\n                    t=min(t,dp[i][k]+dp[i][j-k]);\\n                }\\n                dp[i][j]=dp[j][i]=t;\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436803,
                "title": "java-accepted-for-all-test-cases",
                "content": "```\\nclass Solution {\\n    private int m;\\n    private int n;\\n    private boolean[][] filled;\\n    private int res;\\n\\n    public int tilingRectangle(int n, int m) {\\n        this.m = m;\\n        this.n = n;\\n        this.filled = new boolean[m][n];\\n        this.res = m * n;\\n\\n        backtrack(0, 0, 0);\\n        return res;\\n    }\\n\\n    private void backtrack(int r, int c, int currRes) {\\n        if (currRes >= res) return;\\n\\n        // check if we reached end of the reactange\\n        if (r >= m) {\\n            res = currRes; // since we already compared both and know currRes is smaller\\n            return;\\n        }\\n\\n        // check if we reached current col, go to next row\\n        if (c >= n) {\\n            backtrack(r + 1, 0, currRes);\\n            return;\\n        }\\n\\n        // check if current cell is filled move to next cell\\n        if (filled[r][c]) {\\n            backtrack(r, c + 1, currRes);\\n            return;\\n        }\\n\\n        // find all possible size of k and try to fill from r, c\\n        // max square size should be always min of (m-r) and (n-c);\\n        for (int size = Math.min(m - r, n - c); size > 0 && allCellsAvailable(r, c, size); size--) {\\n            mask(r, c, size, true);\\n            backtrack(r, c + 1, 1 + currRes);\\n            mask(r, c, size, false);\\n        }\\n    }\\n\\n    private void mask(int r, int c, int size, boolean value) {\\n        for (int i = 0; i < size; i++) {\\n            for (int j = 0; j < size; j++) {\\n                filled[r + i][c + j] = value;\\n            }\\n        }\\n    }\\n\\n    private boolean allCellsAvailable(int r, int c, int size) {\\n        for (int i = 0; i < size; i++) {\\n            for (int j = 0; j < size; j++) {\\n                if (filled[r + i][c + j]) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    private int m;\\n    private int n;\\n    private boolean[][] filled;\\n    private int res;\\n\\n    public int tilingRectangle(int n, int m) {\\n        this.m = m;\\n        this.n = n;\\n        this.filled = new boolean[m][n];\\n        this.res = m * n;\\n\\n        backtrack(0, 0, 0);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2132085,
                "title": "python-simple-and-advanced-backtracking-solutions",
                "content": "This is quite a hard question, so don\\'t get frustrated if you can\\'t solve it. I\\'ve spent many hours on it.\\n##### I\\'ve decided to solve this question with **backtracking**, and here\\'s the basic idea:\\n1. We\\'ll solve this problem by placing tiles one after another, trying to fill the entire board. We\\'ll start from the **top left corner**.\\n2. The process of filling will be pretty simple:\\n\\t* Find the next empty cell\\n\\t* Find the max tile size we can place at the location\\n\\t* Iterate all possible sizes (1-max_size) and try placing them\\n\\t\\t* place tile\\n\\t\\t* backtrack the updated board\\n\\t\\t* remove the previously place tile\\n\\n3. We\\'ll have a variable holding the min tiles count we found so far. At the beginning of each backtrack func execution we\\'ll check if the board is filled and update the min tile count.\\n\\nHere\\'s the code for that solution:\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n\\t\\tboard = [[False for _ in range(m)] for _ in range(n)]\\n            self.min_n_tiles = float(\\'inf\\')\\n            \\n            def find_next_empty_cell(board):\\n\\t\\t\\t\\t# go over the entire board, find the first empty cell and return it\\n                for i in range(n):\\n                    for j in range(m):\\n                        if not board[i][j]:\\n                            return i, j\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if the board is all covered, reutrn -1,-1\\n                return -1, -1\\n            \\n            def get_max_tile_size(board, row, col):\\n                # we need to measure the min distance from row, col to a tile/wall\\n                row_dist = col_dist = 1\\n                \\n                while col + col_dist < m and not board[row][col + col_dist]: col_dist += 1                       \\n                while row + row_dist < n and not board[row + row_dist][col]: row_dist += 1                    \\n                \\n                return min(row_dist, col_dist)                                 \\n            \\n            def cover(board, row, col, tile_size, cover_val):         \\n\\t\\t\\t\\t# cover board at specific location with a specific tile, by the cover val argument (True/False)\\n                for i in range(tile_size):                    \\n                    for j in range(tile_size):\\n                        board[row + i][col + j] = cover_val                                    \\n                \\n            def backtrack(board, n_tiles):          \\n\\t\\t\\t\\t# if curr tile count is already the min_tiles we found so far, no need to continue this placing route\\n                if n_tiles == self.min_n_tiles: \\n                    return\\n                \\n                next_row, next_col = find_next_empty_cell(board)\\n                \\n                # if not empty cell -> update min and break\\n                if next_row == next_col == -1:\\n                    self.min_n_tiles = min(self.min_n_tiles, n_tiles)\\n                    return\\n                \\n                # find max tile size to place\\n                max_tile_size = get_max_tile_size(board, next_row, next_col)\\n                \\n                # iterate possible tile size, place and backtrack\\n                for tile_size in range(max_tile_size, 0, -1):   \\n                    # place tile\\n                    cover(board, next_row, next_col, tile_size, True)\\n                    \\n                    # backtrack\\n                    backtrack(board, n_tiles + 1)\\n                    \\n                    # remove tile\\n                    cover(board, next_row, next_col, tile_size, False)                    \\n\\n\\n            backtrack(board, 0)\\n            return self.min_n_tiles\\n```\\n\\n**That\\'s it!**\\nMaybe you\\'ve noticed something while going thorugh the code. **Using a matrix** to represent our board is **costly** in terms of runtime and space.\\nFinding the next cell -> O(n*m). Placing and unplacing tile is also a bit messy. Passing the board to each backtrack call is also expensive.\\n### Can we do better? **Yes**\\n\\nInstead of matrix, we can maintain an **heights array.**  \\n**heights[i] = respresents the number of cells from the top down, that are covered with tiles**\\n\\nLet\\'s look at an example. n = 2, m = 3.\\nIn the previous solution, we would represent this example with a 2X3 board that would look like that:\\n```\\n[False, False, False]\\n[False, False, False]\\n```\\nAnd when we\\'re done covering the board, it would look like that:\\n```\\n[True, True, True]\\n[True, True, True]\\n```\\n\\nIn the new suggested method: heights would look like that: `[0, 0, 0]`\\nLet\\'s say we want to place a tile of size 1, we can just update heights to `[1, 0, 0]`\\nOr place a tile of size 2 instead -> `[2, 2, 0]`. \\nNotice that tile of size 2 would update two columns, tile of size 3 would update the next 3 columns and so on.\\nA board of size n X m would be represent as [0] * m. When it\\'s fully covered, it would look like that: [n] * m because of the m columns contain n covered cells.\\n\\n\\nHere\\'s the code for the new solution:\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n\\t\\theights = [0] * m\\n        self.min_tiles = float(\\'inf\\')\\n        \\n        def find_next_location():\\n            # find the min height, and return the first index of it\\n            min_height = min(heights)\\n            return heights.index(min_height)\\n        \\n        def find_max_tile_size(col_index):  \\n            # when we want to check the max tile size we can place, we need to take into account 3 things:\\n                # 1. we can\\'t go more the m - col_index steps to the right\\n                # 2. we can\\'t go more than n - heights[col_index] steps down\\n                # 3. we can\\'t put a tile bigger than the distance to next tile to the right. We can check that by comparing heights of adjacent columns\\n            curr_height = heights[col_index]\\n            max_height_dist = n - curr_height\\n            \\n            curr_index = col_index + 1\\n            while curr_index < m and heights[curr_index] == curr_height and curr_index - col_index < max_height_dist:\\n                curr_index += 1\\n                        \\n            return curr_index - col_index\\n        \\n        def backtrack(tile_count):\\n            # no need to go further      \\n            if tile_count == self.min_tiles: return\\n            \\n            # find the next possible location to place a tile\\n            next_col = find_next_location()\\n            \\n            # if the min height is n, the board is fully covered\\n            if heights[next_col] == n:\\n                self.min_tiles = min(self.min_tiles, tile_count)\\n                return\\n            \\n            # find the max tile size we can place at the current position\\n            max_tile_size = find_max_tile_size(next_col) \\n                               \\n            # iterate tile option\\n            for tile_size in range(max_tile_size, 0, -1):\\n                \\n                # place tile\\n                for col in range(next_col, next_col + tile_size):\\n                    heights[col] += tile_size\\n                \\n                # backtrack\\n                backtrack(tile_count + 1)\\n                \\n                # remove tile\\n                for col in range(next_col, next_col + tile_size):\\n                    heights[col] -= tile_size\\n            \\n        backtrack(0)\\n        \\n        return self.min_tiles\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n\\t\\tboard = [[False for _ in range(m)] for _ in range(n)]\\n            self.min_n_tiles = float(\\'inf\\')\\n            \\n            def find_next_empty_cell(board):\\n\\t\\t\\t\\t# go over the entire board, find the first empty cell and return it\\n                for i in range(n):\\n                    for j in range(m):\\n                        if not board[i][j]:\\n                            return i, j\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if the board is all covered, reutrn -1,-1\\n                return -1, -1\\n            \\n            def get_max_tile_size(board, row, col):\\n                # we need to measure the min distance from row, col to a tile/wall\\n                row_dist = col_dist = 1\\n                \\n                while col + col_dist < m and not board[row][col + col_dist]: col_dist += 1                       \\n                while row + row_dist < n and not board[row + row_dist][col]: row_dist += 1                    \\n                \\n                return min(row_dist, col_dist)                                 \\n            \\n            def cover(board, row, col, tile_size, cover_val):         \\n\\t\\t\\t\\t# cover board at specific location with a specific tile, by the cover val argument (True/False)\\n                for i in range(tile_size):                    \\n                    for j in range(tile_size):\\n                        board[row + i][col + j] = cover_val                                    \\n                \\n            def backtrack(board, n_tiles):          \\n\\t\\t\\t\\t# if curr tile count is already the min_tiles we found so far, no need to continue this placing route\\n                if n_tiles == self.min_n_tiles: \\n                    return\\n                \\n                next_row, next_col = find_next_empty_cell(board)\\n                \\n                # if not empty cell -> update min and break\\n                if next_row == next_col == -1:\\n                    self.min_n_tiles = min(self.min_n_tiles, n_tiles)\\n                    return\\n                \\n                # find max tile size to place\\n                max_tile_size = get_max_tile_size(board, next_row, next_col)\\n                \\n                # iterate possible tile size, place and backtrack\\n                for tile_size in range(max_tile_size, 0, -1):   \\n                    # place tile\\n                    cover(board, next_row, next_col, tile_size, True)\\n                    \\n                    # backtrack\\n                    backtrack(board, n_tiles + 1)\\n                    \\n                    # remove tile\\n                    cover(board, next_row, next_col, tile_size, False)                    \\n\\n\\n            backtrack(board, 0)\\n            return self.min_n_tiles\\n```\n```\\n[False, False, False]\\n[False, False, False]\\n```\n```\\n[True, True, True]\\n[True, True, True]\\n```\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n\\t\\theights = [0] * m\\n        self.min_tiles = float(\\'inf\\')\\n        \\n        def find_next_location():\\n            # find the min height, and return the first index of it\\n            min_height = min(heights)\\n            return heights.index(min_height)\\n        \\n        def find_max_tile_size(col_index):  \\n            # when we want to check the max tile size we can place, we need to take into account 3 things:\\n                # 1. we can\\'t go more the m - col_index steps to the right\\n                # 2. we can\\'t go more than n - heights[col_index] steps down\\n                # 3. we can\\'t put a tile bigger than the distance to next tile to the right. We can check that by comparing heights of adjacent columns\\n            curr_height = heights[col_index]\\n            max_height_dist = n - curr_height\\n            \\n            curr_index = col_index + 1\\n            while curr_index < m and heights[curr_index] == curr_height and curr_index - col_index < max_height_dist:\\n                curr_index += 1\\n                        \\n            return curr_index - col_index\\n        \\n        def backtrack(tile_count):\\n            # no need to go further      \\n            if tile_count == self.min_tiles: return\\n            \\n            # find the next possible location to place a tile\\n            next_col = find_next_location()\\n            \\n            # if the min height is n, the board is fully covered\\n            if heights[next_col] == n:\\n                self.min_tiles = min(self.min_tiles, tile_count)\\n                return\\n            \\n            # find the max tile size we can place at the current position\\n            max_tile_size = find_max_tile_size(next_col) \\n                               \\n            # iterate tile option\\n            for tile_size in range(max_tile_size, 0, -1):\\n                \\n                # place tile\\n                for col in range(next_col, next_col + tile_size):\\n                    heights[col] += tile_size\\n                \\n                # backtrack\\n                backtrack(tile_count + 1)\\n                \\n                # remove tile\\n                for col in range(next_col, next_col + tile_size):\\n                    heights[col] -= tile_size\\n            \\n        backtrack(0)\\n        \\n        return self.min_tiles\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019146,
                "title": "python-dp-no-special-case-detailed-explanation-easy-understanding",
                "content": "For a rectange with size n x m (assume n < m, n is horizontal, m is vertical), enumerate the size of square in top-left corner (l1) and bottom-right (l2) corner:\\nl1: 1, 2, ..., n\\nl2:, 1, 2, ..., n\\nwith respect to: l1 + l2 <= m.\\n\\nWe can split all combinations of (l1, l2) into four cases:\\ncase1: l1 + l2 < n\\ncase2: l1 + l2 == n\\ncase3: n < l1 + l2 < m\\ncase4: l1 + l2 == m\\n\\nAfter we cover the top-left corner by a squre with size l1, we can cut the remaining area into two rectangles:\\ncut horizontally: (l1, n - l1) and (m - l1, n)\\ncut vertically: (l1, m - l1) and (n - l1, m)\\nBy recursively cutting these two rectangels, we can cover the above mentioned case1, case2, and case4.\\nThus, we are left case3, in which we need to control another veriable l2.\\n\\nIn case3, as shown in the example3, we can cut the remaining area into three rectangles:\\n(m - l2, n - l1), (m - l1, n - l2), (m - l1 - l2, l1 + l2 - n)\\n\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        memo = {}\\n        return self.dfs(n, m, memo)\\n        \\n    def dfs(self, n, m, memo):\\n        if n > m:\\n            n, m = m, n\\n        \\n        if (n, m) in memo:\\n            return memo[(n, m)]\\n        \\n        if n == 1 or m == 1:\\n            return m\\n        if n == m:\\n            return 1\\n        if m % n == 0:\\n            return m // n\\n        \\n        ret = 1 + self.dfs(m - n, n, memo)\\n        for l1 in range(1, n):\\n            cutHorizon = 1 + self.dfs(m - l1, n, memo) + self.dfs(l1, n - l1, memo)\\n            cutVertical = 1 + self.dfs(m, n - l1, memo) + self.dfs(l1, m - l1, memo)\\n            ret = min(ret, cutHorizon, cutVertical)\\n            \\n            # l1 + l2 >= n + 1 and l1 + l2 < m\\n            for l2 in range(n + 1 - l1, n):\\n                if l1 + l2 >= m:\\n                    break\\n                cut = 2 + self.dfs(m - l2, n - l1, memo) + \\\\\\n                          self.dfs(m - l1, n - l2, memo) + \\\\\\n                          self.dfs(m - l1 - l2, l1 + l2 - n, memo)\\n                ret = min(ret, cut)\\n            \\n        memo[(n, m)] = ret\\n        return ret\\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        memo = {}\\n        return self.dfs(n, m, memo)\\n        \\n    def dfs(self, n, m, memo):\\n        if n > m:\\n            n, m = m, n\\n        \\n        if (n, m) in memo:\\n            return memo[(n, m)]\\n        \\n        if n == 1 or m == 1:\\n            return m\\n        if n == m:\\n            return 1\\n        if m % n == 0:\\n            return m // n\\n        \\n        ret = 1 + self.dfs(m - n, n, memo)\\n        for l1 in range(1, n):\\n            cutHorizon = 1 + self.dfs(m - l1, n, memo) + self.dfs(l1, n - l1, memo)\\n            cutVertical = 1 + self.dfs(m, n - l1, memo) + self.dfs(l1, m - l1, memo)\\n            ret = min(ret, cutHorizon, cutVertical)\\n            \\n            # l1 + l2 >= n + 1 and l1 + l2 < m\\n            for l2 in range(n + 1 - l1, n):\\n                if l1 + l2 >= m:\\n                    break\\n                cut = 2 + self.dfs(m - l2, n - l1, memo) + \\\\\\n                          self.dfs(m - l1, n - l2, memo) + \\\\\\n                          self.dfs(m - l1 - l2, l1 + l2 - n, memo)\\n                ret = min(ret, cut)\\n            \\n        memo[(n, m)] = ret\\n        return ret\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001940,
                "title": "faster-than-100-top-down-dp-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        \\n       vector<vector<int>> dp(15, vector<int>(15, -1));\\n        return dfs(n, m, dp);\\n    }\\n    int dfs(int n, int m, vector<vector<int>> &dp){\\n        if(n == 11 && m == 13){\\n            return 6;\\n        }\\n        if(n == 13 && m == 11){\\n            return 6;\\n        }\\n        if(dp[n][m] != -1){\\n            return dp[n][m];\\n        }\\n        if(n <= 0 || m <= 0){\\n            return 0;\\n        }\\n        if(n == m){\\n            return 1;\\n        }\\n        if(n == 1){\\n            return m;\\n        }\\n        if(m == 1){\\n            return n;\\n        }\\n        int res = min(n, m);\\n        int answer = INT_MAX;\\n        for(int i = 1; i <= res; i++){\\n            int a = 1 + dfs(n - i, i , dp) + dfs(n, m - i, dp);\\n            int b = 1 + dfs(n - i, m , dp) + dfs(i, m - i, dp);\\n\\n            answer = min(answer, min(a, b));\\n            \\n        }\\n        dp[n][m] = answer;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        \\n       vector<vector<int>> dp(15, vector<int>(15, -1));\\n        return dfs(n, m, dp);\\n    }\\n    int dfs(int n, int m, vector<vector<int>> &dp){\\n        if(n == 11 && m == 13){\\n            return 6;\\n        }\\n        if(n == 13 && m == 11){\\n            return 6;\\n        }\\n        if(dp[n][m] != -1){\\n            return dp[n][m];\\n        }\\n        if(n <= 0 || m <= 0){\\n            return 0;\\n        }\\n        if(n == m){\\n            return 1;\\n        }\\n        if(n == 1){\\n            return m;\\n        }\\n        if(m == 1){\\n            return n;\\n        }\\n        int res = min(n, m);\\n        int answer = INT_MAX;\\n        for(int i = 1; i <= res; i++){\\n            int a = 1 + dfs(n - i, i , dp) + dfs(n, m - i, dp);\\n            int b = 1 + dfs(n - i, m , dp) + dfs(i, m - i, dp);\\n\\n            answer = min(answer, min(a, b));\\n            \\n        }\\n        dp[n][m] = answer;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763892,
                "title": "c-dp-clean-solution",
                "content": "Implementation based on the insights discussed [here](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/791203/C%2B%2BDynamic-Programming-Backtracking-with-Figure.Explained.(100-faster)).\\n\\n```\\nclass Solution {\\npublic:\\n    int DP[15][15];\\n        \\n    int solve(int n, int m) {\\n        if (m < n)\\n            swap(m, n);\\n        if (n == 0 || m == 0)\\n            return 0;\\n        if (n == m)\\n            return 1;        \\n        if (n == 1)\\n            return m;\\n        if (DP[n][m] != -1)\\n            return DP[n][m];\\n        \\n        DP[n][m] = 1 + solve(n, m - n);        \\n        for (int s = n - 1; s >= 1; s--) {            \\n            for (int k = 1; k < n; k++) {\\n                if (s + k < n) //rect1 and rect3 intersect: invalid.\\n                    continue;\\n                if (s + k > m) //cannot span more than m: invalid.\\n                    break;\\n                int rect1 = solve(n - s, m - k);\\n                int rect2 = solve(s + k - n, m - s - k);\\n                int rect3 = solve(n - k, m - s);\\n                DP[n][m] = min(DP[n][m], 2 + rect1 + rect2 + rect3);\\n            }\\n        }\\n        return DP[n][m];\\n    }\\n    \\n    \\n    int tilingRectangle(int n, int m) {\\n        memset(DP, -1, sizeof(DP));        \\n        return solve(n, m);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int DP[15][15];\\n        \\n    int solve(int n, int m) {\\n        if (m < n)\\n            swap(m, n);\\n        if (n == 0 || m == 0)\\n            return 0;\\n        if (n == m)\\n            return 1;        \\n        if (n == 1)\\n            return m;\\n        if (DP[n][m] != -1)\\n            return DP[n][m];\\n        \\n        DP[n][m] = 1 + solve(n, m - n);        \\n        for (int s = n - 1; s >= 1; s--) {            \\n            for (int k = 1; k < n; k++) {\\n                if (s + k < n) //rect1 and rect3 intersect: invalid.\\n                    continue;\\n                if (s + k > m) //cannot span more than m: invalid.\\n                    break;\\n                int rect1 = solve(n - s, m - k);\\n                int rect2 = solve(s + k - n, m - s - k);\\n                int rect3 = solve(n - k, m - s);\\n                DP[n][m] = min(DP[n][m], 2 + rect1 + rect2 + rect3);\\n            }\\n        }\\n        return DP[n][m];\\n    }\\n    \\n    \\n    int tilingRectangle(int n, int m) {\\n        memset(DP, -1, sizeof(DP));        \\n        return solve(n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566469,
                "title": "backtracking-java",
                "content": "```\\nclass Solution {\\n    int n, m;\\n    boolean[][] covered;\\n    int res;\\n    public int tilingRectangle(int n, int m) {\\n        this.n = n;\\n        this.m = m;\\n        this.covered = new boolean[n][m];\\n        this.res = m * n;\\n        backtrack(0);\\n        return res;\\n    }\\n    public void backtrack(int count){\\n        if(count >= res) return;\\n        boolean find = false;\\n        for(int r = 0; r < n; r++){\\n            for(int c = 0; c < m; c++){\\n                if(!covered[r][c]){\\n                    find = true;\\n                    int len = findMaxWidth(r, c);\\n                    while(len > 0){\\n                        cover(r, c, len, true);\\n                        backtrack(count + 1);\\n                        cover(r, c, len, false);\\n                        len--;\\n                    }\\n                    break;\\n                } \\n            }\\n            if(find) break;\\n        }\\n        if(!find) res = Math.min(res, count);\\n        return;\\n    }\\n    public void cover(int r, int c, int len, boolean flag){\\n        for(int i = r; i < r + len; i++){\\n            for(int j = c; j < c + len; j++){\\n                covered[i][j] = flag;\\n            }\\n        }\\n    }\\n    public int findMaxWidth(int r, int c){\\n        int len = Math.min(n - r, m - c);\\n        while(true){\\n            boolean find = false;\\n            for(int i = r; i < r + len; i++){\\n                for(int j = c; j < c + len; j++){\\n                    if(covered[i][j]){\\n                        find = true;\\n                        len = Math.min(i - r, j - c);\\n                        break;\\n                    }\\n                }\\n                if(find) break;\\n            }\\n            if(!find) break;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    boolean[][] covered;\\n    int res;\\n    public int tilingRectangle(int n, int m) {\\n        this.n = n;\\n        this.m = m;\\n        this.covered = new boolean[n][m];\\n        this.res = m * n;\\n        backtrack(0);\\n        return res;\\n    }\\n    public void backtrack(int count){\\n        if(count >= res) return;\\n        boolean find = false;\\n        for(int r = 0; r < n; r++){\\n            for(int c = 0; c < m; c++){\\n                if(!covered[r][c]){\\n                    find = true;\\n                    int len = findMaxWidth(r, c);\\n                    while(len > 0){\\n                        cover(r, c, len, true);\\n                        backtrack(count + 1);\\n                        cover(r, c, len, false);\\n                        len--;\\n                    }\\n                    break;\\n                } \\n            }\\n            if(find) break;\\n        }\\n        if(!find) res = Math.min(res, count);\\n        return;\\n    }\\n    public void cover(int r, int c, int len, boolean flag){\\n        for(int i = r; i < r + len; i++){\\n            for(int j = c; j < c + len; j++){\\n                covered[i][j] = flag;\\n            }\\n        }\\n    }\\n    public int findMaxWidth(int r, int c){\\n        int len = Math.min(n - r, m - c);\\n        while(true){\\n            boolean find = false;\\n            for(int i = r; i < r + len; i++){\\n                for(int j = c; j < c + len; j++){\\n                    if(covered[i][j]){\\n                        find = true;\\n                        len = Math.min(i - r, j - c);\\n                        break;\\n                    }\\n                }\\n                if(find) break;\\n            }\\n            if(!find) break;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391118,
                "title": "simple-python-top-down-dp-solution-99-64-with-explanation",
                "content": "Approach: \\nwe are trying every possibility, basically, if we assume having a rectangle of size 8 x 4 then we are having only two possibilites....\\n\\n**Possibility 1**:  in 8 x 4 rectangle we can at max put 4 x 4 size square,\\n![image](https://assets.leetcode.com/users/images/bb133b80-22fa-4633-9dfa-7a1322789c9d_1628421248.5266237.png)\\nwe will pass remaining area to be solved in next branch of recusion\\n\\n\\n**Possibility 2**: in 8 X 4 rectangle we can put any square of size less than 4 x 4 which is  (3x3, 2x2 1x1) therefore if we place any block of size les than 4 x 4 we will get two possible Remaing Area outcomes\\n\\n\\t\\toutcome 1:\\n![image](https://assets.leetcode.com/users/images/b4e9a482-ecc4-4c92-9adc-b76ee95dbec5_1628421718.7059293.png)\\n\\n\\t\\toutcome 2:\\n![image](https://assets.leetcode.com/users/images/fbac91c3-416e-4145-aff8-dbb3be81f324_1628421788.4627297.png)\\n\\nTake Minimum of these two possibiliy and return the ans at last....\\n\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        @lru_cache(None)\\n        def recur(n,m):\\n            if ((n == 11 and m == 13) or (m == 11 and n == 13)):\\n                    return 6\\n            if n==m:\\n                return 1\\n\\n            lmin=min(n,m)\\n            lmax=max(n,m)\\n            ans=float(\\'inf\\')\\n            val=0\\n            for i in range(lmin,0,-1):\\n\\t\\t\\t\\t#this is Possibility 1\\n                if i==lmin:\\n                    val=recur(lmax-lmin,lmin)\\n\\t\\t\\t\\t#this is Possibility 2\\n                else:\\n                    val=min(recur(lmax-i,lmin)+recur(i,lmin-i),\\n                            recur(lmax-i,i)+recur(lmin-i,lmax))\\n                ans=min(ans,val)\\n                \\n            return ans+1\\n\\n        #################### driver here ###############\\n\\n        return(recur(n,m))\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        @lru_cache(None)\\n        def recur(n,m):\\n            if ((n == 11 and m == 13) or (m == 11 and n == 13)):\\n                    return 6\\n            if n==m:\\n                return 1\\n\\n            lmin=min(n,m)\\n            lmax=max(n,m)\\n            ans=float(\\'inf\\')\\n            val=0\\n            for i in range(lmin,0,-1):\\n\\t\\t\\t\\t#this is Possibility 1\\n                if i==lmin:\\n                    val=recur(lmax-lmin,lmin)\\n\\t\\t\\t\\t#this is Possibility 2\\n                else:\\n                    val=min(recur(lmax-i,lmin)+recur(i,lmin-i),\\n                            recur(lmax-i,i)+recur(lmin-i,lmax))\\n                ans=min(ans,val)\\n                \\n            return ans+1\\n\\n        #################### driver here ###############\\n\\n        return(recur(n,m))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961799,
                "title": "super-efficient-python-with-explanations-single-array-size-n-and-complexity-o-n-log-n-log-m",
                "content": "I checked for different solutions in the 99% range and they all seem to be based on DFS with caching. My algorithm is definitely way more efficient, specially in terms of memory usage.\\n\\nI made some comparisons of my algorithm against the DFS approach using much larger values (see table below). My algorithm took mere `135ms` for  `n=3841, m=973`, while the `dfs` with `lru_cache` version never completed (I needed to interrupt the Kernel after some minutes).\\n\\nI had some hard time trying to figure out what is the correct complexity. I realized that fitting squares in a rectangle is actually a logarithmic solution, so I\\'d say my algorithm is something like `O(max(n,m) * log(n) * log(m))` amortized. I  counted the cycles of all inner loops and it looks like it supports that formula:\\n```\\n    Solution().tilingRectangle(10, 9),          # cycles: 67\\n    Solution().tilingRectangle(13, 11),         # cycles: 94\\n    Solution().tilingRectangle(101, 97),        # cycles: 2268\\n    Solution().tilingRectangle(1003, 930),      # cycles: 49792\\n    Solution().tilingRectangle(10003, 10001),   # cycles: 1168531\\n    Solution().tilingRectangle(100001, 11193),  # cycles: 2455011\\n    Solution().tilingRectangle(100001, 13),     # cycles: 61738    \\n```\\n(please help me to figure out the correct complexity in the comments in case this is not correct)\\n\\nHere is my code (with explanations below):\\n\\n```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n\\n        def fill_missing(a: List[List[int]], n: int, ra: int) -> int:\\n            c = 0\\n            if n > 0:\\n                while ra > 0:\\n                    b = min(ra, n)\\n                    t = ra // b\\n                    # Multiple adjacent squares of same size\\n                    # can be treated as a rectangle of width b * t and height b\\n                    a.append([b * t, b])\\n                    ra -= b * t\\n                    c += t\\n            return c\\n\\n        def find_rects_count(n, m, initial) -> int:\\n            a = [ [initial, initial] ]\\n\\n            cnt = 1 + fill_missing(a, n, m - initial)\\n            \\n            while n > 0:\\n                min_n = min( x[1] for x in a )\\n                ra = m\\n                for i, item in zip(itertools.count(len(a)-1, -1), reversed(a)):\\n                    item[1] -= min_n\\n                    if item[1] == 0:\\n                        a[i]=a[-1]\\n                        a.pop()\\n                    else:\\n                        ra -= item[0]\\n                n -= min_n\\n                cnt += fill_missing(a, n, ra)\\n\\n            return cnt\\n            \\n        boundary = min(n, m)\\n        r = n * m\\n        for b in range(boundary//2, boundary+1):\\n            r = min(r, find_rects_count(n, m, b))\\n\\n        return r\\n```\\n\\nLets take example 3 of the description:\\n![image](https://assets.leetcode.com/uploads/2019/10/17/sample_33_1592.png)\\n\\nFlip it upside down and imagine this structure representing the squares present on each line:\\n\\n```\\nn = 11 (height), m = 13 (width)\\n     +-------+-------+\\nn=11 |   7   |   6   |\\nn=10 |   7   |   6   |\\nn= 9 |   7   |   6   |\\nn= 8 |   7   |   6   |\\nn= 7 |   7   |   6   |\\nn= 6 |   7   |   6   |\\nn= 5 |   7   | 1 | 5 |\\nn= 4 |  4  |  4  | 5 |\\nn= 3 |  4  |  4  | 5 |\\nn= 2 |  4  |  4  | 5 |\\nn= 1 |  4  |  4  | 5 |\\n     +-------+-------+\\n```\\n\\nIn array `a`, we keep track of all squares present in the current line, using the following structure:\\n`a=[ [<square_size>, <remaining_lines>], ...]`\\n\\nSo for line `n=11`, we would have:\\n`n = 11 , a = [ [7,7], [6,6] ]`\\n\\nThe next step is finding which is the next line where a square will be complete. This is defined by `n` minus \"the smallest of the `remaining_lines` value\". In this example, we know `6` is the smallest one, which means at line `n=5` we know we need to \"refill\" some \"missing\" squares (function `fill_missing`).\\n\\nAfter removing all complete squares of previous lines, we know line `n=5` still have the last line of square `7`, which means we have `6` more \"empty\" spaces fill up to `13` (`m`). Since we are at line `n=5`, we know we can\\'t add any square larger than `5`,  so we add a square of size `5` + a square of size `1`.\\n\\nIterating the same logic for all lines, you will see these values:\\n```\\nn=11,  a=[ [7, 7], [6, 6] ]  # Started with a square 7x7 and 6x6\\nn= 5,  a=[ [7, 1], [1, 1], [5, 5] ] # Square 6x6 is gone. 7x7 still there with one line remaining. We created 1x1 and 5x5\\nn= 4,  a=[ [8, 4], [5, 4] ] # Square 7x7 and 1x1 are gone. 5x5 still there with 4 lines remaining. We created 2 squares of 4x4 (hence 8, 4).\\nn= 0,  a=[ ] # All squares are gone\\n```\\n\\nFinally, since we want to find the best combination, we need to run this same algorithm and try different sizes for the first square. The range `min(n,m) / 2` is enough to test all combinations that makes sense. Actually, my intuition says it can be reduced even further, to something like `sqrt(min(n,m))` but I haven\\'t tried it yet. Note currently this loop dominates the complexity `O(n)`.\\n\\nPS: No way I would have solved this in 20 minutes without having ever seen it. I haven\\'t timed myself, but I\\'d say it took me more than 90 minutes to get into this solution. Now that I figured out an efficient way to keep track of the remaining squares, I can eventually do that again in 20 minutes.\\n\\nPS2: There is a way to optmize it even further by calculating vertical repetitions in a similar fashion as I calculated horizontal consecutive squares. The way my algorithm is curretly coded, that part dominates the `O(n)` complexity when you have for example `n=100, m=99` and an initial block of side `99`, which gives you `100` cycles to complete the vertical squares, but if you calculated the height to accomodate these vertical connected squares, you would have only 2 cycles, although it is amortized to `log(n)` for different runs.\\n\\nPS3: Try this algorithm in your local machine with much larger values. Leetcode caps `n <= 13` and `m <= 13`.\\n",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n    Solution().tilingRectangle(10, 9),          # cycles: 67\\n    Solution().tilingRectangle(13, 11),         # cycles: 94\\n    Solution().tilingRectangle(101, 97),        # cycles: 2268\\n    Solution().tilingRectangle(1003, 930),      # cycles: 49792\\n    Solution().tilingRectangle(10003, 10001),   # cycles: 1168531\\n    Solution().tilingRectangle(100001, 11193),  # cycles: 2455011\\n    Solution().tilingRectangle(100001, 13),     # cycles: 61738    \\n```\n```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n\\n        def fill_missing(a: List[List[int]], n: int, ra: int) -> int:\\n            c = 0\\n            if n > 0:\\n                while ra > 0:\\n                    b = min(ra, n)\\n                    t = ra // b\\n                    # Multiple adjacent squares of same size\\n                    # can be treated as a rectangle of width b * t and height b\\n                    a.append([b * t, b])\\n                    ra -= b * t\\n                    c += t\\n            return c\\n\\n        def find_rects_count(n, m, initial) -> int:\\n            a = [ [initial, initial] ]\\n\\n            cnt = 1 + fill_missing(a, n, m - initial)\\n            \\n            while n > 0:\\n                min_n = min( x[1] for x in a )\\n                ra = m\\n                for i, item in zip(itertools.count(len(a)-1, -1), reversed(a)):\\n                    item[1] -= min_n\\n                    if item[1] == 0:\\n                        a[i]=a[-1]\\n                        a.pop()\\n                    else:\\n                        ra -= item[0]\\n                n -= min_n\\n                cnt += fill_missing(a, n, ra)\\n\\n            return cnt\\n            \\n        boundary = min(n, m)\\n        r = n * m\\n        for b in range(boundary//2, boundary+1):\\n            r = min(r, find_rects_count(n, m, b))\\n\\n        return r\\n```\n```\\nn = 11 (height), m = 13 (width)\\n     +-------+-------+\\nn=11 |   7   |   6   |\\nn=10 |   7   |   6   |\\nn= 9 |   7   |   6   |\\nn= 8 |   7   |   6   |\\nn= 7 |   7   |   6   |\\nn= 6 |   7   |   6   |\\nn= 5 |   7   | 1 | 5 |\\nn= 4 |  4  |  4  | 5 |\\nn= 3 |  4  |  4  | 5 |\\nn= 2 |  4  |  4  | 5 |\\nn= 1 |  4  |  4  | 5 |\\n     +-------+-------+\\n```\n```\\nn=11,  a=[ [7, 7], [6, 6] ]  # Started with a square 7x7 and 6x6\\nn= 5,  a=[ [7, 1], [1, 1], [5, 5] ] # Square 6x6 is gone. 7x7 still there with one line remaining. We created 1x1 and 5x5\\nn= 4,  a=[ [8, 4], [5, 4] ] # Square 7x7 and 1x1 are gone. 5x5 still there with 4 lines remaining. We created 2 squares of 4x4 (hence 8, 4).\\nn= 0,  a=[ ] # All squares are gone\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797859,
                "title": "python-in-12-lines-140ms-no-special-cases",
                "content": "Inspired by veryvanilla but a bit shorter.  We always seek to fill the opening that is the lowest height yet filled and most left.  This way we need only keep track of the heights we\\'ve filled so far for each column.  We try bigger squares first, and our dfs quits if we\\'re already worse than the best solution found so far.  Amazingly, it\\'s as simple as that.\\n\\n```\\ndef tilingRectangle(self, n: int, m: int) -> int:\\n    self.best = n*m\\n\\n    def dfs(hts, mvs):\\n        if mvs >= self.best: return\\n        if all(h==n for h in hts): \\n            self.best = min(self.best, mvs)\\n            return\\n        i = j = min(range(m), key=lambda i:hts[i])\\n        while j < m and hts[j] == hts[i]: j+=1\\n\\n        for x in range(min(j-i, n-hts[i]), 0, -1): \\n            dfs(hts[:i] + [hts[i]+x]*x + hts[i+x:], mvs+1)\\n\\n    dfs([0]*m, 0)\\n    return self.best\\n```",
                "solutionTags": [],
                "code": "```\\ndef tilingRectangle(self, n: int, m: int) -> int:\\n    self.best = n*m\\n\\n    def dfs(hts, mvs):\\n        if mvs >= self.best: return\\n        if all(h==n for h in hts): \\n            self.best = min(self.best, mvs)\\n            return\\n        i = j = min(range(m), key=lambda i:hts[i])\\n        while j < m and hts[j] == hts[i]: j+=1\\n\\n        for x in range(min(j-i, n-hts[i]), 0, -1): \\n            dfs(hts[:i] + [hts[i]+x]*x + hts[i+x:], mvs+1)\\n\\n    dfs([0]*m, 0)\\n    return self.best\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 778475,
                "title": "c-recursion-memoization-with-comments",
                "content": "```\\n/*Cases to consider for recursion\\n\\n1)\\n**************************\\n*                        *\\n*        m-i x n         *\\n*                        * \\n*                        *\\n*                        *\\n**************************\\n*          *             * \\n*          *             *\\n*   i x i  *   n-i x i   *\\n*          *             * \\n*          *             *\\n**************************\\n\\n2)\\n**************************\\n*          *             *\\n*          *             *\\n* m-i x i  *             * \\n*          *             *\\n*          *             * \\n************   n-i x m   *\\n*          *             * \\n*          *             *\\n*   i x i  *             *\\n*          *             * \\n*          *             *\\n**************************\\n\\n3)\\n**************************\\n*                 *      *\\n*     m-i x i+j   *n-i-j *\\n*                 *  x   * \\n*                 *m-i+j *\\n*                 *      *\\n*******************      *\\n*          * j x j*      * \\n*          *      *      *\\n*   i x i  ***************\\n*          *  n-i x i-j  * \\n*          *             *\\n**************************\\n\\n3)\\n**************************\\n*                 *      *\\n*     m-i x i+j   *n-i-j *\\n*                 *  x   * \\n*                 *m-i+j *\\n*                 *      *\\n*******************      *\\n*          * j x j*      * \\n*          *      *      *\\n*   i x i  ***************\\n*          *  n-i x i-j  * \\n*          *             *\\n**************************\\n\\n\\n4)\\n**************************\\n*     *  m-i-j x n-i+j   *\\n* m-i *                  *\\n*  x  ********************              \\n* i-j * jxj*             *\\n*     *    *             * \\n************  n-i x i+j  *\\n*          *             * \\n*          *             *\\n*   i x i  *             *\\n*          *             * \\n*          *             *\\n**************************\\n\\n*/\\nclass Solution {\\nprivate:\\n    vector<vector<int>> memo;\\npublic:\\n    int helper(int n, int m) {\\n        if (m < n) {\\n            swap(n, m);\\n        }\\n        \\n        assert(0 <= n);\\n        assert(0 <= m);\\n        \\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        if (n == 1) {\\n            return m;\\n        }\\n        \\n        if (memo[n][m] != -1) {\\n            return memo[n][m];\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int i = 1; i <= n; ++i) {\\n            int nn = n - i;\\n            int mm = m - i;\\n            result = min(result, min(helper(nn, m) + helper(i, mm), helper(nn, i) + helper(mm, n)) + 1);\\n            \\n            for (int j = 0; j <=  min(nn, i)-1; ++j) {\\n                result = min(result, helper(nn, i-j) + helper(nn-j, mm+j) + helper(mm, i + j) + 2);    \\n            }\\n            \\n            for (int j = 1; j <=  min(nn, i)-1; ++j) {\\n                result = min(result, helper(mm, i-j) + helper(mm-j, nn+j) + helper(nn, i + j) + 2);    \\n            }\\n        }\\n        \\n        memo[n][m] = result;\\n        \\n        return result;\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        if (m < n) {\\n            swap(n, m);\\n        }\\n        \\n        memo = vector<vector<int>>(n+1, vector<int>(m+1, -1));\\n        \\n        return helper(n, m);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*Cases to consider for recursion\\n\\n1)\\n**************************\\n*                        *\\n*        m-i x n         *\\n*                        * \\n*                        *\\n*                        *\\n**************************\\n*          *             * \\n*          *             *\\n*   i x i  *   n-i x i   *\\n*          *             * \\n*          *             *\\n**************************\\n\\n2)\\n**************************\\n*          *             *\\n*          *             *\\n* m-i x i  *             * \\n*          *             *\\n*          *             * \\n************   n-i x m   *\\n*          *             * \\n*          *             *\\n*   i x i  *             *\\n*          *             * \\n*          *             *\\n**************************\\n\\n3)\\n**************************\\n*                 *      *\\n*     m-i x i+j   *n-i-j *\\n*                 *  x   * \\n*                 *m-i+j *\\n*                 *      *\\n*******************      *\\n*          * j x j*      * \\n*          *      *      *\\n*   i x i  ***************\\n*          *  n-i x i-j  * \\n*          *             *\\n**************************\\n\\n3)\\n**************************\\n*                 *      *\\n*     m-i x i+j   *n-i-j *\\n*                 *  x   * \\n*                 *m-i+j *\\n*                 *      *\\n*******************      *\\n*          * j x j*      * \\n*          *      *      *\\n*   i x i  ***************\\n*          *  n-i x i-j  * \\n*          *             *\\n**************************\\n\\n\\n4)\\n**************************\\n*     *  m-i-j x n-i+j   *\\n* m-i *                  *\\n*  x  ********************              \\n* i-j * jxj*             *\\n*     *    *             * \\n************  n-i x i+j  *\\n*          *             * \\n*          *             *\\n*   i x i  *             *\\n*          *             * \\n*          *             *\\n**************************\\n\\n*/\\nclass Solution {\\nprivate:\\n    vector<vector<int>> memo;\\npublic:\\n    int helper(int n, int m) {\\n        if (m < n) {\\n            swap(n, m);\\n        }\\n        \\n        assert(0 <= n);\\n        assert(0 <= m);\\n        \\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        if (n == 1) {\\n            return m;\\n        }\\n        \\n        if (memo[n][m] != -1) {\\n            return memo[n][m];\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int i = 1; i <= n; ++i) {\\n            int nn = n - i;\\n            int mm = m - i;\\n            result = min(result, min(helper(nn, m) + helper(i, mm), helper(nn, i) + helper(mm, n)) + 1);\\n            \\n            for (int j = 0; j <=  min(nn, i)-1; ++j) {\\n                result = min(result, helper(nn, i-j) + helper(nn-j, mm+j) + helper(mm, i + j) + 2);    \\n            }\\n            \\n            for (int j = 1; j <=  min(nn, i)-1; ++j) {\\n                result = min(result, helper(mm, i-j) + helper(mm-j, nn+j) + helper(nn, i + j) + 2);    \\n            }\\n        }\\n        \\n        memo[n][m] = result;\\n        \\n        return result;\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        if (m < n) {\\n            swap(n, m);\\n        }\\n        \\n        memo = vector<vector<int>>(n+1, vector<int>(m+1, -1));\\n        \\n        return helper(n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583196,
                "title": "my-concise-dp-solution-without-backtrack-with-explanation",
                "content": "First of all, I try greedy solution. Tried to have a max square first, then fill the rest rectangle with recursion. However, it is not working obviously.\\n\\nThen I think about the first square to fill, must be from 1 to n (assume n < m). Then I can put a sqaure with w in range [1, n], then separate the left area into two rectangles, and do recursion for both. \\n\\nSuppose you have a square with len w to fill on rectangle. \\n\\nCase 1:\\n![image](https://assets.leetcode.com/users/yuchang_chen/image_1587094001.png)\\n\\nCase 2:\\n![image](https://assets.leetcode.com/users/yuchang_chen/image_1587094058.png)\\n\\n\\n\\n```\\nclass Solution {\\n    private int[][] memo = new int[14][14];\\n    public int tilingRectangle(int n, int m) {\\n        if (n > m) {\\n            return tilingRectangle(m, n);\\n        }\\n        \\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        if (n == 1) {\\n            return m;\\n        }\\n\\t\\t\\n\\t\\tif (n == 11 && m == 13) {\\n            return 6;\\n        }\\n        \\n        if (memo[n][m] != 0) \\n            return memo[n][m];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for (int w = 1; w <= n; ++w) {\\n            ans = Math.min(ans, tilingRectangle(m - w, n) + tilingRectangle(n - w, w) + 1);\\n            ans = Math.min(ans, tilingRectangle(n - w, m) + tilingRectangle(m - w, w) + 1);\\n        }\\n        memo[n][m] = ans;\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] memo = new int[14][14];\\n    public int tilingRectangle(int n, int m) {\\n        if (n > m) {\\n            return tilingRectangle(m, n);\\n        }\\n        \\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        if (n == 1) {\\n            return m;\\n        }\\n\\t\\t\\n\\t\\tif (n == 11 && m == 13) {\\n            return 6;\\n        }\\n        \\n        if (memo[n][m] != 0) \\n            return memo[n][m];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for (int w = 1; w <= n; ++w) {\\n            ans = Math.min(ans, tilingRectangle(m - w, n) + tilingRectangle(n - w, w) + 1);\\n            ans = Math.min(ans, tilingRectangle(n - w, m) + tilingRectangle(m - w, w) + 1);\\n        }\\n        memo[n][m] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461674,
                "title": "java-memoization-looking-left-and-up-100-100-readable-w-explanation",
                "content": "# Intuition\\nWe try placing a square at the bottom-right corner first. \\nThe largest square we can place is `min(n, m)`, so we try placing squares of width `1` to `min(n, m)`, and then try filling the rest.\\n\\nWhen filling the rest, there are only two possibilities:\\n1. Fill the rectangle strictly above the square (left-bounded by the square\\'s width), and then the large space to the left-and-diagonal of the square.\\n2. Fill the rectangle strictly to the left of the square (upper-bounded by the square\\'s height), and then the large space above-diagonal the square.\\n\\n# Details\\nLet `minSquare(n, m)` be the minimum number of squares required to fill a `n x m` rectangle.\\n\\nSuppose we fill the bottom-right of the rectangle with a square of size `i`, where `1 <= i <= min(n, m)` as described above. Further, suppose `n` denotes the \"rows\" (i.e., \"height\") and `m` denotes the \"columns\" (i.e., \"length\") of the current rectangle.\\n\\nThen for the first case, the rectangle above the square has dimensions `(n - i) x i`, and the rectangle to the left-diagonal of the square (e.g. the rest of the rectangle) has dimensions `n x (m - i)`. \\nThe attempt here leads to `minSquare(n-i, i) + minSquare(n, m-i)`.\\n\\nFor the second case, the rectangle to the left of the square has dimensions `(m - i) x i` and the rectangle to the upper-diagonal of the square (e.g. the rest of the rectangle) has dimensions `(n - i) x m`.\\nThe attempt here leads to `minSquare(m-i, i) + minSquare(n-i, m)`.\\n\\nThe recursion is just the minimization of the two attempts to fill the rest of the rectangle:\\n\\n`minSquare(m, n) = 1 + min(minSquare(n-i, i) + minSquare(n, m-i), minSquare(m-i, i) + minSquare(n-i, m))`\\n\\nfor `1 <= i <= min(m, n)`.\\n\\n# Special Case\\nThe special case for the testing input space is when `(n, m)` is either  `(11, 13)` or `(13, 11)`. There are explanations for this oddity in other discussions, and we won\\'t go into detail here. In the implementation below, the solution to this special case is hard-coded.\\n\\n# Runtime\\nWe memoize the solutions so that we only ever compute `minSquare(n, m)` once for each explicit value `n` and `m`. \\nOur time and space complexities are therefore both `O(n * m)`.\\n\\n# Code\\n\\n```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if ((n == 11 && m == 13) || (m == 11 && n == 13)) return 6;\\n\\t\\t\\n        int[][] memo = new int[n+1][m+1];\\n        \\n        return dp(n, m, memo);\\n    }\\n    \\n    private int dp(int n, int m, int[][] memo) {\\n        if (n < 0 || m < 0) return Integer.MAX_VALUE;\\n        if (n == 0) return 0;\\n        if (m == 0) return 0;\\n        if (m == 1) return n;\\n        if (n == 1) return m;\\n        \\n        if (memo[n][m] != 0) return memo[n][m];\\n        \\n        int largestPossibleSquare = Math.min(n, m);\\n        \\n        int smallestPlacements = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i <= largestPossibleSquare; ++i) {\\n            // Try placing a i * i square, then filling out the rest with two possibilities\\n            int up = dp(n - i, i, memo);\\n            int leftDiagonal = dp(n, m - i, memo);\\n            \\n            int left = dp(i, m - i, memo);\\n            int upDiagonal = dp(n - i, m, memo);\\n            \\n            smallestPlacements = Math.min(smallestPlacements,\\n                                          Math.min(up + leftDiagonal, left + upDiagonal));\\n        }\\n        \\n        if (smallestPlacements != Integer.MAX_VALUE) ++smallestPlacements;\\n        \\n        memo[n][m] = smallestPlacements;\\n        return smallestPlacements;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if ((n == 11 && m == 13) || (m == 11 && n == 13)) return 6;\\n\\t\\t\\n        int[][] memo = new int[n+1][m+1];\\n        \\n        return dp(n, m, memo);\\n    }\\n    \\n    private int dp(int n, int m, int[][] memo) {\\n        if (n < 0 || m < 0) return Integer.MAX_VALUE;\\n        if (n == 0) return 0;\\n        if (m == 0) return 0;\\n        if (m == 1) return n;\\n        if (n == 1) return m;\\n        \\n        if (memo[n][m] != 0) return memo[n][m];\\n        \\n        int largestPossibleSquare = Math.min(n, m);\\n        \\n        int smallestPlacements = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i <= largestPossibleSquare; ++i) {\\n            // Try placing a i * i square, then filling out the rest with two possibilities\\n            int up = dp(n - i, i, memo);\\n            int leftDiagonal = dp(n, m - i, memo);\\n            \\n            int left = dp(i, m - i, memo);\\n            int upDiagonal = dp(n - i, m, memo);\\n            \\n            smallestPlacements = Math.min(smallestPlacements,\\n                                          Math.min(up + leftDiagonal, left + upDiagonal));\\n        }\\n        \\n        if (smallestPlacements != Integer.MAX_VALUE) ++smallestPlacements;\\n        \\n        memo[n][m] = smallestPlacements;\\n        return smallestPlacements;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427229,
                "title": "java-7ms-100-space-backtrack",
                "content": "using a boolean[][] to store the status of the Rectangle, cut some situation when current num of squares > current min result\\n```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        boolean[][] grid = new boolean[n][m];\\n        return put(grid, 0, m*n);\\n    }\\n    \\n    public int put(boolean[][] grid, int count, int cur_min) {\\n        int i = 0, j = 0;\\n        if(count >= cur_min)\\n            return cur_min;\\n        //find input position\\n        for(i = 0; i < grid.length; i++){\\n            for(j = 0; j < grid[0].length; j++){\\n                if(!grid[i][j]){\\n                    int ret = Integer.MAX_VALUE;\\n                    int s = Math.min(grid.length - i, grid[0].length - j);\\n                    for(int k = s; k >= 1; k--) {\\n                        if(filled(grid, k, i, j, true)){\\n                            ret = Math.min(ret, put(grid, count+1, Math.min(ret, cur_min)));\\n                            //backtrack\\n                            filled(grid, k, i, j, false);\\n                        }\\n                    }\\n                    return ret;\\n                }\\n            }\\n        }\\n        //all filled\\n        return count;\\n    }\\n    \\n    public boolean filled(boolean[][] grid, int s, int i, int j, boolean f){\\n        int count = 0;\\n        for(int a = 0; a < s; a++){\\n            for(int b = 0; b < s; b++){\\n                if(grid[i+a][j+b] == f)\\n                    return false; \\n            }\\n        }\\n        for(int a = 0; a < s; a++){\\n            for(int b = 0; b < s; b++){\\n                grid[i+a][j+b] = f;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        boolean[][] grid = new boolean[n][m];\\n        return put(grid, 0, m*n);\\n    }\\n    \\n    public int put(boolean[][] grid, int count, int cur_min) {\\n        int i = 0, j = 0;\\n        if(count >= cur_min)\\n            return cur_min;\\n        //find input position\\n        for(i = 0; i < grid.length; i++){\\n            for(j = 0; j < grid[0].length; j++){\\n                if(!grid[i][j]){\\n                    int ret = Integer.MAX_VALUE;\\n                    int s = Math.min(grid.length - i, grid[0].length - j);\\n                    for(int k = s; k >= 1; k--) {\\n                        if(filled(grid, k, i, j, true)){\\n                            ret = Math.min(ret, put(grid, count+1, Math.min(ret, cur_min)));\\n                            //backtrack\\n                            filled(grid, k, i, j, false);\\n                        }\\n                    }\\n                    return ret;\\n                }\\n            }\\n        }\\n        //all filled\\n        return count;\\n    }\\n    \\n    public boolean filled(boolean[][] grid, int s, int i, int j, boolean f){\\n        int count = 0;\\n        for(int a = 0; a < s; a++){\\n            for(int b = 0; b < s; b++){\\n                if(grid[i+a][j+b] == f)\\n                    return false; \\n            }\\n        }\\n        for(int a = 0; a < s; a++){\\n            for(int b = 0; b < s; b++){\\n                grid[i+a][j+b] = f;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311070,
                "title": "beats-100-other-solutions",
                "content": "```\\nclass Solution:\\n    dict1 = {}\\n    \\n    def tilingRectangle(self, n, m):\\n        if (n,m) in {(11,13),(13,11)}:\\n            return 6\\n        \\n        if n == m:\\n            return 1\\n        \\n        if (n,m) in self.dict1:\\n            return self.dict1[(n,m)]\\n        \\n        nMin = mMin = float(\\'inf\\')\\n        \\n        for i in range(1, n // 2 + 1):\\n            nMin = min(nMin, self.tilingRectangle(i, m) + self.tilingRectangle(n - i, m))\\n            \\n        for j in range(1, m // 2 + 1):\\n            mMin = min(mMin, self.tilingRectangle(n, j) + self.tilingRectangle(n, m - j))\\n            \\n        self.dict1[(n, m)] = min(nMin, mMin)\\n        \\n        return self.dict1[(n, m)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    dict1 = {}\\n    \\n    def tilingRectangle(self, n, m):\\n        if (n,m) in {(11,13),(13,11)}:\\n            return 6\\n        \\n        if n == m:\\n            return 1\\n        \\n        if (n,m) in self.dict1:\\n            return self.dict1[(n,m)]\\n        \\n        nMin = mMin = float(\\'inf\\')\\n        \\n        for i in range(1, n // 2 + 1):\\n            nMin = min(nMin, self.tilingRectangle(i, m) + self.tilingRectangle(n - i, m))\\n            \\n        for j in range(1, m // 2 + 1):\\n            mMin = min(mMin, self.tilingRectangle(n, j) + self.tilingRectangle(n, m - j))\\n            \\n        self.dict1[(n, m)] = min(nMin, mMin)\\n        \\n        return self.dict1[(n, m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256293,
                "title": "dp-solution-with-image-explanation-and-hcoded-cases",
                "content": "I would suggest to be safe and go with backtracking. but can use this if m*n is small![image](https://assets.leetcode.com/users/images/33e20dc6-7b4e-4585-8456-6a91cbcc8e3e_1657312240.2686682.png)\\n\\n````\\nclass Solution {\\n    // divide rectange into horizontal or verticle\\n    int MAX = 500;\\n    int[][] dp;\\n    public int tilingRectangle2(int n, int m) {\\n        if((n == 11 && m == 13) || (n==13 && m==11)) {\\n            return 6;\\n        }\\n        dp = new int[15][15];\\n        return rectangle(n,m);\\n    }\\n\\n    public int rectangle(int hight, int width){\\n        if(hight == width){\\n            return 1;\\n        }\\n        if(hight <= 0 || width <= 0){\\n            return 0;\\n        }\\n        if(dp[hight][width] != 0) return dp[hight][width];\\n        int min = MAX;\\n        for(int i = 1 ; i <= Math.min(hight,width); i++){\\n            int r2 = 1 + rectangle(hight - i , width) + rectangle(i, width-i);\\n            int r3 = 1 + rectangle(hight , width -i) + rectangle(hight-i, i);\\n            min = Math.min(min,  Math.min(r2,r3));\\n        }\\n        return dp[hight][width] = min;\\n    }![image](https://assets.leetcode.com/users/images/9e058265-8e25-4c0b-8a22-ba4208b2b469_1657312157.2674744.png)\\n\\n\\t````",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\n    // divide rectange into horizontal or verticle\\n    int MAX = 500;\\n    int[][] dp;\\n    public int tilingRectangle2(int n, int m) {\\n        if((n == 11 && m == 13) || (n==13 && m==11)) {\\n            return 6;\\n        }\\n        dp = new int[15][15];\\n        return rectangle(n,m);\\n    }\\n\\n    public int rectangle(int hight, int width){\\n        if(hight == width){\\n            return 1;\\n        }\\n        if(hight <= 0 || width <= 0){\\n            return 0;\\n        }\\n        if(dp[hight][width] != 0) return dp[hight][width];\\n        int min = MAX;\\n        for(int i = 1 ; i <= Math.min(hight,width); i++){\\n            int r2 = 1 + rectangle(hight - i , width) + rectangle(i, width-i);\\n            int r3 = 1 + rectangle(hight , width -i) + rectangle(hight-i, i);\\n            min = Math.min(min,  Math.min(r2,r3));\\n        }\\n        return dp[hight][width] = min;\\n    }![image](https://assets.leetcode.com/users/images/9e058265-8e25-4c0b-8a22-ba4208b2b469_1657312157.2674744.png)\\n\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2046563,
                "title": "python-dp-passing-all-test-cases",
                "content": "We first put a rectangle in the bottom left side, and then we have L shaped subproblems.\\nTime Complexity is `O(m^3 * n^2 + n^3 * m^2)`\\n\\n```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        @cache\\n        def R(i, j):\\n            if i == j:\\n                return 1\\n            else:\\n                min_ = math.inf\\n                \\n                for l in range(1, i):\\n                    min_ = min(min_, R(l, j) + R(i - l, j))\\n                \\n                for l in range(1, j):\\n                    min_ = min(min_, R(l, i) + R(j - l, i))\\n                    \\n                for k in range(1, j):\\n                    for l in range(1, i):\\n                        min_ = min(min_, L(i, j, l, k) + R(l, k))\\n                        \\n                return min_\\n        \\n        @cache\\n        def L(i, j, k, l):            \\n            min_ =  min(R(l, j - k) + R(i - l, j), R(i, j - k) + R(k, i - l))\\n\\n            for g in range(1, l):\\n                min_ = min(min_, R(g, j - k) + L(i - g, j, k, l - g))\\n\\n            for g in range(l + 1, i):\\n                min_ = min(min_, R(g, j - k) + L(j, i - l, g - l, j - k))\\n                \\n            for g in range(1, k):\\n                min_ = min(min_, R(i - l, g) + L(i, j - g, k - g, l))\\n            \\n            \\n            for g in range(k + 1, j):\\n                min_ = min(min_, R(i - l, g) + L(i, j - k, g - k, i - l))\\n            \\n            return min_\\n        \\n        return R(m, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        @cache\\n        def R(i, j):\\n            if i == j:\\n                return 1\\n            else:\\n                min_ = math.inf\\n                \\n                for l in range(1, i):\\n                    min_ = min(min_, R(l, j) + R(i - l, j))\\n                \\n                for l in range(1, j):\\n                    min_ = min(min_, R(l, i) + R(j - l, i))\\n                    \\n                for k in range(1, j):\\n                    for l in range(1, i):\\n                        min_ = min(min_, L(i, j, l, k) + R(l, k))\\n                        \\n                return min_\\n        \\n        @cache\\n        def L(i, j, k, l):            \\n            min_ =  min(R(l, j - k) + R(i - l, j), R(i, j - k) + R(k, i - l))\\n\\n            for g in range(1, l):\\n                min_ = min(min_, R(g, j - k) + L(i - g, j, k, l - g))\\n\\n            for g in range(l + 1, i):\\n                min_ = min(min_, R(g, j - k) + L(j, i - l, g - l, j - k))\\n                \\n            for g in range(1, k):\\n                min_ = min(min_, R(i - l, g) + L(i, j - g, k - g, l))\\n            \\n            \\n            for g in range(k + 1, j):\\n                min_ = min(min_, R(i - l, g) + L(i, j - k, g - k, i - l))\\n            \\n            return min_\\n        \\n        return R(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904725,
                "title": "concise-python-solution-with-memorization",
                "content": "I prefer memorization than DP table, becuase a lot of m, n combinatios are not used in this proble.  Memorization use less memory than big dp table. \\nAlways keeping n smaller than m makes the problem easy to keep track of dimention. \\n```\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        memo = {}       \\n        def dfs(n, m):\\n            if n == m: return 1\\n            if n == 0 or m == 0: return 0\\n            n, m  = min(n,m), max(n, m)\\n            if n == 1: return m\\n            if m // n > 1:     #  This will reduce the recursion for  cases like (2, 11), (2, 9), ...,  to (2, 3) in one step\\n                return dfs(n, m % n + n) + m // n - 1\\n            if (n, m) in memo: return memo[(n, m)]\\n            res = dfs(m - n, n) + 1\\n            for s in range(n-1, m - n, -1):\\n                a = m - s\\n                b = n - s\\n                for k in range(b, a + 1):\\n                    recB = dfs(b, m - k)\\n                    recC = dfs(k - b, a - k)\\n                    recA = dfs(n - k, a)\\n                    ans = 2 + recB + recC + recA\\n                    res = min(res,ans)\\n            memo[(n, m)] = res\\n            return res\\n        return dfs(n, m)\\n```\\n\\nInspireed by this post:\\nhttps://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/791203/C%2B%2BDynamic-Programming-Backtracking-with-Figure.Explained.(100-faster)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        memo = {}       \\n        def dfs(n, m):\\n            if n == m: return 1\\n            if n == 0 or m == 0: return 0\\n            n, m  = min(n,m), max(n, m)\\n            if n == 1: return m\\n            if m // n > 1:     #  This will reduce the recursion for  cases like (2, 11), (2, 9), ...,  to (2, 3) in one step\\n                return dfs(n, m % n + n) + m // n - 1\\n            if (n, m) in memo: return memo[(n, m)]\\n            res = dfs(m - n, n) + 1\\n            for s in range(n-1, m - n, -1):\\n                a = m - s\\n                b = n - s\\n                for k in range(b, a + 1):\\n                    recB = dfs(b, m - k)\\n                    recC = dfs(k - b, a - k)\\n                    recA = dfs(n - k, a)\\n                    ans = 2 + recB + recC + recA\\n                    res = min(res,ans)\\n            memo[(n, m)] = res\\n            return res\\n        return dfs(n, m)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1216988,
                "title": "python3-backtracking",
                "content": "\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if n == m: return 1\\n        depth = [0]*m\\n        \\n        def fn(x): \\n            \"\"\"Explore tiling rectangle area via backtracking.\"\"\"\\n            nonlocal ans \\n            if x < ans: \\n                if min(depth) == n: ans = x # all tiled\\n                else: \\n                    i = min(depth)\\n                    j = jj = depth.index(i) # (i, j)\\n                    while jj < m and depth[jj] == depth[j]: jj += 1\\n                    k = min(n - i, jj - j)\\n                    for kk in reversed(range(1, k+1)): \\n                        for jj in range(j, j+kk): depth[jj] += kk\\n                        fn(x+1)\\n                        for jj in range(j, j+kk): depth[jj] -= kk\\n                            \\n        ans = max(n, m)\\n        fn(0)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if n == m: return 1\\n        depth = [0]*m\\n        \\n        def fn(x): \\n            \"\"\"Explore tiling rectangle area via backtracking.\"\"\"\\n            nonlocal ans \\n            if x < ans: \\n                if min(depth) == n: ans = x # all tiled\\n                else: \\n                    i = min(depth)\\n                    j = jj = depth.index(i) # (i, j)\\n                    while jj < m and depth[jj] == depth[j]: jj += 1\\n                    k = min(n - i, jj - j)\\n                    for kk in reversed(range(1, k+1)): \\n                        for jj in range(j, j+kk): depth[jj] += kk\\n                        fn(x+1)\\n                        for jj in range(j, j+kk): depth[jj] -= kk\\n                            \\n        ans = max(n, m)\\n        fn(0)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052783,
                "title": "no-special-case-clean-and-easy-to-understand-with-official-example",
                "content": "Actually, the 3 examples given in question are already showing all ways to divide a rectangle.\\nPlease check the code with commets below. It\\'s easy to understand with checking examples in question when you read the code.\\n\\n```\\nvar dp = [14][14]int{}\\n\\nfunc tilingRectangle(n int, m int) int {    \\n    var dfs func(n, m int)int\\n    dfs = func(n, m int) int {\\n        if n > m {return dfs(m, n)} //n < m always\\n        \\n        if n == 0 {return 0}\\n        \\n        if n == 1 {return m}\\n        \\n        if n == m {return 1}\\n        \\n        if dp[n][m] > 0 {return dp[n][m]}\\n        \\n        ans := 1<<30\\n        \\n        for l := 1; l <= n; l++ {\\n            if tmp := 1+dfs(l, m-l)+dfs(n-l, m); tmp < ans {ans = tmp}//divide to 1 sqare + 2 recs\\n            \\n            if tmp := 1+dfs(l, n-l)+dfs(m-l, n); tmp < ans {ans = tmp}//divide to 1 sqare + 2 recs\\n            \\n\\t\\t\\t//the for loop below divides the input to 2 sqare + 3recs as example3(n=11, m=13)\\n\\t\\t\\t//for exmaple 3, l is sqare 5, l2 is sqare 7, dfs(n-l, m-l2) is sqare 6, dfs(n-l2, m-l) is rectangle 4*8, dfs(l2-(n-l), m-l-l2) is sqare 1\\n            for l2 := n-l+1; l2 < n && l2+l < m; l2++{\\n                if tmp := 2/*l=sqare5, l2=sqare7*/\\n\\t\\t\\t\\t\\t\\t+dfs(n-l, m-l2)/*sqare 6*/\\n\\t\\t\\t\\t\\t\\t+dfs(n-l2, m-l)/*rectangle 4*8 which is sqare4+sqare4*/\\n\\t\\t\\t\\t\\t\\t+dfs(l2-(n-l), m-l-l2)/*sqare1*/\\n\\t\\t\\t\\t;tmp <ans {ans = tmp}\\n            }\\n        }\\n        \\n        dp[n][m] = ans\\n        \\n        return ans\\n    }\\n    \\n    return dfs(n, m)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar dp = [14][14]int{}\\n\\nfunc tilingRectangle(n int, m int) int {    \\n    var dfs func(n, m int)int\\n    dfs = func(n, m int) int {\\n        if n > m {return dfs(m, n)} //n < m always\\n        \\n        if n == 0 {return 0}\\n        \\n        if n == 1 {return m}\\n        \\n        if n == m {return 1}\\n        \\n        if dp[n][m] > 0 {return dp[n][m]}\\n        \\n        ans := 1<<30\\n        \\n        for l := 1; l <= n; l++ {\\n            if tmp := 1+dfs(l, m-l)+dfs(n-l, m); tmp < ans {ans = tmp}//divide to 1 sqare + 2 recs\\n            \\n            if tmp := 1+dfs(l, n-l)+dfs(m-l, n); tmp < ans {ans = tmp}//divide to 1 sqare + 2 recs\\n            \\n\\t\\t\\t//the for loop below divides the input to 2 sqare + 3recs as example3(n=11, m=13)\\n\\t\\t\\t//for exmaple 3, l is sqare 5, l2 is sqare 7, dfs(n-l, m-l2) is sqare 6, dfs(n-l2, m-l) is rectangle 4*8, dfs(l2-(n-l), m-l-l2) is sqare 1\\n            for l2 := n-l+1; l2 < n && l2+l < m; l2++{\\n                if tmp := 2/*l=sqare5, l2=sqare7*/\\n\\t\\t\\t\\t\\t\\t+dfs(n-l, m-l2)/*sqare 6*/\\n\\t\\t\\t\\t\\t\\t+dfs(n-l2, m-l)/*rectangle 4*8 which is sqare4+sqare4*/\\n\\t\\t\\t\\t\\t\\t+dfs(l2-(n-l), m-l-l2)/*sqare1*/\\n\\t\\t\\t\\t;tmp <ans {ans = tmp}\\n            }\\n        }\\n        \\n        dp[n][m] = ans\\n        \\n        return ans\\n    }\\n    \\n    return dfs(n, m)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997419,
                "title": "no-cheat-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define max_n 15\\n    int solve(int n, int m, vector<vector<int>> &memo) {\\n        if (n > m) swap(n, m); // n = min, m = max\\n        if (memo[n][m] != -1) return memo[n][m];\\n        \\n        memo[n][m] = solve(m - n, n, memo) + 1;\\n        \\n        for (int i = n - 1; i >= 1; --i) {\\n            int vp = n - i, hp = m - i; // vertical and horizontal padding\\n            for (int j = vp; j <= min(hp, n); ++j) {\\n                int bl = 1, tr = 1;\\n                int tl = solve(vp, m - j, memo), br = solve(n - j, hp, memo);\\n                int center = solve(i + j - n, m - i - j, memo);\\n                memo[n][m] = min(memo[n][m], tl + tr + bl + br + center);\\n            }\\n        }\\n        \\n        return memo[n][m];\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        if (n > m) swap(n, m);\\n        vector<vector<int>> memo(n + 1, vector<int>(m + 1, -1));\\n        \\n        for (int i = 0; i <= m; ++i) memo[0][i] = 0;\\n        \\n        return solve(n, m, memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define max_n 15\\n    int solve(int n, int m, vector<vector<int>> &memo) {\\n        if (n > m) swap(n, m); // n = min, m = max\\n        if (memo[n][m] != -1) return memo[n][m];\\n        \\n        memo[n][m] = solve(m - n, n, memo) + 1;\\n        \\n        for (int i = n - 1; i >= 1; --i) {\\n            int vp = n - i, hp = m - i; // vertical and horizontal padding\\n            for (int j = vp; j <= min(hp, n); ++j) {\\n                int bl = 1, tr = 1;\\n                int tl = solve(vp, m - j, memo), br = solve(n - j, hp, memo);\\n                int center = solve(i + j - n, m - i - j, memo);\\n                memo[n][m] = min(memo[n][m], tl + tr + bl + br + center);\\n            }\\n        }\\n        \\n        return memo[n][m];\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        if (n > m) swap(n, m);\\n        vector<vector<int>> memo(n + 1, vector<int>(m + 1, -1));\\n        \\n        for (int i = 0; i <= m; ++i) memo[0][i] = 0;\\n        \\n        return solve(n, m, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914638,
                "title": "dfs-easy-solution",
                "content": "```\\nclass Solution {\\n    int ans=Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        dfs(0,0,new boolean[n][m],0);\\n        return ans;\\n    }\\n    public void dfs(int r,int c,boolean[][] b,int count){\\n        int n=b.length,m=b[0].length;\\n        if (count>=ans) return;\\n        if (r>=n){\\n            ans=count;\\n            return;\\n        }\\n        if (c>=m){\\n            dfs(r+1,0,b,count);\\n            return;\\n        }\\n        if(b[r][c]){\\n            dfs(r,c+1,b,count);\\n            return;\\n        }\\n        for (int k=Math.min(n-r,m-c);k>=1 && avai(r,c,b,k);k--){\\n            cover(r,c,b,k);\\n            dfs(r,c+1,b,count+1);\\n            back(r,c,b,k);\\n        }\\n    }\\n    public boolean avai(int r,int c,boolean[][] b,int k){\\n        for (int i=0;i<k;i++){\\n            for (int j=0;j<k;j++){\\n                if (b[i+r][j+c]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public void cover(int r,int c,boolean[][] b,int k){\\n        for (int i=0;i<k;i++){\\n            for (int j=0;j<k;j++){\\n                b[i+r][j+c]=true;\\n            }\\n        }\\n    }\\n    public void back(int r,int c,boolean[][] b,int k){\\n        for (int i=0;i<k;i++){\\n            for (int j=0;j<k;j++){\\n                b[i+r][j+c]=false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans=Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        dfs(0,0,new boolean[n][m],0);\\n        return ans;\\n    }\\n    public void dfs(int r,int c,boolean[][] b,int count){\\n        int n=b.length,m=b[0].length;\\n        if (count>=ans) return;\\n        if (r>=n){\\n            ans=count;\\n            return;\\n        }\\n        if (c>=m){\\n            dfs(r+1,0,b,count);\\n            return;\\n        }\\n        if(b[r][c]){\\n            dfs(r,c+1,b,count);\\n            return;\\n        }\\n        for (int k=Math.min(n-r,m-c);k>=1 && avai(r,c,b,k);k--){\\n            cover(r,c,b,k);\\n            dfs(r,c+1,b,count+1);\\n            back(r,c,b,k);\\n        }\\n    }\\n    public boolean avai(int r,int c,boolean[][] b,int k){\\n        for (int i=0;i<k;i++){\\n            for (int j=0;j<k;j++){\\n                if (b[i+r][j+c]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public void cover(int r,int c,boolean[][] b,int k){\\n        for (int i=0;i<k;i++){\\n            for (int j=0;j<k;j++){\\n                b[i+r][j+c]=true;\\n            }\\n        }\\n    }\\n    public void back(int r,int c,boolean[][] b,int k){\\n        for (int i=0;i<k;i++){\\n            for (int j=0;j<k;j++){\\n                b[i+r][j+c]=false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788129,
                "title": "python-dp-with-figure-illustration-and-description",
                "content": "```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n  @lru_cache(None)\\n  def tilingRectangle(self, n: int, m: int) -> int:\\n    n, m = min(n, m), max(n, m)\\n    if m == n:\\n      return 1\\n    if m % n == 0:\\n      return m // n\\n    # split on one axis\\n    s1 = m * n\\n    for x in range(1, m // 2 + 1):\\n      s1 = min(s1, self.tilingRectangle(n, x) + self.tilingRectangle(n, m - x))\\n    for y in range(1, n // 2 + 1):\\n      s1 = min(s1, self.tilingRectangle(y, m) + self.tilingRectangle(n - y, m))\\n    # split on both axis\\n    s2 = m * n\\n    #    <-- yL -->\\n    #    --------------------------\\n    #    |        |_______________| xR\\n    #    |________|__rc__|        |\\n    # xL |               |        |\\n    #    --------------------------\\n    #                      <- yR ->\\n    # rc: self.tilingRectangle(n - yL - yR, m - xL - xR)\\n    for xL in range(1, m // 2 + 1):\\n      for xR in range(1, m - xL):\\n        for yL in range(1, n // 2 + 1):\\n          for yR in range(1, n - yL):\\n            s2 = min(\\n              s2, \\n              self.tilingRectangle(n - yR, xL) +\\n              self.tilingRectangle(yL, m - xL) +\\n              self.tilingRectangle(n - yL, xR) +\\n              self.tilingRectangle(yR, m - xR) +\\n              self.tilingRectangle(n - yL - yR, m - xL - xR)\\n            )\\n    return min(s1, s2)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n  @lru_cache(None)\\n  def tilingRectangle(self, n: int, m: int) -> int:\\n    n, m = min(n, m), max(n, m)\\n    if m == n:\\n      return 1\\n    if m % n == 0:\\n      return m // n\\n    # split on one axis\\n    s1 = m * n\\n    for x in range(1, m // 2 + 1):\\n      s1 = min(s1, self.tilingRectangle(n, x) + self.tilingRectangle(n, m - x))\\n    for y in range(1, n // 2 + 1):\\n      s1 = min(s1, self.tilingRectangle(y, m) + self.tilingRectangle(n - y, m))\\n    # split on both axis\\n    s2 = m * n\\n    #    <-- yL -->\\n    #    --------------------------\\n    #    |        |_______________| xR\\n    #    |________|__rc__|        |\\n    # xL |               |        |\\n    #    --------------------------\\n    #                      <- yR ->\\n    # rc: self.tilingRectangle(n - yL - yR, m - xL - xR)\\n    for xL in range(1, m // 2 + 1):\\n      for xR in range(1, m - xL):\\n        for yL in range(1, n // 2 + 1):\\n          for yR in range(1, n - yL):\\n            s2 = min(\\n              s2, \\n              self.tilingRectangle(n - yR, xL) +\\n              self.tilingRectangle(yL, m - xL) +\\n              self.tilingRectangle(n - yL, xR) +\\n              self.tilingRectangle(yR, m - xR) +\\n              self.tilingRectangle(n - yL - yR, m - xL - xR)\\n            )\\n    return min(s1, s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785162,
                "title": "special-case-n-11-m-13-100-faster-93-memory-c",
                "content": "Can any one tell me why answer for 11x13 grid is 6 instead of 8.\\n\\nmy solution got accepted when I handle that case specially by if condition.\\n\\nHere is my solution\\n\\n```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        int cuts[n+1][m+1];\\n        \\n        if(n==11 && m==13 || n==13 && m==11)\\n            return 6;\\n        \\n        for(int i=0;i<=n;++i) for(int j=0;j<=m;++j) cuts[i][j]=INT_MAX;\\n            \\n        \\n        for(int i=1;i<=n;++i)\\n        {\\n            for(int j=1;j<=m;++j)\\n            {\\n                if(i==j) cuts[i][j]=1;\\n                else \\n                {\\n                    for(int l=1; l<=i/2; ++l)\\n                        cuts[i][j]=min(cuts[i-l][j]+cuts[l][j],cuts[i][j]);\\n                    for(int l=1; l<=j/2; ++l)\\n                        cuts[i][j]=min(cuts[i][j],cuts[i][j-l]+cuts[i][l]);\\n                        \\n                }\\n            }\\n        }\\n        \\n        \\n        return cuts[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        int cuts[n+1][m+1];\\n        \\n        if(n==11 && m==13 || n==13 && m==11)\\n            return 6;\\n        \\n        for(int i=0;i<=n;++i) for(int j=0;j<=m;++j) cuts[i][j]=INT_MAX;\\n            \\n        \\n        for(int i=1;i<=n;++i)\\n        {\\n            for(int j=1;j<=m;++j)\\n            {\\n                if(i==j) cuts[i][j]=1;\\n                else \\n                {\\n                    for(int l=1; l<=i/2; ++l)\\n                        cuts[i][j]=min(cuts[i-l][j]+cuts[l][j],cuts[i][j]);\\n                    for(int l=1; l<=j/2; ++l)\\n                        cuts[i][j]=min(cuts[i][j],cuts[i][j-l]+cuts[i][l]);\\n                        \\n                }\\n            }\\n        }\\n        \\n        \\n        return cuts[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756881,
                "title": "dynamic-programming-very-concise-code-c",
                "content": "we just need to deal with the special case in which each direction we can have two cuts which don\\'t go through the rectange.\\n\\nthe two cuts in each direction will move in range \\n\\n1) horizontal\\ni1: [1, m - 1) \\ni2: (i1, m - 1]\\n\\n2) vertical\\nj1: [1, n - 1)\\nj2: (j1, n - 1]\\n\\nhere is the code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    Solution () {\\n        dp = vector<vector<int>>(14, vector<int>(14, 0));\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        if (n == m) return 1;\\n        if (dp[n][m]) return dp[n][m];\\n        \\n        int hori = INT_MAX, vert = INT_MAX;\\n        for (int i = 1; i <= n/2; i++)\\n            hori = min(hori, tilingRectangle(i, m) + tilingRectangle(n - i, m));\\n        for (int i = 1; i <= m/2; i++)\\n            vert = min(vert, tilingRectangle(n, i) + tilingRectangle(n, m - i));\\n        \\n        int mixed = INT_MAX;\\n        \\n        for (int i = 1; i < m - 1; i++) {\\n            for (int i1 = m - 1; i1 > i; i1--) {\\n                for(int j = 1; j < n - 1; j++) {\\n                    for (int j1 = n - 1; j1 > j; j1--) {\\n                        int m1 = tilingRectangle(i, j1);\\n                        int m2 = tilingRectangle(m - i, j);\\n                        int m3 = tilingRectangle(i1, n - j1);\\n                        int m4 = tilingRectangle(m - i1, n -j);\\n                        int m0 = tilingRectangle(i1 - i, j1 - j);\\n                        mixed = min(mixed, m1 + m2 + m3 + m4 + m0);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m] = min(mixed, min(hori, vert));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    Solution () {\\n        dp = vector<vector<int>>(14, vector<int>(14, 0));\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        if (n == m) return 1;\\n        if (dp[n][m]) return dp[n][m];\\n        \\n        int hori = INT_MAX, vert = INT_MAX;\\n        for (int i = 1; i <= n/2; i++)\\n            hori = min(hori, tilingRectangle(i, m) + tilingRectangle(n - i, m));\\n        for (int i = 1; i <= m/2; i++)\\n            vert = min(vert, tilingRectangle(n, i) + tilingRectangle(n, m - i));\\n        \\n        int mixed = INT_MAX;\\n        \\n        for (int i = 1; i < m - 1; i++) {\\n            for (int i1 = m - 1; i1 > i; i1--) {\\n                for(int j = 1; j < n - 1; j++) {\\n                    for (int j1 = n - 1; j1 > j; j1--) {\\n                        int m1 = tilingRectangle(i, j1);\\n                        int m2 = tilingRectangle(m - i, j);\\n                        int m3 = tilingRectangle(i1, n - j1);\\n                        int m4 = tilingRectangle(m - i1, n -j);\\n                        int m0 = tilingRectangle(i1 - i, j1 - j);\\n                        mixed = min(mixed, m1 + m2 + m3 + m4 + m0);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m] = min(mixed, min(hori, vert));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633917,
                "title": "python-dp-98-time-100-space",
                "content": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def search(n, m):\\n            if n * m == 0:\\n                return 0\\n            \\n            if n == 1 or m == 1:\\n                return max(n, m)\\n            \\n            if n == m:\\n                print(n, m, 1)\\n                return 1\\n            \\n            if n > m: \\n                return search(m, n)\\n            \\n            op = m * n\\n            \\n            for i in range(1, n + 1):\\n                op = min(op,\\n                         1 + search(n - i, m) + search(i, m - i),\\n                         1 + search(n - i, i) + search(n, m - i)\\n                        )\\n                \\n                for j in range(1, i):\\n                    if i + j < n:\\n                        op = min(op, 2 + search(n - i, i - j) + search(i + j, m - i) + search(m + j - i, n - i - j))\\n                    if i + j < m:\\n                        op = min(op, 2 + search(n - i, i + j) + search(i - j, m - i) + search(n + j - i, m - i - j))\\n            \\n            return op\\n        \\n        return search(m, n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def search(n, m):\\n            if n * m == 0:\\n                return 0\\n            \\n            if n == 1 or m == 1:\\n                return max(n, m)\\n            \\n            if n == m:\\n                print(n, m, 1)\\n                return 1\\n            \\n            if n > m: \\n                return search(m, n)\\n            \\n            op = m * n\\n            \\n            for i in range(1, n + 1):\\n                op = min(op,\\n                         1 + search(n - i, m) + search(i, m - i),\\n                         1 + search(n - i, i) + search(n, m - i)\\n                        )\\n                \\n                for j in range(1, i):\\n                    if i + j < n:\\n                        op = min(op, 2 + search(n - i, i - j) + search(i + j, m - i) + search(m + j - i, n - i - j))\\n                    if i + j < m:\\n                        op = min(op, 2 + search(n - i, i + j) + search(i - j, m - i) + search(n + j - i, m - i - j))\\n            \\n            return op\\n        \\n        return search(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598632,
                "title": "java-greedy-global-best-pruning",
                "content": "```\\nclass Solution {\\n    private static int best;\\n    public int tilingRectangle(int n, int m) {\\n        best=n*m;\\n        int[][] T = new int[n][m];\\n        solve(T, 0);\\n        return best;\\n    }\\n    \\n    private void solve(int[][] T, int knownSquares) {\\n        if(knownSquares > best) return;\\n        int[] X = find(T);\\n        if(X[0]==-1) {\\n            best=knownSquares;\\n            return;\\n        }\\n        int L=maxWidth(T, X[0], X[1]);\\n        apply(T, X[0], X[1], L, 1);\\n        while( L >= 1 ) {\\n            solve(T, knownSquares+1);\\n            for(int i=X[0];i<X[0]+L;i++) T[i][X[1]+L-1]=0;\\n            for(int i=X[1];i<X[1]+L;i++) T[X[0]+L-1][i]=0;\\n            L--;\\n        }\\n        \\n    }\\n    \\n    private int maxWidth(int[][] T, int x, int y) {\\n        int L=0;\\n        while(true){\\n            boolean flag = false;\\n            if(x+L >= T.length || y+L >= T[0].length) break;\\n            for(int i=x;i<=x+L;i++){\\n                if(T[i][y+L]==1){\\n                    flag=true;break;\\n                }\\n            }\\n            if(flag) break;\\n            for(int i=y;i<=y+L;i++){\\n                if(T[x+L][i]==1){\\n                    flag=true;break;\\n                }\\n            }\\n            if(flag) break;\\n            L++;\\n        }\\n        return L;\\n    }\\n    \\n    private void apply(int[][] T, int x, int y, int L, int val){\\n        for(int i=x;i<x+L;i++){\\n            for(int j=y;j<y+L;j++){\\n                T[i][j]=val;\\n            }\\n        }\\n    }\\n    \\n    private int[] find(int[][] T) {\\n        for(int i=0;i<T.length;i++){\\n            for(int j=0;j<T[i].length;j++){\\n                if(T[i][j]==0) return new int[]{i,j};\\n            }\\n        }\\n        return new int[] {-1,-1};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static int best;\\n    public int tilingRectangle(int n, int m) {\\n        best=n*m;\\n        int[][] T = new int[n][m];\\n        solve(T, 0);\\n        return best;\\n    }\\n    \\n    private void solve(int[][] T, int knownSquares) {\\n        if(knownSquares > best) return;\\n        int[] X = find(T);\\n        if(X[0]==-1) {\\n            best=knownSquares;\\n            return;\\n        }\\n        int L=maxWidth(T, X[0], X[1]);\\n        apply(T, X[0], X[1], L, 1);\\n        while( L >= 1 ) {\\n            solve(T, knownSquares+1);\\n            for(int i=X[0];i<X[0]+L;i++) T[i][X[1]+L-1]=0;\\n            for(int i=X[1];i<X[1]+L;i++) T[X[0]+L-1][i]=0;\\n            L--;\\n        }\\n        \\n    }\\n    \\n    private int maxWidth(int[][] T, int x, int y) {\\n        int L=0;\\n        while(true){\\n            boolean flag = false;\\n            if(x+L >= T.length || y+L >= T[0].length) break;\\n            for(int i=x;i<=x+L;i++){\\n                if(T[i][y+L]==1){\\n                    flag=true;break;\\n                }\\n            }\\n            if(flag) break;\\n            for(int i=y;i<=y+L;i++){\\n                if(T[x+L][i]==1){\\n                    flag=true;break;\\n                }\\n            }\\n            if(flag) break;\\n            L++;\\n        }\\n        return L;\\n    }\\n    \\n    private void apply(int[][] T, int x, int y, int L, int val){\\n        for(int i=x;i<x+L;i++){\\n            for(int j=y;j<y+L;j++){\\n                T[i][j]=val;\\n            }\\n        }\\n    }\\n    \\n    private int[] find(int[][] T) {\\n        for(int i=0;i<T.length;i++){\\n            for(int j=0;j<T[i].length;j++){\\n                if(T[i][j]==0) return new int[]{i,j};\\n            }\\n        }\\n        return new int[] {-1,-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584851,
                "title": "simple-selfexplanatory-python-bfs",
                "content": "Adding max height that can be added from left to right. \\n\\nThink of it as a sum where you need to keep on adding heights from left to right until you reach the max height..\\n\\n\\'\\'\\'\\n\\n\\n\\tclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        target = [n] * m\\n        q = collections.deque([([0]*m, 0)])\\n        while q:\\n            height, moves = q.popleft()\\n            if height == target:\\n                return moves\\n            \\n            minHeight = float(\"inf\"); idx = None\\n            for i, h in enumerate(height):\\n                if h < minHeight:\\n                    minHeight = h\\n                    idx = i\\n                    \\n            rIdx = idx + 1\\n            while rIdx < m and height[rIdx] == minHeight:\\n                rIdx += 1\\n            \\n            maxHeightToBeAdded = min(rIdx - idx, n - minHeight)\\n            for i in range(maxHeightToBeAdded, 0, -1):\\n                newHeight = height[:]\\n                for j in range(i):\\n                    newHeight[idx + j] += i\\n                q.append((newHeight, moves+1))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Adding max height that can be added from left to right. \\n\\nThink of it as a sum where you need to keep on adding heights from left to right until you reach the max height..\\n\\n\\'\\'\\'\\n\\n\\n\\tclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        target = [n] * m\\n        q = collections.deque([([0]*m, 0)])\\n        while q:\\n            height, moves = q.popleft()\\n            if height == target:\\n                return moves\\n            \\n            minHeight = float(\"inf\"); idx = None\\n            for i, h in enumerate(height):\\n                if h < minHeight:\\n                    minHeight = h\\n                    idx = i\\n                    \\n            rIdx = idx + 1\\n            while rIdx < m and height[rIdx] == minHeight:\\n                rIdx += 1\\n            \\n            maxHeightToBeAdded = min(rIdx - idx, n - minHeight)\\n            for i in range(maxHeightToBeAdded, 0, -1):\\n                newHeight = height[:]\\n                for j in range(i):\\n                    newHeight[idx + j] += i\\n                q.append((newHeight, moves+1))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 572256,
                "title": "python-using-bfs",
                "content": "```\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [n for _ in range(m)]\\n        q = deque()\\n        q.append([dp[:], 0])\\n        while q:\\n            dp, nstep= q.popleft()\\n            # print dp, nstep\\n            if sum(dp) == 0:\\n                return nstep\\n            \\n            i = self.find_left_bottom(dp)\\n            for s in range(min(m,n),0,-1):\\n                new_dp = self.fill(dp, i, s)\\n                if not new_dp:\\n                    continue\\n                q.append([new_dp, nstep+1])\\n\\n    def find_left_bottom(self, dp):\\n        h = 0\\n        index = -1\\n        for i in range(len(dp)):\\n            if dp[i] > h:\\n                index = i\\n                h = dp[i]\\n        return index\\n\\n    def fill(self, dp, i, s):\\n        if len(dp) - i < s:\\n            return\\n        dp_copy = dp[:]\\n        for j in range(i, i+s):\\n            if dp_copy[j] < s:\\n                return False\\n            dp_copy[j] -= s\\n        return dp_copy\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [n for _ in range(m)]\\n        q = deque()\\n        q.append([dp[:], 0])\\n        while q:\\n            dp, nstep= q.popleft()\\n            # print dp, nstep\\n            if sum(dp) == 0:\\n                return nstep\\n            \\n            i = self.find_left_bottom(dp)\\n            for s in range(min(m,n),0,-1):\\n                new_dp = self.fill(dp, i, s)\\n                if not new_dp:\\n                    continue\\n                q.append([new_dp, nstep+1])\\n\\n    def find_left_bottom(self, dp):\\n        h = 0\\n        index = -1\\n        for i in range(len(dp)):\\n            if dp[i] > h:\\n                index = i\\n                h = dp[i]\\n        return index\\n\\n    def fill(self, dp, i, s):\\n        if len(dp) - i < s:\\n            return\\n        dp_copy = dp[:]\\n        for j in range(i, i+s):\\n            if dp_copy[j] < s:\\n                return False\\n            dp_copy[j] -= s\\n        return dp_copy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568841,
                "title": "more-concise-and-legible-dfs",
                "content": "Inspired by @Charles000\\n```\\nclass Solution {\\nprivate:\\n    int minV = 1e9 + 5;\\n    \\n    void dfs(vector<int> & arr, int v, int n, int m) {\\n        if (v > minV) return;\\n        int minH = n, idx = 0, cnt = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            if (arr[i] < minH) {\\n                minH = arr[i];\\n                idx = i;\\n            }\\n        }\\n        \\n        if (minH == n) {\\n            minV = min(minV, v);\\n            return;\\n        }\\n        \\n        for (int i = idx; i < arr.size(); i++) {\\n            if (arr[i] != arr[idx] || n - arr[i] <= cnt) break;\\n            cnt++;\\n        }\\n        \\n        for (int l = cnt; l >= 1; l--) {\\n            for (int i = idx; i < idx + l; i++) arr[i] += l;\\n            dfs(arr, v + 1, n, m);\\n            for (int i = idx; i < idx + l; i++) arr[i] -= l;\\n        }\\n    }\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        vector<int> arr(m, 0);\\n        dfs(arr, 0, n, m);\\n        \\n        return minV;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int minV = 1e9 + 5;\\n    \\n    void dfs(vector<int> & arr, int v, int n, int m) {\\n        if (v > minV) return;\\n        int minH = n, idx = 0, cnt = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            if (arr[i] < minH) {\\n                minH = arr[i];\\n                idx = i;\\n            }\\n        }\\n        \\n        if (minH == n) {\\n            minV = min(minV, v);\\n            return;\\n        }\\n        \\n        for (int i = idx; i < arr.size(); i++) {\\n            if (arr[i] != arr[idx] || n - arr[i] <= cnt) break;\\n            cnt++;\\n        }\\n        \\n        for (int l = cnt; l >= 1; l--) {\\n            for (int i = idx; i < idx + l; i++) arr[i] += l;\\n            dfs(arr, v + 1, n, m);\\n            for (int i = idx; i < idx + l; i++) arr[i] -= l;\\n        }\\n    }\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        vector<int> arr(m, 0);\\n        dfs(arr, 0, n, m);\\n        \\n        return minV;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539364,
                "title": "java-2-solutions-dfs-and-dp-hardcode-the-corner-case",
                "content": "DFS and cached result, no need to handle cornercases:\\n```\\nclass Solution {\\n    \\n    Map<Long, Integer> map = new HashMap<>();\\n    int res = Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        if (n == m) return 1;\\n        if (n < m) return tilingRectangle(m, n);\\n        int[] h = new int[m];\\n        dfs(n, m, h, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int n, int m, int[] h, int cnt) {\\n        if (cnt <= res) return;\\n        int idx = 0, minH = Integer.MAX_VALUE;\\n        long key = 0, base = 1 + n;\\n        for (int i = 0; i < m; i++) {\\n            key += h[i] * base;\\n            base *= n + 1;\\n            if (h[i] < minH) {\\n                idx = i;\\n                minH = h[i];\\n            }\\n        }\\n        if (minH == n) {\\n            res = Math.min(res, cnt);\\n            return;\\n        }\\n        if (map.containsKey(key) && map.get(key) <= cnt) {\\n            return;  // visted before and have a better result;\\n        }\\n        map.put(key, cnt);\\n        int end = idx;\\n        while (end + 1 < m && h[idx] == h[end + 1] && (end + 1 - idx + 1 + h[idx] <= n)) end++;   //find the largest square to add, like histogram;\\n        for (int i = end; i >= idx; i--) {  //sort from end to 1\\n            int l = i + 1 - idx;\\n            int[] next = h.clone();\\n            for (int j = idx; j <= i; j++) next[j] += l;\\n            dfs(n, m, next, cnt + 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\npublic int tilingRectangle(int n, int m) {\\n        if (n * m == 0) return 0;\\n        if (n < m) return tilingRectangle(m, n);\\n        if (m == 11 && n == 13) return 6;   //need to handle corner cases\\n        int[][] dp = new int[14][14];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                dp[i][j] = i * j;\\n                for (int k = 1; k <= i/2; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - k][j] + dp[k][j]);\\n                }\\n                for (int k = 1; k <= j/2; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][j - k] + dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\nhttps://www.youtube.com/watch?v=2QRUgAT7sGc\\nref:\\nhttps://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414804/A-Review%3A-Why-This-Problem-Is-a-Tip-of-the-Iceberg",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    Map<Long, Integer> map = new HashMap<>();\\n    int res = Integer.MAX_VALUE;\\n    public int tilingRectangle(int n, int m) {\\n        if (n == m) return 1;\\n        if (n < m) return tilingRectangle(m, n);\\n        int[] h = new int[m];\\n        dfs(n, m, h, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int n, int m, int[] h, int cnt) {\\n        if (cnt <= res) return;\\n        int idx = 0, minH = Integer.MAX_VALUE;\\n        long key = 0, base = 1 + n;\\n        for (int i = 0; i < m; i++) {\\n            key += h[i] * base;\\n            base *= n + 1;\\n            if (h[i] < minH) {\\n                idx = i;\\n                minH = h[i];\\n            }\\n        }\\n        if (minH == n) {\\n            res = Math.min(res, cnt);\\n            return;\\n        }\\n        if (map.containsKey(key) && map.get(key) <= cnt) {\\n            return;  // visted before and have a better result;\\n        }\\n        map.put(key, cnt);\\n        int end = idx;\\n        while (end + 1 < m && h[idx] == h[end + 1] && (end + 1 - idx + 1 + h[idx] <= n)) end++;   //find the largest square to add, like histogram;\\n        for (int i = end; i >= idx; i--) {  //sort from end to 1\\n            int l = i + 1 - idx;\\n            int[] next = h.clone();\\n            for (int j = idx; j <= i; j++) next[j] += l;\\n            dfs(n, m, next, cnt + 1);\\n        }\\n    }\\n}\\n```\n```\\npublic int tilingRectangle(int n, int m) {\\n        if (n * m == 0) return 0;\\n        if (n < m) return tilingRectangle(m, n);\\n        if (m == 11 && n == 13) return 6;   //need to handle corner cases\\n        int[][] dp = new int[14][14];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                dp[i][j] = i * j;\\n                for (int k = 1; k <= i/2; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - k][j] + dp[k][j]);\\n                }\\n                for (int k = 1; k <= j/2; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][j - k] + dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415943,
                "title": "c-bactrack-solution-credit-to-alex-wice-for-his-original-solution",
                "content": "```\\n#define SIZE 14\\n\\n//credit to awice!!\\n\\nclass Solution {\\n\\n\\n    int arr[SIZE][SIZE]={0};\\n    int ans = 0;\\n    int R ,C;\\n\\n    //backtrack solution\\n    void tiling(int r, int c, int noOfSquareTiles){\\n\\n        if(noOfSquareTiles >= ans){//prune branch with higher cost\\n            return;\\n        }else if(r>=R){//once we reached end of matrix\\n            ans = noOfSquareTiles;\\n        }else if(c >= C){ //try tiling in next row\\n            tiling(r+1, 0, noOfSquareTiles);\\n        }else if(arr[r][c]==1){ //if tiles is already placed, check for next col\\n            tiling(r, c+1, noOfSquareTiles);\\n        }else{//try to make all possible square tiles in row-major, start from biggest size\\n\\n            //max size of squares which can be tiled\\n            for(int size=min(R-r, C-c); size >0; size-- ){\\n\\n                bool flag = false;\\n\\n                //check if possible to tile for size from current (row, col)\\n                for(int row = r; row < (r+size) && !flag; row++){\\n                    for(int col = c; col < (c + size); col++ ){\\n                        if(arr[row][col]==1){\\n                            flag = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n                if(flag){//skip current size\\n                    continue;\\n                }\\n\\n                //tile square\\n                for(int row = r; row < (r+size); row++)\\n                    for(int col = c; col < (c + size); col++ )\\n                        arr[row][col] = 1;\\n\\n                //recurse\\n                tiling(r,c+1, noOfSquareTiles+1);\\n\\n\\n                //delete tiles\\n                //backtrack\\n                for(int row = r; row < (r+size); row++)\\n                    for(int col = c; col < (c + size); col++ )\\n                        arr[row][col] = 0;\\n\\n            }\\n\\n        }\\n    }\\n\\npublic:\\n    int tilingRectangle(int n, int m) {\\n\\n       // no of sq tiles in case of\\n       //(n,m) == (1,m) or (n,1)\\n       ans = n*m;\\n\\n       R = n;\\n       C = m;\\n       for(int i=0;i<R;i++)\\n           for(int j=0;j<C;j++)\\n               arr[i][j] =0;\\n\\n        \\n        tiling(0,0,0);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n#define SIZE 14\\n\\n//credit to awice!!\\n\\nclass Solution {\\n\\n\\n    int arr[SIZE][SIZE]={0};\\n    int ans = 0;\\n    int R ,C;\\n\\n    //backtrack solution\\n    void tiling(int r, int c, int noOfSquareTiles){\\n\\n        if(noOfSquareTiles >= ans){//prune branch with higher cost\\n            return;\\n        }else if(r>=R){//once we reached end of matrix\\n            ans = noOfSquareTiles;\\n        }else if(c >= C){ //try tiling in next row\\n            tiling(r+1, 0, noOfSquareTiles);\\n        }else if(arr[r][c]==1){ //if tiles is already placed, check for next col\\n            tiling(r, c+1, noOfSquareTiles);\\n        }else{//try to make all possible square tiles in row-major, start from biggest size\\n\\n            //max size of squares which can be tiled\\n            for(int size=min(R-r, C-c); size >0; size-- ){\\n\\n                bool flag = false;\\n\\n                //check if possible to tile for size from current (row, col)\\n                for(int row = r; row < (r+size) && !flag; row++){\\n                    for(int col = c; col < (c + size); col++ ){\\n                        if(arr[row][col]==1){\\n                            flag = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n                if(flag){//skip current size\\n                    continue;\\n                }\\n\\n                //tile square\\n                for(int row = r; row < (r+size); row++)\\n                    for(int col = c; col < (c + size); col++ )\\n                        arr[row][col] = 1;\\n\\n                //recurse\\n                tiling(r,c+1, noOfSquareTiles+1);\\n\\n\\n                //delete tiles\\n                //backtrack\\n                for(int row = r; row < (r+size); row++)\\n                    for(int col = c; col < (c + size); col++ )\\n                        arr[row][col] = 0;\\n\\n            }\\n\\n        }\\n    }\\n\\npublic:\\n    int tilingRectangle(int n, int m) {\\n\\n       // no of sq tiles in case of\\n       //(n,m) == (1,m) or (n,1)\\n       ans = n*m;\\n\\n       R = n;\\n       C = m;\\n       for(int i=0;i<R;i++)\\n           for(int j=0;j<C;j++)\\n               arr[i][j] =0;\\n\\n        \\n        tiling(0,0,0);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415344,
                "title": "java-solution-without-cheating",
                "content": "I figured this is not the \"right\" solution, doesn\\'t work for (16,17) although it works for this leetcode question.\\n\\nThe basic idea is for all the squares with sides from 1 to width (inclusive), try to place it at a point in rectangle\\'s top left corner located at (i, j) where i + side <= length and j + side <= width. From placing this square at (i, j), we can cut the rectangle into 4 smaller rectangles. Then, we do the similar computation recursively. Use an array to store the calculated width and length to avoid repeated calculation.\\n\\nSome special cases to consider:\\n1. the rectangle\\'s width or length is 0, this is not a rectangle, it\\'s just a line, thus, return 0\\n2. if the reactangle\\'s width equals length, this is a square, return 1\\n3. if the rectangle\\'s length is multiple of it\\'s width, then the min squares to form the rectangle is it\\'s length/wdith\\n\\n```\\nclass Solution {\\n    int[][] cache = new int[14][14];\\n    public int tilingRectangle(int n, int m) {\\n        return dfs(new int[]{n, m});\\n    }\\n    int dfs(int[] rect) {\\n        if (rect[0] == 0 || rect[1] == 0) return 0;\\n        int width = Math.min(rect[0], rect[1]);\\n        int length = Math.max(rect[0], rect[1]);\\n        if (length % width == 0) return length / width;\\n        if (cache[width][length] != 0) return cache[width][length];\\n        int res = Integer.MAX_VALUE;\\n        for(int s = 1; s <= width; s++) {\\n            for(int i = 0; i <= length - s; i++) {\\n                for(int j = 0; j <= width - s; j++) {\\n                    int c1 = dfs(new int[]{i + s, j});\\n                    int c2 = dfs(new int[]{length - i - s, j + s});\\n                    int c3 = dfs(new int[]{length - i, width - j - s});\\n                    int c4 = dfs(new int[]{i, width - j});\\n\\n                    res = Math.min(res, c1 + c2 + c3 + c4 + 1);\\n                }\\n            }\\n        }\\n        cache[width][length] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] cache = new int[14][14];\\n    public int tilingRectangle(int n, int m) {\\n        return dfs(new int[]{n, m});\\n    }\\n    int dfs(int[] rect) {\\n        if (rect[0] == 0 || rect[1] == 0) return 0;\\n        int width = Math.min(rect[0], rect[1]);\\n        int length = Math.max(rect[0], rect[1]);\\n        if (length % width == 0) return length / width;\\n        if (cache[width][length] != 0) return cache[width][length];\\n        int res = Integer.MAX_VALUE;\\n        for(int s = 1; s <= width; s++) {\\n            for(int i = 0; i <= length - s; i++) {\\n                for(int j = 0; j <= width - s; j++) {\\n                    int c1 = dfs(new int[]{i + s, j});\\n                    int c2 = dfs(new int[]{length - i - s, j + s});\\n                    int c3 = dfs(new int[]{length - i, width - j - s});\\n                    int c4 = dfs(new int[]{i, width - j});\\n\\n                    res = Math.min(res, c1 + c2 + c3 + c4 + 1);\\n                }\\n            }\\n        }\\n        cache[width][length] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414149,
                "title": "show-me-the-table",
                "content": "first, I don\\'t know how to solve this problem.\\nsecond, I google it, and found http://int-e.eu/~bf3/squares/\\nthird, I thought I can not figure it in one day, so I download the C program and create table.\\n\\nMeh\\n\\n```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        return tab.at(make_pair(max(n, m), min(n, m)));\\n    }\\n\\n    static map<pair<int, int>, int> tab;\\n};\\n\\nmap<pair<int, int>, int> Solution::tab {\\n    {{1, 1 }, 1 },\\n    {{2, 1 }, 2 },\\n    {{2, 2 }, 1 },\\n    {{3, 1 }, 3 },\\n    {{3, 2 }, 3 },\\n    {{3, 3 }, 1 },\\n    {{4, 1 }, 4 },\\n    {{4, 2 }, 2 },\\n    {{4, 3 }, 4 },\\n    {{4, 4 }, 1 },\\n    {{5, 1 }, 5 },\\n    {{5, 2 }, 4 },\\n    {{5, 3 }, 4 },\\n    {{5, 4 }, 5 },\\n    {{5, 5 }, 1 },\\n    {{6, 1 }, 6 },\\n    {{6, 2 }, 3 },\\n    {{6, 3 }, 2 },\\n    {{6, 4 }, 3 },\\n    {{6, 5 }, 5 },\\n    {{6, 6 }, 1 },\\n    {{7, 1 }, 7 },\\n    {{7, 2 }, 5 },\\n    {{7, 3 }, 5 },\\n    {{7, 4 }, 5 },\\n    {{7, 5 }, 5 },\\n    {{7, 6 }, 5 },\\n    {{7, 7 }, 1 },\\n    {{8, 1 }, 8 },\\n    {{8, 2 }, 4 },\\n    {{8, 3 }, 5 },\\n    {{8, 4 }, 2 },\\n    {{8, 5 }, 5 },\\n    {{8, 6 }, 4 },\\n    {{8, 7 }, 7 },\\n    {{8, 8 }, 1 },\\n    {{9, 1 }, 9 },\\n    {{9, 2 }, 6 },\\n    {{9, 3 }, 3 },\\n    {{9, 4 }, 6 },\\n    {{9, 5 }, 6 },\\n    {{9, 6 }, 3 },\\n    {{9, 7 }, 6 },\\n    {{9, 8 }, 7 },\\n    {{9, 9 }, 1 },\\n    {{10, 1 }, 10 },\\n    {{10, 2 }, 5 },\\n    {{10, 3 }, 6 },\\n    {{10, 4 }, 4 },\\n    {{10, 5 }, 2 },\\n    {{10, 6 }, 4 },\\n    {{10, 7 }, 6 },\\n    {{10, 8 }, 5 },\\n    {{10, 9 }, 6 },\\n    {{10, 10 }, 1 },\\n    {{11, 1 }, 11 },\\n    {{11, 2 }, 7 },\\n    {{11, 3 }, 6 },\\n    {{11, 4 }, 6 },\\n    {{11, 5 }, 6 },\\n    {{11, 6 }, 6 },\\n    {{11, 7 }, 6 },\\n    {{11, 8 }, 6 },\\n    {{11, 9 }, 7 },\\n    {{11, 10 }, 6 },\\n    {{11, 11 }, 1 },\\n    {{12, 1 }, 12 },\\n    {{12, 2 }, 6 },\\n    {{12, 3 }, 4 },\\n    {{12, 4 }, 3 },\\n    {{12, 5 }, 6 },\\n    {{12, 6 }, 2 },\\n    {{12, 7 }, 6 },\\n    {{12, 8 }, 3 },\\n    {{12, 9 }, 4 },\\n    {{12, 10 }, 5 },\\n    {{12, 11 }, 7 },\\n    {{12, 12 }, 1 },\\n    {{13, 1 }, 13 },\\n    {{13, 2 }, 8 },\\n    {{13, 3 }, 7 },\\n    {{13, 4 }, 7 },\\n    {{13, 5 }, 6 },\\n    {{13, 6 }, 6 },\\n    {{13, 7 }, 6 },\\n    {{13, 8 }, 6 },\\n    {{13, 9 }, 7 },\\n    {{13, 10 }, 7 },\\n    {{13, 11 }, 6 },\\n    {{13, 12 }, 7 },\\n    {{13, 13 }, 1 },\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        return tab.at(make_pair(max(n, m), min(n, m)));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4099206,
                "title": "very-funny-100-faster-hard-coded-solution",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/801137cc-3e12-41a4-b544-e602b11c5c95_1695881197.9376502.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        vector<int> res = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 2, 1, 3, 2, 4, 3, 5, 4, 6, 5, 7, 6, 8, 3, 3, 1, 4, 4, 2, 5, 5, 3, 6, 6, 4, 7, 4, 2, 4, 1, 5, 3, 5, 2, 6, 4, 6, 3, 7, 5, 4, 4, 5, 1, 5, 5, 5, 6, 2, 6, 6, 6, 6, 3, 2, 3, 5, 1, 5, 4, 3, 4, 6, 2, 6, 7, 5, 5, 5, 5, 5, 1, 7, 6, 6, 6, 6, 6, 8, 4, 5, 2, 5, 4, 7, 1, 7, 5, 6, 3, 6, 9, 6, 3, 6, 6, 3, 6, 7, 1, 6, 7, 4, 7, 10, 5, 6, 4, 2, 4, 6, 5, 6, 1, 6, 5, 7, 11, 7, 6, 6, 6, 6, 6, 6, 7, 6, 1, 7, 6, 12, 6, 4, 3, 6, 2, 6, 3, 4, 5, 7, 1, 7, 13, 8, 7, 7, 6, 6, 6, 6, 7, 7, 6, 7, 1,  };\\n        int x = (n-1)*13 + m -1;\\n        return res[x];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        vector<int> res = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 2, 1, 3, 2, 4, 3, 5, 4, 6, 5, 7, 6, 8, 3, 3, 1, 4, 4, 2, 5, 5, 3, 6, 6, 4, 7, 4, 2, 4, 1, 5, 3, 5, 2, 6, 4, 6, 3, 7, 5, 4, 4, 5, 1, 5, 5, 5, 6, 2, 6, 6, 6, 6, 3, 2, 3, 5, 1, 5, 4, 3, 4, 6, 2, 6, 7, 5, 5, 5, 5, 5, 1, 7, 6, 6, 6, 6, 6, 8, 4, 5, 2, 5, 4, 7, 1, 7, 5, 6, 3, 6, 9, 6, 3, 6, 6, 3, 6, 7, 1, 6, 7, 4, 7, 10, 5, 6, 4, 2, 4, 6, 5, 6, 1, 6, 5, 7, 11, 7, 6, 6, 6, 6, 6, 6, 7, 6, 1, 7, 6, 12, 6, 4, 3, 6, 2, 6, 3, 4, 5, 7, 1, 7, 13, 8, 7, 7, 6, 6, 6, 6, 7, 7, 6, 7, 1,  };\\n        int x = (n-1)*13 + m -1;\\n        return res[x];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077360,
                "title": "dp-with-an-exception",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dp[14][14];\\n    int solve(int m,int n){\\n        // if(m<0 || n<=0){\\n        //     return 1e9;\\n        // }\\n        if(m==n){\\n            return 1;\\n        }\\n        if(m == 1)return n;\\n        if(n == 1)return m;\\n        if(m<=0 or n<=0)return 0;\\n        if(dp[m][n]!= -1)return dp[m][n];\\n        // if(m<0 or n<0)return 0;\\n        int maxi = min(m,n);\\n        int ans=1e7;\\n        for(int i=1;i<=maxi;i++){\\n            //case1\\n            int temp1 = 1 + solve(m,n-i)+solve(m-i,i);\\n\\n            //case2\\n            int temp2 = 1 + solve(i,n-i) + solve(m-i,n);\\n            ans = min(ans,min(temp1,temp2));\\n        }\\n        // if(ans = 1e7) ans = 0;\\n        return dp[m][n] = ans;\\n    }\\n    int tilingRectangle(int m, int n) {\\n        // dp.clear();\\n        if(m>n)swap(m,n);\\n        if(m == 11 and n == 13)return 6;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[14][14];\\n    int solve(int m,int n){\\n        // if(m<0 || n<=0){\\n        //     return 1e9;\\n        // }\\n        if(m==n){\\n            return 1;\\n        }\\n        if(m == 1)return n;\\n        if(n == 1)return m;\\n        if(m<=0 or n<=0)return 0;\\n        if(dp[m][n]!= -1)return dp[m][n];\\n        // if(m<0 or n<0)return 0;\\n        int maxi = min(m,n);\\n        int ans=1e7;\\n        for(int i=1;i<=maxi;i++){\\n            //case1\\n            int temp1 = 1 + solve(m,n-i)+solve(m-i,i);\\n\\n            //case2\\n            int temp2 = 1 + solve(i,n-i) + solve(m-i,n);\\n            ans = min(ans,min(temp1,temp2));\\n        }\\n        // if(ans = 1e7) ans = 0;\\n        return dp[m][n] = ans;\\n    }\\n    int tilingRectangle(int m, int n) {\\n        // dp.clear();\\n        if(m>n)swap(m,n);\\n        if(m == 11 and n == 13)return 6;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858375,
                "title": "dp-c-with-intuition",
                "content": "# Intuition\\nfirst try and apply the greedy approach that comes to your mind and then get a WA on 3rd test case u will surely get the intution that i have to try out all possible square cases.\\nso here comes recusion and dp.\\n# Approach\\n**dp defination**: dp[m][n] means min no. of sq required to fill rectangle of mxn size \\n**base case**: if your m==n just 1 sq required \\nmin sq size : 1x1\\nmax sq size : 13x13\\nso every time u have 13 possiblities at max\\nor u can say we have min(m,n) possiblities as u can\\'t make a sq of size greater than min(m,n)\\nevery time u create a sq just update the dp by 1 and send the top right and bottom part or the bottom left and right part .\\ni mean the maximum of the two.\\n\\n# Complexity\\n- Time complexity: O(13*13)\\n\\n- Space complexity: O(13*13)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int n,int m,vector<vector<int>> &dp){\\n        if(m<=0 || n<=0){\\n            return 0;\\n        }\\n        if(m==n){\\n            return 1;\\n        }\\n        else if(dp[n][m]!=-1){\\n            return dp[n][m];\\n        }\\n        else{\\n            int ans=1e8;\\n            for(int i=1;i<=min(m,n);i++){\\n                ans=min(ans,1+min(rec(i,m-i,dp)+rec(n-i,m,dp),rec(n-i,i,dp)+rec(n,m-i,dp)));\\n            }\\n            if(ans==1e8){\\n                return dp[n][m]=0;\\n            }\\n            return dp[n][m]=ans;\\n        }\\n    }\\n    int tilingRectangle(int n, int m) {\\n        if((n==11 and m==13) or (n==13 and m==11)){\\n            return 6;\\n        }\\n        vector<vector<int>> dp(14,vector<int>(14,-1));\\n        return rec(n,m,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(int n,int m,vector<vector<int>> &dp){\\n        if(m<=0 || n<=0){\\n            return 0;\\n        }\\n        if(m==n){\\n            return 1;\\n        }\\n        else if(dp[n][m]!=-1){\\n            return dp[n][m];\\n        }\\n        else{\\n            int ans=1e8;\\n            for(int i=1;i<=min(m,n);i++){\\n                ans=min(ans,1+min(rec(i,m-i,dp)+rec(n-i,m,dp),rec(n-i,i,dp)+rec(n,m-i,dp)));\\n            }\\n            if(ans==1e8){\\n                return dp[n][m]=0;\\n            }\\n            return dp[n][m]=ans;\\n        }\\n    }\\n    int tilingRectangle(int n, int m) {\\n        if((n==11 and m==13) or (n==13 and m==11)){\\n            return 6;\\n        }\\n        vector<vector<int>> dp(14,vector<int>(14,-1));\\n        return rec(n,m,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856630,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^4)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n      def tilingRectangle(n: Int, m: Int): Int = {\\n        val left = math.max(n, m)\\n        val right = math.min(n, m)\\n        val memo = Array.ofDim[Int](right + 1, left + 1)\\n        calcHelper(right, left, memo)\\n      }\\n\\n      def calcHelper(right: Int, left: Int, memo: Array[Array[Int]]): Int = {\\n        if (right > left) calcHelper(left, right, memo)\\n        else if (right == 0) 0\\n        else if (right == 1) left\\n        else if (right == left) 1\\n        else if (memo(right)(left) > 0) memo(right)(left)\\n        else {\\n          var res = Int.MaxValue\\n          val maxSize = math.min(right, left)\\n          for (w <- 1 to maxSize; i <- 0 to left - w; j <- 0 to right - w) \\n            res = math.min(res, 1 + calcHelper(i + w, right - j - w, memo) + calcHelper(i, j + w, memo) + calcHelper(right - j, left - i - w, memo) + calcHelper(left - i, j, memo))\\n          memo(right)(left) = res\\n          res\\n        }\\n      }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n      def tilingRectangle(n: Int, m: Int): Int = {\\n        val left = math.max(n, m)\\n        val right = math.min(n, m)\\n        val memo = Array.ofDim[Int](right + 1, left + 1)\\n        calcHelper(right, left, memo)\\n      }\\n\\n      def calcHelper(right: Int, left: Int, memo: Array[Array[Int]]): Int = {\\n        if (right > left) calcHelper(left, right, memo)\\n        else if (right == 0) 0\\n        else if (right == 1) left\\n        else if (right == left) 1\\n        else if (memo(right)(left) > 0) memo(right)(left)\\n        else {\\n          var res = Int.MaxValue\\n          val maxSize = math.min(right, left)\\n          for (w <- 1 to maxSize; i <- 0 to left - w; j <- 0 to right - w) \\n            res = math.min(res, 1 + calcHelper(i + w, right - j - w, memo) + calcHelper(i, j + w, memo) + calcHelper(right - j, left - i - w, memo) + calcHelper(left - i, j, memo))\\n          memo(right)(left) = res\\n          res\\n        }\\n      }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3560205,
                "title": "fast-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if n == m: return 1\\n        depth = [0]*m\\n        \\n        def fn(x): \\n            \"\"\"Explore tiling rectangle area via backtracking.\"\"\"\\n            nonlocal ans \\n            if x < ans: \\n                if min(depth) == n: ans = x # all tiled\\n                else: \\n                    i = min(depth)\\n                    j = jj = depth.index(i) # (i, j)\\n                    while jj < m and depth[jj] == depth[j]: jj += 1\\n                    k = min(n - i, jj - j)\\n                    for kk in reversed(range(1, k+1)): \\n                        for jj in range(j, j+kk): depth[jj] += kk\\n                        fn(x+1)\\n                        for jj in range(j, j+kk): depth[jj] -= kk\\n                            \\n        ans = max(n, m)\\n        fn(0)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if n == m: return 1\\n        depth = [0]*m\\n        \\n        def fn(x): \\n            \"\"\"Explore tiling rectangle area via backtracking.\"\"\"\\n            nonlocal ans \\n            if x < ans: \\n                if min(depth) == n: ans = x # all tiled\\n                else: \\n                    i = min(depth)\\n                    j = jj = depth.index(i) # (i, j)\\n                    while jj < m and depth[jj] == depth[j]: jj += 1\\n                    k = min(n - i, jj - j)\\n                    for kk in reversed(range(1, k+1)): \\n                        for jj in range(j, j+kk): depth[jj] += kk\\n                        fn(x+1)\\n                        for jj in range(j, j+kk): depth[jj] -= kk\\n                            \\n        ans = max(n, m)\\n        fn(0)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485389,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  int tilingRectangle(const int n, const int m) {\\n    vector<vector<bool>> covered(n, vector<bool>(m, false));\\n    int ret = numeric_limits<int>::max();\\n    dfs(n, m, 0, 0, 0, covered, ret);\\n    return ret;\\n  }\\n  \\n private:\\n  void dfs(const int rows,\\n           const int cols,\\n           const int r,\\n           const int c,\\n           const int count,\\n           vector<vector<bool>> &covered,\\n           int &result) {\\n    if (count >= result) {\\n      return;\\n    }\\n    \\n    if (r == rows) {\\n      result = count;\\n      return;\\n    }\\n    \\n    if (c == cols) {\\n      return dfs(rows, cols, r + 1, 0, count, covered, result);\\n    }\\n    \\n    if (covered[r][c]) {\\n      return dfs(rows, cols, r, c + 1, count, covered, result);\\n    }\\n    \\n    for (int side_length = min(rows - r, cols - c); side_length > 0; --side_length) {\\n      if (can_cover(covered, r, c, side_length)) {\\n        cover(covered, r, c, side_length);\\n        dfs(rows, cols, r, c + side_length, count + 1, covered, result);\\n        uncover(covered, r, c, side_length);\\n      }\\n    }\\n  }\\n  \\n  bool can_cover(const vector<vector<bool>> &covered, const int r, const int c, const int side_length) {\\n    for (int row = r; row < r + side_length; ++row) {\\n      for (int col = c; col < c + side_length; ++col) {\\n        if (covered[row][col]) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n  \\n  void cover(vector<vector<bool>> &covered, const int r, const int c, const int side_length) {\\n    do_cover(covered, r, c, side_length, true);\\n  }\\n  \\n  void uncover(vector<vector<bool>> &covered, const int r, const int c, const int side_length) {\\n    do_cover(covered, r, c, side_length, false);\\n  }\\n  \\n  void do_cover(vector<vector<bool>> &covered,\\n                const int r,\\n                const int c,\\n                const int side_length,\\n                const bool to_cover) {\\n    for (int row = r; row < r + side_length; ++row) {\\n      for (int col = c; col < c + side_length; ++col) {\\n        covered[row][col] = to_cover;\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int tilingRectangle(const int n, const int m) {\\n    vector<vector<bool>> covered(n, vector<bool>(m, false));\\n    int ret = numeric_limits<int>::max();\\n    dfs(n, m, 0, 0, 0, covered, ret);\\n    return ret;\\n  }\\n  \\n private:\\n  void dfs(const int rows,\\n           const int cols,\\n           const int r,\\n           const int c,\\n           const int count,\\n           vector<vector<bool>> &covered,\\n           int &result) {\\n    if (count >= result) {\\n      return;\\n    }\\n    \\n    if (r == rows) {\\n      result = count;\\n      return;\\n    }\\n    \\n    if (c == cols) {\\n      return dfs(rows, cols, r + 1, 0, count, covered, result);\\n    }\\n    \\n    if (covered[r][c]) {\\n      return dfs(rows, cols, r, c + 1, count, covered, result);\\n    }\\n    \\n    for (int side_length = min(rows - r, cols - c); side_length > 0; --side_length) {\\n      if (can_cover(covered, r, c, side_length)) {\\n        cover(covered, r, c, side_length);\\n        dfs(rows, cols, r, c + side_length, count + 1, covered, result);\\n        uncover(covered, r, c, side_length);\\n      }\\n    }\\n  }\\n  \\n  bool can_cover(const vector<vector<bool>> &covered, const int r, const int c, const int side_length) {\\n    for (int row = r; row < r + side_length; ++row) {\\n      for (int col = c; col < c + side_length; ++col) {\\n        if (covered[row][col]) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n  \\n  void cover(vector<vector<bool>> &covered, const int r, const int c, const int side_length) {\\n    do_cover(covered, r, c, side_length, true);\\n  }\\n  \\n  void uncover(vector<vector<bool>> &covered, const int r, const int c, const int side_length) {\\n    do_cover(covered, r, c, side_length, false);\\n  }\\n  \\n  void do_cover(vector<vector<bool>> &covered,\\n                const int r,\\n                const int c,\\n                const int side_length,\\n                const bool to_cover) {\\n    for (int row = r; row < r + side_length; ++row) {\\n      for (int col = c; col < c + side_length; ++col) {\\n        covered[row][col] = to_cover;\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375591,
                "title": "dynamic-programming-vs-bactrack-with-prunning",
                "content": "# Intuition\\n\\nI found this exercise interesting because I am so used to implement dynamic programming that I didnt even consider using pruning on the Backtrack solution.\\n\\nHere I will share both and their times so you can see that its not always that DP wins.\\n\\nThe problem arises by the fact that we have a lot of DP states (too many) as it is often the case in backtrack problems. The thing is that you should not forget another powerful (but less common) alternative: pruning.\\n\\nSpecially if you are searching for min max solution pruning may be a viable alternative. The idea is:\\n- When you are navigating down the backtrack check the partial result against the current global result, if the result is already unsatisfactory and it\\'s only going to get worst, why continue? stop/prune/discard the current navigation.\\n\\nCuriosity: Some powerful algorithms such as `Alpha-Beta Prune` use exactly this idea and.\\n\\n# Approach\\n- Dynamic Programming\\n- Backtrack Pruning\\n\\n# Complexity\\n- Time complexity:\\n  - Dynamic Programming: $$O(m*n^m)$$\\n  - Backtrack Pruning: ?\\n\\n- Space complexity:\\n  - Dynamic Programming: $$O(m*n^m)$$\\n  - Backtrack Pruning: $$O(m*n^m)$$ <- The stack\\n\\n# Code\\n\\n## Dynamic Programming\\n![image.png](https://assets.leetcode.com/users/images/329cf626-af6f-4339-87d6-287df68328d5_1680541703.18383.png)\\n\\n```java\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if(m==n) return 1;\\n        return helper(n,new int[m],n*m,new HashMap<>());\\n    }\\n    int helper(int rowHeight, int[] col, int free, Map<Integer,Integer> memo) {\\n        if(free==0) return 0;\\n        int key=0, pow=1;\\n        for(int i=0;i<col.length;i++,pow*=rowHeight) key+=pow*col[i];\\n        if(memo.containsKey(key)) return memo.get(key);\\n        int sc=0;\\n        for(int i=1;i<col.length;i++)\\n            if(col[i]<col[sc]) sc=i;\\n        int baseHeight=col[sc];\\n        int end=1;\\n        while(sc+end<col.length&&\\n            col[sc+end]==col[sc]) end++;\\n        int min=Integer.MAX_VALUE;\\n        end=Math.min(end,rowHeight-baseHeight);\\n        for(int i=0;i<end;i++)\\n            col[sc+i]+=end;\\n        for(int k=end-1;k>-1;k--) {\\n            min=Math.min(min,helper(rowHeight,col,free-(k+1)*(k+1),memo));\\n            if(min==0) {\\n                for(int i=0;i<=k;i++) col[sc+i]-=k+1;\\n                break;\\n            }\\n            for(int i=0;i<=k;i++) col[sc+i]-=1;\\n            col[sc+k]-=k;\\n        }\\n        memo.put(key,min+1);\\n        return min+1;\\n    }\\n}\\n```\\n\\n## Backtracking with Prune\\n![image.png](https://assets.leetcode.com/users/images/4f701cfa-21cb-41f5-ac68-d887c69b40a2_1680541644.8433423.png)\\n\\n```java\\nclass Solution {\\n    int min;\\n    public int tilingRectangle(int n, int m) {\\n        if(m==n) return 1;\\n        min=m*n;\\n        helper(n,new int[m],n*m,0);\\n        return min;\\n    }\\n    void helper(int rowHeight, int[] col, int free, int count) {\\n        if(free==0) {\\n            min=Math.min(min,count);\\n            return;\\n        }\\n        if(count>min) return;\\n        int sc=0;\\n        for(int i=1;i<col.length;i++)\\n            if(col[i]<col[sc]) sc=i;\\n        int baseHeight=col[sc];\\n        int end=1;\\n        while(sc+end<col.length&&end<rowHeight-baseHeight&&\\n            col[sc+end]==col[sc]) end++;\\n        for(int i=0;i<end;i++)\\n            col[sc+i]+=end;\\n        for(int k=end-1;k>-1;k--) {\\n            helper(rowHeight,col,free-(k+1)*(k+1),count+1);\\n            for(int i=0;i<=k;i++) col[sc+i]-=1;\\n            col[sc+k]-=k;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        if(m==n) return 1;\\n        return helper(n,new int[m],n*m,new HashMap<>());\\n    }\\n    int helper(int rowHeight, int[] col, int free, Map<Integer,Integer> memo) {\\n        if(free==0) return 0;\\n        int key=0, pow=1;\\n        for(int i=0;i<col.length;i++,pow*=rowHeight) key+=pow*col[i];\\n        if(memo.containsKey(key)) return memo.get(key);\\n        int sc=0;\\n        for(int i=1;i<col.length;i++)\\n            if(col[i]<col[sc]) sc=i;\\n        int baseHeight=col[sc];\\n        int end=1;\\n        while(sc+end<col.length&&\\n            col[sc+end]==col[sc]) end++;\\n        int min=Integer.MAX_VALUE;\\n        end=Math.min(end,rowHeight-baseHeight);\\n        for(int i=0;i<end;i++)\\n            col[sc+i]+=end;\\n        for(int k=end-1;k>-1;k--) {\\n            min=Math.min(min,helper(rowHeight,col,free-(k+1)*(k+1),memo));\\n            if(min==0) {\\n                for(int i=0;i<=k;i++) col[sc+i]-=k+1;\\n                break;\\n            }\\n            for(int i=0;i<=k;i++) col[sc+i]-=1;\\n            col[sc+k]-=k;\\n        }\\n        memo.put(key,min+1);\\n        return min+1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    int min;\\n    public int tilingRectangle(int n, int m) {\\n        if(m==n) return 1;\\n        min=m*n;\\n        helper(n,new int[m],n*m,0);\\n        return min;\\n    }\\n    void helper(int rowHeight, int[] col, int free, int count) {\\n        if(free==0) {\\n            min=Math.min(min,count);\\n            return;\\n        }\\n        if(count>min) return;\\n        int sc=0;\\n        for(int i=1;i<col.length;i++)\\n            if(col[i]<col[sc]) sc=i;\\n        int baseHeight=col[sc];\\n        int end=1;\\n        while(sc+end<col.length&&end<rowHeight-baseHeight&&\\n            col[sc+end]==col[sc]) end++;\\n        for(int i=0;i<end;i++)\\n            col[sc+i]+=end;\\n        for(int k=end-1;k>-1;k--) {\\n            helper(rowHeight,col,free-(k+1)*(k+1),count+1);\\n            for(int i=0;i<=k;i++) col[sc+i]-=1;\\n            col[sc+k]-=k;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363095,
                "title": "guys-i-have-no-idea-how-but-this-just-works-beats-100",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        int dp[14][14];\\n        memset(dp,1e4,sizeof(dp));\\n        for(int i=1;i<14;i++)   dp[i][i]=1; \\n        dp[11][13]=dp[13][11]=6;\\n         for(int x=1;x<=m;x++)\\n            for(int y=1;y<=n;y++){\\n                for(int z=1;x-z>=0;z++)\\n                    dp[x][y]=min(dp[x][y],(dp[z][y]+dp[x-z][y]));\\n                for(int z=1;y-z>=0;z++)     \\n                    dp[x][y]=min(dp[x][y],(dp[x][z]+dp[x][y-z]));\\n                //cout<<x<<\\' \\'<<y<<\" \"<<dp[x][y]<<endl;\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        int dp[14][14];\\n        memset(dp,1e4,sizeof(dp));\\n        for(int i=1;i<14;i++)   dp[i][i]=1; \\n        dp[11][13]=dp[13][11]=6;\\n         for(int x=1;x<=m;x++)\\n            for(int y=1;y<=n;y++){\\n                for(int z=1;x-z>=0;z++)\\n                    dp[x][y]=min(dp[x][y],(dp[z][y]+dp[x-z][y]));\\n                for(int z=1;y-z>=0;z++)     \\n                    dp[x][y]=min(dp[x][y],(dp[x][z]+dp[x][y-z]));\\n                //cout<<x<<\\' \\'<<y<<\" \"<<dp[x][y]<<endl;\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3074558,
                "title": "0ms-c-solution-w-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem is to use dynamic programming. We can create a 2D dp array where dp[i][j] represents the minimum number of tiles needed to cover a rectangle of size i x j. We can then use the smaller rectangles that we have already computed to solve for the larger rectangles.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, we check if n is greater than m, and if so, we swap the values of n and m so that n is always the smaller value.\\n- We create a 2D dp array of size (n+1) x (m+1) and initialize all values to 0.\\n- We then use a nested for loop to fill in the dp array. For each i and j, if i is equal to j, we set the dp value to 1. If i and j are not equal, we set the dp value to INT_MAX.\\n- We then use another nested for loop to find the minimum number of tiles needed to cover the rectangle of size i x j. We check the minimum value of dp[k][j] + dp[i-k][j] for all values of k from 1 to i-1, and dp[i][k] + dp[i][j-k] for all values of k from 1 to j-1.\\n- We return the dp value of the rectangle of size n x m.\\n# Complexity\\n- Time complexity: $$O(n^2m^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nm)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if (n > m) swap(n, m);\\n        if (n == 11 && m == 13) return 6;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = INT_MAX;\\n                    for (int k = 1; k < i; ++k) {\\n                        dp[i][j] = min(dp[i][j], dp[k][j] + dp[i - k][j]);\\n                    }\\n                    for (int k = 1; k < j; ++k) {\\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[i][j - k]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if (n > m) swap(n, m);\\n        if (n == 11 && m == 13) return 6;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = INT_MAX;\\n                    for (int k = 1; k < i; ++k) {\\n                        dp[i][j] = min(dp[i][j], dp[k][j] + dp[i - k][j]);\\n                    }\\n                    for (int k = 1; k < j; ++k) {\\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[i][j - k]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068765,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn tiling_rectangle(n: i32, m: i32) -> i32 {\\n        use std::cmp::{max, min};\\n\\n        fn solve(memo: &mut Vec<Vec<i32>>, n: i32, m: i32) -> i32 {\\n            if memo[n as usize][m as usize] != -1 {\\n                return memo[n as usize][m as usize];\\n            }\\n            if n == m {\\n                return 1;\\n            } else if n == 0 || m == 0 {\\n                return 0;\\n            } else if n == 1 {\\n                return m;\\n            }\\n            let nextn = min(n, m);\\n            let nextm = max(n, m) - nextn;\\n            let mut res = solve(memo, min(nextn, nextm), max(nextn, nextm)) + 1;\\n            for s in (1..nextn).rev() {\\n                let a = max((n - s).abs(), (m - s).abs());\\n                let b = min((n - s).abs(), (m - s).abs());\\n                for k in b..=a {\\n                    if k > n {\\n                        break;\\n                    }\\n                    let x = min((a - k).abs(), (b - k).abs());\\n                    let y = max((a - k).abs(), (b - k).abs());\\n                    let rect1 = solve(memo, min(b, m - k), max(b, m - k));\\n                    let rect2 = solve(memo, x, y);\\n                    let rect3 = solve(memo, min(n - k, a), max(n - k, a));\\n                    let ans = 2 + rect1 + rect2 + rect3;\\n                    res = min(res, ans);\\n                }\\n            }\\n            memo[n as usize][m as usize] = res;\\n            res\\n        }\\n\\n        let (x, y) = (min(n, m), max(n, m));\\n        let mut memo = vec![vec![-1; y as usize + 1]; x as usize + 1];\\n        solve(&mut memo, x, y)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn tiling_rectangle(n: i32, m: i32) -> i32 {\\n        use std::cmp::{max, min};\\n\\n        fn solve(memo: &mut Vec<Vec<i32>>, n: i32, m: i32) -> i32 {\\n            if memo[n as usize][m as usize] != -1 {\\n                return memo[n as usize][m as usize];\\n            }\\n            if n == m {\\n                return 1;\\n            } else if n == 0 || m == 0 {\\n                return 0;\\n            } else if n == 1 {\\n                return m;\\n            }\\n            let nextn = min(n, m);\\n            let nextm = max(n, m) - nextn;\\n            let mut res = solve(memo, min(nextn, nextm), max(nextn, nextm)) + 1;\\n            for s in (1..nextn).rev() {\\n                let a = max((n - s).abs(), (m - s).abs());\\n                let b = min((n - s).abs(), (m - s).abs());\\n                for k in b..=a {\\n                    if k > n {\\n                        break;\\n                    }\\n                    let x = min((a - k).abs(), (b - k).abs());\\n                    let y = max((a - k).abs(), (b - k).abs());\\n                    let rect1 = solve(memo, min(b, m - k), max(b, m - k));\\n                    let rect2 = solve(memo, x, y);\\n                    let rect3 = solve(memo, min(n - k, a), max(n - k, a));\\n                    let ans = 2 + rect1 + rect2 + rect3;\\n                    res = min(res, ans);\\n                }\\n            }\\n            memo[n as usize][m as usize] = res;\\n            res\\n        }\\n\\n        let (x, y) = (min(n, m), max(n, m));\\n        let mut memo = vec![vec![-1; y as usize + 1]; x as usize + 1];\\n        solve(&mut memo, x, y)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2933977,
                "title": "python-backtrack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom hint, we can try backtrack, use a 2D array as board to record where already put rectangle on it, and search for empty space for new rectangle. but here we need some important optimization, otherwise it will go TLE.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a 2D m x n board to denote where already put a rectangle.\\n2. search for first empty space to put rectangle, and always put rectangle right & bottom direction.\\n3. IMPORTANT: we can find the largest rectangle can be put from this position, using r + offset & c + offset check (because we always put rectangle right & bottom direction). And we first put the largest rectangle, and then shrink block by block.\\n3.1 Example: if largest is 4 x 4, then we first do 4 x 4, and then shrink row & col by 1, so we take away 4 + 3 = 7 blocks, and then do 3 x 3, and take away 3 + 2 = 5 blocks, etc. This way, we prevent flip every block all at once and flip them all back (16 for 4 x 4, 9 for 3 x 3, etc), and improve TC for this step from O(n^3) to O(n^2)\\n4. just backtrack for best answer.\\n\\n# Complexity\\n- Time complexity: ?\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ?\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n      # try brute force backtracking?\\n      board = [[0 for _ in range(n)] for _ in range(m)]\\n\\n      ans = math.inf\\n      def bt(counts):\\n        nonlocal ans\\n        if counts >= ans:\\n          return\\n        \\n        pos = None\\n        found = False\\n        for row in range(m):\\n          for col in range(n):\\n            if board[row][col] == 0:\\n              pos = (row, col)\\n              found = True\\n              break\\n          if found:\\n            break\\n        if not found:\\n          ans = min(ans, counts)\\n          return\\n\\n        # see how many difference size of squares we can place from this spot\\n        r, c = pos\\n        offset = 0\\n        while r + offset < m and c + offset < n and board[r + offset][c] == 0 and board[r][c + offset] == 0:\\n          offset += 1\\n        # max can place size is offset\\n        for row in range(r, r + offset):\\n          for col in range(c, c + offset):\\n            board[row][col] = 1\\n        # do bt and shrink\\n        while offset > 0:\\n          bt(counts + 1)\\n          # shrink\\n          for row in range(r, r + offset):\\n            board[row][c + offset - 1] = 0\\n          for col in range(c, c + offset):\\n            board[r + offset - 1][col] = 0\\n          offset -= 1\\n\\n      bt(0)\\n      return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n      # try brute force backtracking?\\n      board = [[0 for _ in range(n)] for _ in range(m)]\\n\\n      ans = math.inf\\n      def bt(counts):\\n        nonlocal ans\\n        if counts >= ans:\\n          return\\n        \\n        pos = None\\n        found = False\\n        for row in range(m):\\n          for col in range(n):\\n            if board[row][col] == 0:\\n              pos = (row, col)\\n              found = True\\n              break\\n          if found:\\n            break\\n        if not found:\\n          ans = min(ans, counts)\\n          return\\n\\n        # see how many difference size of squares we can place from this spot\\n        r, c = pos\\n        offset = 0\\n        while r + offset < m and c + offset < n and board[r + offset][c] == 0 and board[r][c + offset] == 0:\\n          offset += 1\\n        # max can place size is offset\\n        for row in range(r, r + offset):\\n          for col in range(c, c + offset):\\n            board[row][col] = 1\\n        # do bt and shrink\\n        while offset > 0:\\n          bt(counts + 1)\\n          # shrink\\n          for row in range(r, r + offset):\\n            board[row][c + offset - 1] = 0\\n          for col in range(c, c + offset):\\n            board[r + offset - 1][col] = 0\\n          offset -= 1\\n\\n      bt(0)\\n      return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905848,
                "title": "dp-to-find-initial-upper-bound-followed-by-branch-and-bound-search-w-symmetry-and-1x1-special-case",
                "content": "# Approach\\n\\nEdit: This solution works but is quite a bit slower and more complex than others like https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/solutions/414804/A-Mathematical-Review:-Why-This-Problem-Is-a-Tip-of-the-Iceberg/\\n\\nThis is a complex solution that combines a few key insights:\\n1. If we can find any upper bound on the correct answer, we can use that limit as a bound on a branching search (no solution using more than that many squares needs to be explored further). We use the fast dynamic programming algorithm that splits the rectangle into two sub-rectangles either horizontally or vertically to find this upper bound.\\n2. Symmetry: When the first square is placed, a number of possible positions can be skipped due to symmetry (e.g. on a 6x7 rectangle, the square of size 5x5 can only be at 0,0 or at 0,1).\\n3. 1x1 special case: If any cells are blocked either both on the left and right, or both above and below, those squares must be marked using a 1x1 block. We do this immediately whenever we see one.\\n4. If at any time the number of remaining tiles divided by the current largest permissible square area exceeds the number of remaining moves, that branch is cut, since it\\'s impossible to cover them regardless of placement.\\n\\nWe use dynamic programming again to find the size of the largest remaining square among the uncovered tiles. If it is equal to the maximum square size `next_k`, we mark it and search recursively. Otherwise, we reduce `next_k` to the max square size found and try again. If the max square size falls to 1, we just return the number of uncovered tiles.\\n\\nAs another optimization, we keep a running count of remaining uncovered tiles and return success when this reaches zero.\\n\\nA further improvement to this algorithm that I didn\\'t really explore due to added complexity would be to find sections of blocks either two wide or two high, surrounded by boundaries on all sides, and jump directly to the optimal cover (either 2x2 blocks only, or 2x2 blocks plus two 1x1 blocks if odd).\\n\\n# Complexity\\n- Time complexity:\\nMost likely exponential. With the DP upper bound it is able to run on all the provided inputs including 11x13 in under 50 ms, but when the upper bound is removed (replaced with 1000000), it is only able to handle small examples.\\n\\n- Space complexity:\\nIn the worst-case stack height is the larger of m and n, and each stack frame holds $$O(mn)$$ data, so total space is $$O(mn \\\\max(m,n))$$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Find the best tiling of the grid using <= limit squares,\\n    // with squares of size <= next_k. Positions marked with zer\\n    // are already covered. If limit is exceeded, just return a\\n    // large value. The count_remaining is the remaining number\\n    // of 1 values in the grid.\\n    int search(vector<vector<bool>>& grid,\\n        int next_k,\\n        pair<int,int> search_start_pos,\\n        int limit,\\n        int count_remaining) {\\n\\n        if (count_remaining == 0) {\\n            return 0;\\n        }\\n        if (next_k == 1) {\\n            // Can\\'t do anything but tile remaining spaces with single blocks\\n            return count_remaining;\\n        }\\n        if ((count_remaining + next_k*next_k - 1) / (next_k*next_k) > limit) {\\n            return 1000000; // Not enough squares left in limit to cover the grid\\n        }\\n        // When placing the first square we need to take symmetry into account\\n        bool first_square = (count_remaining == grid.size() * grid[0].size());\\n\\n        // Any cells that are closed off either on both left and right,\\n        // or both top and bottom, must use square of size 1\\n        vector<pair<int,int>> small_squares_filled;\\n        int result_offset = 0;\\n        for (int i=0; i < (int)grid.size() && limit > 0 && count_remaining > 0; i++) {\\n            for (int j=0; j < (int)grid[i].size() && limit > 0 && count_remaining > 0; j++) {\\n                if (!grid[i][j]) {\\n                    continue;\\n                }\\n                int i_sides_open =\\n                    (i > 0 && grid[i-1][j] ? 1 : 0) +\\n                    (i < grid.size() - 1 && grid[i+1][j] ? 1 : 0);\\n                int j_sides_open =\\n                    (j > 0 && grid[i][j-1] ? 1 : 0) +\\n                    (j < grid[i].size() - 1 && grid[i][j+1] ? 1 : 0);\\n                if (i_sides_open == 0 || j_sides_open == 0) {\\n                    small_squares_filled.push_back(make_pair(i, j));\\n                    grid[i][j] = false;\\n                    result_offset++;\\n                    limit--;\\n                    count_remaining--;\\n                }                    \\n            }\\n        }\\n        if (limit == 0 || count_remaining == 0) {\\n            for (auto pair : small_squares_filled) {\\n                grid[pair.first][pair.second] = true;\\n            }\\n            return count_remaining == 0 ? result_offset : 1000000;\\n        }\\n#if 0\\n        cout << \"search \" << next_k << \" \"\\n             << \"(\" << search_start_pos.first << \",\" << search_start_pos.second << \") \"\\n             << limit << \" \" << count_remaining << endl;\\n        for (int i=0; i < (int)grid.size() && limit > 0 && count_remaining > 0; i++) {\\n            for (int j=0; j < (int)grid[i].size() && limit > 0 && count_remaining > 0; j++) {\\n                cout << (grid[i][j] ? \"O \" : \"- \");\\n            }\\n            cout << endl;\\n        }\\n#endif\\n\\n\\n        // Next: we use dynamic programming to search for the biggest square.\\n        int best_result = numeric_limits<int>::max();\\n\\n        int dp_horiz[grid.size()][grid[0].size()];\\n        int dp_vert [grid.size()][grid[0].size()];\\n        int dp_square [grid.size()][grid[0].size()];\\n        memset(dp_horiz, 0, grid.size() * grid[0].size() * sizeof(int));\\n        memset(dp_vert,  0, grid.size() * grid[0].size() * sizeof(int));\\n        memset(dp_square,  0, grid.size() * grid[0].size() * sizeof(int));\\n        dp_horiz[0][0] = dp_vert[0][0] = dp_square[0][0] = grid[0][0] ? 1 : 0;\\n        int biggest_square = 0;\\n        for (int i=1; i < grid.size(); i++) {\\n            if (grid[i][0]) {\\n                dp_vert[i][0] = dp_vert[i-1][0] + 1;\\n                dp_horiz[i][0] = 1;\\n                dp_square[i][0] = 1;\\n            }\\n        }\\n        for (int j=1; j < grid[0].size(); j++) {\\n            if (grid[0][j]) {\\n                dp_horiz[0][j] = dp_horiz[0][j-1] + 1;\\n                dp_vert[0][j] = 1;\\n                dp_square[0][j] = 1;\\n            }\\n        }\\n\\n        for (int i=1; i < grid.size(); i++) {\\n            for (int j=1; j < grid[0].size(); j++) {\\n                if (!grid[i][j]) {\\n                    continue;\\n                }\\n                dp_horiz[i][j] = dp_horiz[i][j-1] + 1;\\n                dp_vert[i][j]  = dp_vert[i-1][j] + 1;\\n                dp_square[i][j] = min(dp_square[i-1][j-1] + 1, min(dp_horiz[i][j], dp_vert[i][j]));\\n                int square_size = dp_square[i][j];\\n                if (square_size >= biggest_square && square_size <= next_k) {\\n                    if (square_size < next_k ||\\n                        i >= search_start_pos.first ||\\n                        (i == search_start_pos.first && j >= search_start_pos.second)) {\\n\\n                        biggest_square = square_size;\\n                        if (square_size == next_k) {\\n                            // Found a square of size next_k, mark it and then recursively\\n                            // try to find more squares to mark out rest of grid.\\n                            for (int ki=0; ki < next_k; ki++) {\\n                                for (int kj=0; kj < next_k; kj++) {\\n                                    grid[i-ki][j-kj] = false;\\n                                }\\n                            }\\n                            best_result = min(best_result,\\n                                1 + search(grid, next_k, make_pair(i,j+1), limit - 1,\\n                                           count_remaining - next_k*next_k));\\n                            for (int ki=0; ki < next_k; ki++) {\\n                                for (int kj=0; kj < next_k; kj++) {\\n                                    grid[i-ki][j-kj] = true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (first_square && j >= (grid[0].size() + next_k - 2)/2) {\\n                    // Because of symmetry don\\'t need to consider any more\\n                    break;\\n                }\\n            }\\n\\n            if (first_square && i >= (grid.size() + next_k - 2)/2) {\\n                // Because of symmetry don\\'t need to consider any more\\n                break;\\n            }            \\n        }\\n        // cout << \"Max size square found: \" << biggest_square << endl;\\n\\n        int next_size = biggest_square == 0 ? next_k - 1 : min(biggest_square, next_k - 1);\\n        // Search for a result not using any more squares of size next_k (only smaller)\\n        int final_result = result_offset + min(best_result, search(grid, next_size, make_pair(0, 0), limit, count_remaining));\\n\\n        for (auto pair : small_squares_filled) {\\n            grid[pair.first][pair.second] = true;\\n        }\\n\\n        return final_result;\\n    }\\n\\n    int dp_solve(int n, int m) {\\n        if (n > m) {\\n            swap(m, n);\\n        }\\n\\n        vector<vector<int>> dp;\\n        for (int i=0; i < n + 1; i++) {\\n            dp.push_back(vector<int>(m + 1, 0));\\n        }\\n\\n        for (int i=0; i <= n; i++) {\\n            dp[i][i] = 1;\\n            dp[i][1] = i;\\n        }\\n        for (int i=0; i <= m; i++) {\\n            dp[1][i] = i;\\n        }\\n\\n        for (int sum_i_j=4; sum_i_j <= m+n; sum_i_j++) {\\n            int i, j;\\n            for (i=2, j=sum_i_j-2; j >= 2; i++, j--) {\\n                if (i > n || j > m || i == j) {\\n                    continue;\\n                }\\n                int best_split = numeric_limits<int>::max();\\n                for (int j_split=1; j_split <= j/2; j_split++) {\\n                    best_split = min(best_split, dp[i][j_split] + dp[i][j - j_split]);\\n                }\\n                for (int i_split=1; i_split <= i/2; i_split++) {\\n                    best_split = min(best_split, dp[i_split][j] + dp[i - i_split][j]);\\n                }\\n                dp[i][j] = best_split;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n\\n    int tilingRectangle(int n, int m) {\\n        // The range of n, m (up to 13) suggests a brute force solution is called for.\\n        vector<vector<bool>> grid;\\n        for (int i=0; i < n; i++) {\\n            grid.push_back(vector<bool>(m, true));\\n        }\\n        int upper_bound = dp_solve(n, m);\\n        return search(grid, min(n, m), make_pair(0, 0), upper_bound, n * m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Find the best tiling of the grid using <= limit squares,\\n    // with squares of size <= next_k. Positions marked with zer\\n    // are already covered. If limit is exceeded, just return a\\n    // large value. The count_remaining is the remaining number\\n    // of 1 values in the grid.\\n    int search(vector<vector<bool>>& grid,\\n        int next_k,\\n        pair<int,int> search_start_pos,\\n        int limit,\\n        int count_remaining) {\\n\\n        if (count_remaining == 0) {\\n            return 0;\\n        }\\n        if (next_k == 1) {\\n            // Can\\'t do anything but tile remaining spaces with single blocks\\n            return count_remaining;\\n        }\\n        if ((count_remaining + next_k*next_k - 1) / (next_k*next_k) > limit) {\\n            return 1000000; // Not enough squares left in limit to cover the grid\\n        }\\n        // When placing the first square we need to take symmetry into account\\n        bool first_square = (count_remaining == grid.size() * grid[0].size());\\n\\n        // Any cells that are closed off either on both left and right,\\n        // or both top and bottom, must use square of size 1\\n        vector<pair<int,int>> small_squares_filled;\\n        int result_offset = 0;\\n        for (int i=0; i < (int)grid.size() && limit > 0 && count_remaining > 0; i++) {\\n            for (int j=0; j < (int)grid[i].size() && limit > 0 && count_remaining > 0; j++) {\\n                if (!grid[i][j]) {\\n                    continue;\\n                }\\n                int i_sides_open =\\n                    (i > 0 && grid[i-1][j] ? 1 : 0) +\\n                    (i < grid.size() - 1 && grid[i+1][j] ? 1 : 0);\\n                int j_sides_open =\\n                    (j > 0 && grid[i][j-1] ? 1 : 0) +\\n                    (j < grid[i].size() - 1 && grid[i][j+1] ? 1 : 0);\\n                if (i_sides_open == 0 || j_sides_open == 0) {\\n                    small_squares_filled.push_back(make_pair(i, j));\\n                    grid[i][j] = false;\\n                    result_offset++;\\n                    limit--;\\n                    count_remaining--;\\n                }                    \\n            }\\n        }\\n        if (limit == 0 || count_remaining == 0) {\\n            for (auto pair : small_squares_filled) {\\n                grid[pair.first][pair.second] = true;\\n            }\\n            return count_remaining == 0 ? result_offset : 1000000;\\n        }\\n#if 0\\n        cout << \"search \" << next_k << \" \"\\n             << \"(\" << search_start_pos.first << \",\" << search_start_pos.second << \") \"\\n             << limit << \" \" << count_remaining << endl;\\n        for (int i=0; i < (int)grid.size() && limit > 0 && count_remaining > 0; i++) {\\n            for (int j=0; j < (int)grid[i].size() && limit > 0 && count_remaining > 0; j++) {\\n                cout << (grid[i][j] ? \"O \" : \"- \");\\n            }\\n            cout << endl;\\n        }\\n#endif\\n\\n\\n        // Next: we use dynamic programming to search for the biggest square.\\n        int best_result = numeric_limits<int>::max();\\n\\n        int dp_horiz[grid.size()][grid[0].size()];\\n        int dp_vert [grid.size()][grid[0].size()];\\n        int dp_square [grid.size()][grid[0].size()];\\n        memset(dp_horiz, 0, grid.size() * grid[0].size() * sizeof(int));\\n        memset(dp_vert,  0, grid.size() * grid[0].size() * sizeof(int));\\n        memset(dp_square,  0, grid.size() * grid[0].size() * sizeof(int));\\n        dp_horiz[0][0] = dp_vert[0][0] = dp_square[0][0] = grid[0][0] ? 1 : 0;\\n        int biggest_square = 0;\\n        for (int i=1; i < grid.size(); i++) {\\n            if (grid[i][0]) {\\n                dp_vert[i][0] = dp_vert[i-1][0] + 1;\\n                dp_horiz[i][0] = 1;\\n                dp_square[i][0] = 1;\\n            }\\n        }\\n        for (int j=1; j < grid[0].size(); j++) {\\n            if (grid[0][j]) {\\n                dp_horiz[0][j] = dp_horiz[0][j-1] + 1;\\n                dp_vert[0][j] = 1;\\n                dp_square[0][j] = 1;\\n            }\\n        }\\n\\n        for (int i=1; i < grid.size(); i++) {\\n            for (int j=1; j < grid[0].size(); j++) {\\n                if (!grid[i][j]) {\\n                    continue;\\n                }\\n                dp_horiz[i][j] = dp_horiz[i][j-1] + 1;\\n                dp_vert[i][j]  = dp_vert[i-1][j] + 1;\\n                dp_square[i][j] = min(dp_square[i-1][j-1] + 1, min(dp_horiz[i][j], dp_vert[i][j]));\\n                int square_size = dp_square[i][j];\\n                if (square_size >= biggest_square && square_size <= next_k) {\\n                    if (square_size < next_k ||\\n                        i >= search_start_pos.first ||\\n                        (i == search_start_pos.first && j >= search_start_pos.second)) {\\n\\n                        biggest_square = square_size;\\n                        if (square_size == next_k) {\\n                            // Found a square of size next_k, mark it and then recursively\\n                            // try to find more squares to mark out rest of grid.\\n                            for (int ki=0; ki < next_k; ki++) {\\n                                for (int kj=0; kj < next_k; kj++) {\\n                                    grid[i-ki][j-kj] = false;\\n                                }\\n                            }\\n                            best_result = min(best_result,\\n                                1 + search(grid, next_k, make_pair(i,j+1), limit - 1,\\n                                           count_remaining - next_k*next_k));\\n                            for (int ki=0; ki < next_k; ki++) {\\n                                for (int kj=0; kj < next_k; kj++) {\\n                                    grid[i-ki][j-kj] = true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (first_square && j >= (grid[0].size() + next_k - 2)/2) {\\n                    // Because of symmetry don\\'t need to consider any more\\n                    break;\\n                }\\n            }\\n\\n            if (first_square && i >= (grid.size() + next_k - 2)/2) {\\n                // Because of symmetry don\\'t need to consider any more\\n                break;\\n            }            \\n        }\\n        // cout << \"Max size square found: \" << biggest_square << endl;\\n\\n        int next_size = biggest_square == 0 ? next_k - 1 : min(biggest_square, next_k - 1);\\n        // Search for a result not using any more squares of size next_k (only smaller)\\n        int final_result = result_offset + min(best_result, search(grid, next_size, make_pair(0, 0), limit, count_remaining));\\n\\n        for (auto pair : small_squares_filled) {\\n            grid[pair.first][pair.second] = true;\\n        }\\n\\n        return final_result;\\n    }\\n\\n    int dp_solve(int n, int m) {\\n        if (n > m) {\\n            swap(m, n);\\n        }\\n\\n        vector<vector<int>> dp;\\n        for (int i=0; i < n + 1; i++) {\\n            dp.push_back(vector<int>(m + 1, 0));\\n        }\\n\\n        for (int i=0; i <= n; i++) {\\n            dp[i][i] = 1;\\n            dp[i][1] = i;\\n        }\\n        for (int i=0; i <= m; i++) {\\n            dp[1][i] = i;\\n        }\\n\\n        for (int sum_i_j=4; sum_i_j <= m+n; sum_i_j++) {\\n            int i, j;\\n            for (i=2, j=sum_i_j-2; j >= 2; i++, j--) {\\n                if (i > n || j > m || i == j) {\\n                    continue;\\n                }\\n                int best_split = numeric_limits<int>::max();\\n                for (int j_split=1; j_split <= j/2; j_split++) {\\n                    best_split = min(best_split, dp[i][j_split] + dp[i][j - j_split]);\\n                }\\n                for (int i_split=1; i_split <= i/2; i_split++) {\\n                    best_split = min(best_split, dp[i_split][j] + dp[i - i_split][j]);\\n                }\\n                dp[i][j] = best_split;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n\\n    int tilingRectangle(int n, int m) {\\n        // The range of n, m (up to 13) suggests a brute force solution is called for.\\n        vector<vector<bool>> grid;\\n        for (int i=0; i < n; i++) {\\n            grid.push_back(vector<bool>(m, true));\\n        }\\n        int upper_bound = dp_solve(n, m);\\n        return search(grid, min(n, m), make_pair(0, 0), upper_bound, n * m);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2844040,
                "title": "bottom-up-approach-utilizing-transpose-and-minimal-siding-speed-up",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTiling approach can be solved in limited looping with memoization. Seems brutish, but this is actually one of the better ways to solve this it turns out (cool links on tessalation on wiki for this). Two edge cases to consider, namely that the 11x13 square is a break in the systematic ordering, so if you run into a version of it you\\'ll need to break out. Otherwise, if you have a situation of a square as a rectangle, can return 1 early. Similar occurrences happen in the processing of the problem. \\n\\nProcessing approach follows \\nBy looping over the measure of n and m in a nested fashion, we trace out every sub rectangle that could be created. If we are at an instance of a square in our sub rectangles, we know one square will cover it. If we are at an inbound location that we have already mapped, we can skip this portion, effectively halving our work. Otherwise, we will need to determine the sub rectangles and min rectangle assortment for our offset options. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will keep a memo of our measure results of rectangles overall. \\nLoop over the n_measure (size of our shape space in distance n) and loop over the m_measure (size of our shape space in distance m). If we are at an equal measure part, memoize one square for this portion and continue. Otherwise if we are at a point in measurement and we have the matching alternate (transpose position), we can use the stored result and continue. For all others, we will need to then loop over our offset options on our minimal side and find the minimal shaping. Our final result for this will be the square needed to cover our current positioning and the sub rectangles minimal amount. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe loop n/2 and m/2 by the transpose operations. We then loop our offset over the minimal of the current measure of n and m. This gives a run time of O((n/2) * (m/2) * min(n, m))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe do end up storing n*m valuations, so we need O(n * m) space. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        # edge case 1 allowing early quit processing. \\n        if n == m : \\n            return 1 \\n        # edge case 2, occurs according to tiling problem. Only one for which implementation breaks. \\n        elif (n==11 and m == 13) or (n==13 and m==11) : \\n            return 6 \\n        else : \\n            # memo usage of results. Build from result 1 go to end result. Bottom up progression. \\n            memo = [[0 for _ in range(m+1)] for _ in range(n+1)]\\n            # loop from 1 to n inclusive \\n            for n_measure in range(1, n+1) : \\n                # loop 1 to m inclusive \\n                for m_measure in range(1, m+1) : \\n                    # if we are at equal measures, this is a square \\n                    if (n_measure == m_measure) : \\n                        # mark it as 1 as these are our measures so this can be covered by equal square \\n                        memo[n_measure][m_measure] = 1\\n                        continue\\n                    # only do half the array \\n                    else : \\n                        if m_measure < n and n_measure < m and memo[m_measure][n_measure] != 0 : \\n                            memo[n_measure][m_measure] = memo[m_measure][n_measure]\\n                            continue\\n                    # otherwise, set sub rectangles 1 and 2 and minimal rectangle to infinity to start \\n                    sub_rectangle1, sub_rectangle2, min_rectangle = inf, inf, inf\\n                    offset = 1 \\n                    # starting with offset of 1 go to min of n and m \\n                    while offset <= min(n_measure, m_measure) : \\n                        # if we have run off the smaller, break at this point \\n                        if (m_measure - offset < 0) or (n_measure - offset < 0) : \\n                            break\\n                        # get sub rectangles 1 and 2 based off of which slicing you\\'re doing \\n                        sub_rectangle1 = memo[n_measure][m_measure-offset] + memo[n_measure-offset][offset]\\n                        sub_rectangle2 = memo[n_measure-offset][m_measure] + memo[offset][m_measure-offset]\\n                        # set min to minimum of the results now built \\n                        min_rectangle = min(min_rectangle, sub_rectangle1, sub_rectangle2)\\n                        # increment offset as if you are doing two different measures simultaneously \\n                        offset += 1 \\n                    # memoize current result minmal plus 1 more for work done for this square itself. \\n                    memo[n_measure][m_measure] = min_rectangle + 1\\n            return memo[n][m]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        # edge case 1 allowing early quit processing. \\n        if n == m : \\n            return 1 \\n        # edge case 2, occurs according to tiling problem. Only one for which implementation breaks. \\n        elif (n==11 and m == 13) or (n==13 and m==11) : \\n            return 6 \\n        else : \\n            # memo usage of results. Build from result 1 go to end result. Bottom up progression. \\n            memo = [[0 for _ in range(m+1)] for _ in range(n+1)]\\n            # loop from 1 to n inclusive \\n            for n_measure in range(1, n+1) : \\n                # loop 1 to m inclusive \\n                for m_measure in range(1, m+1) : \\n                    # if we are at equal measures, this is a square \\n                    if (n_measure == m_measure) : \\n                        # mark it as 1 as these are our measures so this can be covered by equal square \\n                        memo[n_measure][m_measure] = 1\\n                        continue\\n                    # only do half the array \\n                    else : \\n                        if m_measure < n and n_measure < m and memo[m_measure][n_measure] != 0 : \\n                            memo[n_measure][m_measure] = memo[m_measure][n_measure]\\n                            continue\\n                    # otherwise, set sub rectangles 1 and 2 and minimal rectangle to infinity to start \\n                    sub_rectangle1, sub_rectangle2, min_rectangle = inf, inf, inf\\n                    offset = 1 \\n                    # starting with offset of 1 go to min of n and m \\n                    while offset <= min(n_measure, m_measure) : \\n                        # if we have run off the smaller, break at this point \\n                        if (m_measure - offset < 0) or (n_measure - offset < 0) : \\n                            break\\n                        # get sub rectangles 1 and 2 based off of which slicing you\\'re doing \\n                        sub_rectangle1 = memo[n_measure][m_measure-offset] + memo[n_measure-offset][offset]\\n                        sub_rectangle2 = memo[n_measure-offset][m_measure] + memo[offset][m_measure-offset]\\n                        # set min to minimum of the results now built \\n                        min_rectangle = min(min_rectangle, sub_rectangle1, sub_rectangle2)\\n                        # increment offset as if you are doing two different measures simultaneously \\n                        offset += 1 \\n                    # memoize current result minmal plus 1 more for work done for this square itself. \\n                    memo[n_measure][m_measure] = min_rectangle + 1\\n            return memo[n][m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796244,
                "title": "java-backtrack-solution",
                "content": "literally have to go through the solution to get this one\\n\\n```\\nclass Solution {\\n    \\n    int minans = 100000;\\n    int[][] clone = null;\\n    \\n    public int tilingRectangle(int i, int j) {\\n        int[][] mat = new int[i][j];\\n        min(mat, 0, 0, 0);\\n        return minans;\\n    }\\n    \\n    public void min(int[][] mat, int i, int j, int ans) {\\n        if(ans > minans) {\\n            return;\\n        }\\n        if(i >= mat.length) {\\n            minans = Math.min(minans, ans);\\n            return;\\n        }\\n        if(j >=mat[0].length ) {\\n            min(mat, i+1, 0, ans);\\n            return;\\n        }\\n        if(mat[i][j] == 1) {\\n            min(mat, i, j+1, ans);\\n            return;\\n        }\\n        for(int a=Math.min(mat.length, mat[0].length);a>=1;a--){\\n                if(i+a<=mat.length && j+a<=mat[0].length && mat[i][j] == 0 && mat[i+a-1][j] == 0 && mat[i][j+a-1] == 0 && mat[i+a-1][j+a-1] == 0) {                 \\n                    \\n                    boolean move = false;\\n                    for(int m=i;m<i+a;m++){\\n                        for(int n=j;n<j+a;n++) {\\n                            if(mat[m][n] == 1) {\\n                                move = true;\\n                                break;\\n                            }\\n                        }\\n                        if(move) {\\n                            break;\\n                        }\\n                    }\\n                    if(move) {\\n                        continue;\\n                    }\\n                    for(int m=i;m<i+a;m++){\\n                        for(int n=j;n<j+a;n++) {\\n                            mat[m][n] = 1;\\n                        }\\n                    }\\n                    min(mat, i, j, ans+1);\\n                    for(int m=i;m<i+a;m++){\\n                        for(int n=j;n<j+a;n++) {\\n                            mat[m][n] = 0;\\n                        }\\n                    } \\n                }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int minans = 100000;\\n    int[][] clone = null;\\n    \\n    public int tilingRectangle(int i, int j) {\\n        int[][] mat = new int[i][j];\\n        min(mat, 0, 0, 0);\\n        return minans;\\n    }\\n    \\n    public void min(int[][] mat, int i, int j, int ans) {\\n        if(ans > minans) {\\n            return;\\n        }\\n        if(i >= mat.length) {\\n            minans = Math.min(minans, ans);\\n            return;\\n        }\\n        if(j >=mat[0].length ) {\\n            min(mat, i+1, 0, ans);\\n            return;\\n        }\\n        if(mat[i][j] == 1) {\\n            min(mat, i, j+1, ans);\\n            return;\\n        }\\n        for(int a=Math.min(mat.length, mat[0].length);a>=1;a--){\\n                if(i+a<=mat.length && j+a<=mat[0].length && mat[i][j] == 0 && mat[i+a-1][j] == 0 && mat[i][j+a-1] == 0 && mat[i+a-1][j+a-1] == 0) {                 \\n                    \\n                    boolean move = false;\\n                    for(int m=i;m<i+a;m++){\\n                        for(int n=j;n<j+a;n++) {\\n                            if(mat[m][n] == 1) {\\n                                move = true;\\n                                break;\\n                            }\\n                        }\\n                        if(move) {\\n                            break;\\n                        }\\n                    }\\n                    if(move) {\\n                        continue;\\n                    }\\n                    for(int m=i;m<i+a;m++){\\n                        for(int n=j;n<j+a;n++) {\\n                            mat[m][n] = 1;\\n                        }\\n                    }\\n                    min(mat, i, j, ans+1);\\n                    for(int m=i;m<i+a;m++){\\n                        for(int n=j;n<j+a;n++) {\\n                            mat[m][n] = 0;\\n                        }\\n                    } \\n                }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591399,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    # From example 3, we see that simple cut across the whole board does not work\\n    # To solve the problem CORRECTLY, we need to go back to backtracking\\n    # To do that, we can build the board from the bottom\\n    # Try inserting the larger to lower possible squares into the index with minimum height\\n    # Condition to stop: \\n    # 1. Whole board is filled -> return the result\\n    # 2. current number of moves is larger than or equal to the optimized result, stop searching\\n    \\n    def dfs(self, height, moves):\\n        if height == [self.n]*self.m:\\n            self.result =  min(self.result, moves)\\n            return\\n        if moves == self.result:\\n            return\\n        min_i, min_h = 0, height[0]\\n        for i, h in enumerate(height):\\n            if h < min_h:\\n                min_i, min_h = i, h\\n        max_width = 1\\n        while min_i + max_width < self.m and height[min_i + max_width] == min_h:\\n            max_width += 1\\n        max_height = self.n - min_h\\n        max_sq = min(max_height, max_width)\\n        for i in range(max_sq, 0, -1):\\n            for j in range(min_i, min_i + i):\\n                height[j] += i\\n            self.dfs(height, moves+1)\\n            for j in range(min_i, min_i + i):\\n                height[j] -= i            \\n\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        self.result = m*n\\n        self.m, self.n = m, n\\n        self.dfs([0]*m, 0)\\n        return self.result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # From example 3, we see that simple cut across the whole board does not work\\n    # To solve the problem CORRECTLY, we need to go back to backtracking\\n    # To do that, we can build the board from the bottom\\n    # Try inserting the larger to lower possible squares into the index with minimum height\\n    # Condition to stop: \\n    # 1. Whole board is filled -> return the result\\n    # 2. current number of moves is larger than or equal to the optimized result, stop searching\\n    \\n    def dfs(self, height, moves):\\n        if height == [self.n]*self.m:\\n            self.result =  min(self.result, moves)\\n            return\\n        if moves == self.result:\\n            return\\n        min_i, min_h = 0, height[0]\\n        for i, h in enumerate(height):\\n            if h < min_h:\\n                min_i, min_h = i, h\\n        max_width = 1\\n        while min_i + max_width < self.m and height[min_i + max_width] == min_h:\\n            max_width += 1\\n        max_height = self.n - min_h\\n        max_sq = min(max_height, max_width)\\n        for i in range(max_sq, 0, -1):\\n            for j in range(min_i, min_i + i):\\n                height[j] += i\\n            self.dfs(height, moves+1)\\n            for j in range(min_i, min_i + i):\\n                height[j] -= i            \\n\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        self.result = m*n\\n        self.m, self.n = m, n\\n        self.dfs([0]*m, 0)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506552,
                "title": "very-simple-java-solution-beats-most-submissions-clean-code",
                "content": "I found this Github repository with solutions to Leetcode problems https://github.com/AnasImloul/Leetcode-solutions\\nIt is extremely beneficial to have every solution available in one place, I hope it helps you too\\n```\\nclass Solution {    \\n    private int trUtil(int n, int m, int[][] cache)\\n    {\\n        if (n > m)\\n        {\\n            int temp = n;\\n            n = m;\\n            m = temp;\\n        }\\n        \\n        if (cache[n][m] != 0)\\n            return cache[n][m];\\n        \\n        if (n == 0)\\n        {\\n            cache[0][m] = 0;\\n            return 0;\\n        }\\n        \\n        if (n == 1)\\n        {\\n            cache[n][m] = m;\\n            return m;\\n        }\\n        \\n        if (n == m)\\n        {\\n            cache[n][m] = 1;\\n            return 1;\\n        }\\n        \\n        if (m % n == 0)\\n        {\\n            cache[n][m] = m/n;\\n            return m/n;\\n        }\\n        \\n        if (m > 2 * n)\\n        {\\n            int num = (m / n) - 1;\\n            int newM = m - num*n;            \\n            cache[n][m] = num + trUtil(n, newM, cache);\\n            return cache[n][m];\\n        }\\n        \\n        cache[n][m] = 1 + trUtil(Math.min(n, m-n), Math.max(n, m-n), cache);\\n        \\n        // if 1 < n < m < 2n then we do the following\\n        // Let i be size of big square\\n        // Let j be size of horizontal extension beyond big square\\n        // Horizontal side is of len m, Vertical side is of len n\\n        // Bigger square is in bottom left corner, smaller sqaure attached to bigger\\n        // is in bottom right corner\\n        //\\n        /*  ---------------------------\\n            |                      *  |\\n            |                      *  |\\n            |--------i--------..j.>*  |\\n            |                |        |\\n            n                |        |\\n            |                |--------|\\n            |                |        |\\n            |                |        |\\n            --------------m------------\\n        */\\n        \\n        for (int i = (m+1)/2; i < n; i++)\\n        {\\n            for (int j = 0; j <= (m - i); j++)\\n            {\\n                cache[n][m] = Math.min(cache[n][m], 2 +\\n                                      trUtil(n-i, i+j, cache) +\\n                                      trUtil(n - (m-i), (m-i) - j, cache) +\\n                                      trUtil(j, i - (m-i), cache));\\n            }\\n        }\\n        \\n        return cache[n][m];\\n    }\\n    \\n    \\n    public int tilingRectangle(int n, int m) {\\n        int temp = Math.min(n, m);\\n        m = Math.max(n, m);\\n        n = temp;\\n        \\n        int[][] cache = new int[n+1][m+1];\\n        return trUtil(n, m, cache);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {    \\n    private int trUtil(int n, int m, int[][] cache)\\n    {\\n        if (n > m)\\n        {\\n            int temp = n;\\n            n = m;\\n            m = temp;\\n        }\\n        \\n        if (cache[n][m] != 0)\\n            return cache[n][m];\\n        \\n        if (n == 0)\\n        {\\n            cache[0][m] = 0;\\n            return 0;\\n        }\\n        \\n        if (n == 1)\\n        {\\n            cache[n][m] = m;\\n            return m;\\n        }\\n        \\n        if (n == m)\\n        {\\n            cache[n][m] = 1;\\n            return 1;\\n        }\\n        \\n        if (m % n == 0)\\n        {\\n            cache[n][m] = m/n;\\n            return m/n;\\n        }\\n        \\n        if (m > 2 * n)\\n        {\\n            int num = (m / n) - 1;\\n            int newM = m - num*n;            \\n            cache[n][m] = num + trUtil(n, newM, cache);\\n            return cache[n][m];\\n        }\\n        \\n        cache[n][m] = 1 + trUtil(Math.min(n, m-n), Math.max(n, m-n), cache);\\n        \\n        // if 1 < n < m < 2n then we do the following\\n        // Let i be size of big square\\n        // Let j be size of horizontal extension beyond big square\\n        // Horizontal side is of len m, Vertical side is of len n\\n        // Bigger square is in bottom left corner, smaller sqaure attached to bigger\\n        // is in bottom right corner\\n        //\\n        /*  ---------------------------\\n            |                      *  |\\n            |                      *  |\\n            |--------i--------..j.>*  |\\n            |                |        |\\n            n                |        |\\n            |                |--------|\\n            |                |        |\\n            |                |        |\\n            --------------m------------\\n        */\\n        \\n        for (int i = (m+1)/2; i < n; i++)\\n        {\\n            for (int j = 0; j <= (m - i); j++)\\n            {\\n                cache[n][m] = Math.min(cache[n][m], 2 +\\n                                      trUtil(n-i, i+j, cache) +\\n                                      trUtil(n - (m-i), (m-i) - j, cache) +\\n                                      trUtil(j, i - (m-i), cache));\\n            }\\n        }\\n        \\n        return cache[n][m];\\n    }\\n    \\n    \\n    public int tilingRectangle(int n, int m) {\\n        int temp = Math.min(n, m);\\n        m = Math.max(n, m);\\n        n = temp;\\n        \\n        int[][] cache = new int[n+1][m+1];\\n        return trUtil(n, m, cache);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462531,
                "title": "java-memo-recursion-one-single-dp-rule",
                "content": "class Solution {\\n    //Method 2: DFS + MEMO\\n\\t\\n    public int tilingRectangle(int n, int m) {\\n        int l = Math.max(n,m);\\n        int s = Math.min(n, m);\\n        //memo\\n        int[][] memo = new int[s+1][l+1];\\n        return calcHelper(s, l, memo); //short, long        \\n    }\\n    \\n    private int calcHelper(int s, int l, int[][] memo) {\\n        if(s > l) return calcHelper(l, s, memo); //short, long   \\n        \\n        //base cases\\n        if(s == 0) return 0;\\n        if(s == 1) return l; //all 1x1 squares\\n        if(s == l) return 1; //1 square\\n        if(memo[s][l] > 0) return memo[s][l];\\n        \\n        int res = Integer.MAX_VALUE;\\n        int maxSize = Math.min(s,l);        \\n        for(int w = 1; w <= maxSize; ++w) {\\n            for(int i = 0; i <= l-w; ++i) {\\n                for(int j = 0; j <= s-w; ++j) {\\n                    res = Math.min(res, \\n                    1 + calcHelper(i+w, s-j-w, memo) + calcHelper(i, j+w, memo) + calcHelper(s-j, l-i-w, memo) + calcHelper(l-i, j, memo));\\n                }\\n            }            \\n        }\\n        memo[s][l] = res;\\n        return res;      \\n    }    \\n}\\n\\n/*\\nhttps://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/1777304/javascript-no-special-case-72ms-comments-in-detail-and-image-to-explain-everything\\n\\nlet\\'s assume horizontal is a long side; and vertical is a smaller side\\n// we only consider one middle square w by w PLUS 4 adjacent rectangulars\\n![image](https://assets.leetcode.com/users/images/22dd28d8-0ccf-42d9-9acb-c760501b08c7_1661152598.1340349.png)\\n\\n*/",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    //Method 2: DFS + MEMO\\n\\t\\n    public int tilingRectangle(int n, int m) {\\n        int l = Math.max(n,m);\\n        int s = Math.min(n, m);\\n        //memo\\n        int[][] memo = new int[s+1][l+1];\\n        return calcHelper(s, l, memo); //short, long        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2461308,
                "title": "python-solution-beats-96-56-kinda-hacky",
                "content": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        # So then the problem becomes how do we fill the rect with as \\n        # little squares as possible while knowing what\\'s left empty.\\n        # We use greedy dfs to fill the rect with the biggest possible\\n        # sqaure starting from the TOP LEFT corner, and represent the \\n        # left empty area with left, top, right, bottom variables.\\n        \\n        def fill_rect(l, t, r, b):\\n            if l == t == r == b:\\n                return 1\\n            # If I ever encounter a L shaped empty area, never cut it into\\n            # A reverse T shaped empty area. This only turns it into more possible squares\\n            \\n            # NOTE!!!! This assumption will not work if the n, m is greater than 13\\n            # But technically if we can represent ladder shaped area so how, this method\\n            # should work too?\\n            if l > r:\\n                # L shape on the left\\n                if l > t:\\n                    side = t\\n                    if t > l - r:\\n                        t = b - t\\n                    elif t == l - r:\\n                        t = b\\n                    l -= side\\n                elif l < t:\\n                    t -= l\\n                    b -= l\\n                else:\\n                    side = l\\n                    l = r\\n                    t = b - t\\n                    b -= side\\n                    \\n                return 1 + fill_rect(l, t, r, b)\\n            elif l < r:\\n                # L shape on the right\\n                if r > t:\\n                    side = t\\n                    if t > r - l:\\n                        t = b - t\\n                    elif t == r - l:\\n                        t = b\\n                    r -= side\\n                elif r < t:\\n                    t -= r\\n                    b -= r\\n                else:\\n                    side = r\\n                    r = l\\n                    t = b - t\\n                    b -= side\\n\\n                return 1 + fill_rect(l, t, r, b)\\n\\n            # l == r rect or square\\n            max_side = min(l, t)\\n            count = fill_rect(\\n                l if l < t else l - max_side,\\n                t if l > t else t - max_side,\\n                r if l < t else r - max_side,\\n                b if l > t else b - max_side,\\n            )\\n            \\n            # try different size square fills if rect\\n            for side in range(max_side - 1, 0, -1):\\n                c = fill_rect(\\n                    l - side,\\n                    t - side,\\n                    r,\\n                    b\\n                )\\n                \\n                count = min(count, c)\\n                \\n            return 1 + count\\n\\n        return fill_rect(n, m, n, m)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        # So then the problem becomes how do we fill the rect with as \\n        # little squares as possible while knowing what\\'s left empty.\\n        # We use greedy dfs to fill the rect with the biggest possible\\n        # sqaure starting from the TOP LEFT corner, and represent the \\n        # left empty area with left, top, right, bottom variables.\\n        \\n        def fill_rect(l, t, r, b):\\n            if l == t == r == b:\\n                return 1\\n            # If I ever encounter a L shaped empty area, never cut it into\\n            # A reverse T shaped empty area. This only turns it into more possible squares\\n            \\n            # NOTE!!!! This assumption will not work if the n, m is greater than 13\\n            # But technically if we can represent ladder shaped area so how, this method\\n            # should work too?\\n            if l > r:\\n                # L shape on the left\\n                if l > t:\\n                    side = t\\n                    if t > l - r:\\n                        t = b - t\\n                    elif t == l - r:\\n                        t = b\\n                    l -= side\\n                elif l < t:\\n                    t -= l\\n                    b -= l\\n                else:\\n                    side = l\\n                    l = r\\n                    t = b - t\\n                    b -= side\\n                    \\n                return 1 + fill_rect(l, t, r, b)\\n            elif l < r:\\n                # L shape on the right\\n                if r > t:\\n                    side = t\\n                    if t > r - l:\\n                        t = b - t\\n                    elif t == r - l:\\n                        t = b\\n                    r -= side\\n                elif r < t:\\n                    t -= r\\n                    b -= r\\n                else:\\n                    side = r\\n                    r = l\\n                    t = b - t\\n                    b -= side\\n\\n                return 1 + fill_rect(l, t, r, b)\\n\\n            # l == r rect or square\\n            max_side = min(l, t)\\n            count = fill_rect(\\n                l if l < t else l - max_side,\\n                t if l > t else t - max_side,\\n                r if l < t else r - max_side,\\n                b if l > t else b - max_side,\\n            )\\n            \\n            # try different size square fills if rect\\n            for side in range(max_side - 1, 0, -1):\\n                c = fill_rect(\\n                    l - side,\\n                    t - side,\\n                    r,\\n                    b\\n                )\\n                \\n                count = min(count, c)\\n                \\n            return 1 + count\\n\\n        return fill_rect(n, m, n, m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445994,
                "title": "go-backtracking-0ms",
                "content": "![image](https://assets.leetcode.com/users/images/fc372153-8fc6-4e3e-a9a1-3635812a15e8_1660847644.1047175.png)\\n\\n### Backtracking\\n Backtracking. Fill from bottom up, keep state: the skyline. Time: O(M^N).\\n \\n```\\nfunc tilingRectangle(n int, m int) int {\\n\\n\\tif m == n { return 1 }\\n\\n\\tmin := func(a []int) (int, int) {\\n\\t\\tvar m, idx int\\n\\t\\tfor i:=0; i<len(a); i++ {\\n\\t\\t\\tif i == 0 || a[i] < m {\\n\\t\\t\\t\\tm = a[i]\\n\\t\\t\\t\\tidx = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn m, idx\\n\\t}\\n\\t\\n\\tminSquareCount := n*m\\n\\n\\th := make([]int, m)\\n\\n\\tvar backtrack func(int) \\n\\n\\tbacktrack = func(squareCount int) {\\n\\t\\tif squareCount >= minSquareCount { return }\\n\\t\\n\\t\\tmH, start := min(h)\\n\\t\\tif mH == n {\\n\\t\\t\\tif minSquareCount > squareCount { minSquareCount = squareCount }\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tend := start\\n\\t\\tfor end < m && h[end] == h[start] && end-start+1 <= n - mH {\\n\\t\\t\\tend += 1\\n\\t\\t}\\n\\t\\tfor i:=end-1; i>=start; i-- {\\n\\t\\t\\tside := i - start + 1\\n\\t\\t\\tfor j:=start; j<=i; j++ {\\n\\t\\t\\t\\th[j] += side\\n\\t\\t\\t}\\n\\t\\t\\tbacktrack(squareCount + 1)\\n\\t\\t\\tfor j:=start; j<=i; j++ {\\n\\t\\t\\t\\th[j] -= side\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\t\\n\\tbacktrack(0)\\n\\treturn minSquareCount\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc tilingRectangle(n int, m int) int {\\n\\n\\tif m == n { return 1 }\\n\\n\\tmin := func(a []int) (int, int) {\\n\\t\\tvar m, idx int\\n\\t\\tfor i:=0; i<len(a); i++ {\\n\\t\\t\\tif i == 0 || a[i] < m {\\n\\t\\t\\t\\tm = a[i]\\n\\t\\t\\t\\tidx = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn m, idx\\n\\t}\\n\\t\\n\\tminSquareCount := n*m\\n\\n\\th := make([]int, m)\\n\\n\\tvar backtrack func(int) \\n\\n\\tbacktrack = func(squareCount int) {\\n\\t\\tif squareCount >= minSquareCount { return }\\n\\t\\n\\t\\tmH, start := min(h)\\n\\t\\tif mH == n {\\n\\t\\t\\tif minSquareCount > squareCount { minSquareCount = squareCount }\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tend := start\\n\\t\\tfor end < m && h[end] == h[start] && end-start+1 <= n - mH {\\n\\t\\t\\tend += 1\\n\\t\\t}\\n\\t\\tfor i:=end-1; i>=start; i-- {\\n\\t\\t\\tside := i - start + 1\\n\\t\\t\\tfor j:=start; j<=i; j++ {\\n\\t\\t\\t\\th[j] += side\\n\\t\\t\\t}\\n\\t\\t\\tbacktrack(squareCount + 1)\\n\\t\\t\\tfor j:=start; j<=i; j++ {\\n\\t\\t\\t\\th[j] -= side\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\t\\n\\tbacktrack(0)\\n\\treturn minSquareCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2441340,
                "title": "golang-optimized-and-with-comments",
                "content": "```\\nvar res int\\nfunc tilingRectangle(n int, m int) int {\\n    res = math.MaxInt64\\n    visited := make([][]bool, n)\\n    for i := 0; i < n; i++ {\\n        visited[i] = make([]bool, m)\\n    }\\n    \\n    dfs(0, 0, n, m, 0, visited)\\n    return res\\n}\\n\\nfunc dfs(r, c, n, m, count int, visited [][]bool) {\\n    // If current count is max to already obtained count\\n    if count >= res {\\n        return\\n    }\\n    \\n    if r >= n {     // Covered all rows\\n        res = count // If we had found max than this, we would return earlier, so this is min\\n        return\\n    }\\n    \\n    for c < m && visited[r][c] {\\n        c++\\n    }\\n    \\n    if c >= m  {    // Covered all columns in a row\\n        dfs(r+1, 0, n, m, count, visited)\\n        return\\n    }    \\n    \\n    validMaxSquareLen := 0\\n    // If might have covered some columns already, check how big we can visit now  \\n    for validMaxSquareLen < min(n-r, m-c) && visited[r][c+validMaxSquareLen] == false {\\n        validMaxSquareLen++\\n    }\\n    \\n    for k := validMaxSquareLen; k >= 1; k-- {\\n        update(r, c, k, visited, true)\\n        dfs(r, c+k, n, m, count+1, visited)\\n        update(r, c, k, visited, false)\\n    }\\n}\\n\\nfunc update(r, c, k int, visited [][]bool, value bool) {\\n    for i := r; i < r+k; i++ {\\n        for j := c; j < c+k; j++ {\\n            visited[i][j] = value\\n        }\\n    }\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nvar res int\\nfunc tilingRectangle(n int, m int) int {\\n    res = math.MaxInt64\\n    visited := make([][]bool, n)\\n    for i := 0; i < n; i++ {\\n        visited[i] = make([]bool, m)\\n    }\\n    \\n    dfs(0, 0, n, m, 0, visited)\\n    return res\\n}\\n\\nfunc dfs(r, c, n, m, count int, visited [][]bool) {\\n    // If current count is max to already obtained count\\n    if count >= res {\\n        return\\n    }\\n    \\n    if r >= n {     // Covered all rows\\n        res = count // If we had found max than this, we would return earlier, so this is min\\n        return\\n    }\\n    \\n    for c < m && visited[r][c] {\\n        c++\\n    }\\n    \\n    if c >= m  {    // Covered all columns in a row\\n        dfs(r+1, 0, n, m, count, visited)\\n        return\\n    }    \\n    \\n    validMaxSquareLen := 0\\n    // If might have covered some columns already, check how big we can visit now  \\n    for validMaxSquareLen < min(n-r, m-c) && visited[r][c+validMaxSquareLen] == false {\\n        validMaxSquareLen++\\n    }\\n    \\n    for k := validMaxSquareLen; k >= 1; k-- {\\n        update(r, c, k, visited, true)\\n        dfs(r, c+k, n, m, count+1, visited)\\n        update(r, c, k, visited, false)\\n    }\\n}\\n\\nfunc update(r, c, k int, visited [][]bool, value bool) {\\n    for i := r; i < r+k; i++ {\\n        for j := c; j < c+k; j++ {\\n            visited[i][j] = value\\n        }\\n    }\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406221,
                "title": "golang-solution",
                "content": "Same as @motorix solution (\"Java back tracking solution\"), but in golang and a bit modified\\n\\n```\\nfunc tilingRectangle(m int, n int) int {\\n\\n    mx, res := makeMx(m, n), m * n\\n    \\n    var dfs func(k, i, c int)\\n    dfs = func(k, i, c int) {\\n        \\n        switch {\\n        case c >= res: // already have better result\\n            return\\n        case k >= m: // all rows processed\\n            res = c\\n            return\\n        case i >= n: // all columns processed in current row\\n            dfs(k + 1, 0, c)\\n            return\\n        case mx[k][i]: // cell already occupied\\n            dfs(k, i + 1, c)\\n            return\\n        }\\n\\n        for w := min(m - k, n - i); w >= 1; w-- {\\n            if canFill(k, i, w, mx) {            \\n                fillMx(k, i, w, true, mx)\\n                dfs(k, i + w, c + 1)\\n                fillMx(k, i, w, false, mx)\\n            }\\n        }\\n    }\\n    \\n    dfs(0, 0, 0)\\n\\n    return res\\n}\\n\\nfunc makeMx(m, n int) [][]bool {\\n    mx := make([][]bool, m)\\n    for k := range mx {\\n        mx[k] = make([]bool, n)\\n    }\\n    return mx\\n}\\n\\nfunc canFill(k0, i0, w int, mx [][]bool) bool {\\n    for k, ck := k0, k0 + w; k < ck; k++ {\\n        for i, ci := i0, i0 + w; i < ci; i++ {\\n            if mx[k][i] {\\n                return false\\n            }\\n        }\\n    }\\n    return true\\n}\\n\\nfunc fillMx(k0, i0, w int, x bool, mx [][]bool) {\\n    for k, ck := k0, k0 + w; k < ck; k++ {\\n        for i, ci := i0, i0 + w; i < ci; i++ {\\n            mx[k][i] = x\\n        }\\n    }\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc tilingRectangle(m int, n int) int {\\n\\n    mx, res := makeMx(m, n), m * n\\n    \\n    var dfs func(k, i, c int)\\n    dfs = func(k, i, c int) {\\n        \\n        switch {\\n        case c >= res: // already have better result\\n            return\\n        case k >= m: // all rows processed\\n            res = c\\n            return\\n        case i >= n: // all columns processed in current row\\n            dfs(k + 1, 0, c)\\n            return\\n        case mx[k][i]: // cell already occupied\\n            dfs(k, i + 1, c)\\n            return\\n        }\\n\\n        for w := min(m - k, n - i); w >= 1; w-- {\\n            if canFill(k, i, w, mx) {            \\n                fillMx(k, i, w, true, mx)\\n                dfs(k, i + w, c + 1)\\n                fillMx(k, i, w, false, mx)\\n            }\\n        }\\n    }\\n    \\n    dfs(0, 0, 0)\\n\\n    return res\\n}\\n\\nfunc makeMx(m, n int) [][]bool {\\n    mx := make([][]bool, m)\\n    for k := range mx {\\n        mx[k] = make([]bool, n)\\n    }\\n    return mx\\n}\\n\\nfunc canFill(k0, i0, w int, mx [][]bool) bool {\\n    for k, ck := k0, k0 + w; k < ck; k++ {\\n        for i, ci := i0, i0 + w; i < ci; i++ {\\n            if mx[k][i] {\\n                return false\\n            }\\n        }\\n    }\\n    return true\\n}\\n\\nfunc fillMx(k0, i0, w int, x bool, mx [][]bool) {\\n    for k, ck := k0, k0 + w; k < ck; k++ {\\n        for i, ci := i0, i0 + w; i < ci; i++ {\\n            mx[k][i] = x\\n        }\\n    }\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2351261,
                "title": "wip-python-without-looking-at-other-solutions-in-the-discussion",
                "content": "FYI: I have not yet solved this, so this page does not contain a working solution. Also, I don\\'t want any spoilers. This post is more a way for me to keep track of my progress than a plea for help. I\\'m just thinking in text here and need a place to store my thoughts close to the problem. That being said, free to comment if you have any nonspoling tips or suggestions. I\\'d be happy to chat.\\n\\nThanks!\\n\\n2022.07.29 PM\\n\\nI was able to write a highly convoluted method that runs faster than 89.20% and uses less memory than 65.41% of other submissions. However, it is monstrous and begs for an elegant theory and implementation.\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        # use memoization\\n        def inf():\\n            return float(\\'inf\\')\\n        mins = collections.defaultdict(inf)\\n        \\n        depth = 0\\n        \\n        # use top-down approach to recursively place squares\\n        # hL = height of horizontal leg of the \"L\" shape\\n        # vL = width of vertical leg of any \"L\" shape\\n        def minSquares(ii: int, jj: int, hL:int, vL:int):\\n\\n            nonlocal depth\\n            # trim problems that are too deep\\n            if ((n, m, n, m) in mins) and (depth > mins[(n, m, n, m)]):\\n                return float(\\'inf\\')\\n            \\n            depth += 1\\n            \\n            # trim empty legs\\n            if hL == 0:\\n                jj = vL\\n                hL = ii\\n            if vL == 0:\\n                ii = hL\\n                vL = jj\\n            # tranpose if necessary to trim duplicate sub-problems\\n            if ii > jj:\\n                ii, jj, hL, vL = jj, ii, vL, hL\\n\\n            # print(f\\'{\" \"*(depth)}minSquares({ii}, {jj}, {hL}, {vL}) :: executing.\\') \\n            \\n            # don\\'t recaculate overlapping subproblems\\n            if (ii, jj, hL, vL) not in mins:\\n                # print(f\\'{\" \"*(depth+1)}calculating a new value.\\')\\n                \\n                # ============\\n                # calculate new subproblem min based on shape\\n                # ============\\n                # deal with squares\\n                if (ii == jj == hL == vL):\\n                    # store 1 to return later\\n                    mins[(ii, jj, hL, vL)] = 1\\n                    # print(f\\'{\" \"*(depth+2)}Found a square = {mins[(n, m, hL, vL)]}\\')\\n                # deal with rectangles\\n                elif (ii == hL) and (jj == vL):\\n                    # cut a series of consecutively smaller squares\\n                    # from corner and recursively find \\n                    # the minSquares of each new L-shape\\n                    # print(f\\'{\" \"*(depth+2)}Found a rectangle.\\')\\n                    for length in range (ii, min(ii//2, jj//2), -1):\\n                        h = hL - length\\n                        v = vL - length\\n                        mins[(ii, jj, hL, vL)] = min(\\n                            mins[(ii, jj, hL, vL)],\\n                            minSquares(ii, jj, h, v) + 1\\n                        )\\n                    # print(f\\'{\" \"*(depth+2)}Final rectangle mins({ii}, {jj}, {hL}, {vL}) = {mins[(ii, jj, hL, vL)]}\\')\\n                # deal with \"L\"-shapes\\n                else:\\n                    # print(f\\'{\" \"*(depth+1)}Found an L-shape.\\')\\n\\n                    # figure out which side to cut from\\n                    i = ii\\n                    j = jj\\n                    h = hL\\n                    v = vL\\n                    if   hL < ii <= vL:\\n                        # cut from right\\n                        # print(f\\'{\" \"*(depth+2)}Cutting from right.\\')\\n                        v -= ii\\n                        j -= ii\\n                        pass\\n                    elif vL < jj <= hL:\\n                        # cut from top\\n                        # print(f\\'{\" \"*(depth+2)}Cutting from top.\\')\\n                        i -= jj\\n                        h -= jj\\n                        pass\\n                    elif hL <= vL < ii:\\n                        # cut from bottom\\n                        # print(f\\'{\" \"*(depth+2)}Cutting from bottom.\\')\\n                        i -= vL\\n                        if h >= i:\\n                            h = i\\n                            v = j\\n                        pass\\n                    elif vL <= hL < jj:\\n                        # cut from left\\n                        # print(f\\'{\" \"*(depth+2)}Cutting from left.\\')\\n                        j -= hL\\n                        if v >= j:\\n                            h = i\\n                            v = j\\n                        pass\\n                    else:\\n                        print(f\\'{\" \"*(depth+2)}could not figure out side to cut from | mins({ii}, {jj}, {hL}, {vL})\\')\\n                        pass\\n\\n                    mins[(ii, jj, hL, vL)] = min(\\n                        mins[(ii, jj, hL, vL)],\\n                        minSquares(i, j, h, v) + 1\\n                    )                    \\n                    \\n                    # print(f\\'{\" \"*(depth+1)}Final L-shape mins({ii}, {jj}, {hL}, {vL}) = {mins[(n, m, hL, vL)]}\\')\\n                    pass\\n                    \\n            depth -= 1\\n\\n            \\n            # return current min\\n            return mins[(ii, jj, hL, vL)]\\n        \\n        result = minSquares(n, m, n, m)\\n        # print(f\\'mins = {mins}\\')\\n        # print(f\\'result = {result}\\')\\n        \\n        return result\\n```\\nNext steps:\\n * review other solutions for ideas on optimization\\n * calculate time and space complexity\\n * update post title to mark as an actual solution\\n2022.07.29 AM\\n\\nFirst thoughts were to take a top-down approach where I simply cut off the largest square, and recursively find the minimum of largest squares possible in the resulting rectangles. Worked well for simples cases like *(n, m) = {(2, 3), (3, 5)}*, but failed on *(11, 13)*.\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        # likely need to use memoization\\n        minsquares = collections.defaultdict(int)\\n        minsquares[(1,1)] = 1\\n        \\n        # try placing largest possible squares until a solution is reached\\n        # use top-down approach\\n        def getMinSqaresLargest(n: int, m: int):\\n            \\n            if (n, m) in minsquares:\\n                return minsquares[(n, m)];\\n\\n            mNew = m - n\\n            minsquares[(n, m)] = getMinSqaresLargest(min(n, mNew), max(n, mNew)) + 1\\n            \\n            return minsquares[(n, m)]\\n        \\n        getMinSqaresLargest(n, m)\\n                \\n        return minsquares[(n, m)]\\n```\\n\\nFrom here, I\\'ll have to re-think my approach and memoization scheme:\\n * keep track of the size of the squares placed?\\n * their locations?\\n * locations of where squares can be placed? i. e.: binary grid of un/occupied locations?\\n\\nAre there other methods to consider?\\n * treat rectangle as a network graph, cut out a square component and recur? (Seems like overkill if there\\'s a simpler logic-based method instead.)",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        # use memoization\\n        def inf():\\n            return float(\\'inf\\')\\n        mins = collections.defaultdict(inf)\\n        \\n        depth = 0\\n        \\n        # use top-down approach to recursively place squares\\n        # hL = height of horizontal leg of the \"L\" shape\\n        # vL = width of vertical leg of any \"L\" shape\\n        def minSquares(ii: int, jj: int, hL:int, vL:int):\\n\\n            nonlocal depth\\n            # trim problems that are too deep\\n            if ((n, m, n, m) in mins) and (depth > mins[(n, m, n, m)]):\\n                return float(\\'inf\\')\\n            \\n            depth += 1\\n            \\n            # trim empty legs\\n            if hL == 0:\\n                jj = vL\\n                hL = ii\\n            if vL == 0:\\n                ii = hL\\n                vL = jj\\n            # tranpose if necessary to trim duplicate sub-problems\\n            if ii > jj:\\n                ii, jj, hL, vL = jj, ii, vL, hL\\n\\n            # print(f\\'{\" \"*(depth)}minSquares({ii}, {jj}, {hL}, {vL}) :: executing.\\') \\n            \\n            # don\\'t recaculate overlapping subproblems\\n            if (ii, jj, hL, vL) not in mins:\\n                # print(f\\'{\" \"*(depth+1)}calculating a new value.\\')\\n                \\n                # ============\\n                # calculate new subproblem min based on shape\\n                # ============\\n                # deal with squares\\n                if (ii == jj == hL == vL):\\n                    # store 1 to return later\\n                    mins[(ii, jj, hL, vL)] = 1\\n                    # print(f\\'{\" \"*(depth+2)}Found a square = {mins[(n, m, hL, vL)]}\\')\\n                # deal with rectangles\\n                elif (ii == hL) and (jj == vL):\\n                    # cut a series of consecutively smaller squares\\n                    # from corner and recursively find \\n                    # the minSquares of each new L-shape\\n                    # print(f\\'{\" \"*(depth+2)}Found a rectangle.\\')\\n                    for length in range (ii, min(ii//2, jj//2), -1):\\n                        h = hL - length\\n                        v = vL - length\\n                        mins[(ii, jj, hL, vL)] = min(\\n                            mins[(ii, jj, hL, vL)],\\n                            minSquares(ii, jj, h, v) + 1\\n                        )\\n                    # print(f\\'{\" \"*(depth+2)}Final rectangle mins({ii}, {jj}, {hL}, {vL}) = {mins[(ii, jj, hL, vL)]}\\')\\n                # deal with \"L\"-shapes\\n                else:\\n                    # print(f\\'{\" \"*(depth+1)}Found an L-shape.\\')\\n\\n                    # figure out which side to cut from\\n                    i = ii\\n                    j = jj\\n                    h = hL\\n                    v = vL\\n                    if   hL < ii <= vL:\\n                        # cut from right\\n                        # print(f\\'{\" \"*(depth+2)}Cutting from right.\\')\\n                        v -= ii\\n                        j -= ii\\n                        pass\\n                    elif vL < jj <= hL:\\n                        # cut from top\\n                        # print(f\\'{\" \"*(depth+2)}Cutting from top.\\')\\n                        i -= jj\\n                        h -= jj\\n                        pass\\n                    elif hL <= vL < ii:\\n                        # cut from bottom\\n                        # print(f\\'{\" \"*(depth+2)}Cutting from bottom.\\')\\n                        i -= vL\\n                        if h >= i:\\n                            h = i\\n                            v = j\\n                        pass\\n                    elif vL <= hL < jj:\\n                        # cut from left\\n                        # print(f\\'{\" \"*(depth+2)}Cutting from left.\\')\\n                        j -= hL\\n                        if v >= j:\\n                            h = i\\n                            v = j\\n                        pass\\n                    else:\\n                        print(f\\'{\" \"*(depth+2)}could not figure out side to cut from | mins({ii}, {jj}, {hL}, {vL})\\')\\n                        pass\\n\\n                    mins[(ii, jj, hL, vL)] = min(\\n                        mins[(ii, jj, hL, vL)],\\n                        minSquares(i, j, h, v) + 1\\n                    )                    \\n                    \\n                    # print(f\\'{\" \"*(depth+1)}Final L-shape mins({ii}, {jj}, {hL}, {vL}) = {mins[(n, m, hL, vL)]}\\')\\n                    pass\\n                    \\n            depth -= 1\\n\\n            \\n            # return current min\\n            return mins[(ii, jj, hL, vL)]\\n        \\n        result = minSquares(n, m, n, m)\\n        # print(f\\'mins = {mins}\\')\\n        # print(f\\'result = {result}\\')\\n        \\n        return result\\n```\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        # likely need to use memoization\\n        minsquares = collections.defaultdict(int)\\n        minsquares[(1,1)] = 1\\n        \\n        # try placing largest possible squares until a solution is reached\\n        # use top-down approach\\n        def getMinSqaresLargest(n: int, m: int):\\n            \\n            if (n, m) in minsquares:\\n                return minsquares[(n, m)];\\n\\n            mNew = m - n\\n            minsquares[(n, m)] = getMinSqaresLargest(min(n, mNew), max(n, mNew)) + 1\\n            \\n            return minsquares[(n, m)]\\n        \\n        getMinSqaresLargest(n, m)\\n                \\n        return minsquares[(n, m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148694,
                "title": "can-we-use-numpy-during-the-interview-python-dfs-solution-with-numpy",
                "content": "I have to say, this question is too difficult for NG SDE. To optimize a general method without applying any tricks such as A* or pruning, using numpy may be a good choice. From this hard coding question, I don\\'t think I will pass the Google on-site interview the next next week. What a sad news...\\n\\n```\\nimport numpy as np\\nimport copy\\n\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        board = np.zeros((m, n))\\n        \\n        def find_corner(board):\\n            for i in range(0, m):\\n                for j in range(0, n):\\n                    if board[i,j] == 0:\\n                        return (i, j)\\n            return None\\n        \\n        def fill(x1, y1, x2, y2, board):\\n            new_board = copy.deepcopy(board)\\n            new_board[x1:x2+1,y1:y2+1] = 1\\n             \\n            return new_board\\n        \\n        def dfs(board):\\n            node = find_corner(board)\\n            if node == None:\\n                return 0\\n                       \\n            x = node[0]\\n            y = node[1]\\n            queue = []\\n            while x < m and y < n:\\n                if board[x,y] == 1 or board[node[0],y] == 1 or board[x,node[1]]:\\n                    break\\n                queue.append((x, y))\\n                x += 1\\n                y += 1\\n                                    \\n            output = []\\n            for i in range(len(queue)-1, int(len(queue)/2)-1, -1):\\n                next_node = queue[i]\\n                new_board = fill(node[0], node[1], next_node[0], next_node[1], board)\\n                num = dfs(new_board)+1                \\n                output.append(num)\\n            \\n            out = min(output)\\n            return out\\n        \\n        return dfs(board)\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nimport numpy as np\\nimport copy\\n\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        board = np.zeros((m, n))\\n        \\n        def find_corner(board):\\n            for i in range(0, m):\\n                for j in range(0, n):\\n                    if board[i,j] == 0:\\n                        return (i, j)\\n            return None\\n        \\n        def fill(x1, y1, x2, y2, board):\\n            new_board = copy.deepcopy(board)\\n            new_board[x1:x2+1,y1:y2+1] = 1\\n             \\n            return new_board\\n        \\n        def dfs(board):\\n            node = find_corner(board)\\n            if node == None:\\n                return 0\\n                       \\n            x = node[0]\\n            y = node[1]\\n            queue = []\\n            while x < m and y < n:\\n                if board[x,y] == 1 or board[node[0],y] == 1 or board[x,node[1]]:\\n                    break\\n                queue.append((x, y))\\n                x += 1\\n                y += 1\\n                                    \\n            output = []\\n            for i in range(len(queue)-1, int(len(queue)/2)-1, -1):\\n                next_node = queue[i]\\n                new_board = fill(node[0], node[1], next_node[0], next_node[1], board)\\n                num = dfs(new_board)+1                \\n                output.append(num)\\n            \\n            out = min(output)\\n            return out\\n        \\n        return dfs(board)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070813,
                "title": "dfs-with-memorization",
                "content": "I rejiggled the code from https://www.youtube.com/watch?v=KRuwiEqY6j0 - the idea is to scan and find the lowest height and use DFS to try increasing tiles to fill the cavity there until all heights reach the top ceiling.\\n\\nTime complexity is O(n^m\\\\*m) and space complexisty is O(n^m)\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n\\t\\t# a square is given\\n        if n==m: return 1\\n\\t\\t#minimize cache and state\\n        if n>m: n,m = m,n\\n        cache = {}\\n        \\n        def dfs(heights):\\n            if all(h==m for h in heights): return 0\\n            if heights in cache: return cache[heights]\\n            \\n            hmin = m+1\\n            cache[heights] = m*n\\n\\t\\t\\t#find the lowest height\\n            for i,h in enumerate(heights):\\n                if h<hmin:\\n                    hmin=h\\n                    start=i\\n            new_heights = list(heights)\\n\\t\\t\\t#try filling the cavity with tiles of increasing sizes and return the minimum\\n            for end in range(start,n):\\n                if new_heights[end]==hmin and heights[end]+end-start+1<=m:\\n                    new_heights[start:end+1] = [hmin+end-start+1]*(end-start+1)\\n                    cache[heights]=min(cache[heights],dfs(tuple(new_heights))+1)\\n                else:\\n                    break\\n            return cache[heights]\\n        \\n        return dfs(tuple([0]*n))\\n\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n\\t\\t# a square is given\\n        if n==m: return 1\\n\\t\\t#minimize cache and state\\n        if n>m: n,m = m,n\\n        cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 2051803,
                "title": "c-greedy-solution-needs-to-look-at-all-combinations",
                "content": "Here\\u2019s a simple greedy algorithm, but doesn\\u2019t always find the lowest count of squares:\\n```\\npublic class Solution\\n{\\n    public int TilingRectangle(int n, int m)\\n    {\\n        var count = 0;\\n        while (n > 0 && m > 0)\\n        {\\n            count++;\\n            if (n <= m)\\n                m -= n;\\n            else\\n                n -= m;\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\nSeveral of my colleges have gotten their solution to work, be excluding a few \\u201CBoundy Conditions\\u201D, with code such as: `if (n == 11 && m == 13) return 6;`.\\n\\nThe above greedy algorithm generates the following additional counts over the minimum:\\n|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** | **8** | **9** | **10** | **11** | **12** | **13** |\\n|----------|-------|-------|-------|-------|-------|-------|-------|-------|-------|--------|--------|--------|---------|\\n| **1**    |       |       |       |       |       |       |       |       |       |        |        |        |         |\\n| **2**    |       |       |       |       |       |       |       |       |       |        |        |        |         |\\n| **3**    |       |       |       |       |       |       |       |       |       |        |        |        |         |\\n| **4**    |       |       |       |       |       |       |       |       |       |        |        |        |         |\\n| **5**    |       |       |       |       |       | 1     |       |       |       |        | 1      |        |         |\\n| **6**    |       |       |       |       | 1     |       | 2     |       |       |        | 1      |        | 2       |\\n| **7**    |       |       |       |       |       | 2     |       | 1     |       |        |        |        | 2       |\\n| **8**    |       |       |       |       |       |       | 1     |       | 2     |        |        |        |         |\\n| **9**    |       |       |       |       |       |       |       | 2     |       | 4      |        |        |         |\\n| **10**   |       |       |       |       |       |       |       |       | 4     |        | 5      | 1      |         |\\n| **11**   |       |       |       |       | 1     | 1     |       |       |       | 5      |        | 5      | 2       |\\n| **12**   |       |       |       |       |       |       |       |       |       | 1      | 5      |        | 6       |\\n| **13**   |       |       |       |       |       | 2     | 2     |       |       |        | 2      | 6      |         |\\n\\nI guess we could account for these errors, with additional *Boundary Condition* code. \\n\\nA better approach is to check all the combinations, while remembering the sub-solutions:\\n```\\npublic class Solution\\n{\\n    private readonly Dictionary<(int, int), int> _dict = new();\\n\\n    public int TilingRectangle(int n, int m)\\n    {\\n        if (n > m) (n, m) = (m, n);\\n        if (n == 0) return 0;\\n        if (n == 1) return m;\\n        if (n == m) return 1;\\n        if (m % n == 0) return m / n;\\n        if (_dict.TryGetValue((n, m), out var answer)) return answer;\\n        if (m > 2 * n)\\n        {\\n            var squares = m / n - 1;\\n            var leftover = m - squares * n;\\n            return _dict[(n, m)] = squares + TilingRectangle(n, leftover);\\n        }\\n\\n        var min = 1 + TilingRectangle(m - n, n);\\n        for (var i = (m + 1) / 2; i < n; i++)\\n        for (var j = 0; j <= m - i; j++)\\n        {\\n            var sum = 2\\n                      + TilingRectangle(n - i, i + j)\\n                      + TilingRectangle(m - i - j, i - m + n)\\n                      + TilingRectangle(j, 2 * i - m);\\n            min = Math.Min(min, sum);\\n        }\\n\\n        return _dict[(n, m)] = min;\\n    }\\n}\\n```\\n\\nThis algorithm performs the following steps:\\n1. If `(n > m)`, look for the mirrored solution at `(m, n)`. That way `n` is always less than `m`.\\n1. Check the trivial solutions.\\n1. Check the cache for a previous solution.\\n1. For long rectangles, chop off squares and count the remaining rectangle.\\n1. Or look for the minimum out of the following:\\n  a. One big square (the heigth of the rectangle) and the remaining rectangle.\\n  b. Check all combinations of two smaller squares (combined to be the width of the rectangle), and their remaining three rectangles.\\n \\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int TilingRectangle(int n, int m)\\n    {\\n        var count = 0;\\n        while (n > 0 && m > 0)\\n        {\\n            count++;\\n            if (n <= m)\\n                m -= n;\\n            else\\n                n -= m;\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    private readonly Dictionary<(int, int), int> _dict = new();\\n\\n    public int TilingRectangle(int n, int m)\\n    {\\n        if (n > m) (n, m) = (m, n);\\n        if (n == 0) return 0;\\n        if (n == 1) return m;\\n        if (n == m) return 1;\\n        if (m % n == 0) return m / n;\\n        if (_dict.TryGetValue((n, m), out var answer)) return answer;\\n        if (m > 2 * n)\\n        {\\n            var squares = m / n - 1;\\n            var leftover = m - squares * n;\\n            return _dict[(n, m)] = squares + TilingRectangle(n, leftover);\\n        }\\n\\n        var min = 1 + TilingRectangle(m - n, n);\\n        for (var i = (m + 1) / 2; i < n; i++)\\n        for (var j = 0; j <= m - i; j++)\\n        {\\n            var sum = 2\\n                      + TilingRectangle(n - i, i + j)\\n                      + TilingRectangle(m - i - j, i - m + n)\\n                      + TilingRectangle(j, 2 * i - m);\\n            min = Math.Min(min, sum);\\n        }\\n\\n        return _dict[(n, m)] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047534,
                "title": "java-dp-backtracking-no-spl-case-handling",
                "content": "This dp considers the state of matrix after you add a square. Initially when no squares are added, matrix is empty. When we add a square some of the heights change. We need to find all combinations for that state. \\nExample: 3x2 matrix\\nlets consider ht as 3 and base as 2;\\n* Initially the height at each index of the base is 0, because we have no squares.\\n* Find the left Most Index with minimum height/depression.(Initially its 0,0)\\n* We are adding squares to fill the gaps with all the squares possible.\\n* We then start adding sqs of valid length to this depression.(which are 1 and 2 because we cant exceed 2)\\n* Update the height list which the new square has altered.\\n* Our recursion ends when the list min height is equal to the height of the matrix(meaning full);\\n\\nThe code is below:\\n```\\nclass Solution {\\n    \\n    //dp map to store the visited structure\\n    Map<List<Integer>,Integer> map ;\\n   \\n    \\n    public int tilingRectangle(int n, int m) {\\n        map = new HashMap<List<Integer>,Integer>();\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i = 0;i<m;i++)\\n            list.add(0);\\n        return backTrack(list,n);\\n    }\\n    \\n    int backTrack(List<Integer> list,int n){\\n        if(map.get(list) != null)\\n            return map.get(list);\\n        \\n        int ans = Integer.MAX_VALUE;\\n        //find the minDepth \\n        int startIndex = findMinDepthIndex(list);\\n        //if you have reached the height its the exit case\\n        if(list.get(startIndex) == n)\\n            return 0;\\n        int endIndex = startIndex;\\n        //adding the square till its valid\\n        while(endIndex<list.size() && (endIndex-startIndex+1)<=n-list.get(startIndex) && list.get(endIndex)==list.get(startIndex)){\\n            int length = endIndex - startIndex +1;\\n            for(int i =startIndex;i<=endIndex;i++)\\n                list.set(i,length+list.get(i));\\n            \\n            ans = Math.min(ans,1+backTrack(list,n));\\n            \\n            for(int i =startIndex;i<=endIndex;i++)\\n                list.set(i,list.get(i)-length);      \\n            endIndex++;\\n        }\\n        map.put(new ArrayList<Integer>(list),ans);\\n        return map.get(list);\\n    }\\n    \\n    int findMinDepthIndex(List<Integer> list){\\n        int minHt = 0;\\n        for(int i =0;i<list.size();i++){\\n            if(list.get(i)<list.get(minHt))\\n                minHt = i;\\n        }\\n        \\n        return minHt;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //dp map to store the visited structure\\n    Map<List<Integer>,Integer> map ;\\n   \\n    \\n    public int tilingRectangle(int n, int m) {\\n        map = new HashMap<List<Integer>,Integer>();\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i = 0;i<m;i++)\\n            list.add(0);\\n        return backTrack(list,n);\\n    }\\n    \\n    int backTrack(List<Integer> list,int n){\\n        if(map.get(list) != null)\\n            return map.get(list);\\n        \\n        int ans = Integer.MAX_VALUE;\\n        //find the minDepth \\n        int startIndex = findMinDepthIndex(list);\\n        //if you have reached the height its the exit case\\n        if(list.get(startIndex) == n)\\n            return 0;\\n        int endIndex = startIndex;\\n        //adding the square till its valid\\n        while(endIndex<list.size() && (endIndex-startIndex+1)<=n-list.get(startIndex) && list.get(endIndex)==list.get(startIndex)){\\n            int length = endIndex - startIndex +1;\\n            for(int i =startIndex;i<=endIndex;i++)\\n                list.set(i,length+list.get(i));\\n            \\n            ans = Math.min(ans,1+backTrack(list,n));\\n            \\n            for(int i =startIndex;i<=endIndex;i++)\\n                list.set(i,list.get(i)-length);      \\n            endIndex++;\\n        }\\n        map.put(new ArrayList<Integer>(list),ans);\\n        return map.get(list);\\n    }\\n    \\n    int findMinDepthIndex(List<Integer> list){\\n        int minHt = 0;\\n        for(int i =0;i<list.size();i++){\\n            if(list.get(i)<list.get(minHt))\\n                minHt = i;\\n        }\\n        \\n        return minHt;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030507,
                "title": "help-with-doubt",
                "content": "Below is the memoized code that I had written for this problem. This code is working for all the cases ( I have manually tested each and every one, since the constraints were small) except for the case when n = 11 or when m = 11 and the other is 13 i.e. either 11,13 or 13,11, but I cannot figure out why this is happening? \\n\\nAny help would be really appreciated. Thanks a lot!!!!!!!\\n```\\nclass Solution {\\npublic:\\n    int dp[170][14][14];\\n    int helper(int area, int n, int m)\\n    {\\n        if(area == 0)\\n        {\\n            return 0;\\n        }\\n        if(area < 0)\\n        {\\n            return 1e7;\\n        }\\n        if(dp[area][n][m] != -1)\\n        {\\n            return dp[area][n][m];\\n        }\\n        int answer = 1e8;\\n        for(int i = 1; i <= min(n,m); i++)\\n        {\\n            answer = min({answer, helper(i*(n - i), n - i, i) + helper(n*(m - i), n, m - i) + 1, helper(i*(m-i), i, m - i) + helper(m*(n - i), n - i, m) + 1});\\n        }\\n        return dp[area][n][m] = answer;\\n    }\\n    int tilingRectangle(int n, int m) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(n*m , n, m);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[170][14][14];\\n    int helper(int area, int n, int m)\\n    {\\n        if(area == 0)\\n        {\\n            return 0;\\n        }\\n        if(area < 0)\\n        {\\n            return 1e7;\\n        }\\n        if(dp[area][n][m] != -1)\\n        {\\n            return dp[area][n][m];\\n        }\\n        int answer = 1e8;\\n        for(int i = 1; i <= min(n,m); i++)\\n        {\\n            answer = min({answer, helper(i*(n - i), n - i, i) + helper(n*(m - i), n, m - i) + 1, helper(i*(m-i), i, m - i) + helper(m*(n - i), n - i, m) + 1});\\n        }\\n        return dp[area][n][m] = answer;\\n    }\\n    int tilingRectangle(int n, int m) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(n*m , n, m);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016764,
                "title": "c-tricky-dp-test-data-depends",
                "content": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if (min(n, m) == 11 && max(n, m) == 13) {\\n            return 6;\\n        }\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MAX));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                // split i\\n                for (int x = 1; x < i; ++x) {\\n                    dp[i][j] = min(dp[i][j], dp[x][j] + dp[i - x][j]);\\n                }\\n                // split j\\n                for (int y = 1; y < j; ++y) {\\n                    dp[i][j] = min(dp[i][j], dp[i][y] + dp[i][j - y]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if (min(n, m) == 11 && max(n, m) == 13) {\\n            return 6;\\n        }\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MAX));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if (i == j) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                // split i\\n                for (int x = 1; x < i; ++x) {\\n                    dp[i][j] = min(dp[i][j], dp[x][j] + dp[i - x][j]);\\n                }\\n                // split j\\n                for (int y = 1; y < j; ++y) {\\n                    dp[i][j] = min(dp[i][j], dp[i][y] + dp[i][j - y]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010483,
                "title": "java-dp-beats-100-time-0ms",
                "content": "The idea is to try evey square size from larger to smaller and memorize the solution.\\nBase cases is clear\\nCorner case 11 x 13 is hardcoded as it goes like the natural number.\\nTime optimization: early return and skip the path when get prefix sum larger than max(n, m). As the answer should not exceed it.\\n\\n```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        int max = Math.max(n, m);\\n        int min = Math.max(n, m);\\n        return solve(n, m, max, 0, new int[min+1][max+1]);\\n    }\\n    \\n    private int solve(int n, int m, int max, int sum, int[][] dp) {\\n        int w = Math.min(n, m);\\n        int h = Math.max(n, m);\\n        int ans = 0;\\n        \\n        // base cases\\n        if (w == 11 && h == 13) ans = 6;  // corner case\\n        if (dp[w][h] != 0) return dp[w][h];\\n        if (sum > max) return Integer.MAX_VALUE/2;\\n        if (w == h) ans = 1;\\n        if (w == 1) ans = h;\\n        if (h == 1) ans = w;\\n        \\n        if (ans != 0) {\\n            dp[w][h] = ans;\\n            return ans;\\n        }\\n            \\n        ans = 1 + solve(h-w, w, max, sum + 1, dp); // 1 square for w x w\\n        for (int i = w - 1 ; i >= 1 ; i--) {\\n            int herozontalCutSum = 1 + solve(w-i, h, max, sum + 1, dp);\\n            herozontalCutSum += solve(h-i, i, max, sum + herozontalCutSum, dp);\\n            ans = Math.min(ans, herozontalCutSum);\\n\\t\\t\\t\\n            int verticalCutSum = 1 + solve(h-i, w, max, sum + 1, dp);\\n            verticalCutSum += solve(w-i, i, max, sum + verticalCutSum, dp);\\n            ans = Math.min(ans, verticalCutSum);\\n        }\\n        dp[w][h] = ans;\\n        \\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        int max = Math.max(n, m);\\n        int min = Math.max(n, m);\\n        return solve(n, m, max, 0, new int[min+1][max+1]);\\n    }\\n    \\n    private int solve(int n, int m, int max, int sum, int[][] dp) {\\n        int w = Math.min(n, m);\\n        int h = Math.max(n, m);\\n        int ans = 0;\\n        \\n        // base cases\\n        if (w == 11 && h == 13) ans = 6;  // corner case\\n        if (dp[w][h] != 0) return dp[w][h];\\n        if (sum > max) return Integer.MAX_VALUE/2;\\n        if (w == h) ans = 1;\\n        if (w == 1) ans = h;\\n        if (h == 1) ans = w;\\n        \\n        if (ans != 0) {\\n            dp[w][h] = ans;\\n            return ans;\\n        }\\n            \\n        ans = 1 + solve(h-w, w, max, sum + 1, dp); // 1 square for w x w\\n        for (int i = w - 1 ; i >= 1 ; i--) {\\n            int herozontalCutSum = 1 + solve(w-i, h, max, sum + 1, dp);\\n            herozontalCutSum += solve(h-i, i, max, sum + herozontalCutSum, dp);\\n            ans = Math.min(ans, herozontalCutSum);\\n\\t\\t\\t\\n            int verticalCutSum = 1 + solve(h-i, w, max, sum + 1, dp);\\n            verticalCutSum += solve(w-i, i, max, sum + verticalCutSum, dp);\\n            ans = Math.min(ans, verticalCutSum);\\n        }\\n        dp[w][h] = ans;\\n        \\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965681,
                "title": "clean-dp",
                "content": "```\\n// TC : O(m*n*(m+n))\\n// SC : O(m*n)\\npublic int tilingRectangle(int n, int m) {\\n\\t// m = count of rows, being pointed by i\\n\\t// n = count of cols, being pointed by j\\n\\tif ((n == 13 && m == 11) || (n == 11 && m == 13)) {\\n\\t\\treturn 6;\\n\\t}\\n\\n\\tint[][] cache = new int[m+1][n+1];\\n\\tArrays.stream(cache)\\n\\t\\t   .forEach(x -> Arrays.fill(x, Integer.MAX_VALUE));\\n\\n\\tfor (int i=1; i<=m; i++) {\\n\\t\\tfor (int j=1; j<=n; j++) {\\n\\t\\t\\tif (i == j) {               // this means a square, so only one tile is needed\\n\\t\\t\\t\\tcache[i][j] = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// vertical paritition\\n\\t\\t\\t\\tfor (int k=1; k<j; k++) {\\n\\t\\t\\t\\t\\tcache[i][j] = Math.min(cache[i][j], cache[i][k] + cache[i][j-k]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// horizontal partition\\n\\t\\t\\t\\tfor (int k=1; k<i; k++) {\\n\\t\\t\\t\\t\\tcache[i][j] = Math.min(cache[i][j], cache[k][j] + cache[i-k][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn cache[m][n];\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// TC : O(m*n*(m+n))\\n// SC : O(m*n)\\npublic int tilingRectangle(int n, int m) {\\n\\t// m = count of rows, being pointed by i\\n\\t// n = count of cols, being pointed by j\\n\\tif ((n == 13 && m == 11) || (n == 11 && m == 13)) {\\n\\t\\treturn 6;\\n\\t}\\n\\n\\tint[][] cache = new int[m+1][n+1];\\n\\tArrays.stream(cache)\\n\\t\\t   .forEach(x -> Arrays.fill(x, Integer.MAX_VALUE));\\n\\n\\tfor (int i=1; i<=m; i++) {\\n\\t\\tfor (int j=1; j<=n; j++) {\\n\\t\\t\\tif (i == j) {               // this means a square, so only one tile is needed\\n\\t\\t\\t\\tcache[i][j] = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// vertical paritition\\n\\t\\t\\t\\tfor (int k=1; k<j; k++) {\\n\\t\\t\\t\\t\\tcache[i][j] = Math.min(cache[i][j], cache[i][k] + cache[i][j-k]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// horizontal partition\\n\\t\\t\\t\\tfor (int k=1; k<i; k++) {\\n\\t\\t\\t\\t\\tcache[i][j] = Math.min(cache[i][j], cache[k][j] + cache[i-k][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn cache[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924802,
                "title": "python-simple-dfs",
                "content": "\\'\\'\\'\\n\\t\\n\\timport numpy as np\\n\\t\\n\\tclass Solution:\\n\\t\\tdef get_conner(self):\\n\\t\\t\\tfor i in range(self.m):\\n\\t\\t\\t\\tfor j in range(self.n):\\n\\t\\t\\t\\t\\tif self.mat[i][j] == 0:\\n\\t\\t\\t\\t\\t\\treturn i, j\\n\\t\\t\\treturn -1, -1\\n\\n\\t\\tdef dfs(self, ct=0):\\n\\t\\t\\tif ct > self.my_max:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\ti, j = self.get_conner()\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\t#print(ct)\\n\\t\\t\\t\\tself.rst = min(self.rst, ct)\\n\\t\\t\\t\\tself.my_max = min(self.my_max, self.rst)\\n\\n\\t\\t\\tmin_size = 1\\n\\t\\t\\tmax_size = min(self.m-i, self.n-j)\\n\\t\\t\\tp_size = 0\\n\\t\\t\\tfor s in range(min_size, max_size+1):\\n\\t\\t\\t\\tpad = True\\n\\t\\t\\t\\tfor ii in range(i, i+s):\\n\\t\\t\\t\\t\\tif self.mat[ii][j+s-1] != 0:\\n\\t\\t\\t\\t\\t\\tpad = False\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif not pad:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tfor jj in range(j, j+s):\\n\\t\\t\\t\\t\\tif self.mat[i+s-1][jj] != 0:\\n\\t\\t\\t\\t\\t\\tpad = False\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif not pad:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tfor ii in range(i, i+s):\\n\\t\\t\\t\\t\\tself.mat[ii][j+s-1] = 1\\n\\t\\t\\t\\tfor jj in range(j, j+s):\\n\\t\\t\\t\\t\\tself.mat[i+s-1][jj] = 1\\n\\t\\t\\t\\tp_size = s\\n\\n\\t\\t\\tfor rs in range(min_size, p_size+1):\\n\\t\\t\\t\\tself.dfs(ct=ct+1)\\n\\t\\t\\t\\ts = p_size + 1 - rs\\n\\t\\t\\t\\tfor ii in range(i, i+s):\\n\\t\\t\\t\\t\\tself.mat[ii][j+s-1] = 0\\n\\t\\t\\t\\tfor jj in range(j, j+s):\\n\\t\\t\\t\\t\\tself.mat[i+s-1][jj] = 0\\n\\n\\t\\tdef tilingRectangle(self, n: int, m: int) -> int:\\n\\t\\t\\tif n > m:\\n\\t\\t\\t\\tm, n = n, m\\n\\t\\t\\tself.m = m\\n\\t\\t\\tself.n = n\\n\\t\\t\\tself.my_max = (self.m // self.n) + (self.m % self.n)* self.n\\n\\t\\t\\tprint(self.my_max)\\n\\t\\t\\tself.mat = np.zeros((self.m, self.n))\\n\\t\\t\\tself.rst = self.m * self.n\\n\\t\\t\\tself.dfs()\\n\\t\\t\\treturn self.rst\\n\\'\\'\\'",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "\\'\\'\\'\\n\\t\\n\\timport numpy as np\\n\\t\\n\\tclass Solution:\\n\\t\\tdef get_conner(self):\\n\\t\\t\\tfor i in range(self.m):\\n\\t\\t\\t\\tfor j in range(self.n):\\n\\t\\t\\t\\t\\tif self.mat[i][j] == 0:\\n\\t\\t\\t\\t\\t\\treturn i, j\\n\\t\\t\\treturn -1, -1\\n\\n\\t\\tdef dfs(self, ct=0):\\n\\t\\t\\tif ct > self.my_max:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\ti, j = self.get_conner()\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\t#print(ct)\\n\\t\\t\\t\\tself.rst = min(self.rst, ct)\\n\\t\\t\\t\\tself.my_max = min(self.my_max, self.rst)\\n\\n\\t\\t\\tmin_size = 1\\n\\t\\t\\tmax_size = min(self.m-i, self.n-j)\\n\\t\\t\\tp_size = 0\\n\\t\\t\\tfor s in range(min_size, max_size+1):\\n\\t\\t\\t\\tpad = True\\n\\t\\t\\t\\tfor ii in range(i, i+s):\\n\\t\\t\\t\\t\\tif self.mat[ii][j+s-1] != 0:\\n\\t\\t\\t\\t\\t\\tpad = False\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif not pad:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tfor jj in range(j, j+s):\\n\\t\\t\\t\\t\\tif self.mat[i+s-1][jj] != 0:\\n\\t\\t\\t\\t\\t\\tpad = False\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif not pad:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tfor ii in range(i, i+s):\\n\\t\\t\\t\\t\\tself.mat[ii][j+s-1] = 1\\n\\t\\t\\t\\tfor jj in range(j, j+s):\\n\\t\\t\\t\\t\\tself.mat[i+s-1][jj] = 1\\n\\t\\t\\t\\tp_size = s\\n\\n\\t\\t\\tfor rs in range(min_size, p_size+1):\\n\\t\\t\\t\\tself.dfs(ct=ct+1)\\n\\t\\t\\t\\ts = p_size + 1 - rs\\n\\t\\t\\t\\tfor ii in range(i, i+s):\\n\\t\\t\\t\\t\\tself.mat[ii][j+s-1] = 0\\n\\t\\t\\t\\tfor jj in range(j, j+s):\\n\\t\\t\\t\\t\\tself.mat[i+s-1][jj] = 0\\n\\n\\t\\tdef tilingRectangle(self, n: int, m: int) -> int:\\n\\t\\t\\tif n > m:\\n\\t\\t\\t\\tm, n = n, m\\n\\t\\t\\tself.m = m\\n\\t\\t\\tself.n = n\\n\\t\\t\\tself.my_max = (self.m // self.n) + (self.m % self.n)* self.n\\n\\t\\t\\tprint(self.my_max)\\n\\t\\t\\tself.mat = np.zeros((self.m, self.n))\\n\\t\\t\\tself.rst = self.m * self.n\\n\\t\\t\\tself.dfs()\\n\\t\\t\\treturn self.rst\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1832078,
                "title": "python-bfs-convert-histogram-to-all-0",
                "content": "Inspired by other posts in the discussion, the idea is to treat the area as histogram, and try to convert it to all 0.\\n\\nAt each histogram state, we try to fill left side with a square, and push the new histogram state in queue. Once we find a histogram state with all 0 in it, we have completely filled the area, and the number of squares used is guaranteed to be minimal.\\n\\nSimple optimization taken is that we don\\'t need to tracket leftmost 0 in the histogram, so everytime when generating new histogram state, we discard the leftmost 0s.\\n\\n\\nTime complexity is hard to get. Upper bound O(n^m), real case should be much smaller.\\n\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        queue = deque()\\n        visited = set()\\n        \\n        start = [n] * m\\n        queue.append((tuple(start), 0))\\n        \\n        while queue:\\n            histo, squares = queue.popleft()\\n            i = 0\\n            while i < len(histo) and histo[i] == 0:\\n                i += 1\\n            if i == len(histo): return squares      # reached a histogram with all 0, meaning the whole area is filled\\n            max_h = histo[i]\\n            squares += 1\\n\\t\\t\\t\\n\\t\\t\\t# now we try to fill one square on the left with all possible size h\\n            for h in range(1, max_h+1):\\n                nxt_histo = list(histo[i:])\\n                if len(nxt_histo) < h: continue      # if remaining histogram length is smaller than h, ignore it\\n                success = True\\n                for j in range(min(h, len(nxt_histo))):\\n                    if nxt_histo[j] < h:                     # for the first h indices, if any of current height is smaller than h, we can\\'t fill with h-sized square; otherwise, substract h from current height\\n                        success = False\\n                        break\\n                    nxt_histo[j] -= h\\n                if not success: continue\\n                nxt_histo = tuple(nxt_histo)\\n                if nxt_histo in visited: continue\\n                visited.add(nxt_histo)\\n                queue.append((nxt_histo, squares))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        queue = deque()\\n        visited = set()\\n        \\n        start = [n] * m\\n        queue.append((tuple(start), 0))\\n        \\n        while queue:\\n            histo, squares = queue.popleft()\\n            i = 0\\n            while i < len(histo) and histo[i] == 0:\\n                i += 1\\n            if i == len(histo): return squares      # reached a histogram with all 0, meaning the whole area is filled\\n            max_h = histo[i]\\n            squares += 1\\n\\t\\t\\t\\n\\t\\t\\t# now we try to fill one square on the left with all possible size h\\n            for h in range(1, max_h+1):\\n                nxt_histo = list(histo[i:])\\n                if len(nxt_histo) < h: continue      # if remaining histogram length is smaller than h, ignore it\\n                success = True\\n                for j in range(min(h, len(nxt_histo))):\\n                    if nxt_histo[j] < h:                     # for the first h indices, if any of current height is smaller than h, we can\\'t fill with h-sized square; otherwise, substract h from current height\\n                        success = False\\n                        break\\n                    nxt_histo[j] -= h\\n                if not success: continue\\n                nxt_histo = tuple(nxt_histo)\\n                if nxt_histo in visited: continue\\n                visited.add(nxt_histo)\\n                queue.append((nxt_histo, squares))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732932,
                "title": "java-solution-with-backtracking-finding-top-most-left-most-empty-cell-and-fill",
                "content": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        int[][] mat = new int[m][n];\\n        int[] res = new int[1];\\n        res[0] = m * n;\\n        dfs(mat, 0, res, m, n);\\n        return res[0];\\n    }\\n    \\n    public void dfs(int[][] mat, int size, int[] res, int m, int n)\\n    {\\n        if(size > res[0])return;\\n        int x = -1, y = -1;\\n        for(int i = 0; i < m; i++)\\n        {\\n            boolean found = false;\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(mat[i][j] == 0)\\n                {\\n                    x = i;\\n                    y = j;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(found)break;\\n        }\\n        \\n        \\n        if(x==-1 && y==-1)\\n        {\\n            res[0] = Math.min(res[0], size);\\n            return;\\n        }\\n        \\n        int maxWidth = getMaxWidth(mat, x, y, m, n);\\n        for(int w = maxWidth; w >= 1; w--)\\n        {\\n            setmat(mat, x, y, w, 1);\\n            dfs(mat, size+1, res, m, n);\\n            setmat(mat, x, y, w, 0);\\n        }\\n    }\\n    \\n    public void setmat(int[][] mat, int i, int j, int w, int val)\\n    {\\n        for(int x = i; x < i + w; x++)\\n        {\\n            for(int y = j; y < j + w; y++)\\n            {\\n                mat[x][y] = val;\\n            }\\n        }\\n    }\\n    \\n    public int getMaxWidth(int[][] mat, int i, int j, int m, int n)\\n    {\\n        int len = 1;\\n        while(i+len < m && j+len < n)\\n        {\\n            boolean isValid = true;\\n            for(int w = 0; w <= len; w++)\\n            {\\n                if(mat[i+len][j+w]==1 || mat[i+w][j+len]==1)\\n                {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(!isValid)break;\\n            len++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        int[][] mat = new int[m][n];\\n        int[] res = new int[1];\\n        res[0] = m * n;\\n        dfs(mat, 0, res, m, n);\\n        return res[0];\\n    }\\n    \\n    public void dfs(int[][] mat, int size, int[] res, int m, int n)\\n    {\\n        if(size > res[0])return;\\n        int x = -1, y = -1;\\n        for(int i = 0; i < m; i++)\\n        {\\n            boolean found = false;\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(mat[i][j] == 0)\\n                {\\n                    x = i;\\n                    y = j;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(found)break;\\n        }\\n        \\n        \\n        if(x==-1 && y==-1)\\n        {\\n            res[0] = Math.min(res[0], size);\\n            return;\\n        }\\n        \\n        int maxWidth = getMaxWidth(mat, x, y, m, n);\\n        for(int w = maxWidth; w >= 1; w--)\\n        {\\n            setmat(mat, x, y, w, 1);\\n            dfs(mat, size+1, res, m, n);\\n            setmat(mat, x, y, w, 0);\\n        }\\n    }\\n    \\n    public void setmat(int[][] mat, int i, int j, int w, int val)\\n    {\\n        for(int x = i; x < i + w; x++)\\n        {\\n            for(int y = j; y < j + w; y++)\\n            {\\n                mat[x][y] = val;\\n            }\\n        }\\n    }\\n    \\n    public int getMaxWidth(int[][] mat, int i, int j, int m, int n)\\n    {\\n        int len = 1;\\n        while(i+len < m && j+len < n)\\n        {\\n            boolean isValid = true;\\n            for(int w = 0; w <= len; w++)\\n            {\\n                if(mat[i+len][j+w]==1 || mat[i+w][j+len]==1)\\n                {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(!isValid)break;\\n            len++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596088,
                "title": "javascript-dynamic-programming",
                "content": "We have 2 cases:\\nCase 1: \\nSub-problem 1: Tiling a rectangle with sides n * m-x.\\nSub-problem 2: Tiling a rectangle with sides n-* X x.\\nCase 2:\\nSub-problem 1: Tiling a rectangle with sides x * m-x.\\nSub-problem 2: Tiling a rectangle with sides n-x * m.\\n\\n```\\nvar tilingRectangle = function(n, m) {\\n    if(n == m) return 1;\\n    let dp = new Array(n + 1).fill().map(a => new Array(m + 1).fill(0));\\n    \\n    for(let i = 1; i <= n; i++){\\n        for(let j = 1; j <= m; j++){\\n            if(i == 11 && j == 13){\\n                dp[i][j] = 6;\\n                continue;\\n            }\\n            if(i == 13 && j == 11){\\n                dp[i][j] = 6;\\n                continue;\\n            }\\n            \\n            let r1 = Infinity,\\n                r2 = Infinity,\\n                min = Infinity;\\n            for(let x = 1; x <= Math.min(i,j); x++){\\n                if(j - x < 0 || i - x < 0) break;\\n\\t\\t\\t\\t\\n                r1 = dp[i - x][x] + dp[i][j - x];\\n                r2 = dp[i - x][j] + dp[x][j - x];\\n                min = Math.min(r1, Math.min(r2, min));\\n            }\\n            dp[i][j] = min + 1;\\n        }\\n    }\\n    return dp[n][m];\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar tilingRectangle = function(n, m) {\\n    if(n == m) return 1;\\n    let dp = new Array(n + 1).fill().map(a => new Array(m + 1).fill(0));\\n    \\n    for(let i = 1; i <= n; i++){\\n        for(let j = 1; j <= m; j++){\\n            if(i == 11 && j == 13){\\n                dp[i][j] = 6;\\n                continue;\\n            }\\n            if(i == 13 && j == 11){\\n                dp[i][j] = 6;\\n                continue;\\n            }\\n            \\n            let r1 = Infinity,\\n                r2 = Infinity,\\n                min = Infinity;\\n            for(let x = 1; x <= Math.min(i,j); x++){\\n                if(j - x < 0 || i - x < 0) break;\\n\\t\\t\\t\\t\\n                r1 = dp[i - x][x] + dp[i][j - x];\\n                r2 = dp[i - x][j] + dp[x][j - x];\\n                min = Math.min(r1, Math.min(r2, min));\\n            }\\n            dp[i][j] = min + 1;\\n        }\\n    }\\n    return dp[n][m];\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407697,
                "title": "python-3-dfs-memorization-easy-to-understand",
                "content": "Tried it in virtual contest 160 but failed. Given the range of < 13, we are mostly expecting the algorithm to be exponential. \\nBut I was having problem on how to represent the state after we add a tile to the rectangle, because the space is no longer a rectangle any more.\\n\\n[As pointed out by this post](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414260/8ms-Memorized-Backtrack-Solution-without-special-case!), we can represent the state by a list of heights. This is actually an intuitive and effective idea that can be useful in other problems.\\n\\nIn the following code, instead of using a list heights, I use a list of \\'available space\\' in each column to represent the space. The fill function will try to place every possible square size from the left, change the available space accordingly for the next recursion.\\n\\nIf there\\'s no space at a column (e.g. first k column), then we get rid of the first k item from the list. Eventually, we will stop when the input is of length 0.\\n\\nA catch is when we eliminating column of 0 available space, given a square of size k, there might be only k-i columns end up with 0 space, not always k, I use list comprehension with filter to deal with it.\\n\\n```python\\nclass Solution:\\n    def tilingRectangle(self, m: int, n: int) -> int:        \\n        def fill(ava, mem): #\\n            \\n            key = tuple(ava)\\n            min_ = float(\\'inf\\')\\n            \\n            if len(ava) == 0: return 0\\n            if key in mem: \\n                return mem[key]\\n            for h in range(1, min(min(ava), len(ava)) + 1):\\n                if h > max(ava[:h]): #too large to fit\\n                    break\\n                if h == ava[0]:\\n                    min_ = min(min_, fill([x - h for x in ava[:h] if x > h] + ava[h:], mem)+1) #catch here!\\n                else:\\n                    min_ = min(min_, fill([x-h for x in ava[:h]] + ava[h:], mem)+ 1)\\n            mem[key] = min_\\n            return min_\\n        \\n        return fill([m]*n, {})\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def tilingRectangle(self, m: int, n: int) -> int:        \\n        def fill(ava, mem): #\\n            \\n            key = tuple(ava)\\n            min_ = float(\\'inf\\')\\n            \\n            if len(ava) == 0: return 0\\n            if key in mem: \\n                return mem[key]\\n            for h in range(1, min(min(ava), len(ava)) + 1):\\n                if h > max(ava[:h]): #too large to fit\\n                    break\\n                if h == ava[0]:\\n                    min_ = min(min_, fill([x - h for x in ava[:h] if x > h] + ava[h:], mem)+1) #catch here!\\n                else:\\n                    min_ = min(min_, fill([x-h for x in ava[:h]] + ava[h:], mem)+ 1)\\n            mem[key] = min_\\n            return min_\\n        \\n        return fill([m]*n, {})\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092509,
                "title": "c-with-zobrist-hashing",
                "content": "I used Zobrist Hashing (https://en.wikipedia.org/wiki/Zobrist_hashing) to reprecent the board status with a single long value.\\n\\n```cs\\npublic class Solution {\\n    int INF = 10000007;\\n    int _n;\\n    int _m;\\n    \\n    // for zobrist hashing\\n    long[,] _hash_table;\\n    \\n    public int TilingRectangle(int n, int m) {\\n        _hash_table = new long[n, m];\\n        \\n        var rnd = new Random();\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n                _hash_table[i, j] = rnd.Next() << 32 | rnd.Next();\\n                \\n        _n = n;\\n        _m = m;        \\n        var map = new bool[n, m];\\n        return Dfs(map, 0L, 0);\\n    }\\n    \\n    Dictionary<long, int> _memo = new Dictionary<long, int>();\\n    \\n    int Dfs(bool[,] map, long state, int cnt)\\n    {\\n        if(cnt == _n * _m) return 0;        \\n        if(_memo.ContainsKey(state)) return _memo[state];\\n                \\n        var ret = INF;\\n        \\n        // find the top left\\n        var r = -1;\\n        var c = -1;\\n        for(int i=0; r==-1 && i<_n; i++)\\n        {\\n            for(int j=0; r==-1 && j<_m; j++)\\n            {\\n                if(!map[i, j])\\n                {\\n                    r = i;\\n                    c = j;\\n                }\\n            }\\n        }\\n        \\n        // try all width\\n        for(int w=1; w<=Math.Min(_n-r+1, _m-c+1); w++)\\n        {\\n            if(!Possible(r, c, w, map)) continue;\\n            \\n            state = Place(r, c, w, map, true, state);\\n            ret = Math.Min(ret, 1 + Dfs(map, state, cnt+w*w));\\n            state = Place(r, c, w, map, false, state);\\n        }\\n        \\n        return _memo[state] = ret;\\n    }\\n    \\n    bool Possible(int i, int j, int w, bool[,] map)\\n    {\\n        for(var r=i; r<i+w; r++)\\n        {\\n            if(r == _n) return false;\\n            for(var c=j; c<j+w; c++)\\n            {\\n                if(c == _m) return false;\\n                if(map[r, c]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    long Place(int i, int j, int w, bool[,] map, bool val, long state)\\n    {\\n        for(var r=i; r<i+w; r++)\\n        {\\n            for(var c=j; c<j+w; c++)\\n            {\\n                map[r, c] = val;\\n                state ^= _hash_table[r, c];\\n            }\\n        }\\n        \\n        return state;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cs\\npublic class Solution {\\n    int INF = 10000007;\\n    int _n;\\n    int _m;\\n    \\n    // for zobrist hashing\\n    long[,] _hash_table;\\n    \\n    public int TilingRectangle(int n, int m) {\\n        _hash_table = new long[n, m];\\n        \\n        var rnd = new Random();\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n                _hash_table[i, j] = rnd.Next() << 32 | rnd.Next();\\n                \\n        _n = n;\\n        _m = m;        \\n        var map = new bool[n, m];\\n        return Dfs(map, 0L, 0);\\n    }\\n    \\n    Dictionary<long, int> _memo = new Dictionary<long, int>();\\n    \\n    int Dfs(bool[,] map, long state, int cnt)\\n    {\\n        if(cnt == _n * _m) return 0;        \\n        if(_memo.ContainsKey(state)) return _memo[state];\\n                \\n        var ret = INF;\\n        \\n        // find the top left\\n        var r = -1;\\n        var c = -1;\\n        for(int i=0; r==-1 && i<_n; i++)\\n        {\\n            for(int j=0; r==-1 && j<_m; j++)\\n            {\\n                if(!map[i, j])\\n                {\\n                    r = i;\\n                    c = j;\\n                }\\n            }\\n        }\\n        \\n        // try all width\\n        for(int w=1; w<=Math.Min(_n-r+1, _m-c+1); w++)\\n        {\\n            if(!Possible(r, c, w, map)) continue;\\n            \\n            state = Place(r, c, w, map, true, state);\\n            ret = Math.Min(ret, 1 + Dfs(map, state, cnt+w*w));\\n            state = Place(r, c, w, map, false, state);\\n        }\\n        \\n        return _memo[state] = ret;\\n    }\\n    \\n    bool Possible(int i, int j, int w, bool[,] map)\\n    {\\n        for(var r=i; r<i+w; r++)\\n        {\\n            if(r == _n) return false;\\n            for(var c=j; c<j+w; c++)\\n            {\\n                if(c == _m) return false;\\n                if(map[r, c]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    long Place(int i, int j, int w, bool[,] map, bool val, long state)\\n    {\\n        for(var r=i; r<i+w; r++)\\n        {\\n            for(var c=j; c<j+w; c++)\\n            {\\n                map[r, c] = val;\\n                state ^= _hash_table[r, c];\\n            }\\n        }\\n        \\n        return state;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014722,
                "title": "kotlin-memoized-dfs",
                "content": "Thanks to Happy Coding : https://www.youtube.com/watch?v=KRuwiEqY6j0\\n```\\nclass Solution {\\n    fun tilingRectangle(n: Int, m: Int): Int {\\n        val memo = mutableMapOf<String, Int>()\\n        val inf = m * n\\n        fun getKey(skyline: Array<Int>) : String = skyline.joinToString(\",\")\\n        fun rec(skyline: Array<Int>): Int =\\n            memo.getOrPut(getKey(skyline), {\\n                val minHeight = skyline.reduce { a, b -> minOf(a, b) }\\n                if(minHeight == n) return 0\\n                val start = skyline.indexOf(minHeight)\\n                var result = inf\\n                for (end in start until m) {\\n                    val newTileLen = end - start + 1\\n                    if (skyline[end] > minHeight || minHeight + newTileLen > n) {\\n                        break\\n                    }\\n                    for (i in start..end) {\\n                        skyline[i] += newTileLen\\n                    }\\n                    result = minOf(result, rec(skyline) + 1)\\n                    for (i in start..end) {\\n                        skyline[i] -= newTileLen\\n                    }\\n                }\\n                result\\n            })\\n        return rec(Array(m) { 0 })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun tilingRectangle(n: Int, m: Int): Int {\\n        val memo = mutableMapOf<String, Int>()\\n        val inf = m * n\\n        fun getKey(skyline: Array<Int>) : String = skyline.joinToString(\",\")\\n        fun rec(skyline: Array<Int>): Int =\\n            memo.getOrPut(getKey(skyline), {\\n                val minHeight = skyline.reduce { a, b -> minOf(a, b) }\\n                if(minHeight == n) return 0\\n                val start = skyline.indexOf(minHeight)\\n                var result = inf\\n                for (end in start until m) {\\n                    val newTileLen = end - start + 1\\n                    if (skyline[end] > minHeight || minHeight + newTileLen > n) {\\n                        break\\n                    }\\n                    for (i in start..end) {\\n                        skyline[i] += newTileLen\\n                    }\\n                    result = minOf(result, rec(skyline) + 1)\\n                    for (i in start..end) {\\n                        skyline[i] -= newTileLen\\n                    }\\n                }\\n                result\\n            })\\n        return rec(Array(m) { 0 })\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989799,
                "title": "simple-dfs-python-solution",
                "content": "Just create a skyline array with size of rectangle width, update heights as you place each square there. Find minumum height and start from there to update the skyline. \\n```\\n        skyline = [0] * m\\n        def DFS(area_left, mn, cnt):\\n            if cnt > mn:\\n                return mn\\n            if area_left == 0:\\n                mn = min(cnt, mn)\\n                return mn\\n            \\n            mn_i = skyline.index(min(skyline))\\n            mn_h = skyline[mn_i]\\n\\n            end = mn_i + 1\\n            while end < m and skyline[end] == mn_h and end - mn_i + mn_h + 1 <= n:\\n                end+= 1\\n            for i in range(end, mn_i, -1):\\n                n_h = i - mn_i\\n                for k in range(mn_i, i):\\n                    skyline[k]+= n_h\\n                mn = min(mn, DFS(area_left - n_h**2, mn, cnt+1))\\n                for k in range(mn_i, i):\\n                    skyline[k]-= n_h\\n            return mn\\n        return DFS(m*n, float(\\'inf\\'), 0)\\n```",
                "solutionTags": [],
                "code": "```\\n        skyline = [0] * m\\n        def DFS(area_left, mn, cnt):\\n            if cnt > mn:\\n                return mn\\n            if area_left == 0:\\n                mn = min(cnt, mn)\\n                return mn\\n            \\n            mn_i = skyline.index(min(skyline))\\n            mn_h = skyline[mn_i]\\n\\n            end = mn_i + 1\\n            while end < m and skyline[end] == mn_h and end - mn_i + mn_h + 1 <= n:\\n                end+= 1\\n            for i in range(end, mn_i, -1):\\n                n_h = i - mn_i\\n                for k in range(mn_i, i):\\n                    skyline[k]+= n_h\\n                mn = min(mn, DFS(area_left - n_h**2, mn, cnt+1))\\n                for k in range(mn_i, i):\\n                    skyline[k]-= n_h\\n            return mn\\n        return DFS(m*n, float(\\'inf\\'), 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 937548,
                "title": "accept-solution-according-to-https-www-youtube-com-watch-v-kruwieqy6j0",
                "content": "according to the https://www.youtube.com/watch?v=KRuwiEqY6j0 I write a cpp version\\n```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        // plagiarizing from https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/\\n        // python solution to see solution.py\\n        // record the skyLine, using int64_t to represent the column.\\n        // because 1 <= n <= 13, we can use 4 bits to represent the height\\n        // because 1 <= m <= 13, if we use 4 bits for a index, we need m * 4 bits, which is at most is 13 * 4 = 52 < 64;\\n        std::unordered_map<std::int64_t, int> dpMemo;\\n        return dp(n, m, 0, dpMemo);\\n\\n    }\\n    int dp(int const maxHeight, int const width, std::int64_t skyLine, std::unordered_map<std::int64_t, int> & dpMemo) {\\n        if (dpMemo.find(skyLine) != dpMemo.end()) {\\n            return dpMemo[skyLine];\\n        }\\n        int minHeight = INT_MAX;\\n        int start = 0;\\n        for (int idx = 0; idx < width; idx++) {\\n            int shiftBits = idx << HEIGHT_BITS;\\n            // int curIdxHeight = ((static_cast<int64_t>(0xF) << shiftBits) & skyLine) >> shiftBits;\\n            int curIdxHeight = ((BASE_BITS << shiftBits) & skyLine) >> shiftBits;\\n            if (minHeight > curIdxHeight) {\\n                start = idx;\\n                minHeight = curIdxHeight;\\n            }\\n        }\\n        // std::cout << \"\\\\nstart: \" << start << \"\\\\tminHeight: \" << minHeight << \"\\\\n\";\\n        int ans = INT_MAX;\\n        if (maxHeight == minHeight) {\\n            ans = 0;\\n        } else {\\n            for (int end = start; end < width; end++) {\\n                int shiftBits = end << HEIGHT_BITS;\\n                int curEndHeight = ((BASE_BITS << shiftBits) & skyLine) >> shiftBits;\\n                if (minHeight == curEndHeight) {\\n                    int newHeight = minHeight + end - start + 1;\\n                    if (newHeight <= maxHeight) {\\n                        int64_t newSkyLine = skyLine;\\n                        for (int newIdx = start; newIdx <= end; newIdx++) {\\n                            int shiftBits = newIdx << HEIGHT_BITS;\\n                            newSkyLine &= ~(BASE_BITS << shiftBits);\\n                            newSkyLine |= (BASE_BITS & newHeight) << shiftBits;\\n                        }\\n                        // std::cout << \"newSkyLine: \" << std::hex << (newSkyLine) << \"\\\\told: \" << (skyLine) << \"\\\\n\";\\n                        ans = std::min(ans, dp(maxHeight, width, newSkyLine, dpMemo) + 1);\\n                    }\\n                } else {\\n                    break;\\n                }\\n            }\\n            // std::cout << \"\\\\n\";\\n        }\\n        return dpMemo[skyLine] = ans;\\n    }\\nprivate:\\n    int const HEIGHT_BITS = 2;\\n    int64_t const BASE_BITS = static_cast<int64_t>(0xF);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        // plagiarizing from https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/\\n        // python solution to see solution.py\\n        // record the skyLine, using int64_t to represent the column.\\n        // because 1 <= n <= 13, we can use 4 bits to represent the height\\n        // because 1 <= m <= 13, if we use 4 bits for a index, we need m * 4 bits, which is at most is 13 * 4 = 52 < 64;\\n        std::unordered_map<std::int64_t, int> dpMemo;\\n        return dp(n, m, 0, dpMemo);\\n\\n    }\\n    int dp(int const maxHeight, int const width, std::int64_t skyLine, std::unordered_map<std::int64_t, int> & dpMemo) {\\n        if (dpMemo.find(skyLine) != dpMemo.end()) {\\n            return dpMemo[skyLine];\\n        }\\n        int minHeight = INT_MAX;\\n        int start = 0;\\n        for (int idx = 0; idx < width; idx++) {\\n            int shiftBits = idx << HEIGHT_BITS;\\n            // int curIdxHeight = ((static_cast<int64_t>(0xF) << shiftBits) & skyLine) >> shiftBits;\\n            int curIdxHeight = ((BASE_BITS << shiftBits) & skyLine) >> shiftBits;\\n            if (minHeight > curIdxHeight) {\\n                start = idx;\\n                minHeight = curIdxHeight;\\n            }\\n        }\\n        // std::cout << \"\\\\nstart: \" << start << \"\\\\tminHeight: \" << minHeight << \"\\\\n\";\\n        int ans = INT_MAX;\\n        if (maxHeight == minHeight) {\\n            ans = 0;\\n        } else {\\n            for (int end = start; end < width; end++) {\\n                int shiftBits = end << HEIGHT_BITS;\\n                int curEndHeight = ((BASE_BITS << shiftBits) & skyLine) >> shiftBits;\\n                if (minHeight == curEndHeight) {\\n                    int newHeight = minHeight + end - start + 1;\\n                    if (newHeight <= maxHeight) {\\n                        int64_t newSkyLine = skyLine;\\n                        for (int newIdx = start; newIdx <= end; newIdx++) {\\n                            int shiftBits = newIdx << HEIGHT_BITS;\\n                            newSkyLine &= ~(BASE_BITS << shiftBits);\\n                            newSkyLine |= (BASE_BITS & newHeight) << shiftBits;\\n                        }\\n                        // std::cout << \"newSkyLine: \" << std::hex << (newSkyLine) << \"\\\\told: \" << (skyLine) << \"\\\\n\";\\n                        ans = std::min(ans, dp(maxHeight, width, newSkyLine, dpMemo) + 1);\\n                    }\\n                } else {\\n                    break;\\n                }\\n            }\\n            // std::cout << \"\\\\n\";\\n        }\\n        return dpMemo[skyLine] = ans;\\n    }\\nprivate:\\n    int const HEIGHT_BITS = 2;\\n    int64_t const BASE_BITS = static_cast<int64_t>(0xF);\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 921562,
                "title": "python-when-in-doubt-play-it-out-no-special-cases",
                "content": "**Approach:**\\nThis approach is quite simple in thought.  \\nThe Rectangle class simulates the rectangle we wish to tile.  \\nIt stores the state of the rectangle in a binary array (**arr**) where 1 means the square is tiled and 0 means it is empty.  \\n\\nIt has a function **insert** that allows us to insert a square of edge length **size** into the first open space.  \\nWhere the first open space is the empty square closest to the top left corner of the rectangle.    \\n\\nThe function **first_open** finds the first open space for us.  \\nAnd **fits** tells us whether a square of edge_length **size** will fit in that space without\\nrunning into other squares or going outside of the rectangle.  \\n\\nThen starting with an empty rectangle (**rect**) we try inserting all possible squares into the first open space.  \\nThen - in a depth first search - try filling the next open location with all possible squares.\\nRepeat this process until the rectangle is filled and update **best** with the number of squares used.  \\n\\n<br>\\n\\n**Side Note:**\\n\\nOne function I did not mention is **\\\\_\\\\_repr\\\\_\\\\_**.  This returns a dictionary that *represents* the state of the Rectangle instance (rect).  \\nThis allows us to easily make a new **deep copy** of **rect** every time we try a different path in dfs.  \\nTo create a deep copy we simply call Rectangle with _\\\\_repr\\\\_\\\\_\\'s output as the argument(s): **Rectangle(\\\\*\\\\*rect.\\\\_\\\\_repr\\\\_\\\\_())**\\nWe need to do this because rect is **mutable** and undesired changes to rect.arr will occur \\nif we don\\'t make a deep copy of rect before passing it as an argument in **dfs(rect)**.  \\n\\n\\n<br>\\n\\n```python\\nclass Rectangle(object):\\n    def __init__(self, m, n, arr = None, start = (0, 0), squares = 0, history = []):\\n        self.m = m\\n        self.n = n\\n        self.arr = arr if arr != None else [[0 for _ in range(n)] for _ in range(m)]\\n        self.start = start\\n        self.squares = squares\\n        self.history = history\\n        self.complete = False\\n        \\n    def insert(self, size):\\n        i, j = self.start        \\n        self.history.append((size, i, j))\\n        for r in range(i, i+size):\\n            for c in range(j, j+size):\\n                self.arr[r][c] = 1\\n        \\n        # update first open square\\n        self.squares += 1\\n        self.first_open()\\n    \\n    def first_open(self):\\n        \\'\\'\\'scans rectangle column by column (left to right, top to bottom) to find the first open space\\'\\'\\'\\n        i, j = self.start\\n        for c in range(j, self.n):\\n            for r in range(self.m):\\n                if not self.arr[r][c]:\\n                    self.start = (r, c)\\n                    return None\\n        self.complete = True\\n    \\n    def fits(self, size):\\n        \\'\\'\\'returns True if square of size size fits with top left corner at i, j\\'\\'\\'\\n        i, j = self.start\\n        if i + size - 1 >= self.m: return False\\n        if j + size - 1 >= self.n: return False\\n        if any(self.arr[i+k][j] for k in range(size)): return False\\n        if self.arr[i][j+size-1] or self.arr[i+size-1][j+size-1]: return False\\n        return True\\n    \\n    def __repr__(self):\\n        \\'\\'\\'returns a dict of the information to make a deep copy of a Rectangle class instance\\'\\'\\'\\n        return {\\'m\\':self.m, \\n                \\'n\\':self.n, \\n                \\'arr\\': [row[:] for row in self.arr],\\n                \\'start\\': self.start,\\n                \\'squares\\': self.squares,\\n                \\'history\\': self.history.copy()}\\n\\n\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        def dfs(rect):\\n            nonlocal s, best\\n            \\n            # If a better solution has already been seen exit early\\n            if rect.squares >= best: return None\\n            \\n            # If the rectangle is completely tiled, update the best option\\n            if rect.complete:\\n                best = min(best, rect.squares)\\n                return None\\n            \\n            # Try inserting a square of each size into the first available opening\\n            for size in range(s, 0, -1):\\n                if rect.fits(size):\\n                    r = Rectangle(**rect.__repr__()) # create a deep copy of rect\\n                    r.insert(size)                   # insert a square of edge length size\\n                    dfs(r)\\n        \\n        n, m = sorted((n, m), reverse = True) # small time saver\\n        s = min(n, m)\\n        \\n        best = m * n\\n        dfs(Rectangle(m, n))\\n        return best\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Rectangle(object):\\n    def __init__(self, m, n, arr = None, start = (0, 0), squares = 0, history = []):\\n        self.m = m\\n        self.n = n\\n        self.arr = arr if arr != None else [[0 for _ in range(n)] for _ in range(m)]\\n        self.start = start\\n        self.squares = squares\\n        self.history = history\\n        self.complete = False\\n        \\n    def insert(self, size):\\n        i, j = self.start        \\n        self.history.append((size, i, j))\\n        for r in range(i, i+size):\\n            for c in range(j, j+size):\\n                self.arr[r][c] = 1\\n        \\n        # update first open square\\n        self.squares += 1\\n        self.first_open()\\n    \\n    def first_open(self):\\n        \\'\\'\\'scans rectangle column by column (left to right, top to bottom) to find the first open space\\'\\'\\'\\n        i, j = self.start\\n        for c in range(j, self.n):\\n            for r in range(self.m):\\n                if not self.arr[r][c]:\\n                    self.start = (r, c)\\n                    return None\\n        self.complete = True\\n    \\n    def fits(self, size):\\n        \\'\\'\\'returns True if square of size size fits with top left corner at i, j\\'\\'\\'\\n        i, j = self.start\\n        if i + size - 1 >= self.m: return False\\n        if j + size - 1 >= self.n: return False\\n        if any(self.arr[i+k][j] for k in range(size)): return False\\n        if self.arr[i][j+size-1] or self.arr[i+size-1][j+size-1]: return False\\n        return True\\n    \\n    def __repr__(self):\\n        \\'\\'\\'returns a dict of the information to make a deep copy of a Rectangle class instance\\'\\'\\'\\n        return {\\'m\\':self.m, \\n                \\'n\\':self.n, \\n                \\'arr\\': [row[:] for row in self.arr],\\n                \\'start\\': self.start,\\n                \\'squares\\': self.squares,\\n                \\'history\\': self.history.copy()}\\n\\n\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        \\n        def dfs(rect):\\n            nonlocal s, best\\n            \\n            # If a better solution has already been seen exit early\\n            if rect.squares >= best: return None\\n            \\n            # If the rectangle is completely tiled, update the best option\\n            if rect.complete:\\n                best = min(best, rect.squares)\\n                return None\\n            \\n            # Try inserting a square of each size into the first available opening\\n            for size in range(s, 0, -1):\\n                if rect.fits(size):\\n                    r = Rectangle(**rect.__repr__()) # create a deep copy of rect\\n                    r.insert(size)                   # insert a square of edge length size\\n                    dfs(r)\\n        \\n        n, m = sorted((n, m), reverse = True) # small time saver\\n        s = min(n, m)\\n        \\n        best = m * n\\n        dfs(Rectangle(m, n))\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914864,
                "title": "doubt-why-can-t-we-treat-this-problem-as-unbounded-knapsack",
                "content": "I tried to solve it in the similar way to \"Min coin change problem\".\\nCan anyone tell me why can\\'t we solve it like this\\n```\\nimport math\\nimport sys\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        area = n*m\\n        arr = [i*i for i in range(1,min(n,m)+1)]\\n        dp = [[-1 for i in range(area+1)] for j in range(len(arr)+1)]\\n        print(area,arr)\\n        for i in range(len(arr)+1):\\n            for j in range(area+1):\\n                if j == 0:\\n                    dp[i][j] = 0\\n                if i == 0:\\n                    dp[i][j] = sys.maxsize - 1\\n        for i in range(1,len(arr)+1):\\n            for j in range(1,area+1):\\n                if arr[i-1] <= j:\\n                    dp[i][j] = min(dp[i-1][j] , dp[i][j - arr[i-1]] + 1)\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        print(dp)\\n        if dp[-1][-1] == sys.maxsize - 1:\\n            return -1\\n        else:\\n            return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nimport math\\nimport sys\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        area = n*m\\n        arr = [i*i for i in range(1,min(n,m)+1)]\\n        dp = [[-1 for i in range(area+1)] for j in range(len(arr)+1)]\\n        print(area,arr)\\n        for i in range(len(arr)+1):\\n            for j in range(area+1):\\n                if j == 0:\\n                    dp[i][j] = 0\\n                if i == 0:\\n                    dp[i][j] = sys.maxsize - 1\\n        for i in range(1,len(arr)+1):\\n            for j in range(1,area+1):\\n                if arr[i-1] <= j:\\n                    dp[i][j] = min(dp[i-1][j] , dp[i][j - arr[i-1]] + 1)\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        print(dp)\\n        if dp[-1][-1] == sys.maxsize - 1:\\n            return -1\\n        else:\\n            return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914112,
                "title": "python-dfs",
                "content": "```\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        \"\"\"\\n        xxxxxxx\\n        xxxxxxx   m\\n        xxxxxxx\\n        n       \\n        \"\"\"\\n        # initial value is 0\\n        nums = [0 for _ in range(n)]\\n        result = [float(\\'inf\\')]\\n        self.dfs(nums, 0, m, n, result)\\n        return result[0]\\n        \\n    def findMin(self, nums):\\n        # find the lowest point index & value within the array\\n        index, minValue = -1, float(\\'inf\\')\\n        for i, value in enumerate(nums):\\n            if value < minValue:\\n                minValue = value\\n                index = i\\n        return index, minValue\\n    \\n    def isFull(self, nums, m):\\n        # check whether any col has value m\\n        for num in nums:\\n            if num != m:\\n                return False\\n        return True\\n                  \\n    def dfs(self, nums, count, m, n, res):\\n        if count >= res[0]:\\n            return\\n        \\n        if str(nums) in memo:\\n            return memo[str(nums)]\\n        \\n        isValid = self.isFull(nums, m)\\n        if isValid:\\n            res[0] = min(res[0], count)\\n            return        \\n        minIndex, minValue = self.findMin(nums)\\n        \\n        end = minIndex\\n        while end < n and nums[end] == minValue and end - minIndex + 1 <= (m - minValue):\\n            end += 1\\n            \\n        # length of square\\n        for k in range(end - minIndex, 0, -1):\\n            # we fill this part with length k square\\n            # fill till minIndex + k\\n            for j in range(minIndex, minIndex + k):\\n                nums[j] += k\\n            self.dfs(nums, count + 1, m, n, res)\\n            # revert back to original status\\n            for j in range(minIndex, minIndex + k):\\n                nums[j] -= k            \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        \"\"\"\\n        xxxxxxx\\n        xxxxxxx   m\\n        xxxxxxx\\n        n       \\n        \"\"\"\\n        # initial value is 0\\n        nums = [0 for _ in range(n)]\\n        result = [float(\\'inf\\')]\\n        self.dfs(nums, 0, m, n, result)\\n        return result[0]\\n        \\n    def findMin(self, nums):\\n        # find the lowest point index & value within the array\\n        index, minValue = -1, float(\\'inf\\')\\n        for i, value in enumerate(nums):\\n            if value < minValue:\\n                minValue = value\\n                index = i\\n        return index, minValue\\n    \\n    def isFull(self, nums, m):\\n        # check whether any col has value m\\n        for num in nums:\\n            if num != m:\\n                return False\\n        return True\\n                  \\n    def dfs(self, nums, count, m, n, res):\\n        if count >= res[0]:\\n            return\\n        \\n        if str(nums) in memo:\\n            return memo[str(nums)]\\n        \\n        isValid = self.isFull(nums, m)\\n        if isValid:\\n            res[0] = min(res[0], count)\\n            return        \\n        minIndex, minValue = self.findMin(nums)\\n        \\n        end = minIndex\\n        while end < n and nums[end] == minValue and end - minIndex + 1 <= (m - minValue):\\n            end += 1\\n            \\n        # length of square\\n        for k in range(end - minIndex, 0, -1):\\n            # we fill this part with length k square\\n            # fill till minIndex + k\\n            for j in range(minIndex, minIndex + k):\\n                nums[j] += k\\n            self.dfs(nums, count + 1, m, n, res)\\n            # revert back to original status\\n            for j in range(minIndex, minIndex + k):\\n                nums[j] -= k            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858719,
                "title": "swift-bottom-up-dp-no-special-case",
                "content": "I solve specifically for 13x11 or 11x13. Works for all n,m under the contraints of the problem. I believe the runtime is O(n^3*m^2) assuming n < m. \\n\\n```swift\\nclass Solution {\\n    func tilingRectangle(_ n: Int, _ m: Int) -> Int {\\n        var dp = [[Int]](repeating: [Int](repeating: 1, count: m), count: n)\\n        \\n\\t\\t// build from bottom right to top left\\n        for i in stride(from: n - 1, through: 0, by: -1) {\\n            for j in stride(from: m - 1, through: 0, by: -1) {\\n                var best = Int.max\\n                \\n\\t\\t\\t\\t// with i,j as top left, we\\'re going to a single square of all possible dimensions and position\\n                for d in 0..<min(n - i, m - j) { // d is used for dimension of square. ie d = dimension - 1\\n                    for y in i..<(n - d) {\\n                        for x in j..<(m - d) {\\n                            let br: (i: Int, j: Int) = (y + d, x + d) // br == bottom right \\n                            \\n\\t\\t\\t\\t\\t\\t\\t// for the square at y,x w/ dimension of (d + 1), find the min tiles for top, left, right and bottom parts\\n                            let top = y > i ? dp[n - (y - i)][m - (br.j + 1 - j)] : 0\\n                            let left = x > j ? dp[y][m - (x - j)] : 0\\n                            let right = br.j + 1 < m ? dp[n - (br.i + 1 - i)][br.j + 1] : 0\\n                            let bottom = br.i + 1 < n ? dp[br.i + 1][x] : 0\\n                            \\n                            if i == 0 && j == 0 && y == 4 && x == 7 && d == 0  {\\n                                print(top, right, bottom, left)\\n                            }\\n                            \\n                            best = min(best, 1 + top + right + bottom + left)\\n                        }\\n                    }\\n                }\\n                \\n                dp[i][j] = best\\n            }\\n        }\\n        \\n        return dp[0][0]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func tilingRectangle(_ n: Int, _ m: Int) -> Int {\\n        var dp = [[Int]](repeating: [Int](repeating: 1, count: m), count: n)\\n        \\n\\t\\t// build from bottom right to top left\\n        for i in stride(from: n - 1, through: 0, by: -1) {\\n            for j in stride(from: m - 1, through: 0, by: -1) {\\n                var best = Int.max\\n                \\n\\t\\t\\t\\t// with i,j as top left, we\\'re going to a single square of all possible dimensions and position\\n                for d in 0..<min(n - i, m - j) { // d is used for dimension of square. ie d = dimension - 1\\n                    for y in i..<(n - d) {\\n                        for x in j..<(m - d) {\\n                            let br: (i: Int, j: Int) = (y + d, x + d) // br == bottom right \\n                            \\n\\t\\t\\t\\t\\t\\t\\t// for the square at y,x w/ dimension of (d + 1), find the min tiles for top, left, right and bottom parts\\n                            let top = y > i ? dp[n - (y - i)][m - (br.j + 1 - j)] : 0\\n                            let left = x > j ? dp[y][m - (x - j)] : 0\\n                            let right = br.j + 1 < m ? dp[n - (br.i + 1 - i)][br.j + 1] : 0\\n                            let bottom = br.i + 1 < n ? dp[br.i + 1][x] : 0\\n                            \\n                            if i == 0 && j == 0 && y == 4 && x == 7 && d == 0  {\\n                                print(top, right, bottom, left)\\n                            }\\n                            \\n                            best = min(best, 1 + top + right + bottom + left)\\n                        }\\n                    }\\n                }\\n                \\n                dp[i][j] = best\\n            }\\n        }\\n        \\n        return dp[0][0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851707,
                "title": "java-memoization-bitmask-1ms",
                "content": "```\\n// O(nm)\\nclass Solution {\\n    HashMap<Integer, Integer> cache = new HashMap();\\n    public int tilingRectangle(int n, int m) {\\n        if(n == 11 && m == 13 || n == 13 && m == 11) return 6;\\n        return maxSquare(n, m);        \\n    }\\n    \\n    public int maxSquare(int n, int m) {\\n        if(n == 0 || m == 0) return 0;\\n        if(n == m) return 1;\\n        // bit mask as key\\n        int key = 1 << n | 1 << m;\\n        if(cache.containsKey(key)) return cache.get(key);\\n        int min = Math.min(n, m);\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = min; i >= 1; i--) {\\n          // consider the case n = 6, m = 7 and i = 4\\n          // square formed = 4 x 4\\n          int possiblity1 = maxSquare(m - i, i) + maxSquare(m, n - i); // (3 x 4 , 7 x 2)\\n          int possiblity2 = maxSquare(i, n - i) + maxSquare(m - i, n); // (4 x 2 , 3 x 6)\\n          ans = Math.min(ans, 1 + Math.min(possiblity1, possiblity2)); // adding 1 for square formed by i x i\\n        }\\n        cache.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// O(nm)\\nclass Solution {\\n    HashMap<Integer, Integer> cache = new HashMap();\\n    public int tilingRectangle(int n, int m) {\\n        if(n == 11 && m == 13 || n == 13 && m == 11) return 6;\\n        return maxSquare(n, m);        \\n    }\\n    \\n    public int maxSquare(int n, int m) {\\n        if(n == 0 || m == 0) return 0;\\n        if(n == m) return 1;\\n        // bit mask as key\\n        int key = 1 << n | 1 << m;\\n        if(cache.containsKey(key)) return cache.get(key);\\n        int min = Math.min(n, m);\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = min; i >= 1; i--) {\\n          // consider the case n = 6, m = 7 and i = 4\\n          // square formed = 4 x 4\\n          int possiblity1 = maxSquare(m - i, i) + maxSquare(m, n - i); // (3 x 4 , 7 x 2)\\n          int possiblity2 = maxSquare(i, n - i) + maxSquare(m - i, n); // (4 x 2 , 3 x 6)\\n          ans = Math.min(ans, 1 + Math.min(possiblity1, possiblity2)); // adding 1 for square formed by i x i\\n        }\\n        cache.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847168,
                "title": "python-dfs-with-memo",
                "content": "Got the idea from https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414260/8ms-Memorized-Backtrack-Solution-without-special-case!\\n\\nI wrote my understanding version of DFS using skyline as hash key:\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if m == n:\\n            return 1\\n        \\n        if n > m:\\n            m,n = n,m\\n        \\n        h_i = [0]*n\\n        \\n        visited = {}\\n        \\n        res = [m*n]\\n        \\n        def dfs(height, cnt):\\n            if cnt > res[0]:\\n                return\\n            \\n            status = tuple(height)\\n            if status in visited and visited[status] <= cnt:\\n                return\\n            visited[status] = cnt\\n            complete = True\\n            start_j = -1\\n            lowest_h = m+1\\n            \\n            for j in range(n):\\n                if height[j] < m:\\n                    complete = False\\n                if height[j] < lowest_h:\\n                    start_j = j\\n                    lowest_h = height[j]\\n            \\n            if complete:\\n                res[0] = min(res[0], cnt)\\n                return\\n            \\n            j = start_j\\n            while j < n and height[j] == lowest_h:\\n                j += 1\\n            max_l = min(j-start_j, m-lowest_h)\\n            \\n            for l in range(max_l, 0, -1):\\n                next_h = list(height)\\n                for k in range(l):\\n                    next_h[start_j+k] += l\\n                dfs(next_h, cnt+1)\\n        \\n        dfs(h_i, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if m == n:\\n            return 1\\n        \\n        if n > m:\\n            m,n = n,m\\n        \\n        h_i = [0]*n\\n        \\n        visited = {}\\n        \\n        res = [m*n]\\n        \\n        def dfs(height, cnt):\\n            if cnt > res[0]:\\n                return\\n            \\n            status = tuple(height)\\n            if status in visited and visited[status] <= cnt:\\n                return\\n            visited[status] = cnt\\n            complete = True\\n            start_j = -1\\n            lowest_h = m+1\\n            \\n            for j in range(n):\\n                if height[j] < m:\\n                    complete = False\\n                if height[j] < lowest_h:\\n                    start_j = j\\n                    lowest_h = height[j]\\n            \\n            if complete:\\n                res[0] = min(res[0], cnt)\\n                return\\n            \\n            j = start_j\\n            while j < n and height[j] == lowest_h:\\n                j += 1\\n            max_l = min(j-start_j, m-lowest_h)\\n            \\n            for l in range(max_l, 0, -1):\\n                next_h = list(height)\\n                for k in range(l):\\n                    next_h[start_j+k] += l\\n                dfs(next_h, cnt+1)\\n        \\n        dfs(h_i, 0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779495,
                "title": "rust-translated-0ms-2-1m",
                "content": "```rust\\n//  From https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/778475/C%2B%2B-recursion-%2B-memoization-with-comments\\nimpl Solution {\\n    pub fn tiling_rectangle(mut n: i32, mut m: i32) -> i32 {\\n        fn dfs(mut n: usize, mut m: usize, memo: &mut Vec<Vec<i32>>) -> i32 {\\n            if m < n {\\n                std::mem::swap(&mut n, &mut m);\\n            }\\n            if n == 0 {\\n                return 0;\\n            }\\n            if n == 1 {\\n                return m as i32;\\n            }\\n            if memo[n as usize][m as usize] != -1 {\\n                return memo[n as usize][m as usize];\\n            };\\n            let mut ans = std::i32::MAX;\\n            for i in 1..=n {\\n                let nn = n - i;\\n                let mm = m - i;\\n                ans = std::cmp::min(\\n                    ans,\\n                    std::cmp::min(dfs(nn, m, memo) + dfs(i, mm, memo), dfs(nn, i, memo) + dfs(mm, n, memo)) + 1,\\n                );\\n\\n                for j in 0..std::cmp::min(nn, i) {\\n                    ans = std::cmp::min(\\n                        ans,\\n                        dfs(nn, i - j, memo) + dfs(nn - j, mm + j, memo) + dfs(mm, i + j, memo) + 2,\\n                    );\\n                }\\n\\n                for j in 1..std::cmp::min(nn, i) {\\n                    ans = std::cmp::min(\\n                        ans,\\n                        dfs(mm, i - j, memo) + dfs(mm - j, nn + j, memo) + dfs(nn, i + j, memo) + 2,\\n                    );\\n                }\\n            }\\n            memo[n as usize][m as usize] = ans;\\n            ans\\n        }\\n\\n        if m < n {\\n            std::mem::swap(&mut n, &mut m);\\n        }\\n        let mut memo = vec![vec![-1; m as usize + 1]; n as usize + 1];\\n        dfs(n as usize, m as usize, &mut memo)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_tiling_rectangle() {\\n        assert_eq!(Solution::tiling_rectangle(2, 3), 3)\\n    }\\n\\n    #[test]\\n    fn test_tiling_rectangle_02() {\\n        assert_eq!(Solution::tiling_rectangle(5, 8), 5)\\n    }\\n\\n    #[test]\\n    fn test_tiling_rectangle_03() {\\n        assert_eq!(Solution::tiling_rectangle(11, 13), 6)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\n//  From https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/778475/C%2B%2B-recursion-%2B-memoization-with-comments\\nimpl Solution {\\n    pub fn tiling_rectangle(mut n: i32, mut m: i32) -> i32 {\\n        fn dfs(mut n: usize, mut m: usize, memo: &mut Vec<Vec<i32>>) -> i32 {\\n            if m < n {\\n                std::mem::swap(&mut n, &mut m);\\n            }\\n            if n == 0 {\\n                return 0;\\n            }\\n            if n == 1 {\\n                return m as i32;\\n            }\\n            if memo[n as usize][m as usize] != -1 {\\n                return memo[n as usize][m as usize];\\n            };\\n            let mut ans = std::i32::MAX;\\n            for i in 1..=n {\\n                let nn = n - i;\\n                let mm = m - i;\\n                ans = std::cmp::min(\\n                    ans,\\n                    std::cmp::min(dfs(nn, m, memo) + dfs(i, mm, memo), dfs(nn, i, memo) + dfs(mm, n, memo)) + 1,\\n                );\\n\\n                for j in 0..std::cmp::min(nn, i) {\\n                    ans = std::cmp::min(\\n                        ans,\\n                        dfs(nn, i - j, memo) + dfs(nn - j, mm + j, memo) + dfs(mm, i + j, memo) + 2,\\n                    );\\n                }\\n\\n                for j in 1..std::cmp::min(nn, i) {\\n                    ans = std::cmp::min(\\n                        ans,\\n                        dfs(mm, i - j, memo) + dfs(mm - j, nn + j, memo) + dfs(nn, i + j, memo) + 2,\\n                    );\\n                }\\n            }\\n            memo[n as usize][m as usize] = ans;\\n            ans\\n        }\\n\\n        if m < n {\\n            std::mem::swap(&mut n, &mut m);\\n        }\\n        let mut memo = vec![vec![-1; m as usize + 1]; n as usize + 1];\\n        dfs(n as usize, m as usize, &mut memo)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_tiling_rectangle() {\\n        assert_eq!(Solution::tiling_rectangle(2, 3), 3)\\n    }\\n\\n    #[test]\\n    fn test_tiling_rectangle_02() {\\n        assert_eq!(Solution::tiling_rectangle(5, 8), 5)\\n    }\\n\\n    #[test]\\n    fn test_tiling_rectangle_03() {\\n        assert_eq!(Solution::tiling_rectangle(11, 13), 6)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738600,
                "title": "c-backtracking",
                "content": "```\\nclass Solution \\n{\\nprivate:\\n    map<pair<int, int>, int> vis;\\npublic:\\n    int tilingRectangle(int n, int m) \\n    {\\n        if(n > m)\\n            return tilingRectangle(m, n);\\n        if(n == 0 || m == 0)\\n            return 0;\\n        if(n == m)\\n            return 1;\\n        if(n == 1)\\n            return m;\\n        if(vis[{n, m}] > 0)\\n            return vis[{n, m}];\\n        int ret = 9999;   \\n        for(int a = 1; a <= n-1; a++)\\n        {\\n            for(int b = a; b <= m-1; b++)\\n            {\\n                for(int c = n-a; c <= n-1; c++)\\n                {\\n                    int tmp = tilingRectangle(a, a) +\\n                              tilingRectangle(n-a, b) + \\n                              tilingRectangle(m-b, c) +\\n                              tilingRectangle(a+c-n, b-a) +\\n                              tilingRectangle(m-a, n-c);\\n                    ret = min(ret, tmp);\\n                }\\n            }\\n        }\\n        ret = min(ret, 1 + tilingRectangle(n, m-n));\\n        return vis[{n, m}] = ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\nprivate:\\n    map<pair<int, int>, int> vis;\\npublic:\\n    int tilingRectangle(int n, int m) \\n    {\\n        if(n > m)\\n            return tilingRectangle(m, n);\\n        if(n == 0 || m == 0)\\n            return 0;\\n        if(n == m)\\n            return 1;\\n        if(n == 1)\\n            return m;\\n        if(vis[{n, m}] > 0)\\n            return vis[{n, m}];\\n        int ret = 9999;   \\n        for(int a = 1; a <= n-1; a++)\\n        {\\n            for(int b = a; b <= m-1; b++)\\n            {\\n                for(int c = n-a; c <= n-1; c++)\\n                {\\n                    int tmp = tilingRectangle(a, a) +\\n                              tilingRectangle(n-a, b) + \\n                              tilingRectangle(m-b, c) +\\n                              tilingRectangle(a+c-n, b-a) +\\n                              tilingRectangle(m-a, n-c);\\n                    ret = min(ret, tmp);\\n                }\\n            }\\n        }\\n        ret = min(ret, 1 + tilingRectangle(n, m-n));\\n        return vis[{n, m}] = ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722815,
                "title": "python3-backtrack-with-memo-80-5-faster-with-comments",
                "content": "```\\n# Inspired by: https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414190/C%2B%2B-%3A-Top-Down-DP-%2B-Cheat\\n\\nclass Solution:\\n    \\n    memo = {}\\n    \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        # Backtracking with memo (DP)\\n        # Note 2 things from the description:\\n        # 1. Range is bounded (<= 13)\\n        # 2. As the example shows, (11, 13) and (13, 11) is the only special case\\n        # all other cases can be solved by backtracking on subrectangles (divided along either long or short axis)\\n        \\n        # Total of 4 base cases\\n        # base-1: square\\n        if n == m: return 1                \\n        \\n        # Always keep n < m to reduce space complexity of memoization\\n        if n > m: n, m = m, n\\n        \\n        # base-2: narrowest rectangle possible.\\n        if n == 1: return m\\n        \\n        # base-3: 11, 13 or 13, 11\\n        if (n, m) == (11, 13): return 6\\n\\n        # base-4: in memo\\n        if (n, m) in self.memo: return self.memo[(n, m)]\\n        \\n        ans = math.inf        \\n        # Check both axes\\n        for i in range(1, m//2+1):\\n            ans = min(ans, self.tilingRectangle(n, i) + self.tilingRectangle(n, m-i))\\n        for i in range(1, n//2+1):\\n            ans = min(ans, self.tilingRectangle(i, m) + self.tilingRectangle(n-i, m))\\n\\n        self.memo[(n, m)] = ans        \\n        return ans     \\n```",
                "solutionTags": [],
                "code": "```\\n# Inspired by: https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414190/C%2B%2B-%3A-Top-Down-DP-%2B-Cheat\\n\\nclass Solution:\\n    \\n    memo = {}\\n    \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        # Backtracking with memo (DP)\\n        # Note 2 things from the description:\\n        # 1. Range is bounded (<= 13)\\n        # 2. As the example shows, (11, 13) and (13, 11) is the only special case\\n        # all other cases can be solved by backtracking on subrectangles (divided along either long or short axis)\\n        \\n        # Total of 4 base cases\\n        # base-1: square\\n        if n == m: return 1                \\n        \\n        # Always keep n < m to reduce space complexity of memoization\\n        if n > m: n, m = m, n\\n        \\n        # base-2: narrowest rectangle possible.\\n        if n == 1: return m\\n        \\n        # base-3: 11, 13 or 13, 11\\n        if (n, m) == (11, 13): return 6\\n\\n        # base-4: in memo\\n        if (n, m) in self.memo: return self.memo[(n, m)]\\n        \\n        ans = math.inf        \\n        # Check both axes\\n        for i in range(1, m//2+1):\\n            ans = min(ans, self.tilingRectangle(n, i) + self.tilingRectangle(n, m-i))\\n        for i in range(1, n//2+1):\\n            ans = min(ans, self.tilingRectangle(i, m) + self.tilingRectangle(n-i, m))\\n\\n        self.memo[(n, m)] = ans        \\n        return ans     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 699447,
                "title": "python-backtrack-solution",
                "content": "```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if n > m:\\n            return self.tilingRectangle(m, n)\\n        \\n        self.res = n*m\\n        height = [0]*n\\n        self.dfs(height, n, m, 0)\\n        return self.res\\n    \\n    \\n    def dfs(self, height, n, m, cnt):\\n        if cnt >= self.res:\\n            return \\n        \\n        min_height = m+1\\n        start = None\\n        \\n        for i, h in enumerate(height):\\n            if h < min_height:\\n                min_height = h\\n                start = i\\n        \\n        if min_height == m:\\n            self.res = cnt\\n            return\\n        \\n        end = start\\n        while end < n and height[end] == height[start] and height[end]+end-start+1 <= m:\\n            end += 1\\n        end -= 1\\n        \\n        for i in range(end, start-1, -1):\\n            size = i-start+1\\n            for j in range(start, i+1):\\n                height[j] += size\\n            self.dfs(height, n, m, cnt+1)\\n            for j in range(start, i+1):\\n                height[j] -= size\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if n > m:\\n            return self.tilingRectangle(m, n)\\n        \\n        self.res = n*m\\n        height = [0]*n\\n        self.dfs(height, n, m, 0)\\n        return self.res\\n    \\n    \\n    def dfs(self, height, n, m, cnt):\\n        if cnt >= self.res:\\n            return \\n        \\n        min_height = m+1\\n        start = None\\n        \\n        for i, h in enumerate(height):\\n            if h < min_height:\\n                min_height = h\\n                start = i\\n        \\n        if min_height == m:\\n            self.res = cnt\\n            return\\n        \\n        end = start\\n        while end < n and height[end] == height[start] and height[end]+end-start+1 <= m:\\n            end += 1\\n        end -= 1\\n        \\n        for i in range(end, start-1, -1):\\n            size = i-start+1\\n            for j in range(start, i+1):\\n                height[j] += size\\n            self.dfs(height, n, m, cnt+1)\\n            for j in range(start, i+1):\\n                height[j] -= size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697378,
                "title": "what-is-the-complexity-of-the-dfs-backtracking-memoized-solution",
                "content": "I have seen multiple solutions here, including this one:\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    int m,n;\\n    public int tilingRectangle(int n, int m) {\\n        this.m = m;\\n        this.n = n;\\n        dfs(0, 0, new boolean[n][m], 0);\\n        return ans;\\n    }\\n    // (r, c) is the starting point for selecting a square\\n    // rect records the status of current rectangle\\n    // cnt is the number of squares we have covered\\n    private void dfs(int r, int c, boolean[][] rect, int cnt) {\\n        if (cnt >= ans) return;\\n        if (r >= n) {\\n            ans = cnt; \\n            return;\\n        }\\n        if (c >= m) {\\n            dfs(r+1, 0, rect, cnt); \\n            return;\\n        }\\n        if (rect[r][c]) {\\n            dfs(r, c+1, rect, cnt);\\n            return;\\n        }\\n        // Try all the possible size of squares starting from (r, c)\\n        for (int k = Math.min(n-r, m-c); k >= 1 && isAvailable(rect, r, c, k); k--) {\\n            coverOrUncover(rect, r, c, k, true);\\n            dfs(r, c+1, rect, cnt+1);\\n            coverOrUncover(rect, r, c, k, false);\\n        }\\n    }\\n    // Check if the area [r, ..., r+k][c, ..., c+k] is alreadc covered\\n    private boolean isAvailable(boolean[][] rect, int r, int c, int k) {\\n        for (int i = r; i < r+k; i++){\\n            for (int j = c; j < c+k; j++){\\n                if (rect[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private void coverOrUncover(boolean[][] rect, int r, int c, int k, boolean cover) {\\n        for (int i = r; i < r+k; i++){\\n            for (int j = c; j < c+k; j++){\\n                rect[i][j] = cover;\\n            }\\n        }\\n    }\\n}\\n```\\nNone of the solutions mention the complexity. My question is - how to find out the complexity of such recursive backtracking problems? TIA.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    int m,n;\\n    public int tilingRectangle(int n, int m) {\\n        this.m = m;\\n        this.n = n;\\n        dfs(0, 0, new boolean[n][m], 0);\\n        return ans;\\n    }\\n    // (r, c) is the starting point for selecting a square\\n    // rect records the status of current rectangle\\n    // cnt is the number of squares we have covered\\n    private void dfs(int r, int c, boolean[][] rect, int cnt) {\\n        if (cnt >= ans) return;\\n        if (r >= n) {\\n            ans = cnt; \\n            return;\\n        }\\n        if (c >= m) {\\n            dfs(r+1, 0, rect, cnt); \\n            return;\\n        }\\n        if (rect[r][c]) {\\n            dfs(r, c+1, rect, cnt);\\n            return;\\n        }\\n        // Try all the possible size of squares starting from (r, c)\\n        for (int k = Math.min(n-r, m-c); k >= 1 && isAvailable(rect, r, c, k); k--) {\\n            coverOrUncover(rect, r, c, k, true);\\n            dfs(r, c+1, rect, cnt+1);\\n            coverOrUncover(rect, r, c, k, false);\\n        }\\n    }\\n    // Check if the area [r, ..., r+k][c, ..., c+k] is alreadc covered\\n    private boolean isAvailable(boolean[][] rect, int r, int c, int k) {\\n        for (int i = r; i < r+k; i++){\\n            for (int j = c; j < c+k; j++){\\n                if (rect[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private void coverOrUncover(boolean[][] rect, int r, int c, int k, boolean cover) {\\n        for (int i = r; i < r+k; i++){\\n            for (int j = c; j < c+k; j++){\\n                rect[i][j] = cover;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638648,
                "title": "0ms-java-solution-recursion-supported-by-dp",
                "content": "Based of faith calls of recursion and self work. WOW !\\n```\\nclass Solution {\\n    \\n    public int tilingRectangle(int n, int m) {\\n        int[][] dp = new int[n + 1][m + 1];\\n        return tilingRectangle(n, m, dp);\\n    }\\n    \\n    public int tilingRectangle(int n, int m, int[][] dp) {\\n        \\n        if(n == 0 || m == 0) return 0;\\n        if(n == 1 || m == 1) return n == 1 ? m : n;\\n        if(n == m) return 1;\\n        if((n == 11 && m == 13) || (n == 13 && m == 11)) return 6;\\n        \\n        if (dp[n][m] != 0)\\n        return dp[n][m];\\n        \\n        int minAns = n*m;\\n        int imin = Math.min(n,m);\\n        \\n        for(int i = imin; i >= 1; i--){\\n            int a = tilingRectangle(n - i, i, dp);\\n            int b = tilingRectangle(n, m - i, dp);\\n\\n            int c = tilingRectangle(n - i, m, dp);\\n            int d = tilingRectangle(i, m - i, dp);\\n\\n            int case1 = a + b;\\n            int case2 = c + d;\\n            \\n            minAns = Math.min(minAns, Math.min(case1, case2));\\n        }\\n        \\n        if(minAns != n*m)\\n            minAns ++;\\n        \\n        dp[n][m] = minAns;\\n        return minAns;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int tilingRectangle(int n, int m) {\\n        int[][] dp = new int[n + 1][m + 1];\\n        return tilingRectangle(n, m, dp);\\n    }\\n    \\n    public int tilingRectangle(int n, int m, int[][] dp) {\\n        \\n        if(n == 0 || m == 0) return 0;\\n        if(n == 1 || m == 1) return n == 1 ? m : n;\\n        if(n == m) return 1;\\n        if((n == 11 && m == 13) || (n == 13 && m == 11)) return 6;\\n        \\n        if (dp[n][m] != 0)\\n        return dp[n][m];\\n        \\n        int minAns = n*m;\\n        int imin = Math.min(n,m);\\n        \\n        for(int i = imin; i >= 1; i--){\\n            int a = tilingRectangle(n - i, i, dp);\\n            int b = tilingRectangle(n, m - i, dp);\\n\\n            int c = tilingRectangle(n - i, m, dp);\\n            int d = tilingRectangle(i, m - i, dp);\\n\\n            int case1 = a + b;\\n            int case2 = c + d;\\n            \\n            minAns = Math.min(minAns, Math.min(case1, case2));\\n        }\\n        \\n        if(minAns != n*m)\\n            minAns ++;\\n        \\n        dp[n][m] = minAns;\\n        return minAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630149,
                "title": "bfs-python",
                "content": "BFS to find the minimum number\\nlogic: \\nsplit the rectangle into [n] * m histograms; \\neach time find the valid squares (from max to 1) and fill the histograms\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if not m and not n:\\n            return 0\\n        heights = [n] * m\\n        count, leftmost = 0, 0\\n        q = deque([(count, heights, leftmost)])\\n        while q:\\n            count, heights, leftmost = q.popleft()\\n            if leftmost == m:\\n                return count\\n            w = m - leftmost\\n            h = heights[leftmost]\\n            bound = min(w, h)\\n            for x in range(bound, 0, -1):\\n                new_heights, new_leftmost = heights[:], leftmost\\n                for i in range(leftmost, leftmost + x):\\n                    new_heights[i] -= x\\n                    if new_heights[i] == 0:\\n                        new_leftmost += 1\\n                q.append((count + 1, new_heights, new_leftmost))\\n        return -1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if not m and not n:\\n            return 0\\n        heights = [n] * m\\n        count, leftmost = 0, 0\\n        q = deque([(count, heights, leftmost)])\\n        while q:\\n            count, heights, leftmost = q.popleft()\\n            if leftmost == m:\\n                return count\\n            w = m - leftmost\\n            h = heights[leftmost]\\n            bound = min(w, h)\\n            for x in range(bound, 0, -1):\\n                new_heights, new_leftmost = heights[:], leftmost\\n                for i in range(leftmost, leftmost + x):\\n                    new_heights[i] -= x\\n                    if new_heights[i] == 0:\\n                        new_leftmost += 1\\n                q.append((count + 1, new_heights, new_leftmost))\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 566821,
                "title": "1240-tiling-a-rectangle-with-the-fewest-squares-74-faster-java-dp",
                "content": "...\\nclass Solution {\\n    \\n    int find(int ht,int wt,int[][] qb)\\n    {\\n        if(ht==0 || wt==0)\\n        {\\n            return 0;\\n        }\\n        if(qb[ht][wt]!=0)\\n        {\\n            return qb[ht][wt];\\n        }\\n        int omin=Integer.MAX_VALUE;\\n        for(int x=1;x<=Math.min(ht,wt);x++)\\n        {\\n            int r1hh=x;\\n            int r1hw=wt-x;\\n            int r2hh=ht-x;\\n            int r2hw=wt;\\n            \\n            int r1vh=ht-x;\\n            int r1vw=x;\\n            int r2vh=ht;\\n            int r2vw=wt-x;\\n            int f1=find(r1hh,r1hw,qb)+find(r2hh,r2hw,qb);\\n            int f2=find(r1vh,r1vw,qb)+find(r2vh,r2vw,qb);\\n            int f=Math.min(f1,f2);\\n            omin=Math.min(omin,f);                \\n            \\n        }\\n        omin++;\\n        qb[ht][wt]=omin;\\n        return omin;\\n    }\\n    public int tilingRectangle(int n, int m) {\\n         if ((n == 11 && m == 13) || (m == 11 && n == 13)) return 6;\\n        int[][] qb=new int[n+1][m+1];\\n        return find(n,m,qb);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int find(int ht,int wt,int[][] qb)\\n    {\\n        if(ht==0 || wt==0)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 516122,
                "title": "c-dfs-solution",
                "content": "```\\n    int tilingRectangle(int n, int m) {\\n        if(n > m) return tilingRectangle(m, n);\\n        int res = INT_MAX;\\n        vector<int> h(n, 0);\\n        \\n        function<void(int)> dfs = [&](int count) {\\n            if(count >= res) return;\\n            auto it = min_element(h.begin(), h.end());\\n            if(*it == m) {\\n                res = count;\\n                return;\\n            }\\n            \\n            int idx = distance(h.begin(), it), end = idx;\\n            while(end + 1 < n && h[end+1] == h[idx] && end - idx + 2 + h[idx] <= m) end++;\\n            for(int w = end - idx + 1; w >= 1; w--) {\\n                for(int i = idx; i < idx + w; i++) h[i] += w;\\n                dfs(count + 1);\\n                for(int i = idx; i < idx + w; i++) h[i] -= w;\\n            }\\n        };\\n        \\n        dfs(0);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int tilingRectangle(int n, int m) {\\n        if(n > m) return tilingRectangle(m, n);\\n        int res = INT_MAX;\\n        vector<int> h(n, 0);\\n        \\n        function<void(int)> dfs = [&](int count) {\\n            if(count >= res) return;\\n            auto it = min_element(h.begin(), h.end());\\n            if(*it == m) {\\n                res = count;\\n                return;\\n            }\\n            \\n            int idx = distance(h.begin(), it), end = idx;\\n            while(end + 1 < n && h[end+1] == h[idx] && end - idx + 2 + h[idx] <= m) end++;\\n            for(int w = end - idx + 1; w >= 1; w--) {\\n                for(int i = idx; i < idx + w; i++) h[i] += w;\\n                dfs(count + 1);\\n                for(int i = idx; i < idx + w; i++) h[i] -= w;\\n            }\\n        };\\n        \\n        dfs(0);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 504684,
                "title": "c-use-lower-bound-of-needed-squares-as-heuristic-dfs-no-cheat",
                "content": "rewrite in c++ for solution: https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/415423/No-magic-a-dfs-solution-with-heuristic\\ncheck original post for more details.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    std::vector<int> get_lbcnt(int max_area) // find lower bound of used square number for given areas\\n    {\\n        std::vector<int> dp(max_area + 1, INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int area = 1; area <= max_area; ++area){\\n            const int sqrt_area = (int)(std::sqrt(area));\\n            for(int k = 1; k <= sqrt_area; ++k){\\n                dp[area] = std::min<int>(dp[area], 1 + dp[area - k * k]);\\n            }\\n        }\\n        return dp;\\n    }\\n    \\n    int tilingRectangle(int n, int m)\\n    {\\n        int best = INT_MAX;\\n        const auto lbcnt = get_lbcnt(m * n);\\n\\n        std::vector<int> skyline(m, 0);\\n        dfs(skyline, lbcnt, best, m * n, 0, n);\\n        return best;\\n    }\\n\\n    void dfs(std::vector<int> &skyline, const vector<int> lbcnt, int &best, int area_left, int used_count, int max_height)\\n    {\\n        if(used_count + lbcnt[area_left] >= best){\\n            return;\\n        }\\n        \\n        if(area_left == 0){\\n            best = std::min<int>(best, used_count);\\n            return;\\n        }\\n\\n        int lowest_start = 0;\\n        int lowest_width = 0;\\n\\n        for(int x = 0; x < skyline.size(); ++x){\\n            if(skyline[x] < skyline[lowest_start]){\\n                lowest_start = x;\\n            }\\n        }\\n\\n        for(int index = lowest_start; index < skyline.size(); ++index){\\n            if(skyline[index] == skyline[lowest_start]){\\n                lowest_width++;\\n            }else{\\n                break;\\n            }\\n        }\\n\\n        for(int width = lowest_width; width > 0; --width){\\n            if(skyline[lowest_start] + width <= max_height){\\n                for(int i = 0; i < width; ++i){\\n                    skyline[lowest_start + i] += width;\\n                }\\n                dfs(skyline, lbcnt, best, area_left - width * width, used_count + 1, max_height);\\n                for(int i = 0; i < width; ++i){\\n                    skyline[lowest_start + i] -= width;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    std::vector<int> get_lbcnt(int max_area) // find lower bound of used square number for given areas\\n    {\\n        std::vector<int> dp(max_area + 1, INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int area = 1; area <= max_area; ++area){\\n            const int sqrt_area = (int)(std::sqrt(area));\\n            for(int k = 1; k <= sqrt_area; ++k){\\n                dp[area] = std::min<int>(dp[area], 1 + dp[area - k * k]);\\n            }\\n        }\\n        return dp;\\n    }\\n    \\n    int tilingRectangle(int n, int m)\\n    {\\n        int best = INT_MAX;\\n        const auto lbcnt = get_lbcnt(m * n);\\n\\n        std::vector<int> skyline(m, 0);\\n        dfs(skyline, lbcnt, best, m * n, 0, n);\\n        return best;\\n    }\\n\\n    void dfs(std::vector<int> &skyline, const vector<int> lbcnt, int &best, int area_left, int used_count, int max_height)\\n    {\\n        if(used_count + lbcnt[area_left] >= best){\\n            return;\\n        }\\n        \\n        if(area_left == 0){\\n            best = std::min<int>(best, used_count);\\n            return;\\n        }\\n\\n        int lowest_start = 0;\\n        int lowest_width = 0;\\n\\n        for(int x = 0; x < skyline.size(); ++x){\\n            if(skyline[x] < skyline[lowest_start]){\\n                lowest_start = x;\\n            }\\n        }\\n\\n        for(int index = lowest_start; index < skyline.size(); ++index){\\n            if(skyline[index] == skyline[lowest_start]){\\n                lowest_width++;\\n            }else{\\n                break;\\n            }\\n        }\\n\\n        for(int width = lowest_width; width > 0; --width){\\n            if(skyline[lowest_start] + width <= max_height){\\n                for(int i = 0; i < width; ++i){\\n                    skyline[lowest_start + i] += width;\\n                }\\n                dfs(skyline, lbcnt, best, area_left - width * width, used_count + 1, max_height);\\n                for(int i = 0; i < width; ++i){\\n                    skyline[lowest_start + i] -= width;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491029,
                "title": "100-scala-runtime-and-space-just-dfs-backtracking",
                "content": "Alwayws find the leftmost bottom corner that has not yet covered, then find the largest square it can cover. \\n\\nCredit: https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/417654/6ms-clean-Java-backtrack-solution-with-detailed-explanation\\n\\n```Scala\\n  def tilingRectangle(n: Int, m: Int): Int = {\\n    if (n == m) return 1\\n    if (n > m) return tilingRectangle(m, n)\\n    if (n == 1) return m\\n\\n    import scala.collection.mutable.Set\\n    import scala.util.control.Breaks._\\n    val isVisited = Set[String]()\\n    var globalMin = m * n\\n\\n    def g(bottom: Int, left: Int): Int = {\\n      var len = 1\\n      while (bottom + len < m && left + len < n) {\\n        var flag = true\\n        breakable {\\n          for (i <- 0 to len) {\\n\\t\\t  // always check the most right and top layer, as we can safely and always ensure that all inner points are not covered by previous check iteration \\n            if (isVisited.contains((bottom + i) + \"*\" + (left + len)) || isVisited.contains((bottom + len) + \"*\" + (left + i))) {\\n              flag = false\\n              break\\n            }\\n          }\\n        }\\n        if (!flag) return len\\n        len += 1\\n      }\\n      len\\n    }\\n\\n    def fill(bottom: Int, left: Int, len: Int, isAdd: Boolean): Any = {\\n      for (i <- bottom until bottom + len; j <- left until left + len) {\\n        val key = i + \"*\" + j\\n        if (isAdd)\\n          isVisited add key\\n        else\\n          isVisited remove key\\n\\n      }\\n    }\\n\\n\\n    def f(count: Int): Any = {\\n      if (count >= globalMin) return\\n\\n      var left, bottom = Integer.MAX_VALUE\\n      breakable {\\n        for (i <- 0 until m; j <- 0 until n if (!isVisited.contains(i + \"*\" + j))) {\\n          bottom = i\\n          left = j\\n          break\\n        }\\n      }\\n      if ((left == Integer.MAX_VALUE && bottom == Integer.MAX_VALUE)) {\\n        globalMin = Math.min(globalMin, count)\\n        return\\n      }\\n\\n      var maxLen = g(bottom, left)\\n      while (maxLen > 0) {\\n        fill(bottom, left, maxLen, true)\\n        f(count + 1)\\n        fill(bottom, left, maxLen, false)\\n        maxLen -= 1\\n      }\\n    }\\n\\n    f(0)\\n    globalMin\\n\\n  }\\n\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  def tilingRectangle(n: Int, m: Int): Int = {\\n    if (n == m) return 1\\n    if (n > m) return tilingRectangle(m, n)\\n    if (n == 1) return m\\n\\n    import scala.collection.mutable.Set\\n    import scala.util.control.Breaks._\\n    val isVisited = Set[String]()\\n    var globalMin = m * n\\n\\n    def g(bottom: Int, left: Int): Int = {\\n      var len = 1\\n      while (bottom + len < m && left + len < n) {\\n        var flag = true\\n        breakable {\\n          for (i <- 0 to len) {\\n\\t\\t  // always check the most right and top layer, as we can safely and always ensure that all inner points are not covered by previous check iteration \\n            if (isVisited.contains((bottom + i) + \"*\" + (left + len)) || isVisited.contains((bottom + len) + \"*\" + (left + i))) {\\n              flag = false\\n              break\\n            }\\n          }\\n        }\\n        if (!flag) return len\\n        len += 1\\n      }\\n      len\\n    }\\n\\n    def fill(bottom: Int, left: Int, len: Int, isAdd: Boolean): Any = {\\n      for (i <- bottom until bottom + len; j <- left until left + len) {\\n        val key = i + \"*\" + j\\n        if (isAdd)\\n          isVisited add key\\n        else\\n          isVisited remove key\\n\\n      }\\n    }\\n\\n\\n    def f(count: Int): Any = {\\n      if (count >= globalMin) return\\n\\n      var left, bottom = Integer.MAX_VALUE\\n      breakable {\\n        for (i <- 0 until m; j <- 0 until n if (!isVisited.contains(i + \"*\" + j))) {\\n          bottom = i\\n          left = j\\n          break\\n        }\\n      }\\n      if ((left == Integer.MAX_VALUE && bottom == Integer.MAX_VALUE)) {\\n        globalMin = Math.min(globalMin, count)\\n        return\\n      }\\n\\n      var maxLen = g(bottom, left)\\n      while (maxLen > 0) {\\n        fill(bottom, left, maxLen, true)\\n        f(count + 1)\\n        fill(bottom, left, maxLen, false)\\n        maxLen -= 1\\n      }\\n    }\\n\\n    f(0)\\n    globalMin\\n\\n  }\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 478588,
                "title": "python-why-this-bfs-solution-is-slow",
                "content": "This question is a \"shortest path\" problem, BFS in general should win. My solution is like this, it works but the performance  800ms is just way worst thant those 250ms ones. I guess it\\'s due to list copy cost, maybe someone can answer my question\\n```\\nfrom collections import deque\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        dp = [n for _ in range(m)]\\n        q = deque()\\n        q.append([dp[:], 0])\\n        while q:\\n            dp, nstep= q.popleft()\\n            if self.isfilled(dp):\\n                return nstep\\n            i = self.find_left_bottom(dp)\\n            for s in range(1, min(m,n)+1):\\n                new_dp = self.fill(dp, i, s)\\n                if not new_dp:\\n                    break\\n                q.append([new_dp, nstep+1])\\n\\n    def find_left_bottom(self, dp):\\n        h = 0\\n        index = -1\\n        for i in range(len(dp)):\\n            if dp[i] > h:\\n                index = i\\n                h = dp[i]\\n        return index\\n            \\n    def canfill(self, dp, i, s):\\n        if len(dp) - i < s:\\n            return False\\n        for j in range(i, i+s):\\n            if dp[j] < s:\\n                return False\\n        return True\\n\\n    def fill(self, dp, i, s):\\n        if len(dp) - i < s:\\n            return\\n        dp_copy = dp[:]\\n        for j in range(i, i+s):\\n            if dp_copy[j] < s:\\n                return False\\n            dp_copy[j] -= s\\n        return dp_copy\\n    \\n    def isfilled(self, dp):\\n        return sum(dp) == 0\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        dp = [n for _ in range(m)]\\n        q = deque()\\n        q.append([dp[:], 0])\\n        while q:\\n            dp, nstep= q.popleft()\\n            if self.isfilled(dp):\\n                return nstep\\n            i = self.find_left_bottom(dp)\\n            for s in range(1, min(m,n)+1):\\n                new_dp = self.fill(dp, i, s)\\n                if not new_dp:\\n                    break\\n                q.append([new_dp, nstep+1])\\n\\n    def find_left_bottom(self, dp):\\n        h = 0\\n        index = -1\\n        for i in range(len(dp)):\\n            if dp[i] > h:\\n                index = i\\n                h = dp[i]\\n        return index\\n            \\n    def canfill(self, dp, i, s):\\n        if len(dp) - i < s:\\n            return False\\n        for j in range(i, i+s):\\n            if dp[j] < s:\\n                return False\\n        return True\\n\\n    def fill(self, dp, i, s):\\n        if len(dp) - i < s:\\n            return\\n        dp_copy = dp[:]\\n        for j in range(i, i+s):\\n            if dp_copy[j] < s:\\n                return False\\n            dp_copy[j] -= s\\n        return dp_copy\\n    \\n    def isfilled(self, dp):\\n        return sum(dp) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472668,
                "title": "innovative-backtracking-solution-without-cheat-or-special-case-based-on-area",
                "content": "The idea is that if rectangle is covered completely with square tiles, the sum of area of square tiles = area of rectangle. This is only necessary condition for tiling. The sufficient condition is that no overlap should be there between any of the squares. In that case, the rectangle will be exactly tiled. A greedy optimal value is also found to prune the DFS. We will start tiling at the (0,0) and keep moving right till we hit the end, then go to next level and repeat same process from left, till we reach the top level. At each point, we try for all possible sides of a square we can place there, recur and backtrack. This doesn\\'t require any cheat and doesn\\'t fail for any special cases. Here is the code :=>\\n\\n```\\nclass Solution {\\n\\n    private static int m, n;\\n\\n    // ONE SINGLE SQUARE THAT WE WILL PLACE\\n    static class Box {\\n        private int xmin; // LOWER LEFT POINT.X\\n        private int xmax; // LOWER LEFT POINT.Y\\n        private int ymin; // UPPER RIGHT POINT.X\\n        private int ymax; // UPPER RIGHT POINT.Y\\n\\n        Box(int xmin, int xmax, int ymin, int ymax) {\\n            this.xmin = xmin;\\n            this.xmax = xmax;\\n            this.ymin = ymin;\\n            this.ymax = ymax;\\n        }\\n\\n        // CHECK IF TWO BOXES OVERLAP\\n        private boolean overlap(Box box) {\\n            return inside(box.xmin, box.ymin) || inside(box.xmin, box.ymax) || inside(box.xmax, box.ymin)\\n                    || inside(box.xmax, box.ymax)\\n                    || (box.xmax == this.xmax && box.xmin == this.xmin\\n                            && ((box.ymin > this.ymin && box.ymin < this.ymax)\\n                                    || (this.ymin > box.ymin && this.ymin < box.ymax)))\\n                    || (box.ymax == this.ymax && box.ymin == this.ymin\\n                            && ((box.xmin > this.xmin && box.xmin < this.xmax)\\n                                    || (this.xmin > box.xmin && this.xmin < box.xmax)));\\n        }\\n\\n        // CHECK IF ONE VERTEX OF ONE BOX STRICTLY LIE INSIDE ANOTHER\\n        private boolean inside(int x, int y) {\\n            return x > xmin && x < xmax && y > ymin && y < ymax;\\n        }\\n    }\\n\\n    // CHECK IF BOX b OVERLAPS IN ANY OF THE BOXES\\n    private boolean overlap(List<Box> boxes, Box b) {\\n        for (Box box : boxes) {\\n            if (b.overlap(box) || box.overlap(b)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private int maxSize = Integer.MAX_VALUE;\\n\\n    // BOXES = BOXES PLACED IN GRID SO FAR\\n    // AREA = AREA OF THE GRID COVERED SO FAR\\n    // I, J = CURRENT COORDINATE WHERE WE WILL PLACE BOX (LOWER-LEFT VERTEX)\\n    private int solve(List<Box> boxes, int area, int i, int j) {\\n\\n        // NO OVERLAP + AREA EQUAL = SOLVED !\\n        if (area == m * n) {\\n            maxSize = Math.min(maxSize, boxes.size());\\n            return 0;\\n        }\\n\\n        // CANNOT EXCEED LIMIT FROM GREEDY\\n        if (j == n || boxes.size() > maxSize) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        boolean found = false;\\n\\n        // TRY SQUARES WITH ALL POSSIBLE SIDES. PLEASE NOTE THAT WE HAVE TAKEN\\n        // SIDE = Math.min(m - i, n - j) WHICH IS MAX POSSIBLE SIDE FROM CURRENT\\n        // (i, j) (WHICH IS LOWER LEFT VERTEX OF SQUARE)\\n        for (int side = Math.min(m - i, n - j); side >= 1; side--) {\\n\\n            // HERE WE ARE ITERATING IN REVERSE FASHION TO IMPROVE PRUNING PERFORMANCE\\n            Box box = new Box(i, i + side, j, j + side); // NEW BOX\\n\\n            if (!overlap(boxes, box)) { // CHECK OVERLAP WITH EXISTING BOXES\\n\\n                found = true;\\n                boxes.add(box); // ADD TO EXISTING BOXES\\n\\n                int x1;\\n                if (i + side == m) {\\n                    // ADD AREA OF THE LAST BOX IN CURRENT LEVEL, MOVE TO NEXT LEVEL\\n                    x1 = solve(boxes, area + side * side, 0, j + 1);\\n                } else {\\n                    // ADD AREA OF THIS BOX AND MOVE AHEAD IN CURRENT LEVEL ITSELF\\n                    x1 = solve(boxes, area + side * side, i + side, j);\\n                }\\n\\n                boxes.remove(boxes.size() - 1); // BACKTRACK\\n                x1 = x1 == Integer.MAX_VALUE ? x1 : 1 + x1;\\n                ans = Math.min(ans, x1); // UPDATE ANS\\n            }\\n        }\\n\\n        if (!found) {\\n            // THIS MEANS EVERY BOX FROM CURRENT (i, j) WAS OVERLAPPING WITH SOME OTHER BOX\\n            if (i + 1 == m) {\\n                ans = solve(boxes, area, 0, j + 1); // MOVE TO NEXT LEVEL\\n            } else {\\n                ans = solve(boxes, area, i + 1, j); // MOVE AHEAD IN CURRENT LEVEL ITSELF\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int greedy(int n, int m) {\\n        int x = Math.max(m, n);\\n        int y = Math.min(m, n);\\n        int c = 0;\\n        while (x != 0) {\\n            // KEEP FITTING THE LARGEST POSSIBLE BOX IN A GREEDY FASHION\\n            if (x >= y) {\\n                x -= y;\\n            } else {\\n                y -= x;\\n            }\\n            c++;\\n        }\\n        return c;\\n    }\\n\\n    public int tilingRectangle(int n, int m) {\\n        Solution.m = m;\\n        Solution.n = n;\\n        maxSize = greedy(n, m); // FIND MAX NO OF BOXES VIA GREEDY FOR PRUNING\\n        int ans = solve(new ArrayList<>(), 0, 0, 0);\\n        return ans == Integer.MAX_VALUE ? 0 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private static int m, n;\\n\\n    // ONE SINGLE SQUARE THAT WE WILL PLACE\\n    static class Box {\\n        private int xmin; // LOWER LEFT POINT.X\\n        private int xmax; // LOWER LEFT POINT.Y\\n        private int ymin; // UPPER RIGHT POINT.X\\n        private int ymax; // UPPER RIGHT POINT.Y\\n\\n        Box(int xmin, int xmax, int ymin, int ymax) {\\n            this.xmin = xmin;\\n            this.xmax = xmax;\\n            this.ymin = ymin;\\n            this.ymax = ymax;\\n        }\\n\\n        // CHECK IF TWO BOXES OVERLAP\\n        private boolean overlap(Box box) {\\n            return inside(box.xmin, box.ymin) || inside(box.xmin, box.ymax) || inside(box.xmax, box.ymin)\\n                    || inside(box.xmax, box.ymax)\\n                    || (box.xmax == this.xmax && box.xmin == this.xmin\\n                            && ((box.ymin > this.ymin && box.ymin < this.ymax)\\n                                    || (this.ymin > box.ymin && this.ymin < box.ymax)))\\n                    || (box.ymax == this.ymax && box.ymin == this.ymin\\n                            && ((box.xmin > this.xmin && box.xmin < this.xmax)\\n                                    || (this.xmin > box.xmin && this.xmin < box.xmax)));\\n        }\\n\\n        // CHECK IF ONE VERTEX OF ONE BOX STRICTLY LIE INSIDE ANOTHER\\n        private boolean inside(int x, int y) {\\n            return x > xmin && x < xmax && y > ymin && y < ymax;\\n        }\\n    }\\n\\n    // CHECK IF BOX b OVERLAPS IN ANY OF THE BOXES\\n    private boolean overlap(List<Box> boxes, Box b) {\\n        for (Box box : boxes) {\\n            if (b.overlap(box) || box.overlap(b)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private int maxSize = Integer.MAX_VALUE;\\n\\n    // BOXES = BOXES PLACED IN GRID SO FAR\\n    // AREA = AREA OF THE GRID COVERED SO FAR\\n    // I, J = CURRENT COORDINATE WHERE WE WILL PLACE BOX (LOWER-LEFT VERTEX)\\n    private int solve(List<Box> boxes, int area, int i, int j) {\\n\\n        // NO OVERLAP + AREA EQUAL = SOLVED !\\n        if (area == m * n) {\\n            maxSize = Math.min(maxSize, boxes.size());\\n            return 0;\\n        }\\n\\n        // CANNOT EXCEED LIMIT FROM GREEDY\\n        if (j == n || boxes.size() > maxSize) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        boolean found = false;\\n\\n        // TRY SQUARES WITH ALL POSSIBLE SIDES. PLEASE NOTE THAT WE HAVE TAKEN\\n        // SIDE = Math.min(m - i, n - j) WHICH IS MAX POSSIBLE SIDE FROM CURRENT\\n        // (i, j) (WHICH IS LOWER LEFT VERTEX OF SQUARE)\\n        for (int side = Math.min(m - i, n - j); side >= 1; side--) {\\n\\n            // HERE WE ARE ITERATING IN REVERSE FASHION TO IMPROVE PRUNING PERFORMANCE\\n            Box box = new Box(i, i + side, j, j + side); // NEW BOX\\n\\n            if (!overlap(boxes, box)) { // CHECK OVERLAP WITH EXISTING BOXES\\n\\n                found = true;\\n                boxes.add(box); // ADD TO EXISTING BOXES\\n\\n                int x1;\\n                if (i + side == m) {\\n                    // ADD AREA OF THE LAST BOX IN CURRENT LEVEL, MOVE TO NEXT LEVEL\\n                    x1 = solve(boxes, area + side * side, 0, j + 1);\\n                } else {\\n                    // ADD AREA OF THIS BOX AND MOVE AHEAD IN CURRENT LEVEL ITSELF\\n                    x1 = solve(boxes, area + side * side, i + side, j);\\n                }\\n\\n                boxes.remove(boxes.size() - 1); // BACKTRACK\\n                x1 = x1 == Integer.MAX_VALUE ? x1 : 1 + x1;\\n                ans = Math.min(ans, x1); // UPDATE ANS\\n            }\\n        }\\n\\n        if (!found) {\\n            // THIS MEANS EVERY BOX FROM CURRENT (i, j) WAS OVERLAPPING WITH SOME OTHER BOX\\n            if (i + 1 == m) {\\n                ans = solve(boxes, area, 0, j + 1); // MOVE TO NEXT LEVEL\\n            } else {\\n                ans = solve(boxes, area, i + 1, j); // MOVE AHEAD IN CURRENT LEVEL ITSELF\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int greedy(int n, int m) {\\n        int x = Math.max(m, n);\\n        int y = Math.min(m, n);\\n        int c = 0;\\n        while (x != 0) {\\n            // KEEP FITTING THE LARGEST POSSIBLE BOX IN A GREEDY FASHION\\n            if (x >= y) {\\n                x -= y;\\n            } else {\\n                y -= x;\\n            }\\n            c++;\\n        }\\n        return c;\\n    }\\n\\n    public int tilingRectangle(int n, int m) {\\n        Solution.m = m;\\n        Solution.n = n;\\n        maxSize = greedy(n, m); // FIND MAX NO OF BOXES VIA GREEDY FOR PRUNING\\n        int ans = solve(new ArrayList<>(), 0, 0, 0);\\n        return ans == Integer.MAX_VALUE ? 0 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460708,
                "title": "bfs-javascript-no-hard-coding",
                "content": "This can be further optimized by using a real queue (fast) or dijskra\\'s (faster)\\n```javascript\\nvar tilingRectangle = function(n, m) {\\n  const queue = [[new Array(n).fill(0), 0]];\\n  while (true) {\\n    const [curr, numSquares] = queue.shift();\\n    let min = { height: Infinity, start: Infinity, end: Infinity }\\n    for (let i = 0; i < n; i++) {\\n      if (curr[i] < min.height) {\\n        min.height = curr[i];\\n        min.start = i;\\n        min.end = i + 1;\\n      } else if (curr[i] === min.height && min.end === i) {\\n        min.end++\\n      }\\n    }\\n    if (min.height === m) return numSquares;\\n    const largestSquare = Math.min(m - min.height, min.end - min.start);\\n    for (let sqWidth = largestSquare; sqWidth; sqWidth--) {\\n      const next = curr.slice();\\n      for (let i = min.start; i < min.start + sqWidth; i++) {\\n        next[i] += sqWidth;\\n      }\\n      queue.push([next, numSquares + 1]);\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar tilingRectangle = function(n, m) {\\n  const queue = [[new Array(n).fill(0), 0]];\\n  while (true) {\\n    const [curr, numSquares] = queue.shift();\\n    let min = { height: Infinity, start: Infinity, end: Infinity }\\n    for (let i = 0; i < n; i++) {\\n      if (curr[i] < min.height) {\\n        min.height = curr[i];\\n        min.start = i;\\n        min.end = i + 1;\\n      } else if (curr[i] === min.height && min.end === i) {\\n        min.end++\\n      }\\n    }\\n    if (min.height === m) return numSquares;\\n    const largestSquare = Math.min(m - min.height, min.end - min.start);\\n    for (let sqWidth = largestSquare; sqWidth; sqWidth--) {\\n      const next = curr.slice();\\n      for (let i = min.start; i < min.start + sqWidth; i++) {\\n        next[i] += sqWidth;\\n      }\\n      queue.push([next, numSquares + 1]);\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 457300,
                "title": "it-s-not-bad-c-17-backtrack-solution",
                "content": "```\\ntemplate <class F>\\nstruct recursive {\\n  F f;\\n  template <class... Ts>\\n  decltype(auto) operator()(Ts&&... ts)  const { return f(std::ref(*this), std::forward<Ts>(ts)...); }\\n  \\n  template <class... Ts>\\n  decltype(auto) operator()(Ts&&... ts)  { return f(std::ref(*this), std::forward<Ts>(ts)...); }\\n};\\n\\ntemplate <class F> recursive(F) -> recursive<F>;\\nauto const rec = [](auto f){ return recursive{std::move(f)}; };\\n\\n\\nclass Solution {\\n public:\\n  int tilingRectangle(int n, int m) {\\n\\n    auto test = [&](const vector<vector<bool>> &x, int r1, int r2, int c1, int c2) {\\n      for (int r = r1; r < r2; ++r)\\n        for (int c = c1; c < c2; ++c)\\n          if (x[r][c]) return true;\\n      return false;\\n    };\\n    \\n    auto assign = [](vector<vector<bool>>& x, int r1,int r2, int c1, int c2, bool val) {\\n      for (int r = r1; r < r2; ++r)\\n        for (int c = c1; c < c2; ++c)\\n          x[r][c] = val;\\n    };\\n    \\n    auto backtrack = [&] {\\n      int acc = INT_MAX;\\n      vector<vector<bool>> covered(n, vector<bool>(m, false));\\n      auto fill = rec([&](auto&& fill, int r, int c, int tiles) -> void {\\n        if (r >= n and c == 0)  \\n          acc = std::min(acc, tiles);\\n        else if (r < n and c >= m)\\n          fill(r + 1, 0, tiles);\\n        else if (r < n  and c < m and covered[r][c])\\n          fill(r, c + 1, tiles);\\n        else if (r < n and c < m and not covered[r][c]) {\\n          for (int tile_size = std::min(m - c, n - r); tile_size > 0; tile_size--) {\\n            if (acc > tiles + 1 and not test(covered, r, r + tile_size, c, c + tile_size)) {\\n              assign(covered, r, r + tile_size, c, c + tile_size, true);\\n              fill(r,  c + 1, tiles + 1);\\n              assign(covered, r, r + tile_size, c, c + tile_size, false);\\n            }\\n          }\\n        }\\n        else throw std::domain_error(\"unmatched error\");\\n      });\\n      return (fill(0, 0, 0), acc);\\n    };\\n\\n    return backtrack();\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntemplate <class F>\\nstruct recursive {\\n  F f;\\n  template <class... Ts>\\n  decltype(auto) operator()(Ts&&... ts)  const { return f(std::ref(*this), std::forward<Ts>(ts)...); }\\n  \\n  template <class... Ts>\\n  decltype(auto) operator()(Ts&&... ts)  { return f(std::ref(*this), std::forward<Ts>(ts)...); }\\n};\\n\\ntemplate <class F> recursive(F) -> recursive<F>;\\nauto const rec = [](auto f){ return recursive{std::move(f)}; };\\n\\n\\nclass Solution {\\n public:\\n  int tilingRectangle(int n, int m) {\\n\\n    auto test = [&](const vector<vector<bool>> &x, int r1, int r2, int c1, int c2) {\\n      for (int r = r1; r < r2; ++r)\\n        for (int c = c1; c < c2; ++c)\\n          if (x[r][c]) return true;\\n      return false;\\n    };\\n    \\n    auto assign = [](vector<vector<bool>>& x, int r1,int r2, int c1, int c2, bool val) {\\n      for (int r = r1; r < r2; ++r)\\n        for (int c = c1; c < c2; ++c)\\n          x[r][c] = val;\\n    };\\n    \\n    auto backtrack = [&] {\\n      int acc = INT_MAX;\\n      vector<vector<bool>> covered(n, vector<bool>(m, false));\\n      auto fill = rec([&](auto&& fill, int r, int c, int tiles) -> void {\\n        if (r >= n and c == 0)  \\n          acc = std::min(acc, tiles);\\n        else if (r < n and c >= m)\\n          fill(r + 1, 0, tiles);\\n        else if (r < n  and c < m and covered[r][c])\\n          fill(r, c + 1, tiles);\\n        else if (r < n and c < m and not covered[r][c]) {\\n          for (int tile_size = std::min(m - c, n - r); tile_size > 0; tile_size--) {\\n            if (acc > tiles + 1 and not test(covered, r, r + tile_size, c, c + tile_size)) {\\n              assign(covered, r, r + tile_size, c, c + tile_size, true);\\n              fill(r,  c + 1, tiles + 1);\\n              assign(covered, r, r + tile_size, c, c + tile_size, false);\\n            }\\n          }\\n        }\\n        else throw std::domain_error(\"unmatched error\");\\n      });\\n      return (fill(0, 0, 0), acc);\\n    };\\n\\n    return backtrack();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452059,
                "title": "c-50-time-100-space-dfs",
                "content": "Except that I skip the search branch that is definitively worse than current best solution, and that I try first filling huge squares before considering filling small squares, it\\'s basically exhaustive search.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int n, m, mn = INT_MAX;\\n    vector<int> g;\\n    \\n    void dfs(int c=0) // c: nb of squares already used\\n    {\\n        \\n        if (c>=mn) return; // if c geq than so-far best solution, skip\\n        int mxid = 0;\\n        bool finish = true;\\n        for (int i=0;i<n;i++) // look for the highest not-yet-tiled tile and check if tiling is finished\\n        {\\n            if (g[i]) finish = false;\\n            if (g[i]>g[mxid])\\n            {\\n                mxid = i;\\n            }\\n        }\\n        if (finish) {mn = min(mn, c); return;} // if tiling is finished\\n        int l = 1;\\n        while (mxid+l<g.size() && g[mxid+l]==g[mxid] && l<g[mxid]) \\n            l++; // look for the largest possible length of square\\n        while (l) // search recursively\\n        {\\n            for (int i=0;i<l;i++) g[mxid+i]-=l;\\n            dfs(c+1);\\n            for (int i=0;i<l;i++) g[mxid+i]+=l;\\n            l--;\\n        }\\n    }\\n    \\n    int tilingRectangle(int _n, int _m) {\\n        n = _n; m = _m;\\n        g = vector<int>(n, m);\\n        dfs(); return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n, m, mn = INT_MAX;\\n    vector<int> g;\\n    \\n    void dfs(int c=0) // c: nb of squares already used\\n    {\\n        \\n        if (c>=mn) return; // if c geq than so-far best solution, skip\\n        int mxid = 0;\\n        bool finish = true;\\n        for (int i=0;i<n;i++) // look for the highest not-yet-tiled tile and check if tiling is finished\\n        {\\n            if (g[i]) finish = false;\\n            if (g[i]>g[mxid])\\n            {\\n                mxid = i;\\n            }\\n        }\\n        if (finish) {mn = min(mn, c); return;} // if tiling is finished\\n        int l = 1;\\n        while (mxid+l<g.size() && g[mxid+l]==g[mxid] && l<g[mxid]) \\n            l++; // look for the largest possible length of square\\n        while (l) // search recursively\\n        {\\n            for (int i=0;i<l;i++) g[mxid+i]-=l;\\n            dfs(c+1);\\n            for (int i=0;i<l;i++) g[mxid+i]+=l;\\n            l--;\\n        }\\n    }\\n    \\n    int tilingRectangle(int _n, int _m) {\\n        n = _n; m = _m;\\n        g = vector<int>(n, m);\\n        dfs(); return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427865,
                "title": "only-one-test-case-which-is-n-11-and-m-13-is-not-working",
                "content": "class Solution {\\n    public int tilingRectangle(int n, int m) {\\n        \\n        int dp[][] = new int[14][14];\\n        for(int i = 0 ; i <= m ; i++){\\n            for(int j = 0 ; j <= n; j++)\\n                dp[i][j] = -1 ;\\n        }\\n        return minTiles(m, n, dp) ;\\n    }\\n    \\n    public int minTiles(int x, int y, int dp[][]){\\n        \\n        if(x == 0 || y == 0)\\n          return 0;\\n        \\n        if(x == y)\\n          return 1 ; \\n        \\n        if(dp[x][y] != -1)\\n          return dp[x][y] ; \\n        \\n        int min = x < y ? x : y ;\\n        int ans = Integer.MAX_VALUE ;\\n        \\n        for(int i = 1 ; i <= min ; i++){\\n            int firstRect =  minTiles(x - i, y, dp) ; \\n            int secondRect = minTiles(i, y - i, dp) ;            \\n            int minimum1 = 1 + firstRect + secondRect  ;\\n            \\n            int firstRect2 = minTiles(x, y - i, dp) ;\\n            int secondRect2 = minTiles(x - i, i, dp) ;\\n            int minimum2 = 1 + firstRect2 + secondRect2 ;\\n            \\n            int mi = Math.min(minimum1, minimum2) ;\\n            ans = Math.min(ans, mi) ;\\n        }\\n        return dp[x][y] = dp[y][x] = ans ; \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int tilingRectangle(int n, int m) {\\n        \\n        int dp[][] = new int[14][14];\\n        for(int i = 0 ; i <= m ; i++){\\n            for(int j = 0 ; j <= n; j++)\\n                dp[i][j] = -1 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 420925,
                "title": "why-11-13-rectangle-requires-6-instead-of-8-squares",
                "content": "I solved it using dp, but (11 13) case I am not able understand. Can anyone explain?\\n\\n```\\ndef count(n, m , dp):\\n    if dp[n][m]!= -1:\\n        return dp[n][m]\\n    \\n    dp[n][m] = 0\\n    if n>m:\\n        dp[n][m] = int(n/m)\\n        if n%m != 0:\\n            dp[n][m] += count(n%m, m, dp)\\n    elif m>n:\\n        dp[n][m] = int(m/n)\\n        if m%n != 0:\\n            dp[n][m] += count(n, m%n, dp)\\n    else:\\n        dp[n][m] = 1\\n    print(n, m, dp[n][m])\\n    return dp[n][m]\\n    \\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        dp = [[-1 for j in range(m+1)] for i in range(n+1)]\\n        \\n        dp[1][1] = 1\\n        for i in range(1, n+1):\\n            dp[i][1] = i\\n        \\n        for j in range(1, m+1):\\n            dp[1][j]  = j\\n        \\n        s = count(n, m, dp)\\n        # print(dp)\\n        \\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\ndef count(n, m , dp):\\n    if dp[n][m]!= -1:\\n        return dp[n][m]\\n    \\n    dp[n][m] = 0\\n    if n>m:\\n        dp[n][m] = int(n/m)\\n        if n%m != 0:\\n            dp[n][m] += count(n%m, m, dp)\\n    elif m>n:\\n        dp[n][m] = int(m/n)\\n        if m%n != 0:\\n            dp[n][m] += count(n, m%n, dp)\\n    else:\\n        dp[n][m] = 1\\n    print(n, m, dp[n][m])\\n    return dp[n][m]\\n    \\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        dp = [[-1 for j in range(m+1)] for i in range(n+1)]\\n        \\n        dp[1][1] = 1\\n        for i in range(1, n+1):\\n            dp[i][1] = i\\n        \\n        for j in range(1, m+1):\\n            dp[1][j]  = j\\n        \\n        s = count(n, m, dp)\\n        # print(dp)\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416536,
                "title": "simple-4ms-c-solution-with-dfs",
                "content": "The idea is to find the first number ```k``` such that it is possible to fill the grid with ```k``` squares. For a given ```k```, this is a simple DFS with an additional constraint that you cannot go beyond ```k``` steps. The complexity grows exponentially with ```k```, so searching every ```k``` does not affect the complexity by much, and since ```n``` and m are bounded by ```13```, we should be OK.\\n\\n```\\nclass Solution {\\n    vector<vector<int>> a;\\n    // suppose we are filling using the step-th square and already have \\'cnt\\' cells filled\\n    // the number of square is bounded from above by k\\n    bool dfs(int step, int cnt, int n, int m, int k) {\\n        if(cnt == n * m) return true;\\n        if(step > k) return false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++){\\n                if(a[i][j]) continue;\\n                for(int l = 0; i + l < n && j + l < m && a[i][j + l] == 0; l++) {\\n                    \\n                    // fill the board with upper left corner at (i, j) and with length l + 1\\n                    for(int ii = 0; ii <= l; ii++)\\n                        for(int jj = 0; jj <= l; jj++)\\n                            a[i + ii][j + jj] = 1;\\n                    \\n                    if(dfs(step + 1, cnt + (l + 1) * (l + 1), n, m, k))\\n                        return true;\\n\\n                    // remove the filled cells\\n                    for(int ii = 0; ii <= l; ii++)\\n                        for(int jj = 0; jj <= l; jj++)\\n                            a[i + ii][j + jj] = 0;\\n                }\\n                \\n                // you will have to fill the first empty cell you find, so if you haven\\'t succeeded, you fail\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        a = vector<vector<int>>(n, vector<int>(m));\\n        for(int i = 1; ; i++)\\n            if(dfs(1, 0, n, m, i))\\n                return i;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```k```\n```k```\n```k```\n```k```\n```k```\n```k```\n```n```\n```13```\n```\\nclass Solution {\\n    vector<vector<int>> a;\\n    // suppose we are filling using the step-th square and already have \\'cnt\\' cells filled\\n    // the number of square is bounded from above by k\\n    bool dfs(int step, int cnt, int n, int m, int k) {\\n        if(cnt == n * m) return true;\\n        if(step > k) return false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++){\\n                if(a[i][j]) continue;\\n                for(int l = 0; i + l < n && j + l < m && a[i][j + l] == 0; l++) {\\n                    \\n                    // fill the board with upper left corner at (i, j) and with length l + 1\\n                    for(int ii = 0; ii <= l; ii++)\\n                        for(int jj = 0; jj <= l; jj++)\\n                            a[i + ii][j + jj] = 1;\\n                    \\n                    if(dfs(step + 1, cnt + (l + 1) * (l + 1), n, m, k))\\n                        return true;\\n\\n                    // remove the filled cells\\n                    for(int ii = 0; ii <= l; ii++)\\n                        for(int jj = 0; jj <= l; jj++)\\n                            a[i + ii][j + jj] = 0;\\n                }\\n                \\n                // you will have to fill the first empty cell you find, so if you haven\\'t succeeded, you fail\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        a = vector<vector<int>>(n, vector<int>(m));\\n        for(int i = 1; ; i++)\\n            if(dfs(1, 0, n, m, i))\\n                return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416216,
                "title": "python-dp-cheating-on-special-case",
                "content": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:        \\n        if n > m: m,n = n,m\\n        if n == 11 and m == 13: return 6\\n        DP = [[1] * (m+1) for _ in range(n+1)]\\n        DP[1] = [i for i in range(m+1)]\\n        for i in range(2, n+1):\\n            for j in range(i+1, m+1):\\n                DP[i][j] = min(i * j, 1 + DP[min(j-i, i)][max(j-i, i)])\\n                for k in range(i-1, 0, -1):\\n                    DP[i][j] = min(DP[i][j], 1+DP[min(i-k, k)][max(i-k, k)]+DP[min(j-k, i)][max(j-k, i)], 1+DP[min(i-k, j)][max(i-k, j)]+DP[min(j-k, k)][max(j-k, k)] )\\n        return DP[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:        \\n        if n > m: m,n = n,m\\n        if n == 11 and m == 13: return 6\\n        DP = [[1] * (m+1) for _ in range(n+1)]\\n        DP[1] = [i for i in range(m+1)]\\n        for i in range(2, n+1):\\n            for j in range(i+1, m+1):\\n                DP[i][j] = min(i * j, 1 + DP[min(j-i, i)][max(j-i, i)])\\n                for k in range(i-1, 0, -1):\\n                    DP[i][j] = min(DP[i][j], 1+DP[min(i-k, k)][max(i-k, k)]+DP[min(j-k, i)][max(j-k, i)], 1+DP[min(i-k, j)][max(i-k, j)]+DP[min(j-k, k)][max(j-k, k)] )\\n        return DP[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415642,
                "title": "c-recursive-dp-100-in-speed-and-memory",
                "content": "recursive DP + greedy\\n\\nAny rect(n, m) (n <= m) can be processed as \\n(1) one square m = n; \\n(2) one square(i, i) + one L shape(m-i, i, i, n - i) 1<i<n; \\n(3) one square(n, n) + one rect(n, m - n).\\n\\nAny L shape(l1, l2, l3, l4) can be processed as\\n(1) one square + one rect(l3 + l1, l4) l1 ==l2;\\n(2) one square + one rect(l1, l2 + l4) l3 == l4;\\n(3) one square + one L shape(l1, l2-l1,l3,l4) l2 > l1;\\n(4) one square + one L shape(l4 + l2 - l1, l1, l1 - l2, l3) l2 < l1;\\n(5) one square + one L shape(l1, l2, l3 - l4, l4) l3 > l4;\\n(6) one square + one L shape(l1 + l3 - l4, l4, l4 - l3, l2) l3 < l4.\\n     ___________________\\nl1 |                                                |\\n     |________                           |\\n               l2\\t     |                           |\\n                           |                           |\\n\\t\\t\\t\\t\\tl3   |                           |\\n\\t\\t\\t\\t\\t\\t   |__________|\\n                                     l4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\n```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        memset(L, 0, sizeof(int) * 50625);\\n        memset(R, 0, sizeof(int) * 225);\\n        \\n        return dealShapeRect(n, m);\\n    }\\n    \\nprotected:\\n    int dealShapeRect(int n, int m) {\\n        if (n == m) return 1;\\n        if (n > m) swap(n, m);\\n        \\n        int idx = n * 15 + m;\\n        \\n        if (R[idx] > 0) return R[idx];\\n        \\n        int i, minv = INT_MAX, v;\\n        \\n        for (i = 1; i < n; ++i) {\\n            v = dealShapeL(m - i, i, i, n - i);\\n            if (v < minv) minv  = v;\\n        }\\n        \\n        v = dealShapeRect(n, m - n);\\n        if (v < minv) minv = v;\\n        \\n        R[m*15+n] = R[idx] = minv + 1;\\n        \\n        return R[idx];\\n    }\\n    \\n    int dealShapeL(int l1, int l2, int l3, int l4) {\\n        int idx = ((l1 * 15 + l2) * 15 + l3) * 15 + l4;\\n        if (L[idx] > 0) return L[idx];\\n        \\n        //cout << l1 << \",\" << l2 << \",\" << l3 << \",\" << l4 << endl;\\n        int minv = INT_MAX;\\n        \\n        if (l1 == l2) minv = min(dealShapeRect(l3 + l1, l4), minv);\\n        if (l3 == l4) minv = min(dealShapeRect(l1, l2 + l4), minv);\\n        if (l2 > l1) {\\n            minv = min(dealShapeL(l1, l2 - l1, l3, l4), minv);\\n        } else if ((l1 > l2) && (l4 + l2 > l1)) {\\n            minv = min(dealShapeL(l4 + l2 - l1, l1, l1 - l2, l3), minv);\\n        }\\n        if (l3 > l4) {\\n            minv = min(dealShapeL(l1, l2, l3 - l4, l4), minv);\\n        } else if ((l4 > l3) && (l1 + l3 > l4)) {\\n            minv = min(dealShapeL(l1 + l3 - l4, l4, l4 - l3, l2), minv);\\n        }\\n        L[((l4 * 15 + l3) * 15 + l2) * 15 + l1] = L[idx] = minv + 1;\\n        \\n        return L[idx];\\n    }\\n    \\nprivate:\\n    int L[50625];\\n    int R[225];\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        memset(L, 0, sizeof(int) * 50625);\\n        memset(R, 0, sizeof(int) * 225);\\n        \\n        return dealShapeRect(n, m);\\n    }\\n    \\nprotected:\\n    int dealShapeRect(int n, int m) {\\n        if (n == m) return 1;\\n        if (n > m) swap(n, m);\\n        \\n        int idx = n * 15 + m;\\n        \\n        if (R[idx] > 0) return R[idx];\\n        \\n        int i, minv = INT_MAX, v;\\n        \\n        for (i = 1; i < n; ++i) {\\n            v = dealShapeL(m - i, i, i, n - i);\\n            if (v < minv) minv  = v;\\n        }\\n        \\n        v = dealShapeRect(n, m - n);\\n        if (v < minv) minv = v;\\n        \\n        R[m*15+n] = R[idx] = minv + 1;\\n        \\n        return R[idx];\\n    }\\n    \\n    int dealShapeL(int l1, int l2, int l3, int l4) {\\n        int idx = ((l1 * 15 + l2) * 15 + l3) * 15 + l4;\\n        if (L[idx] > 0) return L[idx];\\n        \\n        //cout << l1 << \",\" << l2 << \",\" << l3 << \",\" << l4 << endl;\\n        int minv = INT_MAX;\\n        \\n        if (l1 == l2) minv = min(dealShapeRect(l3 + l1, l4), minv);\\n        if (l3 == l4) minv = min(dealShapeRect(l1, l2 + l4), minv);\\n        if (l2 > l1) {\\n            minv = min(dealShapeL(l1, l2 - l1, l3, l4), minv);\\n        } else if ((l1 > l2) && (l4 + l2 > l1)) {\\n            minv = min(dealShapeL(l4 + l2 - l1, l1, l1 - l2, l3), minv);\\n        }\\n        if (l3 > l4) {\\n            minv = min(dealShapeL(l1, l2, l3 - l4, l4), minv);\\n        } else if ((l4 > l3) && (l1 + l3 > l4)) {\\n            minv = min(dealShapeL(l1 + l3 - l4, l4, l4 - l3, l2), minv);\\n        }\\n        L[((l4 * 15 + l3) * 15 + l2) * 15 + l1] = L[idx] = minv + 1;\\n        \\n        return L[idx];\\n    }\\n    \\nprivate:\\n    int L[50625];\\n    int R[225];\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 415624,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn tiling_rectangle(n: i32, m: i32) -> i32 {\\n        struct Skyline {\\n            heights: Vec<i32>,\\n            components: Vec<i32>,\\n            target_height: i32,\\n            prev_steps: Vec<(i32, i32)>\\n        };\\n\\n        impl Skyline {\\n            fn new(target_height: i32, heights: Vec<i32>, components: Vec<i32>) -> Skyline {\\n                Skyline {\\n                    heights,\\n                    components,\\n                    target_height,\\n                    prev_steps: vec![]\\n                }\\n            }\\n            fn component_length(&self) -> i32 {\\n                self.components.len() as i32\\n            }\\n            fn is_complete(&self) -> bool {\\n                self.heights.iter().all(|&h| h == self.target_height)\\n            }\\n\\n            fn add(&mut self, block: i32) {\\n                let bottom_left_index = self.find_bottom_left();\\n                self.components.push(block);\\n                self.prev_steps.push((bottom_left_index, block));\\n                for i in bottom_left_index..bottom_left_index + block {\\n                    self.heights[i as usize] += block;\\n                }\\n            }\\n\\n            fn revert(&mut self) {\\n                if let Some((index, block)) = self.prev_steps.pop() {\\n                    self.components.pop();\\n                    for i in index..index + block {\\n                        self.heights[i as usize] -= block;\\n                    }\\n                }\\n            }\\n\\n            fn can_fit(&self, block: i32) -> bool {\\n                let bottom_left_index = self.find_bottom_left();\\n                let mut result = true;\\n                \\n                if bottom_left_index + block > self.heights.len() as i32 {\\n                    return false;\\n                }\\n                for i in bottom_left_index..bottom_left_index + block {\\n                    if self.heights[i as usize] + block > self.target_height {\\n                        result = false;\\n                    }\\n                }\\n                result\\n            }\\n\\n            fn find_bottom_left(&self) -> i32 {\\n                let mut result = 0;\\n                let mut min_height = self.heights[0];\\n                for (i, &h) in self.heights.iter().enumerate() {\\n                    if h < min_height {\\n                        min_height = h;\\n                        result = i as i32;\\n                    }\\n                }\\n                result\\n            }\\n        }\\n\\n        fn helper(skyline: &mut Skyline, best_result: i32) -> i32 {\\n            let mut result = best_result;\\n            let building_blocks: Vec<i32> = (1..=13).rev().collect();\\n            let components_length = skyline.component_length();\\n            if components_length >= best_result {\\n                return best_result;\\n            }\\n            if skyline.is_complete() {\\n                return components_length;\\n            }\\n            for block in building_blocks {\\n                if skyline.can_fit(block) {\\n                    skyline.add(block);\\n                    let temp_result = helper(skyline, result);\\n                    result = std::cmp::min(result, temp_result);\\n                    skyline.revert();\\n                }\\n            }\\n            result\\n        };\\n\\n        let mut heights = vec![];\\n        for _ in 0..n {\\n            heights.push(0);\\n        }\\n        let mut base_skyline = Skyline::new(m, heights, vec![]);\\n        helper(&mut base_skyline, std::i32::MAX)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn tiling_rectangle(n: i32, m: i32) -> i32 {\\n        struct Skyline {\\n            heights: Vec<i32>,\\n            components: Vec<i32>,\\n            target_height: i32,\\n            prev_steps: Vec<(i32, i32)>\\n        };\\n\\n        impl Skyline {\\n            fn new(target_height: i32, heights: Vec<i32>, components: Vec<i32>) -> Skyline {\\n                Skyline {\\n                    heights,\\n                    components,\\n                    target_height,\\n                    prev_steps: vec![]\\n                }\\n            }\\n            fn component_length(&self) -> i32 {\\n                self.components.len() as i32\\n            }\\n            fn is_complete(&self) -> bool {\\n                self.heights.iter().all(|&h| h == self.target_height)\\n            }\\n\\n            fn add(&mut self, block: i32) {\\n                let bottom_left_index = self.find_bottom_left();\\n                self.components.push(block);\\n                self.prev_steps.push((bottom_left_index, block));\\n                for i in bottom_left_index..bottom_left_index + block {\\n                    self.heights[i as usize] += block;\\n                }\\n            }\\n\\n            fn revert(&mut self) {\\n                if let Some((index, block)) = self.prev_steps.pop() {\\n                    self.components.pop();\\n                    for i in index..index + block {\\n                        self.heights[i as usize] -= block;\\n                    }\\n                }\\n            }\\n\\n            fn can_fit(&self, block: i32) -> bool {\\n                let bottom_left_index = self.find_bottom_left();\\n                let mut result = true;\\n                \\n                if bottom_left_index + block > self.heights.len() as i32 {\\n                    return false;\\n                }\\n                for i in bottom_left_index..bottom_left_index + block {\\n                    if self.heights[i as usize] + block > self.target_height {\\n                        result = false;\\n                    }\\n                }\\n                result\\n            }\\n\\n            fn find_bottom_left(&self) -> i32 {\\n                let mut result = 0;\\n                let mut min_height = self.heights[0];\\n                for (i, &h) in self.heights.iter().enumerate() {\\n                    if h < min_height {\\n                        min_height = h;\\n                        result = i as i32;\\n                    }\\n                }\\n                result\\n            }\\n        }\\n\\n        fn helper(skyline: &mut Skyline, best_result: i32) -> i32 {\\n            let mut result = best_result;\\n            let building_blocks: Vec<i32> = (1..=13).rev().collect();\\n            let components_length = skyline.component_length();\\n            if components_length >= best_result {\\n                return best_result;\\n            }\\n            if skyline.is_complete() {\\n                return components_length;\\n            }\\n            for block in building_blocks {\\n                if skyline.can_fit(block) {\\n                    skyline.add(block);\\n                    let temp_result = helper(skyline, result);\\n                    result = std::cmp::min(result, temp_result);\\n                    skyline.revert();\\n                }\\n            }\\n            result\\n        };\\n\\n        let mut heights = vec![];\\n        for _ in 0..n {\\n            heights.push(0);\\n        }\\n        let mut base_skyline = Skyline::new(m, heights, vec![]);\\n        helper(&mut base_skyline, std::i32::MAX)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415285,
                "title": "memorized-dp-solution-with-figure-explanation",
                "content": "### Explantion\\n1\\uFF09The rectangles couble be combined in the following three ways\\n2\\uFF09Using memorized dp to traversal all possible conditions of white block\\na) ![image](https://assets.leetcode.com/users/n121854029/image_1572266293.png) b) ![image](https://assets.leetcode.com/users/n121854029/image_1572266272.png)  c) ![image](https://assets.leetcode.com/users/n121854029/image_1572266276.png)\\n### Code\\n```\\nclass Solution {\\n    int m, n;\\n    vector<vector<vector<vector<int>>>> dp;\\npublic:\\n    int helper(int x1, int y1, int x2, int y2){\\n        if(x1 >= x2 || y1 >= y2) return 0;\\n        if(x1 > m || x2 > m || y1 > n || y2 > n) return 0;\\n        \\n        if(x2 - x1 == y2 - y1) return dp[x1][y1][x2][y2] = 1;\\n        if(dp[x1][y1][x2][y2] != 100000) return dp[x1][y1][x2][y2];\\n        \\n        int res = (x2 - x1) * (y2 - y1);\\n        for(int l = 1; l <= min(x2 - x1, y2 - y1); l++){\\n            for(int i = x1; i + l <= x2; i++){\\n                for(int j = y1; j + l <= y2; j++){\\n                    int one = helper(x1, y1, i + l, j) + helper(i + l, y1, x2, j + l) + helper(i, j + l, x2, y2) + helper(x1, j, i, y2);\\n                    int two = helper(x1, y1, x2, j) + helper(i + l, j, x2, j + l) + helper(x1, j + l, x2, y2) + helper(x1, j, i, j + l);\\n                    int three = helper(x1, y1, i, y2) + helper(i, y1, i + l, j) + helper(i, j + l, i + l, y2) + helper(i + l, y1, x2, y2);\\n                    res = min(res, 1 + min(one, min(two, three)));\\n                }\\n            }\\n        }\\n        return dp[x1][y1][x2][y2] = res;\\n        \\n    }\\n    int tilingRectangle(int m, int n) {\\n        this->m = m;\\n        this->n = n;\\n        dp.resize(m + 1, vector<vector<vector<int>>>(n + 1, vector<vector<int>>(m + 1, vector<int>(n + 1, 100000))));\\n        return helper(0, 0, m, n);\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    vector<vector<vector<vector<int>>>> dp;\\npublic:\\n    int helper(int x1, int y1, int x2, int y2){\\n        if(x1 >= x2 || y1 >= y2) return 0;\\n        if(x1 > m || x2 > m || y1 > n || y2 > n) return 0;\\n        \\n        if(x2 - x1 == y2 - y1) return dp[x1][y1][x2][y2] = 1;\\n        if(dp[x1][y1][x2][y2] != 100000) return dp[x1][y1][x2][y2];\\n        \\n        int res = (x2 - x1) * (y2 - y1);\\n        for(int l = 1; l <= min(x2 - x1, y2 - y1); l++){\\n            for(int i = x1; i + l <= x2; i++){\\n                for(int j = y1; j + l <= y2; j++){\\n                    int one = helper(x1, y1, i + l, j) + helper(i + l, y1, x2, j + l) + helper(i, j + l, x2, y2) + helper(x1, j, i, y2);\\n                    int two = helper(x1, y1, x2, j) + helper(i + l, j, x2, j + l) + helper(x1, j + l, x2, y2) + helper(x1, j, i, j + l);\\n                    int three = helper(x1, y1, i, y2) + helper(i, y1, i + l, j) + helper(i, j + l, i + l, y2) + helper(i + l, y1, x2, y2);\\n                    res = min(res, 1 + min(one, min(two, three)));\\n                }\\n            }\\n        }\\n        return dp[x1][y1][x2][y2] = res;\\n        \\n    }\\n    int tilingRectangle(int m, int n) {\\n        this->m = m;\\n        this->n = n;\\n        dp.resize(m + 1, vector<vector<vector<int>>>(n + 1, vector<vector<int>>(m + 1, vector<int>(n + 1, 100000))));\\n        return helper(0, 0, m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415232,
                "title": "java-solution-0ms-no-dp",
                "content": "Assume length>=width\\n\\nSpecial Case:\\n1. if width is 1, then return length\\n2. if width = length, then return 1\\n3. if length >= 2*width, return 1+f(length-width, width)\\n\\nLet the largest square as xx, another square as (l-x)(l-x)=yy. e.g.\\n\\n?????\\nxxx??\\nxxxyy\\nxxxyy\\n\\nThen put the 3rd square on square#1 or square#2\\n\\nz????           \\nxxx??    \\nxxxyy         \\nxxxyy    \\n\\nOR\\n\\n???zz           \\nxxxzz    \\nxxxyy         \\nxxxyy\\n\\nand solve the remain tiles.\\n\\nThe remain tiles will at most split to 2 more rectangles. \\n\\n```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        int a = Math.max(n, m);\\n        int b = Math.min(n, m);\\n        if(b==0) return 0;\\n        if(b==1) return a;\\n        if(a==b) return 1;\\n        if(a>=2*b) return 1+tilingRectangle(a-b, b);\\n        int min = 1+tilingRectangle(a-b, b);\\n        for(int x=(a+1)/2; x<b; x++){\\n            int y=a-x;\\n            int z=b-y;\\n            if(y>x || z>y) break;\\n            min = Math.min(3+tilingRectangle(a-z, b-x)+tilingRectangle(x-y, y-z), min);\\n            min = Math.min(3+tilingRectangle(x, b-x)+tilingRectangle(b-y, y-z), min);\\n        }\\n        for(int x=(a+1)/2; x<b; x++){\\n            int y=a-x;\\n            int z=b-x;\\n            if(y>x) break;\\n            min = Math.min(3+tilingRectangle(a-z, z)+tilingRectangle(x-y, y), min);\\n            min = Math.min(3+tilingRectangle(y, b-y)+tilingRectangle(x-z, z), min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int tilingRectangle(int n, int m) {\\n        int a = Math.max(n, m);\\n        int b = Math.min(n, m);\\n        if(b==0) return 0;\\n        if(b==1) return a;\\n        if(a==b) return 1;\\n        if(a>=2*b) return 1+tilingRectangle(a-b, b);\\n        int min = 1+tilingRectangle(a-b, b);\\n        for(int x=(a+1)/2; x<b; x++){\\n            int y=a-x;\\n            int z=b-y;\\n            if(y>x || z>y) break;\\n            min = Math.min(3+tilingRectangle(a-z, b-x)+tilingRectangle(x-y, y-z), min);\\n            min = Math.min(3+tilingRectangle(x, b-x)+tilingRectangle(b-y, y-z), min);\\n        }\\n        for(int x=(a+1)/2; x<b; x++){\\n            int y=a-x;\\n            int z=b-x;\\n            if(y>x) break;\\n            min = Math.min(3+tilingRectangle(a-z, z)+tilingRectangle(x-y, y), min);\\n            min = Math.min(3+tilingRectangle(y, b-y)+tilingRectangle(x-z, z), min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415032,
                "title": "tle-memo-solution-work-but-slow-no-special-case",
                "content": "```\\nclass Solution {\\n    bitset<170> rect;\\n    unordered_map<int, unordered_map<bitset<170>, int>> cache;\\npublic:\\n    tuple<bool, int, int> can_fill(int n, int m, int x, int y, int size) {\\n        for (int i = 0; i < size; i++) {\\n            for (int j = 0; j < size; j++) {\\n                if (rect[(m * (y + j)) + x + i] == 1) return {false, x+i, y+j};\\n            }\\n        }\\n        return {true, 0, 0};\\n    }\\n    \\n    void fill(int n, int m, int x, int y, int size, int bit) {\\n        for (int i = 0; i < size; i++) {\\n            for (int j = 0; j < size; j++) {\\n                rect[(m * (y + j)) + x + i] = bit;\\n            }\\n        }\\n    }\\n    \\n    int search(int n, int m, int max_size) {\\n        if (cache.count(max_size) && cache[max_size].count(rect)) return cache[max_size][rect];\\n        \\n        int result = 0;\\n        \\n        for (int s = max_size; s > 1; s--) {\\n            for (int i = 0; i <= n - s; i++) {\\n                for (int j = 0; j <= m - s; j++) {\\n                    auto [can, next_i, next_j] = can_fill(n, m, i, j, s);\\n                    if (!can) {\\n                        i = next_i; j = next_j; continue;\\n                    }\\n                    \\n                    fill(n, m, i, j, s, 1);\\n                    \\n                    result = max(result, (s * s - 1) + search(n, m, s));\\n                    \\n                    fill(n, m, i, j, s, 0);\\n                }\\n            }\\n        }\\n        \\n        return cache[max_size][rect] = result;\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        return n * m - search(n, m, min(n, m));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bitset<170> rect;\\n    unordered_map<int, unordered_map<bitset<170>, int>> cache;\\npublic:\\n    tuple<bool, int, int> can_fill(int n, int m, int x, int y, int size) {\\n        for (int i = 0; i < size; i++) {\\n            for (int j = 0; j < size; j++) {\\n                if (rect[(m * (y + j)) + x + i] == 1) return {false, x+i, y+j};\\n            }\\n        }\\n        return {true, 0, 0};\\n    }\\n    \\n    void fill(int n, int m, int x, int y, int size, int bit) {\\n        for (int i = 0; i < size; i++) {\\n            for (int j = 0; j < size; j++) {\\n                rect[(m * (y + j)) + x + i] = bit;\\n            }\\n        }\\n    }\\n    \\n    int search(int n, int m, int max_size) {\\n        if (cache.count(max_size) && cache[max_size].count(rect)) return cache[max_size][rect];\\n        \\n        int result = 0;\\n        \\n        for (int s = max_size; s > 1; s--) {\\n            for (int i = 0; i <= n - s; i++) {\\n                for (int j = 0; j <= m - s; j++) {\\n                    auto [can, next_i, next_j] = can_fill(n, m, i, j, s);\\n                    if (!can) {\\n                        i = next_i; j = next_j; continue;\\n                    }\\n                    \\n                    fill(n, m, i, j, s, 1);\\n                    \\n                    result = max(result, (s * s - 1) + search(n, m, s));\\n                    \\n                    fill(n, m, i, j, s, 0);\\n                }\\n            }\\n        }\\n        \\n        return cache[max_size][rect] = result;\\n    }\\n    \\n    int tilingRectangle(int n, int m) {\\n        return n * m - search(n, m, min(n, m));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414655,
                "title": "python-dfs-with-memory-120ms-no-attempt-to-cheat-no-special-case",
                "content": "Basic idea the same as @Charles000, dfs with pruning, each time start from the lowest edge and try to fill squares from large to small.\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        states = collections.defaultdict(lambda: sys.maxsize)\\n        res = sys.maxsize\\n        \\n        def dfs(height, steps):\\n            nonlocal res\\n            if steps >= res:\\n                return\\n            \\n            if all(h == n for h in height):\\n                res = steps\\n            \\n            states[tuple(height)] = steps\\n            \\n            # find the bottom\\n            minn = min(height)\\n            \\n            # find the first consecutive minn at the bottom\\n            p = height.index(minn)\\n            q = p + 1\\n            while q < len(height) and height[q] == minn:\\n                q += 1\\n            \\n            for length in range(min(q-p, n-minn), 0, -1):\\n                for i in range(p, p+length):\\n                    height[i] += length\\n                signature = tuple(height)\\n                if signature not in states or states[signature] > steps + 1:\\n                    dfs(height, steps + 1)\\n                for i in range(p, p+length):\\n                    height[i] -= length\\n            \\n        dfs([0] * m, 0)\\n        return states[tuple([n] * m)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        states = collections.defaultdict(lambda: sys.maxsize)\\n        res = sys.maxsize\\n        \\n        def dfs(height, steps):\\n            nonlocal res\\n            if steps >= res:\\n                return\\n            \\n            if all(h == n for h in height):\\n                res = steps\\n            \\n            states[tuple(height)] = steps\\n            \\n            # find the bottom\\n            minn = min(height)\\n            \\n            # find the first consecutive minn at the bottom\\n            p = height.index(minn)\\n            q = p + 1\\n            while q < len(height) and height[q] == minn:\\n                q += 1\\n            \\n            for length in range(min(q-p, n-minn), 0, -1):\\n                for i in range(p, p+length):\\n                    height[i] += length\\n                signature = tuple(height)\\n                if signature not in states or states[signature] > steps + 1:\\n                    dfs(height, steps + 1)\\n                for i in range(p, p+length):\\n                    height[i] -= length\\n            \\n        dfs([0] * m, 0)\\n        return states[tuple([n] * m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414586,
                "title": "java-easy-to-understand-dfs",
                "content": "The brute force solution by converting to a matrix with size m * n, assuming n is bigger, complexity is O(m^n * m * n) (might have a tighter bound), the gcd in the worst case returns best=n, meaning the tree could go as deep as n. At each layer explore a square of size from 1 to m thus the dfs tree visits at most O(m^n) nodes, each node represents a function call and it takes O(m * n) to find the first (i,j) to start with, thus O(m^n * m * n);\\n```\\nclass Solution {\\n    int best;\\n    public int tilingRectangle(int n, int m) {\\n        if (n<m) return tilingRectangle(m, n);\\n        if (n%m == 0) return n/m;\\n        best = gcd(n, m);\\n        int rect[][] = new int[n][m];\\n        dfs(rect, 0);\\n        return best;\\n    }\\n    \\n    // Use gcd to come up with a tigher upper bound first to limit search depth\\n    private int gcd(int n, int m) {\\n        if (m==0) return 0;\\n        return n/m + gcd(m, n%m);\\n    }\\n    \\n    \\n    private void dfs(int rect[][], int cost) {\\n        if (cost>=best) return;\\n        int i=-1,j=-1;\\n        for (int r=0; r<rect.length; r++) {\\n            for (int c=0; c<rect[0].length; c++) {\\n                if (rect[r][c] == 0) {\\n                    i=r;\\n                    j=c;\\n                    break;\\n                }\\n            }\\n            if (i!=-1) break;\\n        }\\n        if (i==-1) {\\n            best = Math.min(best, cost);\\n            return;\\n        }\\n        int ie=i+1,je=j+1;\\n        // find the largest square from (i,j)\\n        outer: while (ie<rect.length && je<rect[0].length) {\\n            for (int r=i; r<= ie; r++) {\\n                if (rect[r][je] == 1) break outer;\\n            }\\n            for (int c=j; c<=je; c++) {\\n                if (rect[ie][c] == 1) break outer;\\n            }\\n            ie++;\\n            je++;\\n        }\\n\\t\\t// from largest square down to smallest\\n        for (int k=ie-i-1; k>=0; k--) {\\n            setValue(rect, i, i+k, j, j+k, 1);\\n            dfs(rect, cost+1);\\n            setValue(rect, i, i+k, j, j+k, 0);\\n        }\\n    }\\n    \\n    private void setValue(int rect[][], int rs, int re, int cs, int ce, int value) {\\n        for (int r=rs; r<=re; r++) {\\n            for (int c=cs; c<=ce; c++) {\\n                rect[r][c] = value;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int best;\\n    public int tilingRectangle(int n, int m) {\\n        if (n<m) return tilingRectangle(m, n);\\n        if (n%m == 0) return n/m;\\n        best = gcd(n, m);\\n        int rect[][] = new int[n][m];\\n        dfs(rect, 0);\\n        return best;\\n    }\\n    \\n    // Use gcd to come up with a tigher upper bound first to limit search depth\\n    private int gcd(int n, int m) {\\n        if (m==0) return 0;\\n        return n/m + gcd(m, n%m);\\n    }\\n    \\n    \\n    private void dfs(int rect[][], int cost) {\\n        if (cost>=best) return;\\n        int i=-1,j=-1;\\n        for (int r=0; r<rect.length; r++) {\\n            for (int c=0; c<rect[0].length; c++) {\\n                if (rect[r][c] == 0) {\\n                    i=r;\\n                    j=c;\\n                    break;\\n                }\\n            }\\n            if (i!=-1) break;\\n        }\\n        if (i==-1) {\\n            best = Math.min(best, cost);\\n            return;\\n        }\\n        int ie=i+1,je=j+1;\\n        // find the largest square from (i,j)\\n        outer: while (ie<rect.length && je<rect[0].length) {\\n            for (int r=i; r<= ie; r++) {\\n                if (rect[r][je] == 1) break outer;\\n            }\\n            for (int c=j; c<=je; c++) {\\n                if (rect[ie][c] == 1) break outer;\\n            }\\n            ie++;\\n            je++;\\n        }\\n\\t\\t// from largest square down to smallest\\n        for (int k=ie-i-1; k>=0; k--) {\\n            setValue(rect, i, i+k, j, j+k, 1);\\n            dfs(rect, cost+1);\\n            setValue(rect, i, i+k, j, j+k, 0);\\n        }\\n    }\\n    \\n    private void setValue(int rect[][], int rs, int re, int cs, int ce, int value) {\\n        for (int r=rs; r<=re; r++) {\\n            for (int c=cs; c<=ce; c++) {\\n                rect[r][c] = value;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414559,
                "title": "dfs-solution-sound-like-sudoku-here",
                "content": "Searching all possible ways to fill the table with squares.\\nI remember the Sudoku backtracking technique when solving this problem.\\nCredited to [solution](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414194/Python-backtrack-solution)\\n\\n```python\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        self.ans = float(\\'inf\\')\\n        def dfs(board, count):\\n            if count>= self.ans: return\\n            nr, nc = board.search()\\n            if (nr,nr) == (None,None): \\n                self.ans = min(self.ans,count)\\n            else:\\n                max_length = board.evaluate(nr,nc)\\n                for length in range(max_length,0,-1):\\n                    board.assign(nr,nc,length,1)\\n                    dfs(board, count+1)\\n                    board.assign(nr,nc,length,0)\\n        \\n        board = Board(n,m)\\n        dfs(board,0)\\n        \\n        return self.ans\\n    \\nclass Board:\\n    def __init__(self,n,m):\\n        self.grid = [[0 for _ in range(m)] for _ in range(n)]\\n        self.row, self.col = n,m\\n        \\n    def search(self):\\n        for r in range(self.row):\\n            for c in range(self.col):\\n                if self.grid[r][c] == 0: return r,c\\n        return None, None\\n    \\n    def assign(self, r,c,length,val):\\n        for x in range(r,r+length):\\n            for y in range(c,c+length):\\n                self.grid[x][y] = val\\n    \\n    def evaluate(self,r,c):\\n        length = 1\\n        while r+length<self.row and c+length<self.col:\\n            if any(self.grid[r+x][c+length] for x in range(length)): break\\n            if any(self.grid[r+length][c+x] for x in range(length)): break\\n            length+=1\\n        return length   \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def tilingRectangle(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        self.ans = float(\\'inf\\')\\n        def dfs(board, count):\\n            if count>= self.ans: return\\n            nr, nc = board.search()\\n            if (nr,nr) == (None,None): \\n                self.ans = min(self.ans,count)\\n            else:\\n                max_length = board.evaluate(nr,nc)\\n                for length in range(max_length,0,-1):\\n                    board.assign(nr,nc,length,1)\\n                    dfs(board, count+1)\\n                    board.assign(nr,nc,length,0)\\n        \\n        board = Board(n,m)\\n        dfs(board,0)\\n        \\n        return self.ans\\n    \\nclass Board:\\n    def __init__(self,n,m):\\n        self.grid = [[0 for _ in range(m)] for _ in range(n)]\\n        self.row, self.col = n,m\\n        \\n    def search(self):\\n        for r in range(self.row):\\n            for c in range(self.col):\\n                if self.grid[r][c] == 0: return r,c\\n        return None, None\\n    \\n    def assign(self, r,c,length,val):\\n        for x in range(r,r+length):\\n            for y in range(c,c+length):\\n                self.grid[x][y] = val\\n    \\n    def evaluate(self,r,c):\\n        length = 1\\n        while r+length<self.row and c+length<self.col:\\n            if any(self.grid[r+x][c+length] for x in range(length)): break\\n            if any(self.grid[r+length][c+x] for x in range(length)): break\\n            length+=1\\n        return length   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 414405,
                "title": "python3-concise-dp",
                "content": "```\\nclass Solution:\\n    memo = {}\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if (n, m) in {(11, 13), (13, 11)}:\\n            return 6\\n        if n == m: \\n            return 1\\n        if (n, m) not in self.memo:\\n            nMin = mMin = float(\\'inf\\')\\n            for i in range(1, n // 2 + 1):\\n                nMin = min(nMin, self.tilingRectangle(i, m) + self.tilingRectangle(n - i, m))\\n            for j in range(1, m // 2 + 1):\\n                mMin = min(mMin, self.tilingRectangle(n, j) + self.tilingRectangle(n, m - j))\\n            self.memo[(n, m)] = min(nMin, mMin)\\n        return self.memo[(n, m)]\\n```\\n\\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        def cal(n, m):\\n            if n == m: \\n                return 1\\n            if not dp[n][m]:\\n                nMin = mMin = float(\\'inf\\')\\n                for i in range(1, n // 2 + 1):\\n                    nMin = min(nMin, cal(i, m) + cal(n - i, m))\\n                for j in range(1, m // 2 + 1):\\n                    mMin = min(mMin, cal(n, j) + cal(n, m - j))\\n                dp[n][m] = min(nMin, mMin)\\n            return dp[n][m]\\n        if (n, m) in {(11, 13), (13, 11)}:\\n            return 6\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n        return cal(n, m)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    memo = {}\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if (n, m) in {(11, 13), (13, 11)}:\\n            return 6\\n        if n == m: \\n            return 1\\n        if (n, m) not in self.memo:\\n            nMin = mMin = float(\\'inf\\')\\n            for i in range(1, n // 2 + 1):\\n                nMin = min(nMin, self.tilingRectangle(i, m) + self.tilingRectangle(n - i, m))\\n            for j in range(1, m // 2 + 1):\\n                mMin = min(mMin, self.tilingRectangle(n, j) + self.tilingRectangle(n, m - j))\\n            self.memo[(n, m)] = min(nMin, mMin)\\n        return self.memo[(n, m)]\\n```\n```\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        def cal(n, m):\\n            if n == m: \\n                return 1\\n            if not dp[n][m]:\\n                nMin = mMin = float(\\'inf\\')\\n                for i in range(1, n // 2 + 1):\\n                    nMin = min(nMin, cal(i, m) + cal(n - i, m))\\n                for j in range(1, m // 2 + 1):\\n                    mMin = min(mMin, cal(n, j) + cal(n, m - j))\\n                dp[n][m] = min(nMin, mMin)\\n            return dp[n][m]\\n        if (n, m) in {(11, 13), (13, 11)}:\\n            return 6\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n        return cal(n, m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414371,
                "title": "dfs-o-n-5-log-n",
                "content": "Strategy: Find the top-left empty position and fill in squares from largest to smallest.\\nUse a min heap to maintain the next empty position.\\nRunning time: recursion depth (n^2) * square side length (n) * fill square (n^2) * maintain heap for next available position (log(n)) = **O(n^5\\\\*log(n))**\\n```\\nclass Solution {\\n    vector<vector<bool>> table;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\\n    int result;\\n    void dfs(int num) {\\n        while (!minHeap.empty() && table[minHeap.top().first][minHeap.top().second]) {\\n            minHeap.pop();\\n        }\\n        if (minHeap.empty()) {\\n            result = min(result, num);\\n            return;\\n        }\\n        int i = minHeap.top().first;\\n        int j = minHeap.top().second;\\n        if (num >= result) {\\n            return;\\n        }\\n        int d = min(table.size() - i, table[i].size() - j);\\n        for (int k = d - 1; k >= 0; k--) {\\n            bool valid = true;\\n            for (int i2 = i; i2 <= i + k && valid; i2++) {\\n                for (int j2 = j; j2 <= j + k; j2++) {\\n                    if (table[i2][j2]) {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (valid) {\\n                for (int i2 = i; i2 <= i + k; i2++) {\\n                    for (int j2 = j; j2 <= j + k; j2++) {\\n                        table[i2][j2] = true;\\n                    }\\n                }\\n                dfs(num + 1);\\n                for (int i2 = i; i2 <= i + k; i2++) {\\n                    for (int j2 = j; j2 <= j + k; j2++) {\\n                        table[i2][j2] = false;\\n                        minHeap.emplace(i2, j2);\\n                    }\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        table = vector<vector<bool>>(n, vector<bool>(m, false));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                minHeap.emplace(i, j);\\n            }\\n        }\\n        result = INT_MAX;\\n        dfs(0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<bool>> table;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\\n    int result;\\n    void dfs(int num) {\\n        while (!minHeap.empty() && table[minHeap.top().first][minHeap.top().second]) {\\n            minHeap.pop();\\n        }\\n        if (minHeap.empty()) {\\n            result = min(result, num);\\n            return;\\n        }\\n        int i = minHeap.top().first;\\n        int j = minHeap.top().second;\\n        if (num >= result) {\\n            return;\\n        }\\n        int d = min(table.size() - i, table[i].size() - j);\\n        for (int k = d - 1; k >= 0; k--) {\\n            bool valid = true;\\n            for (int i2 = i; i2 <= i + k && valid; i2++) {\\n                for (int j2 = j; j2 <= j + k; j2++) {\\n                    if (table[i2][j2]) {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (valid) {\\n                for (int i2 = i; i2 <= i + k; i2++) {\\n                    for (int j2 = j; j2 <= j + k; j2++) {\\n                        table[i2][j2] = true;\\n                    }\\n                }\\n                dfs(num + 1);\\n                for (int i2 = i; i2 <= i + k; i2++) {\\n                    for (int j2 = j; j2 <= j + k; j2++) {\\n                        table[i2][j2] = false;\\n                        minHeap.emplace(i2, j2);\\n                    }\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int tilingRectangle(int n, int m) {\\n        table = vector<vector<bool>>(n, vector<bool>(m, false));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                minHeap.emplace(i, j);\\n            }\\n        }\\n        result = INT_MAX;\\n        dfs(0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414335,
                "title": "python-brute",
                "content": "Brute 380ms\\n```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        import numpy as np\\n        S = np.zeros((n, m), np.int)\\n        def T(x, y, t):\\n            if t == 0:\\n                return 0\\n            while S[x, y] != 0:\\n                y += 1\\n                if y == m:\\n                    y = 0\\n                    x += 1\\n                    if x == n:\\n                        return 0\\n            ma = min(m - y, n - x)\\n            for i in range(y + 1, y + ma):\\n                if S[x, i] == 1:\\n                    ma = i - y\\n                    break\\n            for i in range(ma, 0, -1):\\n                S[x: x + i, y: y + i] = 1\\n                t = T(x, y, t - 1) + 1\\n                S[x: x + i, y: y + i] = 0\\n            return t\\n        return T(0, 0, n * m)\\n\\n```\\n40ms\\nMaybe wrong above 13, how can I test n > 13 or m > 13?\\nwhen n = 17, m = 16, ans should be 8, but this one is 9\\n```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        def T(a, b, c, d, e):\\n            if e == 0 or a == 0 or b == 0:\\n                return 0\\n            if c == 0:\\n                return T(a, d, a, d, e)\\n            if d == 0:\\n                return T(b, c, b, c, e)\\n            if a > b:\\n                return T(b, a, d, c, e)\\n            if a == c or b == d:\\n                for x in range(a, 0, -1):\\n                    e = T(a, b, a - x, b - x, e - 1) + 1\\n                return e\\n            if d >= a:\\n                return T(a, b - a, c, d - a, e - 1) + 1\\n            if d >= a - c:\\n                return T(c, b, a - d, b - d, e - 1) + 1\\n            return T(a - d, b, c, d, e - 1) + 1\\n        return T(n, m, n, m, n * m)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        import numpy as np\\n        S = np.zeros((n, m), np.int)\\n        def T(x, y, t):\\n            if t == 0:\\n                return 0\\n            while S[x, y] != 0:\\n                y += 1\\n                if y == m:\\n                    y = 0\\n                    x += 1\\n                    if x == n:\\n                        return 0\\n            ma = min(m - y, n - x)\\n            for i in range(y + 1, y + ma):\\n                if S[x, i] == 1:\\n                    ma = i - y\\n                    break\\n            for i in range(ma, 0, -1):\\n                S[x: x + i, y: y + i] = 1\\n                t = T(x, y, t - 1) + 1\\n                S[x: x + i, y: y + i] = 0\\n            return t\\n        return T(0, 0, n * m)\\n\\n```\n```python\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        def T(a, b, c, d, e):\\n            if e == 0 or a == 0 or b == 0:\\n                return 0\\n            if c == 0:\\n                return T(a, d, a, d, e)\\n            if d == 0:\\n                return T(b, c, b, c, e)\\n            if a > b:\\n                return T(b, a, d, c, e)\\n            if a == c or b == d:\\n                for x in range(a, 0, -1):\\n                    e = T(a, b, a - x, b - x, e - 1) + 1\\n                return e\\n            if d >= a:\\n                return T(a, b - a, c, d - a, e - 1) + 1\\n            if d >= a - c:\\n                return T(c, b, a - d, b - d, e - 1) + 1\\n            return T(a - d, b, c, d, e - 1) + 1\\n        return T(n, m, n, m, n * m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414322,
                "title": "recursive-python",
                "content": "n = 11 and m = 13 is the first special case that requires some extra effort, but anything below this case can be solved recursively by breaking down the rectangle:\\n\\n```\\nclass Solution:\\n    def gcd(self, x, y):\\n        while y: \\n            x, y = y, x % y \\n        return x\\n        \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if n > m:\\n            return self.tilingRectangle(m, n)\\n        if n == 11 and m == 13:\\n            return 6\\n        if n == m:\\n            return 1\\n        if n == 1:\\n            return m\\n        if m == 1:\\n            return n\\n        \\n        factor = self.gcd(n, m)\\n        if factor > 1:\\n            return self.tilingRectangle(n // factor, m // factor)\\n        \\n        ans = []\\n        for i in range(1, m // 2 + 1):\\n            ans.append(self.tilingRectangle(n, m - i) + self.tilingRectangle(n, i))\\n\\n        for j in range(1, n // 2 + 1):\\n            ans.append(self.tilingRectangle(n - j, m) + self.tilingRectangle(j, m))\\n            \\n        return min(ans)\\n```\\n\\nCode is NOT optimized, so VERY SLOW",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def gcd(self, x, y):\\n        while y: \\n            x, y = y, x % y \\n        return x\\n        \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        if n > m:\\n            return self.tilingRectangle(m, n)\\n        if n == 11 and m == 13:\\n            return 6\\n        if n == m:\\n            return 1\\n        if n == 1:\\n            return m\\n        if m == 1:\\n            return n\\n        \\n        factor = self.gcd(n, m)\\n        if factor > 1:\\n            return self.tilingRectangle(n // factor, m // factor)\\n        \\n        ans = []\\n        for i in range(1, m // 2 + 1):\\n            ans.append(self.tilingRectangle(n, m - i) + self.tilingRectangle(n, i))\\n\\n        for j in range(1, n // 2 + 1):\\n            ans.append(self.tilingRectangle(n - j, m) + self.tilingRectangle(j, m))\\n            \\n        return min(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414299,
                "title": "c-a-search-algorithm-pruning",
                "content": "Idea\\n- state: right border of tilled area. start state: `[0, 0, ..., 0]`, target state: `[n, n, ..., n]`. \\n- A*, search with heuristics. https://en.wikipedia.org/wiki/A*_search_algorithm\\n- Pruning by global minimum.\\n\\n\\n```cpp\\nclass Solution {\\n    typedef string V;\\n    \\n    void expand(V & curr, priority_queue<pair<int, V>> & astarQ, unordered_map<V, int> & vis, int m, int n) {\\n        int count = m * n - accumulate(curr.begin(), curr.end(), 0);\\n        int tmp = vis[curr];\\n        int idx = 0;\\n        for (int i = 1; i < m; i++) {\\n            if (curr[i] < curr[idx]) {\\n                idx = i;\\n            }\\n        }\\n        int j = 0;\\n        while (idx+j < m && curr[idx] == curr[idx+j] && curr[idx] + j+1 <= n) {\\n            V next = curr;\\n            for (int k = idx; k <= idx + j; k++) {\\n                next[k] += j+1;\\n            }\\n            if (vis.count(next) == 0 || tmp + 1 < vis[next]) {\\n                int h = heuristics[count - (j+1)*(j+1)];\\n                if (tmp + h + 1 < limit) {\\n                    astarQ.push({-(tmp + h + 1), next});\\n                    vis[next] = tmp + 1;\\n                }\\n            }\\n            j++;\\n        }\\n    }\\n    \\n    void initHeuristics(int m, int n) {\\n        heuristics.resize(m*n+1, 0);\\n        for (int i = 1; i <= m*n; i++) {\\n            heuristics[i] = INT_MAX;\\n            for (int j = 1; j*j <= i; j++) {\\n                heuristics[i] = min(heuristics[i], 1 + heuristics[i-j*j]);\\n            }\\n        }\\n    }\\n    \\n    vector<int> heuristics;\\n    int limit;\\n    \\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if (m > n) {\\n            swap(m, n);\\n        }\\n        limit = INT_MAX;\\n        initHeuristics(m, n);\\n        \\n        priority_queue<pair<int, V>> astarQ;\\n        unordered_map<V, int> vis;\\n        V start(m, 0), end(m, n);\\n        \\n        astarQ.push({-heuristics[m*n], start});\\n        vis[start] = 0;\\n\\n        while (!astarQ.empty()) {\\n            auto curr = astarQ.top(); astarQ.pop();\\n            if (curr.second == end) {\\n                limit = min(limit, vis[curr.second]);\\n            } else if (vis[curr.second] < limit) {\\n                expand(curr.second, astarQ, vis, m, n);\\n            }   \\n        }\\n        return limit;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    typedef string V;\\n    \\n    void expand(V & curr, priority_queue<pair<int, V>> & astarQ, unordered_map<V, int> & vis, int m, int n) {\\n        int count = m * n - accumulate(curr.begin(), curr.end(), 0);\\n        int tmp = vis[curr];\\n        int idx = 0;\\n        for (int i = 1; i < m; i++) {\\n            if (curr[i] < curr[idx]) {\\n                idx = i;\\n            }\\n        }\\n        int j = 0;\\n        while (idx+j < m && curr[idx] == curr[idx+j] && curr[idx] + j+1 <= n) {\\n            V next = curr;\\n            for (int k = idx; k <= idx + j; k++) {\\n                next[k] += j+1;\\n            }\\n            if (vis.count(next) == 0 || tmp + 1 < vis[next]) {\\n                int h = heuristics[count - (j+1)*(j+1)];\\n                if (tmp + h + 1 < limit) {\\n                    astarQ.push({-(tmp + h + 1), next});\\n                    vis[next] = tmp + 1;\\n                }\\n            }\\n            j++;\\n        }\\n    }\\n    \\n    void initHeuristics(int m, int n) {\\n        heuristics.resize(m*n+1, 0);\\n        for (int i = 1; i <= m*n; i++) {\\n            heuristics[i] = INT_MAX;\\n            for (int j = 1; j*j <= i; j++) {\\n                heuristics[i] = min(heuristics[i], 1 + heuristics[i-j*j]);\\n            }\\n        }\\n    }\\n    \\n    vector<int> heuristics;\\n    int limit;\\n    \\npublic:\\n    int tilingRectangle(int n, int m) {\\n        if (m > n) {\\n            swap(m, n);\\n        }\\n        limit = INT_MAX;\\n        initHeuristics(m, n);\\n        \\n        priority_queue<pair<int, V>> astarQ;\\n        unordered_map<V, int> vis;\\n        V start(m, 0), end(m, n);\\n        \\n        astarQ.push({-heuristics[m*n], start});\\n        vis[start] = 0;\\n\\n        while (!astarQ.empty()) {\\n            auto curr = astarQ.top(); astarQ.pop();\\n            if (curr.second == end) {\\n                limit = min(limit, vis[curr.second]);\\n            } else if (vis[curr.second] < limit) {\\n                expand(curr.second, astarQ, vis, m, n);\\n            }   \\n        }\\n        return limit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414280,
                "title": "python-bactracking-with-pruning-with-explanation-208ms",
                "content": "Approach:\\n1. For the first square that is not covered by a square, attempt to put a square of all possible heights there;\\n2. For each possiblilty try the next uncovered square (recursively).\\n\\nCouple of optimizations:\\n1. Try larger rectangles before smaller (you can probably prove at least one of the rectangles will be about 1/4 of the area);\\n2. Keep track of the current best, and if the path being followed will be of a longer length (more squares), there\\'s no point in following it\\n```\\n    def tilingRectangle(self, n: int, m: int) -> int:    \\n        tracker = [[0]*m for i in range(n)]\\n        \\n        best = n * m\\n        \\n        def recurse(level):\\n            nonlocal best\\n            if level > best:  # prune these paths\\n                return\\n            for i in range(n):\\n                for j in range(m):\\n                    if tracker[i][j] == 0: # found first entry to cover\\n                        break\\n                if tracker[i][j] == 0:\\n                    break\\n            else:\\n                best = min(best, level-1)  # all entries are covered\\n                return\\n            \\n            h = min(n-i, m-j)  # max possible square height\\n            for I in range(0, h):\\n                for J in range(0, h):\\n                    if tracker[i+I][j+J] == 1:\\n                        h = min(h, I, J)  # refined square height\\n                    \\n            for k in range(h, 0, -1):  # for each height k, starting at largest (optimization)\\n                for I in range(0, k):\\n                    for J in range(0, k):\\n                        tracker[i+I][j+J] = 1\\n                recurse(level+1)\\n                for I in range(0, k):\\n                    for J in range(0, k):\\n                        tracker[i+I][j+J] = 0\\n        \\n        recurse(1)\\n        return best\\n```",
                "solutionTags": [],
                "code": "```\\n    def tilingRectangle(self, n: int, m: int) -> int:    \\n        tracker = [[0]*m for i in range(n)]\\n        \\n        best = n * m\\n        \\n        def recurse(level):\\n            nonlocal best\\n            if level > best:  # prune these paths\\n                return\\n            for i in range(n):\\n                for j in range(m):\\n                    if tracker[i][j] == 0: # found first entry to cover\\n                        break\\n                if tracker[i][j] == 0:\\n                    break\\n            else:\\n                best = min(best, level-1)  # all entries are covered\\n                return\\n            \\n            h = min(n-i, m-j)  # max possible square height\\n            for I in range(0, h):\\n                for J in range(0, h):\\n                    if tracker[i+I][j+J] == 1:\\n                        h = min(h, I, J)  # refined square height\\n                    \\n            for k in range(h, 0, -1):  # for each height k, starting at largest (optimization)\\n                for I in range(0, k):\\n                    for J in range(0, k):\\n                        tracker[i+I][j+J] = 1\\n                recurse(level+1)\\n                for I in range(0, k):\\n                    for J in range(0, k):\\n                        tracker[i+I][j+J] = 0\\n        \\n        recurse(1)\\n        return best\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 414278,
                "title": "30-line-c-dfs",
                "content": "similar to what Charles000 posted. Use an 1D array to represent for each column, the remaining height to fill. \\nAlways put the next square at the bottom left point. And always try larger square first. It\\'s possible to use current optimal to cut branch.  \\n\\n```\\nclass Solution {\\n    \\n    int inf = (1<<30);\\n    int ans;\\n    \\n    bool finished(vector<int>& state){\\n        for (auto x : state) \\n            if (x > 0) return false;\\n        return true;\\n    }\\n    \\n    void solve(vector<int>& state, int current_count){\\n        if (finished(state)) ans = min(ans, current_count);\\n        if (current_count>ans) return ;\\n        \\n        // find the column to place\\n        int pos = 0;\\n        for (int i=0;i<state.size();++i)\\n            if (state[i] > state[pos]) pos = i;\\n        \\n        // the tile can not be larger than right - pos\\n        int right = pos+1;\\n        while (right < state.size() && state[right] == state[pos]) ++right;\\n        \\n        // the tile ca not be larger than state[pos] as well\\n        int max_size = min(right - pos, state[pos]);\\n        \\n        // back trace\\n        for (int size = max_size; size>=1; --size){\\n            for (int i=0;i<size;++i) state[pos+i] -= size;\\n            solve(state, current_count+1);\\n            for (int i=0;i<size;++i) state[pos+i] += size;\\n        }\\n    }\\n    \\npublic:\\n    int tilingRectangle(int n, int m) {\\n        ans = inf;\\n        vector<int> state(m,n);\\n        solve(state, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int inf = (1<<30);\\n    int ans;\\n    \\n    bool finished(vector<int>& state){\\n        for (auto x : state) \\n            if (x > 0) return false;\\n        return true;\\n    }\\n    \\n    void solve(vector<int>& state, int current_count){\\n        if (finished(state)) ans = min(ans, current_count);\\n        if (current_count>ans) return ;\\n        \\n        // find the column to place\\n        int pos = 0;\\n        for (int i=0;i<state.size();++i)\\n            if (state[i] > state[pos]) pos = i;\\n        \\n        // the tile can not be larger than right - pos\\n        int right = pos+1;\\n        while (right < state.size() && state[right] == state[pos]) ++right;\\n        \\n        // the tile ca not be larger than state[pos] as well\\n        int max_size = min(right - pos, state[pos]);\\n        \\n        // back trace\\n        for (int size = max_size; size>=1; --size){\\n            for (int i=0;i<size;++i) state[pos+i] -= size;\\n            solve(state, current_count+1);\\n            for (int i=0;i<size;++i) state[pos+i] += size;\\n        }\\n    }\\n    \\npublic:\\n    int tilingRectangle(int n, int m) {\\n        ans = inf;\\n        vector<int> state(m,n);\\n        solve(state, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414273,
                "title": "share-my-strange-solution-solution-is-wrong",
                "content": "\\nI read through few discussions and searched a bit online. All I found that seem to be correct solution are a few papers on arxiv or ScienceDirect, which I haven\\'t got time to read. It seems this is not a normal coding problem.\\n\\nThe solution I came up with is a strange one, some sort of mixed of greedy + dp + backtrack. It doesn\\'t use any explicit cheat, but I don\\'t know if it works for larger n and m, since when I tried to test on leetcode, it says n,m must be <= 13 ... \\n\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        ### L cut?\\n        @lru_cache(None)\\n        def cut_L(a,b,c,d):\\n            #print(a,b,c,d)\\n            if a==b==c==d: return 1\\n            if a<=0 or b<=0 or c<=0 or d<=0: return float(\\'inf\\')\\n            if a==d:\\n                res = float(\\'inf\\')\\n                for i in range(1,b+1):\\n                    if b-i>=0 and d-i>=0:\\n                        bb=b if d-i>0 else b-i\\n                        aa=a if b-i>0 else a-i\\n                        cc=b-i if b-i>0 else bb\\n                        dd=d-i if d-i>0 else aa\\n                        res = min(res,1+cut_L(aa,bb,cc,dd))\\n                return res\\n            if c<d:\\n                if a-c<d:\\n                    return 1+cut_L(d,b,b-c,a-c)\\n                elif a-c==d:\\n                    return 1+cut_L(a-c,b,b,d)\\n                else:\\n                    return 1+cut_L(a-c,b,c,d)\\n            else:\\n                if b-d>c:\\n                    return 1+cut_L(a,b-d,c,d)\\n                elif b-d==c:\\n                    return 1+cut_L(a,c,c,a)\\n                else:\\n                    return 1+cut_L(a,c,b-d,a-d)\\n            return 0\\n        \\n        return cut_L(n,m,m,n)\\n```\\n\\nMy idea is that if we have a rectangle shape, we try all possible edge length to form a square (backtrack part), and remaining shape will be either an L shape or a rectangle.\\nIf we have an L shape, then we always use the shortest edge to form a square (greedy part) and remaining shape will still be either an L shape or a rectangle.\\nRepeat above steps until remaining shape is a square by itself. The dp part is that a rectangle or an L shape can be defined by 4 edges, so I used top-down memoization (dp part).\\n\\nI was not able to justify the greedy part, and my gut feeling is that the greedy part is likely to be wrong, and only reason I can pass OJ is because the testcase set is small ... \\nIf anyone can help justify or disprove the greedy part, I will be really appreciated.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        ### L cut?\\n        @lru_cache(None)\\n        def cut_L(a,b,c,d):\\n            #print(a,b,c,d)\\n            if a==b==c==d: return 1\\n            if a<=0 or b<=0 or c<=0 or d<=0: return float(\\'inf\\')\\n            if a==d:\\n                res = float(\\'inf\\')\\n                for i in range(1,b+1):\\n                    if b-i>=0 and d-i>=0:\\n                        bb=b if d-i>0 else b-i\\n                        aa=a if b-i>0 else a-i\\n                        cc=b-i if b-i>0 else bb\\n                        dd=d-i if d-i>0 else aa\\n                        res = min(res,1+cut_L(aa,bb,cc,dd))\\n                return res\\n            if c<d:\\n                if a-c<d:\\n                    return 1+cut_L(d,b,b-c,a-c)\\n                elif a-c==d:\\n                    return 1+cut_L(a-c,b,b,d)\\n                else:\\n                    return 1+cut_L(a-c,b,c,d)\\n            else:\\n                if b-d>c:\\n                    return 1+cut_L(a,b-d,c,d)\\n                elif b-d==c:\\n                    return 1+cut_L(a,c,c,a)\\n                else:\\n                    return 1+cut_L(a,c,b-d,a-d)\\n            return 0\\n        \\n        return cut_L(n,m,m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414250,
                "title": "python-a-greedy-solution-but-maybe-wrong-with-larger-m-n",
                "content": "I have tried 2 greedy case, get_ret1 is for the 1st & 2nd samples and get_ret2 is for the 3rd sample.\\n\\nsuppose m>=n\\nget_ret1 make it to be a n\\\\*(m-n) case.\\nget_ret2 get a a\\\\*a rectangle, then some (m-a)\\\\*(m-a) and (n-a)\\\\*(n-a) rectangles. \\nthen the rest area is seperated into 1 or 2 rectangles.\\n\\nGenerally, it\\'s a DP solution, but the transition function is greedy. \\n\\nSo I\\'m not sure it is correct with larger m & n. \\n\\n\\n```\\nclass Solution:\\n    def __init__(self) :\\n        self.gdict = {}\\n        get_key=lambda x, y:x*100+y\\n        self.gget=lambda x, y:self.gdict.get(get_key(x, y), None)\\n        def lat(x, y, v) :\\n            self.gdict[get_key(x, y)]=v\\n        self.gadd=lat\\n        \\n    def get_ret1(self, m, n) :\\n        assert m >= n\\n        if m == n :\\n            return 1\\n        elif n == 1 :\\n            return m\\n        mn, nn = min(m, n), abs(m-n)\\n        return 1+self.tilingRectangle(m=max(mn, nn), n=min(mn, nn))\\n    def get_ret2(self, m, n) :\\n        assert m >= n\\n        mint = 1e6\\n        for bigt in range((m+1)//2, n-1) :\\n            a, na = bigt, 1\\n            b = m-a\\n            nb = (a-1)//b+1\\n            c = n-a\\n            nc = a // c\\n            tangas = [[n-b*nb, m-c*nc], [c-(n-b*nb), a-c*nc]]\\n            tangbs = [[c, a-c], [n-b*nb, m-a]]\\n            nb -= 1\\n            nc += 1\\n            tangcs = [[n-b*nb, m-c*nc], [b-(m-c*nc), a-b*nb]]\\n            tangds = [[c, m-c*nc], [a-b*nb, b]]\\n            count_t = nb+nc+1\\n            all_rang = [tangas, tangbs, tangcs, tangds]\\n            for t in all_rang :\\n                # print(a, b, c, t)\\n                if min(map(min, t)) < 0 :\\n                    continue\\n                tempt = count_t + self.tilingRectangle(*t[0]) + self.tilingRectangle(*t[1])\\n                mint = min(mint, tempt)\\n                # print(count_t, tempt)\\n        return mint\\n            \\n            \\n        \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        m, n = max(m, n), min(m, n)\\n        if n == 0 :\\n            return 0\\n        \\n        temp_ans = self.gget(m, n)\\n        if not temp_ans is None :\\n            return temp_ans\\n        \\n        ret1 = self.get_ret1(m, n)\\n        if m>=2*n :\\n            return ret1\\n        \\n        ret2 = self.get_ret2(m, n)\\n        # print(m, n, ret1, ret2)\\n        to_ret = min(ret1, ret2);\\n        \\n        self.gadd(m, n, to_ret)\\n        return to_ret\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self) :\\n        self.gdict = {}\\n        get_key=lambda x, y:x*100+y\\n        self.gget=lambda x, y:self.gdict.get(get_key(x, y), None)\\n        def lat(x, y, v) :\\n            self.gdict[get_key(x, y)]=v\\n        self.gadd=lat\\n        \\n    def get_ret1(self, m, n) :\\n        assert m >= n\\n        if m == n :\\n            return 1\\n        elif n == 1 :\\n            return m\\n        mn, nn = min(m, n), abs(m-n)\\n        return 1+self.tilingRectangle(m=max(mn, nn), n=min(mn, nn))\\n    def get_ret2(self, m, n) :\\n        assert m >= n\\n        mint = 1e6\\n        for bigt in range((m+1)//2, n-1) :\\n            a, na = bigt, 1\\n            b = m-a\\n            nb = (a-1)//b+1\\n            c = n-a\\n            nc = a // c\\n            tangas = [[n-b*nb, m-c*nc], [c-(n-b*nb), a-c*nc]]\\n            tangbs = [[c, a-c], [n-b*nb, m-a]]\\n            nb -= 1\\n            nc += 1\\n            tangcs = [[n-b*nb, m-c*nc], [b-(m-c*nc), a-b*nb]]\\n            tangds = [[c, m-c*nc], [a-b*nb, b]]\\n            count_t = nb+nc+1\\n            all_rang = [tangas, tangbs, tangcs, tangds]\\n            for t in all_rang :\\n                # print(a, b, c, t)\\n                if min(map(min, t)) < 0 :\\n                    continue\\n                tempt = count_t + self.tilingRectangle(*t[0]) + self.tilingRectangle(*t[1])\\n                mint = min(mint, tempt)\\n                # print(count_t, tempt)\\n        return mint\\n            \\n            \\n        \\n    def tilingRectangle(self, n: int, m: int) -> int:\\n        m, n = max(m, n), min(m, n)\\n        if n == 0 :\\n            return 0\\n        \\n        temp_ans = self.gget(m, n)\\n        if not temp_ans is None :\\n            return temp_ans\\n        \\n        ret1 = self.get_ret1(m, n)\\n        if m>=2*n :\\n            return ret1\\n        \\n        ret2 = self.get_ret2(m, n)\\n        # print(m, n, ret1, ret2)\\n        to_ret = min(ret1, ret2);\\n        \\n        self.gadd(m, n, to_ret)\\n        return to_ret\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 414245,
                "title": "i-am-lost-backtracking-may-be-better",
                "content": "**I am lost...**\\n\\nExcept the example 3, i can give the dp solution, \\nbut when coming to example 3, I am lost.\\n\\nIt is a good question, but i think it is not suitable for interview. \\n\\n```\\npublic int tilingRectangle(int n, int m) {\\n        if (n < m) return tilingRectangle(m, n);\\n\\t\\t// special \\n        if (n == 13 && m == 11) return 6;\\n        if (m == n) return 1;\\n        int[][] dp = new int[n+1][m+1];\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 1; k <= Math.min(i, j); ++k) {\\n\\t\\t\\t\\t\\t// divide into two different sub-question\\n                    int ans = Math.min(dp[i-k][j]+dp[k][j-k], dp[i-k][k]+dp[i][j-k]) + 1;\\n                    dp[i][j] = Math.min(dp[i][j], ans);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n\\n---------------------------------------------------------\\n\\n**Backtracking solution**\\n\\nAfter view some other posts like [this one from @kevincabbage](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414329/DFS), the backtracking method would give correct solution.\\n\\nOur method is to backtracking each enums to search best solution, so how to solve this problem?\\n1. suppose the top-left position at (0, 0)\\n2. each recursion, search for the top-left unfilled cell, and try to fill bigger square.\\n\\tsuppose the position is at **(top, left)**, so the possible length of square is in **[1, min{n-top, m-left}]**, just enumerate each possible length.\\n3. continue to backtrack\\n\\nimportant optimization:\\n* when enumerate the length of square, we should select from **min{n-top, m-left}** to 1,  because the optimal solution would appear earily.\\n* we can return easily if the current num is bigger than previous num. (followed by the first point)\\n\\n```\\npublic static class Solution {\\n\\t// record the optimal solution\\n\\tprivate int res;\\n\\tpublic int tilingRectangle(int n, int m) {\\n\\t\\tboolean[][] matrix = new boolean[n][m];    // m*n cells, true means filled, false means unfilled \\u8868\\u793Am*n\\u4E2A\\u5355\\u5143\\u683C\\uFF0Cfalse\\u8868\\u793A\\u672A\\u586B\\u5145\\n\\t\\tres = m*n;  // initilazation, all 1 cell to fill\\n\\t\\tDFS(matrix, 0, m*n);\\n\\t\\treturn res;\\n\\t}\\n\\t/*\\n\\tmatrix means the cells of n*m\\n\\tcurNum means the current nums of square\\n\\tleftNum means the num of left cells\\n\\t*/\\n\\tprivate void DFS(boolean[][] matrix,  int curNum, int leftNum) {\\n\\t\\t// pruning\\n\\t\\tif (curNum >= res) return;\\n\\t\\t// finish till\\n\\t\\tif (leftNum == 0) {\\n\\t\\t\\tres = Math.min(curNum, res);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// find left-top unfilled position\\n\\t\\tint left = 0, top;\\n\\t\\tfor (top = 0; top < matrix.length; ++top) {\\n\\t\\t\\tfor (left = 0; left < matrix[0].length; ++left) {\\n\\t\\t\\t\\tif (!matrix[top][left]) break;\\n\\t\\t\\t}\\n\\t\\t\\tif (left < matrix[0].length) break;\\n\\t\\t}\\n\\t\\t// try all size square from large to small\\n\\t\\tint len = 1; // enum the length of square\\n\\t\\tfor (len = Math.min(matrix.length-top, matrix[0].length-left); len >= 1; --len) {\\n\\t\\t\\t// check if the len is valid\\n\\t\\t\\tboolean valid = true;\\n\\t\\t\\tfor (int i = top; i < top+len; ++i) {\\n\\t\\t\\t\\tfor (int j = left; j < left+len; ++j) {\\n\\t\\t\\t\\t\\tif (matrix[i][j]) {\\n\\t\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!valid) break;\\n\\t\\t\\t}\\n\\t\\t\\tif (!valid) continue;\\n\\t\\t\\t// fill\\n\\t\\t\\tfor (int i = top; i < top+len; ++i) {\\n\\t\\t\\t\\tfor (int j = left; j < left + len; ++j) {\\n\\t\\t\\t\\t\\tmatrix[i][j] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tDFS(matrix, curNum+1, leftNum-len*len);\\n\\t\\t\\t// unfill\\n\\t\\t\\tfor (int i = top; i < top+len; ++i) {\\n\\t\\t\\t\\tfor (int j = left; j < left + len; ++j) {\\n\\t\\t\\t\\t\\tmatrix[i][j] = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int tilingRectangle(int n, int m) {\\n        if (n < m) return tilingRectangle(m, n);\\n\\t\\t// special \\n        if (n == 13 && m == 11) return 6;\\n        if (m == n) return 1;\\n        int[][] dp = new int[n+1][m+1];\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 1; k <= Math.min(i, j); ++k) {\\n\\t\\t\\t\\t\\t// divide into two different sub-question\\n                    int ans = Math.min(dp[i-k][j]+dp[k][j-k], dp[i-k][k]+dp[i][j-k]) + 1;\\n                    dp[i][j] = Math.min(dp[i][j], ans);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```\\npublic static class Solution {\\n\\t// record the optimal solution\\n\\tprivate int res;\\n\\tpublic int tilingRectangle(int n, int m) {\\n\\t\\tboolean[][] matrix = new boolean[n][m];    // m*n cells, true means filled, false means unfilled \\u8868\\u793Am*n\\u4E2A\\u5355\\u5143\\u683C\\uFF0Cfalse\\u8868\\u793A\\u672A\\u586B\\u5145\\n\\t\\tres = m*n;  // initilazation, all 1 cell to fill\\n\\t\\tDFS(matrix, 0, m*n);\\n\\t\\treturn res;\\n\\t}\\n\\t/*\\n\\tmatrix means the cells of n*m\\n\\tcurNum means the current nums of square\\n\\tleftNum means the num of left cells\\n\\t*/\\n\\tprivate void DFS(boolean[][] matrix,  int curNum, int leftNum) {\\n\\t\\t// pruning\\n\\t\\tif (curNum >= res) return;\\n\\t\\t// finish till\\n\\t\\tif (leftNum == 0) {\\n\\t\\t\\tres = Math.min(curNum, res);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// find left-top unfilled position\\n\\t\\tint left = 0, top;\\n\\t\\tfor (top = 0; top < matrix.length; ++top) {\\n\\t\\t\\tfor (left = 0; left < matrix[0].length; ++left) {\\n\\t\\t\\t\\tif (!matrix[top][left]) break;\\n\\t\\t\\t}\\n\\t\\t\\tif (left < matrix[0].length) break;\\n\\t\\t}\\n\\t\\t// try all size square from large to small\\n\\t\\tint len = 1; // enum the length of square\\n\\t\\tfor (len = Math.min(matrix.length-top, matrix[0].length-left); len >= 1; --len) {\\n\\t\\t\\t// check if the len is valid\\n\\t\\t\\tboolean valid = true;\\n\\t\\t\\tfor (int i = top; i < top+len; ++i) {\\n\\t\\t\\t\\tfor (int j = left; j < left+len; ++j) {\\n\\t\\t\\t\\t\\tif (matrix[i][j]) {\\n\\t\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!valid) break;\\n\\t\\t\\t}\\n\\t\\t\\tif (!valid) continue;\\n\\t\\t\\t// fill\\n\\t\\t\\tfor (int i = top; i < top+len; ++i) {\\n\\t\\t\\t\\tfor (int j = left; j < left + len; ++j) {\\n\\t\\t\\t\\t\\tmatrix[i][j] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tDFS(matrix, curNum+1, leftNum-len*len);\\n\\t\\t\\t// unfill\\n\\t\\t\\tfor (int i = top; i < top+len; ++i) {\\n\\t\\t\\t\\tfor (int j = left; j < left + len; ++j) {\\n\\t\\t\\t\\t\\tmatrix[i][j] = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414236,
                "title": "is-this-a-well-known-problem-or-what",
                "content": "I wonder if this is a classic or well-known question... How come so many people know the answer already??",
                "solutionTags": [],
                "code": "I wonder if this is a classic or well-known question... How come so many people know the answer already??",
                "codeTag": "Java"
            },
            {
                "id": 414232,
                "title": "c-brutal-force",
                "content": "What is the time complexicty, it\\'s like boooooooooom, I am surprise that this can pass... \\nTo improve, I guess how to expand a square can improve.\\n```\\nclass Solution {\\npublic:\\n// help to tell start from (x,y) as left top croner, can you make a squre with side length l \\nbool help2(vector<vector<int>>& board, int x, int y, int l) {\\n    for (int i = x; i <= x + l - 1; i++) {\\n        for (int j = y; j <= y + l - 1; j++) {\\n            if (i >= board.size() || j>=board[0].size())\\n                return false;\\n            if (board[i][j])\\n                return false;\\n        }\\n    }\\n    return true;\\n}\\n// help to tell where is the most left top empty cell(i,j), and what is the max side length of square can make from this cell. {i,j, max side length squre from ij}\\nvector<int> help(vector<vector<int>>& board) {\\n    int k = 1;\\n    int i = 0;\\n    for (; i < (int)board.size(); i++) {\\n        int j = 0;\\n        for (; j <(int)board[0].size(); j++) {\\n            // cout  << i << \" \" << j << endl;\\n            if (board[i][j] == 0) {\\n                for (; k <= 13; k++) {\\n                    if (i + k - 1 < board.size() && j + k - 1 < board[0].size()) {\\n                        if (!help2(board, i, j, k)) {\\n                            break;\\n                        }\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return {i,j,k-1};\\n            }\\n        }\\n    }\\n    return {};\\n}\\n\\n// use for back tracking , can set a square to 0 or 1.\\nvoid help3(vector<vector<int>>& board, int x, int y, int l, int flag) {\\n    for (int i = x; i <= x + l - 1; i++) {\\n        for (int j = y; j <= y + l - 1; j++) {\\n            board[i][j] = flag;\\n        }\\n    }\\n}\\nvoid dfs(vector<vector<int>>& board, int cur_square, int left, int& result) {\\n    if (cur_square >= result)\\n        return;\\n    if (left == 0) {\\n        \\n        result = min(result, cur_square);\\n        return;\\n    }\\n    vector<int> h = help(board);\\n\\n    \\n     for (int k = h[2]; k >=1; k--) {\\n        help3(board,h[0],h[1],k,1);\\n        dfs(board, cur_square + 1, left - k*k, result);\\n        help3(board,h[0],h[1],k,0);\\n    }\\n}\\n\\nint tilingRectangle(int n, int m) {\\n    if (n==m)\\n        return 1;\\n    if (n > m) {\\n        swap(n,m);\\n    }\\n    vector<vector<int>> board(n, vector<int>(m,0));\\n    int result = INT_MAX;\\n    dfs(board, 0, m * n, result);\\n    \\n    return result;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n// help to tell start from (x,y) as left top croner, can you make a squre with side length l \\nbool help2(vector<vector<int>>& board, int x, int y, int l) {\\n    for (int i = x; i <= x + l - 1; i++) {\\n        for (int j = y; j <= y + l - 1; j++) {\\n            if (i >= board.size() || j>=board[0].size())\\n                return false;\\n            if (board[i][j])\\n                return false;\\n        }\\n    }\\n    return true;\\n}\\n// help to tell where is the most left top empty cell(i,j), and what is the max side length of square can make from this cell. {i,j, max side length squre from ij}\\nvector<int> help(vector<vector<int>>& board) {\\n    int k = 1;\\n    int i = 0;\\n    for (; i < (int)board.size(); i++) {\\n        int j = 0;\\n        for (; j <(int)board[0].size(); j++) {\\n            // cout  << i << \" \" << j << endl;\\n            if (board[i][j] == 0) {\\n                for (; k <= 13; k++) {\\n                    if (i + k - 1 < board.size() && j + k - 1 < board[0].size()) {\\n                        if (!help2(board, i, j, k)) {\\n                            break;\\n                        }\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return {i,j,k-1};\\n            }\\n        }\\n    }\\n    return {};\\n}\\n\\n// use for back tracking , can set a square to 0 or 1.\\nvoid help3(vector<vector<int>>& board, int x, int y, int l, int flag) {\\n    for (int i = x; i <= x + l - 1; i++) {\\n        for (int j = y; j <= y + l - 1; j++) {\\n            board[i][j] = flag;\\n        }\\n    }\\n}\\nvoid dfs(vector<vector<int>>& board, int cur_square, int left, int& result) {\\n    if (cur_square >= result)\\n        return;\\n    if (left == 0) {\\n        \\n        result = min(result, cur_square);\\n        return;\\n    }\\n    vector<int> h = help(board);\\n\\n    \\n     for (int k = h[2]; k >=1; k--) {\\n        help3(board,h[0],h[1],k,1);\\n        dfs(board, cur_square + 1, left - k*k, result);\\n        help3(board,h[0],h[1],k,0);\\n    }\\n}\\n\\nint tilingRectangle(int n, int m) {\\n    if (n==m)\\n        return 1;\\n    if (n > m) {\\n        swap(n,m);\\n    }\\n    vector<vector<int>> board(n, vector<int>(m,0));\\n    int result = INT_MAX;\\n    dfs(board, 0, m * n, result);\\n    \\n    return result;\\n}\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1564928,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1565213,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1566658,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1568236,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1567631,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1574505,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1573560,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1573138,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1574310,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1573562,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1564928,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1565213,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1566658,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1568236,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1567631,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1574505,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1573560,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1573138,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1574310,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1573562,
                "content": [
                    {
                        "username": "lee215",
                        "content": "Solution [here](http://int-e.eu/~bf3/squares/young.cc)\\n[Cheat Table](http://int-e.eu/~bf3/squares/young.txt)\\n\\nThough it\\'s a well known problem,\\nis it really problem for interview?\\n\\nI think if we can only cuts rectagle into rectaglex,\\nit can be solved by dp,\\nwhich makes more sense as an interview problem.\\n\\nAs you can see in the example 1 and exampl 2,\\nthe original rectangle are cuts into rectagles each time.\\nWhile example 3 has an annoying small square in the middle.\\n\\nBut it seems that, `[11, 13]` in the example 3 is the only special case within size of 13.\\n"
                    },
                    {
                        "username": "zerotrac2",
                        "content": "I have taken the same action (pre-calculated all the answers and stored them into an array) in Weekly Contest 80 Problem 4 but was unfortunately banned by Leetcode.\\n\\nBelow is what I have received when arguing with Leetcode administrators:\\n\\n\"Our contest organizers decided to ban all solutions which pre-calculate the results in order to evade TLE results due to concern of fairness raised by other contestants. We reserve the right to have the final say in the decision. Thanks for your understanding.\"\\n\\nSo PLEASE unrate this contest. Since there are so many solutions with pre-calculation and tricky DP."
                    },
                    {
                        "username": "user3779R",
                        "content": "that\\'s kind of interesting\\u3002\\nhttp://int-e.eu/~bf3/squares/view.html#13,11"
                    },
                    {
                        "username": "danielchandg",
                        "content": "The solutions so far all have an if statement for the special case of 11x13, and assumes every other solution can cut the rectangle. I am wondering if there is a more universal solution. For example, maybe if the problem\\'s parameters were 1<=m,n<=14, how would we solve it, given that we cannot hardcode for special cases?"
                    },
                    {
                        "username": "pgmreddy",
                        "content": "---\\n\\nThis one is too hard one to be given in for contest.\\nHowever, solvable in an hour, in theory, even if you dont know earlier by reading below links. And, since some can code in 5 mins, so possible.\\nFeel free to share a code solution based on the below, I am exhausted for the day. :)\\n\\n---\\n\\n**Algo**\\n- Pictorial solution below\\n- Rules in the picture\\n- Related links:\\n  - https://en.wikipedia.org/wiki/Squaring_the_square#Squaring_the_plane\\n  - https://en.wikipedia.org/wiki/Tessellation\\n  - https://en.wikipedia.org/wiki/Squaring_the_square\\n\\nHope it is simple to understand.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/cc8a73c1-43c8-4d61-abaa-9ac59dddcc9f_1625233251.8624575.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/8feb8202-9028-4c16-9b96-8a9b00d84d76_1625233272.520392.png)\\n\\n---\\n"
                    },
                    {
                        "username": "user1434C",
                        "content": "I see many solutions out here, but do not see much discussion on time complexity. Please help if someone has figured out.\\n\\nI feel O (N\\\\*M\\\\*N). N=rows, M=cols\\n\\nThat is, for each cell (N\\\\*M) we try out N options."
                    },
                    {
                        "username": "bluecloud",
                        "content": "Say you\\'re asked this question during interview. Is it best to give DP or backtracking solution?\\n\\nHopefully interviewer would guide in right direction, but what if not?\\n\\nThis problem seems at first like DP. I think it\\'s difficult to uncover the 11, 13 case, and there might be more cases.\\n\\nThe interviewer may prefer DP (accepting the wrong cases), or backtracking due to correctness. Or either is fine."
                    },
                    {
                        "username": "Don12138",
                        "content": "so many people are talking about dp,As a novice,Can i ask what is dp?"
                    },
                    {
                        "username": "Boboppity",
                        "content": "Super late reply, you have probably found your answer by now, but I already started typing...\\n\\ndp == dynamic programming\\n\\nIt\\'s a convention to solve non-deterministic/optimization problems quickly (psuedo-polynomial time).\\n\\nA non-deterministic problem is one where there may be many equally preferable paths to a solution and/or equally preferable solutions. (see pgmreddy\\'s comment above for an example of equally preferable solutions). \\n\\nPsuedo-polynomial time, is polynomial time on the input value as opposed to the input size.\\n- A polynomial time algorithm could reach a solution in time based on a polynomial of the input size. This could look something like O(t^3) or O(t^10), where t is the number of inputs (input size) i.e. sort a list of t integers.\\n- A psuedo-polynomial time algorithm could reach solution in time based on a polynomial of the input value, which could look something like O(t*b) where b could be a weight capacity (input value) and t is the number of items with weights to fill the capacity (input size). This would be exponential in input size but polynomial in input value.\\n\\nWhy dynamic programming?\\nTo mitigate the difficulty of having multiple preferable paths to a solution, you start with a small version of the problem (based on input size), and use the solution to the small problem to narrow the solution space for the next problem small+1, and so on until you have found a solution to the size of the actual problem (small+n == b) you wish to solve. i.e. if there is no solution to the problem of size b, then the solution to the problem of size b-1 is the best, and so on.\\nThis approach is called tabulation (bottom up).\\nIt is typically faster than classical approaches, and there is generally a recursive nature to the problem you are trying to solve, BUT you never use recursion within the dp solution.\\nFor example, the naive recursive approach to fibonacci is O(2^n) time where n is the nth fibonacci number where as the dp approach is O(n) time. In this case the input value == input size, and you solve for the each sub problem using the solution from the previous sub problem to build to your final solution. fib(1), fib(2), ...., fib(n).\\n\\nI took this course on the subject. It\\'s free, https://learn.udacity.com/courses/ud401"
                    },
                    {
                        "username": "poojagl85",
                        "content": "[https://medium.com/@poojagl85/1240-tiling-a-rectangle-with-the-fewest-squares-leetcode-c6e6b348d42e](http://)\\n\\nif you like the solution do give some claps."
                    },
                    {
                        "username": "gsp26",
                        "content": "can anyone explain ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimize Deviation in Array",
        "question_content": "<p>You are given an array <code>nums</code> of <code>n</code> positive integers.</p>\n\n<p>You can perform two types of operations on any element of the array any number of times:</p>\n\n<ul>\n\t<li>If the element is <strong>even</strong>, <strong>divide</strong> it by <code>2</code>.\n\n\t<ul>\n\t\t<li>For example, if the array is <code>[1,2,3,4]</code>, then you can do this operation on the last element, and the array will be <code>[1,2,3,<u>2</u>].</code></li>\n\t</ul>\n\t</li>\n\t<li>If the element is <strong>odd</strong>, <strong>multiply</strong> it by <code>2</code>.\n\t<ul>\n\t\t<li>For example, if the array is <code>[1,2,3,4]</code>, then you can do this operation on the first element, and the array will be <code>[<u>2</u>,2,3,4].</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>The <strong>deviation</strong> of the array is the <strong>maximum difference</strong> between any two elements in the array.</p>\n\n<p>Return <em>the <strong>minimum deviation</strong> the array can have after performing some number of operations.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You can transform the array to [1,2,3,<u>2</u>], then to [<u>2</u>,2,3,2], then the deviation will be 3 - 2 = 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,1,5,20,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You can transform the array after two operations to [4,<u>2</u>,5,<u>5</u>,3], then the deviation will be 5 - 2 = 3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,10,8]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style=\"font-size: 10.8333px;\">4</span></sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 955262,
                "title": "c-intuitions-and-flip",
                "content": "We have two types of operations: double odd numbers, and halve even numbers. We can try to sort all numbers, and increase the smallest number (if it\\'s odd) and decrease the largest number (if it\\'s even). This can get quite complicated.\\n\\n**Intuition 1**: we can divide even numbers multiple times - till we get an odd number, but we can only double odd numbers once. After that, it will become an even number.\\n\\n**Intuition 2:** Even numbers never increase.\\n\\n**Flip**: we can double all odd numbers first, so we can get forget of the second operation. Now, we only need to decrease the largest number - while it\\'s even, which results a very simple solution. \\n\\n**Solution**\\nDouble odd numbers and put all numbers into a max heap. Track the smallest number. Track the minimum difference between the top of the heap and the smallest number. While the top of the heap is even, remove it, divide, and put back to the heap.\\n\\nTwo solutions below use the same approach; the first one is easier to read, and the second one - faster (since we use the array version of max heap).\\n\\n**priority_queue**\\n```cpp\\nint minimumDeviation(vector<int>& nums) {\\n    int res = INT_MAX, min_n = INT_MAX;\\n    priority_queue<int> pq;\\n    for (auto n : nums) {\\n        n = n % 2 ? n * 2 : n;\\n        pq.push(n);\\n        min_n = min(min_n, n); \\n    }\\n    while (pq.top() % 2 == 0) {\\n        res = min(res, pq.top() - min_n);\\n        min_n = min(min_n, pq.top() / 2);\\n        pq.push(pq.top() / 2);\\n        pq.pop();\\n    }\\n    return min(res, pq.top() - min_n);\\n}\\n```\\n**make_heap**\\n```cpp\\nint minimumDeviation(vector<int>& n) {\\n    int res = INT_MAX, min_n = INT_MAX;\\n    for (int i = 0; i < n.size(); ++i) {\\n        n[i] = n[i] % 2 ? n[i] * 2 : n[i];\\n        min_n = min(min_n, n[i]);\\n    }     \\n    make_heap(begin(n), end(n));\\n    while (n[0] % 2 == 0) {\\n        res = min(res, n[0] - min_n);\\n        min_n = min(min_n, n[0] / 2);\\n        pop_heap(begin(n), end(n));\\n        n.back() /= 2;\\n        push_heap(begin(n), end(n));\\n    }\\n    return min(res, n[0] - min_n);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimumDeviation(vector<int>& nums) {\\n    int res = INT_MAX, min_n = INT_MAX;\\n    priority_queue<int> pq;\\n    for (auto n : nums) {\\n        n = n % 2 ? n * 2 : n;\\n        pq.push(n);\\n        min_n = min(min_n, n); \\n    }\\n    while (pq.top() % 2 == 0) {\\n        res = min(res, pq.top() - min_n);\\n        min_n = min(min_n, pq.top() / 2);\\n        pq.push(pq.top() / 2);\\n        pq.pop();\\n    }\\n    return min(res, pq.top() - min_n);\\n}\\n```\n```cpp\\nint minimumDeviation(vector<int>& n) {\\n    int res = INT_MAX, min_n = INT_MAX;\\n    for (int i = 0; i < n.size(); ++i) {\\n        n[i] = n[i] % 2 ? n[i] * 2 : n[i];\\n        min_n = min(min_n, n[i]);\\n    }     \\n    make_heap(begin(n), end(n));\\n    while (n[0] % 2 == 0) {\\n        res = min(res, n[0] - min_n);\\n        min_n = min(min_n, n[0] / 2);\\n        pop_heap(begin(n), end(n));\\n        n.back() /= 2;\\n        push_heap(begin(n), end(n));\\n    }\\n    return min(res, n[0] - min_n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3223541,
                "title": "day-55-priority-queue-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\nThe intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create a max heap and a variable to keep track of the minimum value in the array.\\n2. For each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\n3. Also, update the minimum value if necessary.\\n4. Initialize a variable to keep track of the minimum deviation.\\n5. While the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\n6. If the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\n7. Return the minimum deviation.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int minVal = INT_MAX;\\n        for (int num : nums) {\\n            if (num % 2 == 1)\\n                num = num * 2;\\n            pq.push(num);\\n            minVal = min(minVal, num);\\n        }\\n        int minDeviation = INT_MAX;\\n        while (true) {\\n            int maxVal = pq.top();\\n            pq.pop();\\n            minDeviation = min(minDeviation, maxVal - minVal);\\n            //The reason we need to break out of the loop when the maximum value is odd is that we have already transformed all odd numbers in the input array to even numbers by multiplying them by 2. Therefore, if the maximum value in the priority queue is odd, it must have been obtained by performing the \"multiply by 2\" operation on some even number. We cannot undo this operation by performing the \"divide by 2\" operation, so we cannot reduce the maximum value any further.\\n            if (maxVal % 2 == 1)\\n                break;\\n            maxVal = maxVal / 2;\\n            minVal = min(minVal, maxVal);\\n            pq.push(maxVal);\\n        }\\n        return minDeviation;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int minVal = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1)\\n                num = num * 2;\\n            pq.offer(num);\\n            minVal = Math.min(minVal, num);\\n        }\\n        int minDeviation = Integer.MAX_VALUE;\\n        while (true) {\\n            int maxVal = pq.poll();\\n            minDeviation = Math.min(minDeviation, maxVal - minVal);\\n            if (maxVal % 2 == 1)\\n                break;\\n            maxVal = maxVal / 2;\\n            minVal = Math.min(minVal, maxVal);\\n            pq.offer(maxVal);\\n        }\\n        return minDeviation;\\n    }\\n}\\n\\n```\\n```Python []\\n///Note : In the Python code, we use a min-heap instead of a max-heap because Python\\'s heapq module only provides a min-heap implementation. Therefore, we negate the values in the heap to simulate a max-heap.\\n\\nimport heapq\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        pq = [-num*2 if num % 2 == 1 else -num for num in nums]\\n        heapq.heapify(pq)\\n        min_val = -float(\\'inf\\')\\n        for num in nums:\\n            min_val = min(min_val, -num if num % 2 == 0 else -num*2)\\n        min_deviation = float(\\'inf\\')\\n        while True:\\n            max_val = -heapq.heappop(pq)\\n            min_deviation = min(min_deviation, max_val - min_val)\\n            if max_val % 2 == 1:\\n                break\\n            max_val //= 2\\n            min_val = min(min_val, -max_val)\\n            heapq.heappush(pq, -max_val)\\n        return min_deviation\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(nlogn)**\\nThe algorithm involves inserting n elements(worst case) into a priority queue, which takes O(n log n) time. The while loop iterates at most log(maximum value in the array) times. In the worst case, the maximum value can be as large as 10^9, so the loop iterates log(10^9) times, which is a constant value. The operations inside the loop take O(log n) time, which is the time required to insert or delete an element from the priority queue. Therefore, the overall time complexity of the algorithm is O(n log n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\nThe algorithm uses a priority queue to store the elements, which takes O(n) space. Additionally, it uses a few constant-size variables to keep track of the minimum and maximum values, as well as the answer. Therefore, the overall space complexity of the algorithm is O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int minVal = INT_MAX;\\n        for (int num : nums) {\\n            if (num % 2 == 1)\\n                num = num * 2;\\n            pq.push(num);\\n            minVal = min(minVal, num);\\n        }\\n        int minDeviation = INT_MAX;\\n        while (true) {\\n            int maxVal = pq.top();\\n            pq.pop();\\n            minDeviation = min(minDeviation, maxVal - minVal);\\n            //The reason we need to break out of the loop when the maximum value is odd is that we have already transformed all odd numbers in the input array to even numbers by multiplying them by 2. Therefore, if the maximum value in the priority queue is odd, it must have been obtained by performing the \"multiply by 2\" operation on some even number. We cannot undo this operation by performing the \"divide by 2\" operation, so we cannot reduce the maximum value any further.\\n            if (maxVal % 2 == 1)\\n                break;\\n            maxVal = maxVal / 2;\\n            minVal = min(minVal, maxVal);\\n            pq.push(maxVal);\\n        }\\n        return minDeviation;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int minVal = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1)\\n                num = num * 2;\\n            pq.offer(num);\\n            minVal = Math.min(minVal, num);\\n        }\\n        int minDeviation = Integer.MAX_VALUE;\\n        while (true) {\\n            int maxVal = pq.poll();\\n            minDeviation = Math.min(minDeviation, maxVal - minVal);\\n            if (maxVal % 2 == 1)\\n                break;\\n            maxVal = maxVal / 2;\\n            minVal = Math.min(minVal, maxVal);\\n            pq.offer(maxVal);\\n        }\\n        return minDeviation;\\n    }\\n}\\n\\n```\n```Python []\\n///Note : In the Python code, we use a min-heap instead of a max-heap because Python\\'s heapq module only provides a min-heap implementation. Therefore, we negate the values in the heap to simulate a max-heap.\\n\\nimport heapq\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        pq = [-num*2 if num % 2 == 1 else -num for num in nums]\\n        heapq.heapify(pq)\\n        min_val = -float(\\'inf\\')\\n        for num in nums:\\n            min_val = min(min_val, -num if num % 2 == 0 else -num*2)\\n        min_deviation = float(\\'inf\\')\\n        while True:\\n            max_val = -heapq.heappop(pq)\\n            min_deviation = min(min_deviation, max_val - min_val)\\n            if max_val % 2 == 1:\\n                break\\n            max_val //= 2\\n            min_val = min(min_val, -max_val)\\n            heapq.heappush(pq, -max_val)\\n        return min_deviation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781709,
                "title": "c-easy-2-approaches-priority-queue-set",
                "content": "# 1675. Minimize Deviation in Array\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2 approaches one using Priority Queue & other using Set. \\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**APPROACH 1 USING PRIORITY QUEUE**\\n\\n**EXPLANATION**\\n\\n```\\n1. To decrease the deviation either increase the minn or decrease the maxx.\\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\\n3. since every element is as maximum as possible , you can not increase any number further\\n4. Now we are left with just one operation decrease the maxx\\n5. So perform this operation as many times as u can and keep track of the min_deviation\\n```\\n\\n**Time Complexity: O(nlog(m)log(n))**\\n**Space Complexity: O(n)**\\n\\n**If the maximum element is m, the number of candidates in its range is at most log(m), which happens when it is a power of 2. There are n elements, for a maximum of nlog(m) candidates. At each step, a new element is inserted into the priority queue with a time complexity of O(log(n)).**\\n\\n*Complexity: O(nlog(m)log(n)) time, O(n) space*\\n\\n**CODE**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n = nums.size();\\n        int mx = INT_MIN, mn = INT_MAX;\\n        \\n        // Increasing all elements to as maximum as it can and tranck the minimum,\\n        // number and also the resutl\\n        for(int i = 0; i<n; ++i)\\n        {\\n            if((nums[i]%2) != 0)    // multiplication by 2 if nums[i] is odd\\n                nums[i] *= 2;   // maximising all odd numbers\\n\\n        \\n            mx = max(mx,nums[i]);\\n            mn = min(mn,nums[i]);\\n        }\\n        \\n        int min_deviation = mx - mn;\\n        \\n        priority_queue<int> pq;\\n        // Inserting into Priority queue (Max Heap) and try to decrease as much we can\\n        for(int i = 0; i<n; ++i)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        \\n        while((pq.top()) % 2 == 0)\\n        {\\n            int top = pq.top();\\n            pq.pop(); // popped the top element\\n            \\n            min_deviation = min(min_deviation, top - mn);\\n            top /= 2;\\n            mn = min(mn, top);  // updating min\\n            pq.push(top);   // pushing again the top as we have to minimize the max\\n        }\\n        \\n        min_deviation = min(min_deviation, pq.top() - mn);\\n        \\n        // we are returning mx - mn\\n        \\n        return min_deviation;\\n    }\\n};\\n\\n```\\n\\n**APPROACH 2 USING SET**\\n\\n**EXPLANATION**\\n\\n```\\nEven numbers can be divided multiple times until it converts to an odd number.\\nOdd numbers can be doubled only once as it converts to an even number.\\nTherefore, even numbers can never be increased.\\nFollow the steps below to solve the problem: \\n \\n\\n1. Traverse the vector and double all the odd vector elements. This nullifies the requirement for the 2nd operation.\\n2. Now, decrease the largest vector element while it\\u2019s even.\\n3. To store the vector elements in sorted manner, insert all vector elements into a Set.\\n4. Greedily reduce the maximum element present in the Set\\n5. If the maximum element present in the Set is odd, break the loop.\\n6. Print the minimum deviation obtained.\\n```\\n\\n**Time Complexity : O(N * log(N))**\\n**Space Complexity : O(N)**\\n\\n**while loop O(n)\\n1.) begin():-Returns an iterator to the first element in the set. Tc=O(log(n))\\n2.) rbegin():-Returns a reverse iterator pointing to the last element in the container. Tc=O(log(n))**\\n\\n*Hence,\\nWorst caseTime Complexity= O(n * log(n));*\\n\\n**CODE**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set <int>  s;\\n        \\n        // Storing all  elements  in sorted order\\n        //insert even directly and odd with one time multiplication\\n        //and it will become even\\n        for(int i = 0; i<nums.size() ; ++i)\\n        {\\n            if(nums[i] % 2 == 0)\\n                s.insert(nums[i]);\\n            \\n            else\\n                // Odd number are transformed\\n                // using 2nd operation\\n                s.insert(nums[i] * 2);\\n        }\\n        \\n        // maximum - minimun\\n        int diff = *s.rbegin() - *s.begin();\\n        \\n        //run the loop untill difference is minimized\\n        while(*s.rbegin() % 2 == 0)\\n        {\\n            \\n            // Maximum element of the set\\n            int x = *s.rbegin();\\n            s.erase(x);\\n            // remove begin element and inserted half of it for minimizing\\n            s.insert(x/2);\\n            \\n            diff = min(diff, *s.rbegin() - *s.begin());\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2 approaches one using Priority Queue & other using Set. \\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n1. To decrease the deviation either increase the minn or decrease the maxx.\\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\\n3. since every element is as maximum as possible , you can not increase any number further\\n4. Now we are left with just one operation decrease the maxx\\n5. So perform this operation as many times as u can and keep track of the min_deviation\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n = nums.size();\\n        int mx = INT_MIN, mn = INT_MAX;\\n        \\n        // Increasing all elements to as maximum as it can and tranck the minimum,\\n        // number and also the resutl\\n        for(int i = 0; i<n; ++i)\\n        {\\n            if((nums[i]%2) != 0)    // multiplication by 2 if nums[i] is odd\\n                nums[i] *= 2;   // maximising all odd numbers\\n\\n        \\n            mx = max(mx,nums[i]);\\n            mn = min(mn,nums[i]);\\n        }\\n        \\n        int min_deviation = mx - mn;\\n        \\n        priority_queue<int> pq;\\n        // Inserting into Priority queue (Max Heap) and try to decrease as much we can\\n        for(int i = 0; i<n; ++i)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        \\n        while((pq.top()) % 2 == 0)\\n        {\\n            int top = pq.top();\\n            pq.pop(); // popped the top element\\n            \\n            min_deviation = min(min_deviation, top - mn);\\n            top /= 2;\\n            mn = min(mn, top);  // updating min\\n            pq.push(top);   // pushing again the top as we have to minimize the max\\n        }\\n        \\n        min_deviation = min(min_deviation, pq.top() - mn);\\n        \\n        // we are returning mx - mn\\n        \\n        return min_deviation;\\n    }\\n};\\n\\n```\n```\\nEven numbers can be divided multiple times until it converts to an odd number.\\nOdd numbers can be doubled only once as it converts to an even number.\\nTherefore, even numbers can never be increased.\\nFollow the steps below to solve the problem: \\n \\n\\n1. Traverse the vector and double all the odd vector elements. This nullifies the requirement for the 2nd operation.\\n2. Now, decrease the largest vector element while it\\u2019s even.\\n3. To store the vector elements in sorted manner, insert all vector elements into a Set.\\n4. Greedily reduce the maximum element present in the Set\\n5. If the maximum element present in the Set is odd, break the loop.\\n6. Print the minimum deviation obtained.\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set <int>  s;\\n        \\n        // Storing all  elements  in sorted order\\n        //insert even directly and odd with one time multiplication\\n        //and it will become even\\n        for(int i = 0; i<nums.size() ; ++i)\\n        {\\n            if(nums[i] % 2 == 0)\\n                s.insert(nums[i]);\\n            \\n            else\\n                // Odd number are transformed\\n                // using 2nd operation\\n                s.insert(nums[i] * 2);\\n        }\\n        \\n        // maximum - minimun\\n        int diff = *s.rbegin() - *s.begin();\\n        \\n        //run the loop untill difference is minimized\\n        while(*s.rbegin() % 2 == 0)\\n        {\\n            \\n            // Maximum element of the set\\n            int x = *s.rbegin();\\n            s.erase(x);\\n            // remove begin element and inserted half of it for minimizing\\n            s.insert(x/2);\\n            \\n            diff = min(diff, *s.rbegin() - *s.begin());\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952857,
                "title": "java-c-python-priority-queue",
                "content": "# Explanation\\nFor each `a` in `A`,\\ndivide `a` by 2 until it is an odd.\\nPush divided `a` and its original value in to the `pq`.\\n\\nThe current max value in `pq` is noted as `ma`.\\nWe iterate from the smallest value in `pq`,\\nUpdate `res = min(res, ma - a)`,\\nthen we check we can get `a * 2`.\\n\\nIf `a` is an odd, we can get `a * 2`,\\nIf `a < a0`, which is its original value, we can also get `a*2`.\\n\\nIf we can, we push `[a*2,a0]` back to the pq and continue this process.\\n<br>\\n\\n# Complexity\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n# Solution 1: Use Priority Queue\\n**Python**\\n```py\\n    def minimumDeviation(self, A):\\n        pq = []\\n        for a in A:\\n            heapq.heappush(pq, [a / (a & -a), a])\\n        res = float(\\'inf\\')\\n        ma = max(a for a, a0 in pq)\\n        while len(pq) == len(A):\\n            a, a0 = heapq.heappop(pq)\\n            res = min(res, ma - a)\\n            if a % 2 == 1 or a < a0:\\n                ma = max(ma, a * 2)\\n                heapq.heappush(pq, [a * 2, a0])\\n        return res\\n```\\n<br>\\n\\n# Solution 2: Use Tree\\nSince odd can only be doubled once,\\nand even can not be doubled.\\nWe can double all odds first.\\n\\n**Java, using PriorityQueue**\\n```java\\n    public int minimumDeviation(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        int n = A.length, mi = Integer.MAX_VALUE, res = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            if (a % 2 == 1) a *= 2;\\n            pq.add(-a);\\n            mi = Math.min(mi, a);\\n        }\\n        while (true) {\\n            int a = -pq.poll();\\n            res = Math.min(res, a - mi);\\n            if (a % 2 == 1) break;\\n            mi = Math.min(mi, a / 2);\\n            pq.add(-a / 2);\\n        }\\n        return res;\\n    }\\n```\\n**Python, using heap**\\n```py\\n    def minimumDeviation(self, A):\\n        pq = []\\n        for a in A:\\n            heapq.heappush(pq, -a * 2 if a % 2 else -a)\\n        res = float(\\'inf\\')\\n        mi = -max(pq)\\n        while len(pq) == len(A):\\n            a = -heapq.heappop(pq)\\n            res = min(res, a - mi)\\n            if a % 2 == 0:\\n                mi = min(mi, a / 2)\\n                heapq.heappush(pq, -a / 2)\\n        return res\\n```\\n**C++, using set**\\n```cpp\\n    int minimumDeviation(vector<int>& A) {\\n        set<int> s;\\n        for (int &a : A)\\n            s.insert(a % 2 ? a * 2 : a);\\n        int res = *s.rbegin() - *s.begin();\\n        while (*s.rbegin() % 2 == 0) {\\n            s.insert(*s.rbegin() / 2);\\n            s.erase(*s.rbegin());\\n            res = min(res, *s.rbegin() - *s.begin());\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```py\\n    def minimumDeviation(self, A):\\n        pq = []\\n        for a in A:\\n            heapq.heappush(pq, [a / (a & -a), a])\\n        res = float(\\'inf\\')\\n        ma = max(a for a, a0 in pq)\\n        while len(pq) == len(A):\\n            a, a0 = heapq.heappop(pq)\\n            res = min(res, ma - a)\\n            if a % 2 == 1 or a < a0:\\n                ma = max(ma, a * 2)\\n                heapq.heappush(pq, [a * 2, a0])\\n        return res\\n```\n```java\\n    public int minimumDeviation(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        int n = A.length, mi = Integer.MAX_VALUE, res = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            if (a % 2 == 1) a *= 2;\\n            pq.add(-a);\\n            mi = Math.min(mi, a);\\n        }\\n        while (true) {\\n            int a = -pq.poll();\\n            res = Math.min(res, a - mi);\\n            if (a % 2 == 1) break;\\n            mi = Math.min(mi, a / 2);\\n            pq.add(-a / 2);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minimumDeviation(self, A):\\n        pq = []\\n        for a in A:\\n            heapq.heappush(pq, -a * 2 if a % 2 else -a)\\n        res = float(\\'inf\\')\\n        mi = -max(pq)\\n        while len(pq) == len(A):\\n            a = -heapq.heappop(pq)\\n            res = min(res, a - mi)\\n            if a % 2 == 0:\\n                mi = min(mi, a / 2)\\n                heapq.heappush(pq, -a / 2)\\n        return res\\n```\n```cpp\\n    int minimumDeviation(vector<int>& A) {\\n        set<int> s;\\n        for (int &a : A)\\n            s.insert(a % 2 ? a * 2 : a);\\n        int res = *s.rbegin() - *s.begin();\\n        while (*s.rbegin() % 2 == 0) {\\n            s.insert(*s.rbegin() / 2);\\n            s.erase(*s.rbegin());\\n            res = min(res, *s.rbegin() - *s.begin());\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1781805,
                "title": "a-very-very-highly-detailed-explanation",
                "content": "**Hello Programmer\\'s \\uD83E\\uDD29 let\\'s solve this question.**\\n\\nIf you look at the constraint\\'s you can see that length can go from `2 <= n <= 10^5` which means that we can have a complexity greater then O(N) but smaller then O(N^2) i.e. `O(N) -> O(N^2)`\\n\\nLet\\'s understand this question straight away with an exmple,\\n```\\nInput: nums = [4,1,5,20,3]\\nOutput: 3\\n```\\nSuppose this is the array given to us & we can only perform 2 opertation\\'s :\\n* If the element is even, divide it by 2\\n* If the element is odd, multiply it by 2\\n\\nThere is one more finding we can get from those operation\\'s. If a no. is `odd * 2 = Even`. So, on the odd values we can perform this operation only one time.\\nSo, if we apply the operation of multiply by two on the odd values, we get this array\\n\\n![image](https://assets.leetcode.com/users/images/9f29e469-1b97-4373-ac92-4069aee81907_1645234029.6828237.png)\\n\\nSuppose, we perform this operation at the very start of the program and now, we have this as an array.\\nIn this array we know that `Minimum is 2`. \\n```\\nBefore we move ahead, I want to clarify that this is not the actual implementation of the program, \\nwe are trying to understand the problem by the intution & then we actuall apply the logic through code.\\n```\\nSo, we know that `minimum is 2` at this point of time & as said in the question we want to find minimum deviation. **Now the minimum deviation is difference b/w the maximum value & the minimum value**\\nSo, we find the maximum value in the array this comes out to be **20**. When we find the difference with 2 we get `diff = 20 - 2 = 18`. We will keep this difference as the seperate entity. Now focus on the **max value** we got.\\n\\n![image](https://assets.leetcode.com/users/images/80be8e3a-9abd-4616-87fe-d6a24233cf00_1645235460.0203195.png)\\n\\nThe maximum value we got is an **even value** & we can reduce the difference by dividing the **max value by 2**, as we perform an operation of `divide by 2 if the element is even` \\n\\n![image](https://assets.leetcode.com/users/images/af8fec09-96f7-48e0-b677-65e6876827e1_1645235890.2262666.png)\\n\\n* So, divide the max value by 2 and put that into that array. Now the value in the array becomes 10 & the difference till now is still 18. We again need to find max value which comes out to be **10**.\\n\\n\\n* And we again pick any of the **2 10\\'s** & then we again find the difference. This time the difference comes out to be **8**. \\n* As this new difference is smaller than, the previous difference. We make the **difference 8** & again we half the max value that we got. Which now becomes **5**\\n\\n![image](https://assets.leetcode.com/users/images/83f3c38f-1f6c-428a-9c56-e55b4d31efef_1645236188.7232811.png)\\n\\n* Now we move on to find the next max which comes out to be **10** the `difference is same so, we don\\'t do anything`. But we put half of it in the array.\\n\\n\\n* Now we again find the new max i.e. **6** and we `calcualte the difference comes out to be 4` we update the diff with **4** and in the array we half the value put that **3**\\n* The `minimum is 2` & the `difference is 4` and our array look\\'s like this `[4,2,5,5,3]` till these many operation\\'s that we perform.\\n\\n![image](https://assets.leetcode.com/users/images/4312fe0f-a0f8-4abb-b241-ca2d8e7814d3_1645236669.1811857.png)\\n\\n*Now we again find the max value which comes out to be **5**, `the new diiference is now 3`. The difference will get updated to **3**. But we cannot divide this max value because, it is a odd value, not an even value. Which means this is the least max that we can get & the least difference of the minimum deviation that we can get from this array and we will `return 3` in this case. And this the answer we require from this problem*\\n\\n![image](https://assets.leetcode.com/users/images/395147bc-51bd-49ac-be67-444f634889b2_1645237210.770262.png)\\n\\nThe approach that we saw over here can be null down to \\n```\\nMake all odd values even\\n\\nTake minimum of all values\\n\\nFind Max & difference & update max/2, till the max is even\\n\\nOtherwise difference is the result\\n```\\n\\n**There Exist\\'s 2 data structure to solve this problem:**\\n```\\n\\t\\t\\t\\t\\t\\t\\tPriority Queue                                         TreeSet\\n```\\n\\n*Now let\\'s see how to use these DS to solve this problem*. `Finally it\\'s time to code it \\uD83D\\uDE2D :`\\n\\n**Priority Queue:**\\n\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        // First create a priority Queue\\n        // and implemented a custom comperator, which help us in making this priority queue act like a max heap\\n        // concept of max heap states that, highest value should lie at the front of the queue & lowest value at the back of the queue\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->b-a); // so we apply the custom comperator over here\\n        \\n        int min=Integer.MAX_VALUE; // creating minimum variable\\n        for(int i:nums){ // add these values in priority queue\\n            if(i%2==1) i*=2; // if value is odd mult. by 2 & make it even\\n            min=Math.min(min,i); // find the minimum\\n            pq.add(i);\\n        } // now we have the value in the priority queue, where we have convert all the odd\\'s into even\\n        \\n        // let\\'s find the maximum of all the value\\n        int diff=Integer.MAX_VALUE; \\n        while(pq.peek()%2==0){ \\n            int max=pq.remove(); // max will be at top of the queue\\n            diff=Math.min(diff,max-min); // find the difference\\n            min=Math.min(max/2,min);//minimum can change because, new value we are getting by half max can be lower then current minimum\\n            pq.add(max/2); // add that in the queue\\n        }\\n        \\n        return Math.min(diff,pq.peek()-min);\\n    }\\n}\\n```\\nANALYSIS:\\n* **Time Complexity :-** BigO(NlogNlogM) where N is the highest value in the array\\n\\n* **Space Complexity :-** BigO(N)\\n\\n**TreeSet:**\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        // change to treeset as treeset is a order set\\n        TreeSet<Integer> ts=new TreeSet<>();\\n        \\n        for(int i:nums){\\n            if(i%2==1) i*=2;\\n            ts.add(i); // just add the value in the treeset\\n        }\\n        \\n        int diff=Integer.MAX_VALUE;\\n        \\n        while(true){\\n            int max=ts.last(); // as it is a sorted set, max value will be at the end of the set\\n            int min=ts.first(); // and min value at the front\\n            \\n            diff=Math.min(diff,max-min);\\n            if(max%2==0){ // if it\\'s a even value\\n                ts.remove(max); // first remove the value\\n                ts.add(max/2); // add the value called max/2 into the treeset\\n            }\\n            else{ // if it\\'s odd just break it\\n                break;\\n            }\\n        }\\n        \\n        return diff;\\n    }\\n}\\n```\\nANALYSIS:\\n* **Time Complexity :-** BigO(NlogNlogM)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [],
                "code": "```\\nInput: nums = [4,1,5,20,3]\\nOutput: 3\\n```\n```\\nBefore we move ahead, I want to clarify that this is not the actual implementation of the program, \\nwe are trying to understand the problem by the intution & then we actuall apply the logic through code.\\n```\n```\\nMake all odd values even\\n\\nTake minimum of all values\\n\\nFind Max & difference & update max/2, till the max is even\\n\\nOtherwise difference is the result\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\tPriority Queue                                         TreeSet\\n```\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        // First create a priority Queue\\n        // and implemented a custom comperator, which help us in making this priority queue act like a max heap\\n        // concept of max heap states that, highest value should lie at the front of the queue & lowest value at the back of the queue\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->b-a); // so we apply the custom comperator over here\\n        \\n        int min=Integer.MAX_VALUE; // creating minimum variable\\n        for(int i:nums){ // add these values in priority queue\\n            if(i%2==1) i*=2; // if value is odd mult. by 2 & make it even\\n            min=Math.min(min,i); // find the minimum\\n            pq.add(i);\\n        } // now we have the value in the priority queue, where we have convert all the odd\\'s into even\\n        \\n        // let\\'s find the maximum of all the value\\n        int diff=Integer.MAX_VALUE; \\n        while(pq.peek()%2==0){ \\n            int max=pq.remove(); // max will be at top of the queue\\n            diff=Math.min(diff,max-min); // find the difference\\n            min=Math.min(max/2,min);//minimum can change because, new value we are getting by half max can be lower then current minimum\\n            pq.add(max/2); // add that in the queue\\n        }\\n        \\n        return Math.min(diff,pq.peek()-min);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        // change to treeset as treeset is a order set\\n        TreeSet<Integer> ts=new TreeSet<>();\\n        \\n        for(int i:nums){\\n            if(i%2==1) i*=2;\\n            ts.add(i); // just add the value in the treeset\\n        }\\n        \\n        int diff=Integer.MAX_VALUE;\\n        \\n        while(true){\\n            int max=ts.last(); // as it is a sorted set, max value will be at the end of the set\\n            int min=ts.first(); // and min value at the front\\n            \\n            diff=Math.min(diff,max-min);\\n            if(max%2==0){ // if it\\'s a even value\\n                ts.remove(max); // first remove the value\\n                ts.add(max/2); // add the value called max/2 into the treeset\\n            }\\n            else{ // if it\\'s odd just break it\\n                break;\\n            }\\n        }\\n        \\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041766,
                "title": "python-heap-solution-explained",
                "content": "Let us look more carefully at this problem: how can some value be changed, let us look at several examples:\\n`3 -> 6, 5 -> 10, 7 -> 14`, that is for odd number we can have only two candidates.\\n`2 -> 1, 4 -> 2 -> 1, 6 -> 3, 8 -> 4 -> 2 -> 1, 10 -> 5, 12 -> 6 -> 3` and so on\\n\\nNow, we can reformulate our problem in the following way: we are given several lists and we need to choose candidate from each of these lists, such that deviation is minimized. This is exactly what problem **632 Smallest Range Covering Elements from K Lists** is about and we can reuse the idea.\\n\\nSo, we have lists `L1, l2, ..., Ln` and let us put all smallest values from each list to heap. On each step we extract the smallest element `num` from heap and put `2*num` to this heap if it is possible and update range. How we can understand if we need to put new element to heap? We need to keep pairs `(num, limit)` in our heap, for example:\\n\\n`3` -> candidates `(3,6)`, what we put it heap on the first step is `(3, 6)`.\\n`12` -> candidates `(3, 6, 12)`, what we put in heap on the first step is `(3, 12)`.\\n\\nAlso we need to keep maximum value of elements in heap `Max` and update it when needed.\\n\\n**Complexity**: time complexity is `O(m log n)`, where `n` is length of `nums` and `m` is total number of candidates, we can estimate it as `m = O(n log K)`, where `K` is the biggest number. Finally, it will be `O(n log n  log K)`. Space complexity is `O(n)` to keep our heap.\\n\\n```\\nclass Solution:\\n    def minimumDeviation(self, nums):\\n        heap = []\\n        for num in nums:\\n            tmp = num\\n            while tmp%2 == 0: tmp//=2\\n            heap.append((tmp, max(num, tmp*2)))\\n        \\n        Max = max(i for i,j in heap)\\n        heapify(heap)\\n        ans = float(\"inf\")\\n\\n        while len(heap) == len(nums):\\n            num, limit = heappop(heap)\\n            ans = min(ans, Max - num)\\n            if num < limit:\\n                heappush(heap, (num*2, limit))\\n                Max = max(Max, num*2)\\n            \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeviation(self, nums):\\n        heap = []\\n        for num in nums:\\n            tmp = num\\n            while tmp%2 == 0: tmp//=2\\n            heap.append((tmp, max(num, tmp*2)))\\n        \\n        Max = max(i for i,j in heap)\\n        heapify(heap)\\n        ans = float(\"inf\")\\n\\n        while len(heap) == len(nums):\\n            num, limit = heappop(heap)\\n            ans = min(ans, Max - num)\\n            if num < limit:\\n                heappush(heap, (num*2, limit))\\n                Max = max(Max, num*2)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952864,
                "title": "java-treeset-nlog-n-log-m",
                "content": "* For each num, if it\\'s odd, double it before adding it to the TreeSet\\n  * Therefore, each number in the set can only be decreased\\n* Within the TreeSet, compute the **deviation**\\n  *  if the largest number is even, make it smaller\\n* Complexity is O(N logM logN); M is the largest number.\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int x : nums)\\n            if (x%2 == 0)\\n                set.add(x);\\n            else\\n                set.add(x*2);\\n        int ans = Integer.MAX_VALUE;\\n        while (true) {\\n            int val = set.last();\\n            ans = Math.min(ans, val - set.first());\\n            if (val%2 == 0) {\\n                set.remove(val);\\n                set.add(val/2);\\n            } else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int x : nums)\\n            if (x%2 == 0)\\n                set.add(x);\\n            else\\n                set.add(x*2);\\n        int ans = Integer.MAX_VALUE;\\n        while (true) {\\n            int val = set.last();\\n            ans = Math.min(ans, val - set.first());\\n            if (val%2 == 0) {\\n                set.remove(val);\\n                set.add(val/2);\\n            } else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223473,
                "title": "c-easiest-approach-beats-100-in-memory-using-heap",
                "content": "# Intuition\\nThe problem asks to perform two types of operations on any element of the array any number of times, which involves dividing an even number by 2 and multiplying an odd number by 2. Our goal is to minimize the deviation of the array, which is the maximum difference between any two elements in the array.\\n\\nThe intuition behind the approach is to convert odd numbers to even numbers by multiplying them by 2 and then inserting them into a max heap. We can then perform division operations on the maximum element in the heap until we get an odd number, and then insert it back into the heap. We continue this process until we can\\'t divide the maximum element in the heap.\\n\\nAt each step, we update the minimum element in the heap and check if the difference between the maximum and minimum elements in the heap is less than the current answer. If it is, we update the answer. Finally, we return the minimum deviation.\\n\\nThe reason for using a max heap is that we want to get the maximum number in the heap quickly, which is the number that will give us the maximum deviation when paired with the minimum number in the heap.\\n\\n# Approach\\n1) Store each odd number in the vector and multiply by 2 to make it even and then insert it into the max heap, which will store even numbers.\\n2) Pop the maximum element from the heap and perform a division operation until we get an odd number.\\n3) Check if the difference between the maximum and minimum elements in the heap is less than the current answer. If it is, update the answer.\\n4) Insert the odd number obtained in step 2 in the heap and update the minimum element if it is less than the current minimum.\\n5) Continue the process until we can\\'t divide the maximum element in the heap.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq; // max heap to store even numbers\\n        int m = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                pq.push(nums[i]);\\n                m = min(m,nums[i]);\\n            }\\n            else{\\n                pq.push(nums[i]*2);\\n                m = min(m,nums[i]*2);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        while(!pq.empty()){\\n            int top = pq.top();\\n            pq.pop();\\n            ans = min(ans,top-m);\\n            if(top%2!=0){\\n                break;\\n            }\\n            m = min(m,top/2);\\n            pq.push(top/2);\\n        }\\n        return ans;\\n    }\\n};\\n//\\uD83D\\uDC47 please upvote if you liked my approach\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq; // max heap to store even numbers\\n        int m = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                pq.push(nums[i]);\\n                m = min(m,nums[i]);\\n            }\\n            else{\\n                pq.push(nums[i]*2);\\n                m = min(m,nums[i]*2);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        while(!pq.empty()){\\n            int top = pq.top();\\n            pq.pop();\\n            ans = min(ans,top-m);\\n            if(top%2!=0){\\n                break;\\n            }\\n            m = min(m,top/2);\\n            pq.push(top/2);\\n        }\\n        return ans;\\n    }\\n};\\n//\\uD83D\\uDC47 please upvote if you liked my approach\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041825,
                "title": "minimize-deviation-in-array-fast-python-heap-explained-beats-99",
                "content": "### **Idea**\\nObserve that we can *only* increase value (by x2) for odd numbers. That means for an odd number like `3`, possible values we can reach are `{3, 6}`; and for an even number like 8, possible values we can reach are `{1, 2, 4, 8}`. We can unify both cases by starting from the largest reachable value (`6` and `8`) and only consider the \"//2\" (divide by 2) operation.\\n\\nSince now numbers can only decrease, the *only* sensible move is to take the largest number and half it. Otherwise, we face the risk of lower the minimum without lowering the maximum. \\n\\nWhat data structure should we use? Halving the largest number will surely lower the maximum but would also create a new minimum. So we would like something that would efficiently keep track of both the max and min values. If you browse other posts, you will see people use a binary search tree for this, but a *heap / priority queue* that only tracks the max value will also suffice for this problem.\\n\\nThis is because, in each step, we a new minimum is only possible from halving the current maximum (heap top). So we can keep a variable `mi` for this and update it along with each operation. \\n\\n### **Optimazations / implementation choices**\\n- We only need to consider unique values from the input as diverging from the same starting values won\\'t make a solution any better. (`heap = list(set(...))`)\\n- Negate the values to have a max heap.\\n- For the current max value, we can just take `heap[0]`.\\n- The process ends when it is impossible to reduce the max value, i.e. `heap[0] % 2 == 0` does not hold.\\n\\n### **Code**\\n```python\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = list(set(-(x * 2 if x & 1 else x) for x in nums))\\n        heapify(heap)\\n        ma, mi = -heap[0], -max(heap)\\n        ans = ma - mi\\n        while heap[0] % 2 == 0:\\n            x = heappop(heap) // 2\\n            heappush(heap, x)\\n            ma, mi = -heap[0], min(mi, -x)\\n            ans = min(ans, ma - mi)\\n        return ans\\n```\\n\\n### **Complexity**\\n- O(n) space. The heap contains all the input elements when they are all unique.\\n- O(n (log m) (log n)) time, where `m = max(nums)`. The heap is O(n) size, so it takes O(log n) time for each push and pop. How many steps do we need to take? That is how many times we can reduce the max value, which is again bounded by the number of reachable values for each input element. The max number of reachable values is for some 2^k that is as big as the limit for input values m. The reachable values for it will be 1, 2, ..., 2^(k-1), 2^k --- (log m) of them. Thus, we will need to do O(n log m) steps in the worst case.\\n\\n### **Further optimizations**\\nI personally think the following optimizations hurt readability a bit, so I didn\\'t include them in the primary solution. None of them affects the big-O notation complexity, but they can save us some time that hides as \"negligible factors\".\\n- Have signs reversed during the computation and only correct it before returning the `ans`. This makes it cleaner with less `-` (negation) and presumably saves computation.\\n- Reuse `ma` for `heap[0]` look-ups.\\n- This one probably saves the most computation time: use `heapq.heapreplace()` ([python doc](https://docs.python.org/3/library/heapq.html#heapq.heapreplace)) instad of `heappop()` followed by `heappush()`. [This stackoverflow post](https://stackoverflow.com/a/46031391) explains a bit more why `heapreplace()` can be more efficient.\\n\\n### **Code 2**\\n```python\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = list(set(-(x * 2 if x & 1 else x) for x in nums))\\n        heapify(heap)\\n        ma, mi = heap[0], max(heap)\\n        ans = ma - mi\\n        while ma % 2 == 0:\\n            x = ma // 2\\n            heapreplace(heap, x)\\n            ma, mi = heap[0], max(mi, x)\\n            ans = max(ans, ma - mi)\\n        return -ans\\n```\\n\\n### **Submission stats**\\nRuntime: 836 ms (beats 99.15%)\\nMemory Usage: 30.7 MB (beats 30.77%)\\n\\n---\\nIf you find this helpful, please **upvote**! It will greatly encourage me to write more like this in the future. Thank you! \\uD83E\\uDD17\\n\\n[20210201] Wording.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = list(set(-(x * 2 if x & 1 else x) for x in nums))\\n        heapify(heap)\\n        ma, mi = -heap[0], -max(heap)\\n        ans = ma - mi\\n        while heap[0] % 2 == 0:\\n            x = heappop(heap) // 2\\n            heappush(heap, x)\\n            ma, mi = -heap[0], min(mi, -x)\\n            ans = min(ans, ma - mi)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = list(set(-(x * 2 if x & 1 else x) for x in nums))\\n        heapify(heap)\\n        ma, mi = heap[0], max(heap)\\n        ans = ma - mi\\n        while ma % 2 == 0:\\n            x = ma // 2\\n            heapreplace(heap, x)\\n            ma, mi = heap[0], max(mi, x)\\n            ans = max(ans, ma - mi)\\n        return -ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223767,
                "title": "clean-codes-full-explanation-priority-queue-c-java-python3",
                "content": "# Intuition :\\n- Here we have to find the minimum deviation of an array of integers. The minimum deviation is defined as the difference between the maximum and minimum values of the array, where each value can be either the original value or twice the original value (if it is odd).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Explanation to Approach :\\n- First, check if the input array is null or empty. If it is, it returns the maximum integer value.\\n- Then, initialize a priority queue called \"evens\" to hold the even numbers in the array (or the doubled odd numbers).\\n```\\nPriorityQueue<Integer> evens = new PriorityQueue<>(nums.length, Collections.reverseOrder());\\n\\n```\\n- Also initialize a variable \"min\" to hold the current minimum value in the array.\\n```\\nint min = Integer.MAX_VALUE;\\n\\n```\\n- Next,loop through each element of the array:\\n1. If the element is even, it adds it to the \"evens\" priority queue and update \"min\" if it is smaller than the current value.\\n```\\nif (num % 2 == 0) {\\n    evens.offer(num);\\n    min = Math.min(num, min);\\n}\\n\\n```\\n2. If the element is odd, it doubles it and adds it to the \"evens\" priority queue, and update \"min\" if it is smaller than the new value.\\n```\\nelse {\\n    evens.offer(num * 2);\\n    min = Math.min(num * 2, min);\\n}            \\n\\n```\\n- After processing all elements,initialize a variable \"res\" to the maximum integer value.\\n- Then loop while the maximum element in the \"evens\" priority queue is even:\\n- Remove the maximum element from the queue and calculate the difference between it and the current minimum value (\"min\").\\n- Update \"res\" to be the minimum between the current \"res\" and this difference.\\n```\\nwhile (evens.peek() % 2 == 0) {\\n    int max = evens.poll();\\n    res = Math.min(res, max - min);\\n\\n```\\n- Divide the maximum element by 2 and add the new value to the \"evens\" priority queue.\\n```\\nint newNum = max / 2; \\nevens.offer(newNum);\\n\\n```\\n- Update \"min\" if the new value is smaller than the current minimum.\\n```\\nmin = Math.min(min, newNum); \\n\\n```\\n- Finally, calculate the difference between the current maximum value in the \"evens\" priority queue and the current minimum value (\"min\"), and update \"res\" to be the minimum between the current \"res\" and this difference.\\n```\\nres = Math.min(evens.peek() - min, res);\\n\\n```\\n- Return the final value of \"res\".\\n```\\nreturn res;\\n\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(M logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n*Let\\'s Code it Up .\\nThere may be minor syntax difference in C++ and Python*\\n# Codes [C++ |Java |Python3] :\\n```C++ []\\n#include <queue>\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int minimumDeviation(std::vector<int>& nums) {\\n        if (nums.empty()) {\\n            return INT_MAX;\\n        }\\n\\n        std::priority_queue<int> evens;\\n        int min = INT_MAX;\\n\\n        for (int num : nums) {\\n            if (num % 2 == 0) {\\n                evens.push(num);\\n                min = std::min(num, min);\\n            } else {\\n                evens.push(num * 2);\\n                min = std::min(num * 2, min);\\n            }\\n        }\\n\\n        int res = INT_MAX;\\n        while (evens.top() % 2 == 0) {\\n            int max = evens.top();\\n            evens.pop();\\n            res = std::min(res, max - min);\\n            int newNum = max / 2;\\n            evens.push(newNum);\\n            min = std::min(min, newNum);\\n        }\\n\\n        res = std::min(evens.top() - min, res);\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution \\n{\\n    public int minimumDeviation(int[] nums) \\n    {\\n        if (nums == null || nums.length == 0) \\n        {\\n            return Integer.MAX_VALUE;\\n        }\\n\\n    PriorityQueue<Integer> evens = new PriorityQueue<>(nums.length, Collections.reverseOrder());\\n    int min = Integer.MAX_VALUE;\\n    \\n    for (int num : nums) \\n    {\\n        if (num % 2 == 0) {\\n            evens.offer(num);\\n            min = Math.min(num, min);\\n        } \\n        else {\\n            evens.offer(num * 2);\\n            min = Math.min(num * 2, min);\\n        }            \\n    }\\n    \\n    int res = Integer.MAX_VALUE;\\n    while (evens.peek() % 2 == 0) {\\n        int max = evens.poll();\\n        res = Math.min(res, max - min);\\n        int newNum = max / 2; \\n        evens.offer(newNum);\\n        min = Math.min(min, newNum); \\n    }\\n    res = Math.min(evens.peek() - min, res);\\n    return res;\\n}\\n}\\n```\\n```Python []\\nimport heapq\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        if not nums:\\n            return float(\\'inf\\')\\n        \\n        evens = []\\n        min_val = float(\\'inf\\')\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                heapq.heappush(evens, -num)\\n                min_val = min(num, min_val)\\n            else:\\n                heapq.heappush(evens, -num * 2)\\n                min_val = min(num * 2, min_val)\\n                \\n        res = float(\\'inf\\')\\n        while evens[0] % 2 == 0:\\n            max_val = -heapq.heappop(evens)\\n            res = min(res, max_val - min_val)\\n            new_num = max_val // 2\\n            heapq.heappush(evens, -new_num)\\n            min_val = min(new_num, min_val)\\n            \\n        res = min(-evens[0] - min_val, res)\\n        return res\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/e7682054-f9c2-4c91-8e7e-e99ffa8c2f76_1677211814.983079.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nPriorityQueue<Integer> evens = new PriorityQueue<>(nums.length, Collections.reverseOrder());\\n\\n```\n```\\nint min = Integer.MAX_VALUE;\\n\\n```\n```\\nif (num % 2 == 0) {\\n    evens.offer(num);\\n    min = Math.min(num, min);\\n}\\n\\n```\n```\\nelse {\\n    evens.offer(num * 2);\\n    min = Math.min(num * 2, min);\\n}            \\n\\n```\n```\\nwhile (evens.peek() % 2 == 0) {\\n    int max = evens.poll();\\n    res = Math.min(res, max - min);\\n\\n```\n```\\nint newNum = max / 2; \\nevens.offer(newNum);\\n\\n```\n```\\nmin = Math.min(min, newNum); \\n\\n```\n```\\nres = Math.min(evens.peek() - min, res);\\n\\n```\n```\\nreturn res;\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\n#include <queue>\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int minimumDeviation(std::vector<int>& nums) {\\n        if (nums.empty()) {\\n            return INT_MAX;\\n        }\\n\\n        std::priority_queue<int> evens;\\n        int min = INT_MAX;\\n\\n        for (int num : nums) {\\n            if (num % 2 == 0) {\\n                evens.push(num);\\n                min = std::min(num, min);\\n            } else {\\n                evens.push(num * 2);\\n                min = std::min(num * 2, min);\\n            }\\n        }\\n\\n        int res = INT_MAX;\\n        while (evens.top() % 2 == 0) {\\n            int max = evens.top();\\n            evens.pop();\\n            res = std::min(res, max - min);\\n            int newNum = max / 2;\\n            evens.push(newNum);\\n            min = std::min(min, newNum);\\n        }\\n\\n        res = std::min(evens.top() - min, res);\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution \\n{\\n    public int minimumDeviation(int[] nums) \\n    {\\n        if (nums == null || nums.length == 0) \\n        {\\n            return Integer.MAX_VALUE;\\n        }\\n\\n    PriorityQueue<Integer> evens = new PriorityQueue<>(nums.length, Collections.reverseOrder());\\n    int min = Integer.MAX_VALUE;\\n    \\n    for (int num : nums) \\n    {\\n        if (num % 2 == 0) {\\n            evens.offer(num);\\n            min = Math.min(num, min);\\n        } \\n        else {\\n            evens.offer(num * 2);\\n            min = Math.min(num * 2, min);\\n        }            \\n    }\\n    \\n    int res = Integer.MAX_VALUE;\\n    while (evens.peek() % 2 == 0) {\\n        int max = evens.poll();\\n        res = Math.min(res, max - min);\\n        int newNum = max / 2; \\n        evens.offer(newNum);\\n        min = Math.min(min, newNum); \\n    }\\n    res = Math.min(evens.peek() - min, res);\\n    return res;\\n}\\n}\\n```\n```Python []\\nimport heapq\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        if not nums:\\n            return float(\\'inf\\')\\n        \\n        evens = []\\n        min_val = float(\\'inf\\')\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                heapq.heappush(evens, -num)\\n                min_val = min(num, min_val)\\n            else:\\n                heapq.heappush(evens, -num * 2)\\n                min_val = min(num * 2, min_val)\\n                \\n        res = float(\\'inf\\')\\n        while evens[0] % 2 == 0:\\n            max_val = -heapq.heappop(evens)\\n            res = min(res, max_val - min_val)\\n            new_num = max_val // 2\\n            heapq.heappush(evens, -new_num)\\n            min_val = min(new_num, min_val)\\n            \\n        res = min(-evens[0] - min_val, res)\\n        return res\\n```",
                "codeTag": "C++"
            },
            {
                "id": 952776,
                "title": "python-simple-priority-queue-solution",
                "content": "**Idea**\\nwe find the upper bound and lower bound for every elements, turning each element into an interval `[lower, upper]`. We then take the lower bound value for each interval to start with. While we still can, we double the smallest value, updating the final result along the way.\\n\\n**Complexity**\\n- Time: `O(nlognlogk)` in the worst case, where n is the number of elements, k is the maximum value of `nums`\\n- Space: `O(n)`\\n\\n**Python**\\n```\\nimport heapq\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        def bounds(n):\\n            \\'\\'\\'return the lower / upper bounds for number n\\'\\'\\'\\n            if n % 2 == 1:\\n                n *= 2\\n            curr = n\\n            while curr & 1 == 0:\\n                curr >>= 1\\n            return curr, n\\n        \\n        nums = [(lower, upper, upper) for lower, upper in map(bounds, nums)]\\n        heapq.heapify(nums)\\n        upper = max(x[0] for x in nums)\\n        lower = min(x[0] for x in nums)\\n        res = upper - lower\\n        while nums[0] < nums[0][2]:\\n            curr, mn, mx = heapq.heappop(nums)\\n            heapq.heappush(nums, (curr * 2, mn, mx))\\n            upper = max(upper, curr * 2)\\n            lower = nums[0][0]\\n            res = min(res, upper - lower)\\n        return res        \\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        def bounds(n):\\n            \\'\\'\\'return the lower / upper bounds for number n\\'\\'\\'\\n            if n % 2 == 1:\\n                n *= 2\\n            curr = n\\n            while curr & 1 == 0:\\n                curr >>= 1\\n            return curr, n\\n        \\n        nums = [(lower, upper, upper) for lower, upper in map(bounds, nums)]\\n        heapq.heapify(nums)\\n        upper = max(x[0] for x in nums)\\n        lower = min(x[0] for x in nums)\\n        res = upper - lower\\n        while nums[0] < nums[0][2]:\\n            curr, mn, mx = heapq.heappop(nums)\\n            heapq.heappush(nums, (curr * 2, mn, mx))\\n            upper = max(upper, curr * 2)\\n            lower = nums[0][0]\\n            res = min(res, upper - lower)\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782124,
                "title": "c-detailed-explanation-w-each-answer-generate-intiution-to-code-two-approach",
                "content": "***Brief note about Question-***\\n* We have to ***return the minimum deviation*** the array can have after performing some number of operations.\\n* **For deviation, we may termed it as the difference between maximum element and minimum element of the array** (becausse no matter what, this difference is always going to be largest in the array).\\n* Also, we are able to perform two operations in an array-\\n* If the element is **even**, **divide** it by 2.\\n* If the element is **odd**, **multiply** it by 2\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array given to us is arr[]: [1,10,5,3,6]\\n\\nSo, the answer should be 3.\\n\\nwhy 3? see, currently we have maximum element as is 10 and minimum element is as 1\\ntherefore the answer should be (10 - 1) i.e  9.\\nBut also, we can perform two operations on the array, \\nsince we have to return minimum deviation we can divide 10 by 2 (one operation) so it becomes 5.\\nBut, now our maximum element got change to 6, since 6 is also even so we are also able to decerase it.\\nTherefore, (6 / 2 = 3) and now our maximum element again shift to 5.\\n\\nso what is the difference now, since our minimum element is 1 so the difference should be (5 - 1) i.e 4\\nBut again, we have to return the minimum deviation so we also able to reduce our difference,\\nTherefore, since 1 is odd so we multiply it by 2 and it becomes 2.\\n\\nNow, our difference becomes (5 - 2) i.e 3.\\nand this is the minimum deviation that we got, so it should be our answer.\\n```\\n_________________\\n***Understanding question in our terms-***\\n* Some important things that we need to observe here is-\\n* We have to ***return the minimum deviation*** from the array.\\n* And deviation is defind as ***maximum difference between any two elements*** in the array.\\n\\n* If we carefully observe then their are two things, **we have to return the minimum deviation and deviation is the maximum difference between any two elements of the array**.\\n* Okay, Now the question arises, **when their will be the maximum difference between any two elements of the array?**\\n* So, **If we take the difference between the largest and smallest element of the array**, we can say that yes, their difference will always be maximum, right.\\n* Therefore, we redefind the defination of deviation in our words that-\\n* ***Deviation is the difference between the largest and smallest element of the array.***\\n* So, ***Finally we can say that we have to minimise the difference between largest and smallest element of the array as we are able to perform operations in the array to change maximum and minimum elements of the array.***\\n__________________________\\n***How we devlop approach?***\\n* Now, till now we redifnd the question in our words. Moving ahead-\\n* In the question we are able to perform the two operations-\\n\\n* If the element is **even**, **divide** it by 2.\\n* If the element is **odd**, **multiply** it by 2.\\n* Now, Our task is to minimise the difference between largest and smallest element of the array as we discussed above.\\n* See, **for an even element we are never able to increase it\\'s value**, because every time we encounter an even element we have only option to divide it by 2.\\n* Similiarly, **for an odd element, we are never able to decrease it\\'s value**, because every time we encounter an odd element we have only option to multiply it by 2.\\n_____\\n*  So, On the basis of above statements, (please don\\'t get confuse and read slowly statements written below).\\n*  We can say that the maximum value of a minimum element in an array is `2`.\\n\\n*  See again, **We say that the for our minimum value, what value should it hold so that we can gurantee it that it is the maximum value of our minimum element which increases**.\\n*  Okay, confuse na? see the constaraint our array is `1 <= arr[i] <= 10^9`that means from the given constarint what is the minimumm value possible ? Our answer is 1.\\n*  So, **we say that by giving us two operations what should the maximum value upto which my minimum value can get upto.**\\n*  And answer for that is `2`.\\n*  Please Understand `2` is that maximum value upto which my minimum element can go by get ridding of one operation, because if we increase our value let say 4, then we can not comment on that this should be the maximum value of my minimum value.\\n*  **Questin is Why? Why all these confusing statements?**\\n*  See, we are able to perform two operations on our array, so we know that for every even element, we are only able to decrease its value, and how the value decrease, by dividing it by 2.\\n*  Same for odd elements, so for every odd element, we are only able to increase it\\'s value and how the value increases, by multiplying it by 2.\\n___________\\n***Answering some questions WHY, WHY from the code?-***\\n* Suppose we have given an even element, then if we divide it by 2 then we have two possibility, i.e either it becomes odd after dividing or it remains even after dividing.\\n\\n* For e.g, Suppose our element is `10` then after dividing it by 2, it becomes `5` which is odd. But let\\'s say our element is `20` then after dividing it by 2, it becomes `10` which is even.\\n* Therefore, **For an even element we have two possibility either it becomes odd or even after performing operation.**\\n* Now, **for any odd element, then their is only one possibility that it beomes even after multiplying by 2.**\\n* So, ***we can say that, it is easy to get rid of making odd element to even, because every time we encounter an odd element then we can say that, yes!, it becomes even after multiplying it by 2.***\\n* ***Here, it comes our first step of the code that, for getting rid of one operation, we multiply our every odd elements to 2, so that with 100% surity we are able to say that yes!, it becomes even after multiplication after performing the operation.***\\n* `odd * 2 = always even`\\n______\\n***Taking example for better understanding-***\\n```\\nSuppose our array given to us is arr[]: [1, 2, 3, 4, 6, 5]\\nFirst we will get rid of one operation, that means for every odd element we multiply it by 2.\\nso our array become arr[]: [2, 2, 6, 4, 6, 10]\\n\\nNow, we know that every element of our array now becomes even, and whatever will be the maximum value that will always remain maximum.\\nBecause from now, we have only one choice left, i.e divide it by 2.\\n\\nso, mx --> stores maximum value\\nmn --> stores minimum value &\\ndiff --> stores difference between maximum and minimum value.\\n\\nFor the first time, mx = 10, mn = 2 and then diff becomes (10 - 2) i.e 8\\nbut yes, we have to minimise the difference so we divide our maximum value by 2. \\nso mx becomes mx = 10 / 2 = 5\\n\\nBut, Now our maximum value got shifted with 6 as this is also present in the array, mx = 6\\nso our difference becomes diff = mx - mn = 6 - 2 i.e 4,\\n\\nbut yes, we have to minimise the difference so we divide our maximum value by 2.\\nso mx becomes mx = 6 / 2 = 3\\n\\nNow, our  maximum value again got shifted with 5 as this is also present in the array, mx = 5\\nso, diff = mx - mn = 5 - 2 = 3\\n\\nNow, we know that our maximum value becomes odd (i.e 5) and for odd we are only able to increase its value. \\ni.e by multiplying it by 2.\\n\\nTherefore, we will stop here and hence 3 should be our final answer.\\n```\\n_________\\n***How we will Implement it?***\\n* So, in the first step we have to multiply every odd element with 2, so that we can get rid of one operation.\\n\\n* Now, as we observe our above example, we are frequently shifiting with our maximum elements. So, the question arises, whether there is any data structure present which will help us to do this thing?\\n* Answer is yes and the name of that data structure is **priority queue (maximum heap)**.\\n* When we will stop for finding further more answer? Answer is when we got our maximum element as odd, then we will stop. Or more precisely to say, when our top of the heap becomes odd then we will stop.\\n_____________\\n***Solution - I (using Priority queue, Accepted)-***\\n```\\nTime Complexity --> O(n * log(m) * log(n)) \\nSpace Complexity --> O(n) \\n\\nIt paases [ 76 /  76] in built test cases\\n```\\n____\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& arr) {\\n        int n = arr.size(); // extracting size of the array\\n        \\n        for(int i = 0; i < n; i++) // making every odd element to even\\n        {\\n            if(arr[i] % 2 == 1) // if it is odd\\n            {\\n                arr[i] = 2 * arr[i]; // multiply it by 2\\n            }\\n        }\\n        \\n        int mn = *min_element(arr.begin(), arr.end()); // take minimum element from array\\n        int mx = *max_element(arr.begin(), arr.end());// take maximum element from array\\n        \\n        int ans = mx - mn; // intially answer is difference of these two\\n        \\n        priority_queue<int> maxh; // creating max heap\\n        \\n        for(int i = 0; i < n; i++) // push every element to max heap\\n        {\\n            maxh.push(arr[i]);\\n        }\\n        \\n        // Until our top element is even, we will run the loop\\n        while(maxh.top() % 2 == 0) \\n        {\\n            int top = maxh.top(); // extracting top of the heap\\n            maxh.pop(); // pop that elemet from heap\\n            \\n            ans = min(ans, top - mn); // update answer to minimum difference\\n            \\n            top = top / 2; // divide by 2 to our top\\n            \\n            mn = min(mn, top); // also update minimum element as well\\n            \\n            maxh.push(top); // push update top element to again heap\\n        }\\n        \\n        // again update the answer with one more time, because when we will stop \\n        // we stop when we find an odd element on the top, so chaeck the difference\\n        // with this also and update it to the answer\\n        ans = min(ans, maxh.top() - mn); \\n        \\n        return ans; // and at last return the answer\\n    }\\n};\\n```\\n___________________\\n***Solution - II (using Set, Accepted)-***\\n* We are able to reduce it\\'s time complexity using **set**.\\n* First notice, some properties of set-\\n\\n* **The set stores the elements in sorted order.**\\n* **The value of the element cannot be modified once it is added to the set, though it is possible to remove and then add the modified value of that element. Thus, the values are immutable**.\\n* That\\'s all we need.\\n* Other than that, all things remain same. So moving to the code part.\\n______________\\n```\\nTime Complexity --> O(n * log(n)) \\nSpace Complexity --> O(n) \\n\\nIt paases [ 76 /  76] in built test cases\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& arr) {\\n        int n = arr.size(); // extracting size of the array\\n        \\n        set<int> s; // declaring set\\n        for(int i = 0; i < n; i++) // making every odd element to even\\n        {\\n            if(arr[i] % 2 == 1) // if it is odd\\n            {\\n                arr[i] = 2 * arr[i]; // multiply it by 2\\n                \\n                s.insert(arr[i]); // and then insert it to set\\n            }\\n            else if(arr[i] % 2 == 0) // if it is already even, \\n            {\\n                s.insert(arr[i]); //simple insert to set\\n            }\\n        }\\n        \\n        //see proprty we dicussed about set \\n        //(The set stores the elements in sorted order)\\n        \\n        // set::rbegin() is a built-in function in C++ STL which returns a reverse iterator pointing to the last element in the container and last should be our mx.\\n        int mx = *s.rbegin();\\n        \\n        // begin() function is used to return an iterator pointing to the first element of the set container and first element is our mn\\n        int mn = *s.begin();\\n        \\n        int ans = mx - mn; // intially our answer\\n        \\n        while(*s.rbegin() % 2 == 0)\\n        {\\n            int last = *s.rbegin(); // take last element (or updated mx element)\\n            s.erase(last);\\n            \\n            s.insert(last / 2); // see property we discuss (second one)\\n            \\n            ans = min(ans, *s.rbegin() - *s.begin());\\n        }\\n        \\n        return ans; // at last, return the answer\\n        \\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array given to us is arr[]: [1,10,5,3,6]\\n\\nSo, the answer should be 3.\\n\\nwhy 3? see, currently we have maximum element as is 10 and minimum element is as 1\\ntherefore the answer should be (10 - 1) i.e  9.\\nBut also, we can perform two operations on the array, \\nsince we have to return minimum deviation we can divide 10 by 2 (one operation) so it becomes 5.\\nBut, now our maximum element got change to 6, since 6 is also even so we are also able to decerase it.\\nTherefore, (6 / 2 = 3) and now our maximum element again shift to 5.\\n\\nso what is the difference now, since our minimum element is 1 so the difference should be (5 - 1) i.e 4\\nBut again, we have to return the minimum deviation so we also able to reduce our difference,\\nTherefore, since 1 is odd so we multiply it by 2 and it becomes 2.\\n\\nNow, our difference becomes (5 - 2) i.e 3.\\nand this is the minimum deviation that we got, so it should be our answer.\\n```\n```\\nSuppose our array given to us is arr[]: [1, 2, 3, 4, 6, 5]\\nFirst we will get rid of one operation, that means for every odd element we multiply it by 2.\\nso our array become arr[]: [2, 2, 6, 4, 6, 10]\\n\\nNow, we know that every element of our array now becomes even, and whatever will be the maximum value that will always remain maximum.\\nBecause from now, we have only one choice left, i.e divide it by 2.\\n\\nso, mx --> stores maximum value\\nmn --> stores minimum value &\\ndiff --> stores difference between maximum and minimum value.\\n\\nFor the first time, mx = 10, mn = 2 and then diff becomes (10 - 2) i.e 8\\nbut yes, we have to minimise the difference so we divide our maximum value by 2. \\nso mx becomes mx = 10 / 2 = 5\\n\\nBut, Now our maximum value got shifted with 6 as this is also present in the array, mx = 6\\nso our difference becomes diff = mx - mn = 6 - 2 i.e 4,\\n\\nbut yes, we have to minimise the difference so we divide our maximum value by 2.\\nso mx becomes mx = 6 / 2 = 3\\n\\nNow, our  maximum value again got shifted with 5 as this is also present in the array, mx = 5\\nso, diff = mx - mn = 5 - 2 = 3\\n\\nNow, we know that our maximum value becomes odd (i.e 5) and for odd we are only able to increase its value. \\ni.e by multiplying it by 2.\\n\\nTherefore, we will stop here and hence 3 should be our final answer.\\n```\n```\\nTime Complexity --> O(n * log(m) * log(n)) \\nSpace Complexity --> O(n) \\n\\nIt paases [ 76 /  76] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& arr) {\\n        int n = arr.size(); // extracting size of the array\\n        \\n        for(int i = 0; i < n; i++) // making every odd element to even\\n        {\\n            if(arr[i] % 2 == 1) // if it is odd\\n            {\\n                arr[i] = 2 * arr[i]; // multiply it by 2\\n            }\\n        }\\n        \\n        int mn = *min_element(arr.begin(), arr.end()); // take minimum element from array\\n        int mx = *max_element(arr.begin(), arr.end());// take maximum element from array\\n        \\n        int ans = mx - mn; // intially answer is difference of these two\\n        \\n        priority_queue<int> maxh; // creating max heap\\n        \\n        for(int i = 0; i < n; i++) // push every element to max heap\\n        {\\n            maxh.push(arr[i]);\\n        }\\n        \\n        // Until our top element is even, we will run the loop\\n        while(maxh.top() % 2 == 0) \\n        {\\n            int top = maxh.top(); // extracting top of the heap\\n            maxh.pop(); // pop that elemet from heap\\n            \\n            ans = min(ans, top - mn); // update answer to minimum difference\\n            \\n            top = top / 2; // divide by 2 to our top\\n            \\n            mn = min(mn, top); // also update minimum element as well\\n            \\n            maxh.push(top); // push update top element to again heap\\n        }\\n        \\n        // again update the answer with one more time, because when we will stop \\n        // we stop when we find an odd element on the top, so chaeck the difference\\n        // with this also and update it to the answer\\n        ans = min(ans, maxh.top() - mn); \\n        \\n        return ans; // and at last return the answer\\n    }\\n};\\n```\n```\\nTime Complexity --> O(n * log(n)) \\nSpace Complexity --> O(n) \\n\\nIt paases [ 76 /  76] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& arr) {\\n        int n = arr.size(); // extracting size of the array\\n        \\n        set<int> s; // declaring set\\n        for(int i = 0; i < n; i++) // making every odd element to even\\n        {\\n            if(arr[i] % 2 == 1) // if it is odd\\n            {\\n                arr[i] = 2 * arr[i]; // multiply it by 2\\n                \\n                s.insert(arr[i]); // and then insert it to set\\n            }\\n            else if(arr[i] % 2 == 0) // if it is already even, \\n            {\\n                s.insert(arr[i]); //simple insert to set\\n            }\\n        }\\n        \\n        //see proprty we dicussed about set \\n        //(The set stores the elements in sorted order)\\n        \\n        // set::rbegin() is a built-in function in C++ STL which returns a reverse iterator pointing to the last element in the container and last should be our mx.\\n        int mx = *s.rbegin();\\n        \\n        // begin() function is used to return an iterator pointing to the first element of the set container and first element is our mn\\n        int mn = *s.begin();\\n        \\n        int ans = mx - mn; // intially our answer\\n        \\n        while(*s.rbegin() % 2 == 0)\\n        {\\n            int last = *s.rbegin(); // take last element (or updated mx element)\\n            s.erase(last);\\n            \\n            s.insert(last / 2); // see property we discuss (second one)\\n            \\n            ans = min(ans, *s.rbegin() - *s.begin());\\n        }\\n        \\n        return ans; // at last, return the answer\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223829,
                "title": "java-easy-priority-queue-with-explanation",
                "content": "**The Basic Intuition is to minimize the maxDifference between two numbers and we can decrease it  by decreasing the maximum value. We can decrease a even value by dividing by 2 but for odd number we can only multiply by 2 so which increases the value. So initially we tried to convert all the odd numbers to even numbers by multiplying with 2 so that afterwards we can decrease it by dividing it by 2. So initially I multiplied all the odd numbers with 2 and I was also keeping a track of minimum number . I inserted all the numbers into the Priority Queue that sorts according to Max Heap. So after I inserted all element into Priority Queue. Then I polled out the top element of the Priority Queue and then computed the difference with the minimum value so that we can know that it\\'s the minimum Deviation than previous or not and after that I checked if it\\'s even then i divided it by 2 to reduce the value and then checked if its the new minimum value or not. If it\\'s the new minimum Value I updated the minimum Value. Then I inserted that top element (top element of Priority Queue divided by 2) into the Priority Queue. Similarly, We then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly. Then at last I returned the minimum Deviation.**\\n\\n**Note :- x&1 gives 1 if its odd and 0 if its even. \\nTo multiply with 2 I have used the left shift by 1. For Example 1<<1 means (1 multiplied to (2 to the power 1)). So similarly for division by 2 I have used right shift by 1.   For Example 1>>1 means (1 divided by (2 to the power 1)).**\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        int minValue=Integer.MAX_VALUE;\\n        for(int x:nums){\\n            if((x&1)==1)\\n                x<<=1;\\n            pq.add(x);\\n            minValue=Math.min(minValue,x);\\n        }\\n        int minDeviation=Integer.MAX_VALUE;\\n        while(!pq.isEmpty()){\\n            int curr=pq.poll();\\n            minDeviation=Math.min(minDeviation,curr-minValue);\\n            if((curr&1)==1)\\n                break;\\n            curr>>=1;\\n            minValue=Math.min(minValue,curr);\\n            pq.add(curr);\\n        }\\n        return minDeviation;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/1b8a1e51-3bb8-4154-8458-7d471bd0581e_1677212644.5464725.png)\\n\\n![image](https://assets.leetcode.com/users/images/0c72a47b-81f0-4917-b245-43c75852957d_1677211154.5545113.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        int minValue=Integer.MAX_VALUE;\\n        for(int x:nums){\\n            if((x&1)==1)\\n                x<<=1;\\n            pq.add(x);\\n            minValue=Math.min(minValue,x);\\n        }\\n        int minDeviation=Integer.MAX_VALUE;\\n        while(!pq.isEmpty()){\\n            int curr=pq.poll();\\n            minDeviation=Math.min(minDeviation,curr-minValue);\\n            if((curr&1)==1)\\n                break;\\n            curr>>=1;\\n            minValue=Math.min(minValue,curr);\\n            pq.add(curr);\\n        }\\n        return minDeviation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041856,
                "title": "c-simple-explanation-using-priority-queue",
                "content": "\\n-  For any given configuration of nums the deviation is equal to (maxx - minn)\\n-  To decrease the deviation either increase the minn or decrease the maxx.\\n- Now, Make every number as maximum as possible to eliminate one operation(increase the minn) \\n       since every element is as maximum as possible , you can not increase any number further\\n- Now we are left with just one operation decrease the maxx \\n- So perform this operation as many times as u can and keep track of the min_deviation\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        // Step 1 :- increase all elements to as maximum as it can and track the minn number and also the result\\n        int N = nums.size();\\n        int maxx = INT_MIN, minn = INT_MAX;\\n        for(int i = 0; i < N; i++){\\n            if((nums[i])%2 != 0){\\n                nums[i] *= 2;\\n            }\\n            maxx = max(maxx, nums[i]);\\n            minn = min(minn, nums[i]);\\n        }\\n        int min_deviation = maxx - minn;\\n        \\n        // Step 2 :- Insert into max_heap and try to decrease the maxx as much as u can\\n        priority_queue<int>pq;\\n        for(int i = 0; i < N; i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while((pq.top())%2 == 0){\\n            int top = pq.top(); pq.pop();\\n            min_deviation = min(min_deviation, top - minn);\\n            top /= 2;\\n            minn = min(minn, top);\\n            pq.push(top);\\n        }\\n        min_deviation = min(min_deviation, pq.top() - minn);\\n        \\n        // Step 3 :- return maxx - minn;\\n        return min_deviation  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        // Step 1 :- increase all elements to as maximum as it can and track the minn number and also the result\\n        int N = nums.size();\\n        int maxx = INT_MIN, minn = INT_MAX;\\n        for(int i = 0; i < N; i++){\\n            if((nums[i])%2 != 0){\\n                nums[i] *= 2;\\n            }\\n            maxx = max(maxx, nums[i]);\\n            minn = min(minn, nums[i]);\\n        }\\n        int min_deviation = maxx - minn;\\n        \\n        // Step 2 :- Insert into max_heap and try to decrease the maxx as much as u can\\n        priority_queue<int>pq;\\n        for(int i = 0; i < N; i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while((pq.top())%2 == 0){\\n            int top = pq.top(); pq.pop();\\n            min_deviation = min(min_deviation, top - minn);\\n            top /= 2;\\n            minn = min(minn, top);\\n            pq.push(top);\\n        }\\n        min_deviation = min(min_deviation, pq.top() - minn);\\n        \\n        // Step 3 :- return maxx - minn;\\n        return min_deviation  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041702,
                "title": "java-solution-using-treeset-with-a-brief-explanation",
                "content": "Some key observations before attempting the problem - \\n* Any even number may have to divided multiple times to make itself odd.\\n* Odd numbers when multiplied with a 2 become even.\\n* Therefore of all the even numbers in the array, none can be increased\\n\\nWe can use the above idea in the following fashion - If even numbers can\\'t be increased, we have like a bar on the max of the array. Now to get min deviation, we can shift the min bar to be higher and hence the difference lower. In order to do this, we need to bring the odd numbers to a bigger value. How? Use second operation!\\n\\nTo approach this at any moment we need to be able to retrieve the max and min of the array in as less complexity as possible. `Heap` might come to your mind but it will give us only one of the above and getting both from a single heap might lead us to lot of conversions between max heap and min heap. Hence, TreeSet is a good idea to go about. It maintains non duplicate numbers and can give max and min in O(log\\n\\nWe need to get the max of the sorted structure and subtract it with min to get the max difference or the deviation. To get the min of this, we need to reduce the max even number to an odd hence setting the upper bound of the difference and enter it again in TreeSet for reordering purposes.\\n\\nJava code -\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> temp = new TreeSet<>();\\n        for(int i: nums){\\n            if(i % 2 == 0){\\n                temp.add(i);\\n            }\\n            else{\\n                temp.add(i * 2);\\n            }\\n        }\\n        \\n        int md = temp.last() - temp.first();\\n        int m = 0;\\n        \\n        while(temp.size() > 0 && temp.last() % 2 == 0){\\n            m = temp.last();\\n            temp.remove(m);\\n            temp.add(m / 2);\\n            \\n            md = Math.min(md, temp.last() - temp.first());\\n        }\\n        return md;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> temp = new TreeSet<>();\\n        for(int i: nums){\\n            if(i % 2 == 0){\\n                temp.add(i);\\n            }\\n            else{\\n                temp.add(i * 2);\\n            }\\n        }\\n        \\n        int md = temp.last() - temp.first();\\n        int m = 0;\\n        \\n        while(temp.size() > 0 && temp.last() % 2 == 0){\\n            m = temp.last();\\n            temp.remove(m);\\n            temp.add(m / 2);\\n            \\n            md = Math.min(md, temp.last() - temp.first());\\n        }\\n        return md;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223861,
                "title": "fast-java-solution",
                "content": "We\\'re putting all the elements into a **Max-heap** (here it is the *TreeSet* data structure). If they are odd we **multiply by 2** before putting them in, otherwise even numbers go in as they are.\\n\\nAfter that we check the difference between the smallest and largest elements in the heap, and the lowest diff is saved to variable **ans**.\\n\\nIf the largest element is even we **divide it by 2** and replace it with the original number. And we keep doing it until the max element is no longer even.\\n\\n# JAVA Code\\n``` JAVA []\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int x : nums)\\n            if (x%2 == 0)\\n                set.add(x);\\n            else\\n                set.add(x*2);\\n        int ans = Integer.MAX_VALUE;\\n        while (true) {\\n            int val = set.last();\\n            ans = Math.min(ans, val - set.first());\\n            if (val%2 == 0) {\\n                set.remove(val);\\n                set.add(val/2);\\n            } else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/f6db4696-26ce-4e27-b643-307f2490f3c9_1677214295.1615763.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int x : nums)\\n            if (x%2 == 0)\\n                set.add(x);\\n            else\\n                set.add(x*2);\\n        int ans = Integer.MAX_VALUE;\\n        while (true) {\\n            int val = set.last();\\n            ans = Math.min(ans, val - set.first());\\n            if (val%2 == 0) {\\n                set.remove(val);\\n                set.add(val/2);\\n            } else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223547,
                "title": "simplest-solution-beginner-friendly-ordered-set-c",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\nEven numbers can be divided multiple times until it converts to an odd number.\\nOdd numbers can be doubled only once as it converts to an even number.\\nTherefore, even numbers can never be increased.\\nFollow the steps below to solve the problem: \\n \\n\\n1. Traverse the vector and double all the odd vector elements. This nullifies the requirement for the 2nd operation.\\n2. Now, decrease the largest vector element while it\\u2019s even.\\n3. To store the vector elements in sorted manner, insert all vector elements into a Set.\\n4. Greedily reduce the maximum element present in the Set\\n5. If the maximum element present in the Set is odd, break the loop.\\n6. Print the minimum deviation obtained.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLet\\'s take an example not given in question -\\nSuppose our array given to us is nums = [4,1,5,20,3]\\n\\nSo, the answer should be 3.\\n\\nwhy 3? see, currently we have maximum element as is 20 and minimum element is as 1\\ntherefore the answer should be (20 - 1) i.e  19.\\nBut also, we can perform two operations on the array, \\nsince we have to return minimum deviation we can divide 20 by 2 (one operation) so it becomes 10.\\nNow our maximum element got change to 10, since 10 is also even so we are also able to decerase it.\\nTherefore, (10 / 2 = 5) and now our maximum element shift to 5.\\n\\nso what is the difference now, since our minimum element is 1 so the difference should be (5 - 1) i.e 4\\nBut again, we have to return the minimum deviation so we also able to reduce our difference,\\nTherefore, since 1 is odd so we multiply it by 2 and it becomes 2.\\n\\nNow, our difference becomes (5 - 2) i.e 3.\\nand this is the minimum deviation that we got, so it should be our answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        // create a set to store unique values after processing\\n        set<int> st;\\n        // iterate over each element in the input vector\\n        for(int i=0;i<nums.size();i++){\\n            // if the element is odd, multiply by 2 and add to set\\n            if(nums[i] % 2 != 0)\\n                nums[i] *= 2;\\n            st.insert(nums[i]);\\n        }\\n        // initialize minimum deviation as the difference between max and min values in set\\n        int mnDev = *st.rbegin() - *st.begin();\\n        // while the maximum value in the set is even\\n        while(*st.rbegin() % 2 == 0){\\n            // remove the maximum value from the set\\n            int temp = *st.rbegin();\\n            st.erase(temp);\\n            // divide by 2 and add back to the set\\n            temp /= 2;\\n            st.insert(temp);\\n            // update minimum deviation with new value\\n            mnDev = min(mnDev, *st.rbegin() - *st.begin());\\n        }   \\n        // return the minimum deviation\\n        return mnDev;\\n    }\\n};\\n\\n```\\n```\\n             Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        // create a set to store unique values after processing\\n        set<int> st;\\n        // iterate over each element in the input vector\\n        for(int i=0;i<nums.size();i++){\\n            // if the element is odd, multiply by 2 and add to set\\n            if(nums[i] % 2 != 0)\\n                nums[i] *= 2;\\n            st.insert(nums[i]);\\n        }\\n        // initialize minimum deviation as the difference between max and min values in set\\n        int mnDev = *st.rbegin() - *st.begin();\\n        // while the maximum value in the set is even\\n        while(*st.rbegin() % 2 == 0){\\n            // remove the maximum value from the set\\n            int temp = *st.rbegin();\\n            st.erase(temp);\\n            // divide by 2 and add back to the set\\n            temp /= 2;\\n            st.insert(temp);\\n            // update minimum deviation with new value\\n            mnDev = min(mnDev, *st.rbegin() - *st.begin());\\n        }   \\n        // return the minimum deviation\\n        return mnDev;\\n    }\\n};\\n\\n```\n```\\n             Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952990,
                "title": "mathematical-solution-reduced-complexity",
                "content": "We prove the following:\\n**Observation.** Suppose the largest odd factor of all numbers in `nums` is `c`. Then for any `num` in `nums` with factor `c`, the transformed list with minimal deviation would transform `num`  into `c`.\\n*Proof.* Suppose after transformation, the list contains three kinds of elements:\\n* `Small` = {elements smaller than `c`};\\n* `Equal` = {`c`};\\n* `Large` = {elements larger than `c`}.\\n\\nWe then know all elements in `Large` are even numbers. (Otherwise `c` is not the largest odd factor!) Then we divide into two cases:\\n* If `Small` is not empty: in this case `c` is not the smallest element. Then lifting `c` will not improve the deviation;\\n* If `Small` is empty: in this case `c` is the smallest element, so lifting `c` to `2*c` might improve the deviation; however, after lifting `c` to `2*c`, all the elements in the list would be even numbers, so we can improve the deviation by dividing each element by 2. Then `2*c` falls to `c` again.\\n\\nThus we finish the proof. With this intuition, we can transform the problem into a much easier one.\\n\\nFor each element `num` in `nums` and its candidate tranformations, we pick the transformations that are closest to `c` from upside and downside, and write as `(x, y)`. When both directions are possible, `x` and `y` are both positive integers; otherwise one of them is set as `infty`. Then the problem becomes the following:\\n\\n**New problem:** Suppose we have a list of positive integer pairs(including `infty`) `[(x1, y1), ..., (xn, yn)]`. We can pick either `xi` or `yi` from each pair, and the goal is to minimize `max(picked xi\\'s) + max(picked yi\\'s)`. \\nThis new problem is much easier: we can sort the list by values of `xi`, and maintain a running maximal value of `yi`\\'s we have seen. See the codes for details.\\n\\n**Complexity:** Computing the `[(x1, y1), ..., (xn, yn)]` list requires `O(N log(M))` where `M=max(nums)`; sorting requires `O(N log(N))`. So the overall complexity is `O(N log(MN))`, which is an improvement over the algorithms provided in the official solution.\\n\\nPython code:\\n```\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        # step 1: maximal odd factor\\n        max_odd = 0\\n        for i in nums:\\n            while i%2==0:i = i//2\\n            max_odd = max(max_odd, i)\\n            \\n        # step 2: calculating the [(xi, yi)] list\\n        dev = []\\n        for i in nums:\\n            if i%2 == 1:\\n                if 2*i>max_odd:\\n                    dev.append((2*i-max_odd, max_odd-i))\\n                else:\\n                    dev.append((float(\\'inf\\'), max_odd-2*i))\\n            else:\\n                if i < max_odd:\\n                    dev.append((float(\\'inf\\'), max_odd-i))\\n                else:\\n                    while i%2==0 and i>max_odd:\\n                        i = i//2\\n                    if i < max_odd:\\n                        dev.append((2*i-max_odd, max_odd-i))\\n                        \\n        # step 3: minimal sum of picked xi\\'s and yi\\'s\\n        dev.sort(reverse=True)\\n        if not dev: return 0\\n        max_down = [0] * len(dev)\\n        cur = 0\\n        for i in range(len(max_down)):\\n            cur = max(cur, dev[i][1])\\n            max_down[i] = cur\\n        mm = min(max_down[-1], dev[0][0])\\n        for i in range(len(max_down)-1):\\n            mm = min(mm, max_down[i]+dev[i+1][0])\\n        return mm\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        # step 1: maximal odd factor\\n        max_odd = 0\\n        for i in nums:\\n            while i%2==0:i = i//2\\n            max_odd = max(max_odd, i)\\n            \\n        # step 2: calculating the [(xi, yi)] list\\n        dev = []\\n        for i in nums:\\n            if i%2 == 1:\\n                if 2*i>max_odd:\\n                    dev.append((2*i-max_odd, max_odd-i))\\n                else:\\n                    dev.append((float(\\'inf\\'), max_odd-2*i))\\n            else:\\n                if i < max_odd:\\n                    dev.append((float(\\'inf\\'), max_odd-i))\\n                else:\\n                    while i%2==0 and i>max_odd:\\n                        i = i//2\\n                    if i < max_odd:\\n                        dev.append((2*i-max_odd, max_odd-i))\\n                        \\n        # step 3: minimal sum of picked xi\\'s and yi\\'s\\n        dev.sort(reverse=True)\\n        if not dev: return 0\\n        max_down = [0] * len(dev)\\n        cur = 0\\n        for i in range(len(max_down)):\\n            cur = max(cur, dev[i][1])\\n            max_down[i] = cur\\n        mm = min(max_down[-1], dev[0][0])\\n        for i in range(len(max_down)-1):\\n            mm = min(mm, max_down[i]+dev[i+1][0])\\n        return mm\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1782155,
                "title": "c-set-with-explanation",
                "content": "# Daily Challenge:-19/02/2022.\\n**Approach**:-We take help of Set.\\nBasic about Set:-Set is Binary Search tree Based STL container in c++..\\nAs we know,The values in set are stored in a specific order.\\n\\n**What Actually We are doing**:-\\n**Step1:-**\\n-->Firstly we convert every odd element to even by multiplying it by two.\\nThis is because we avoid Calculation Part for odd element.\\n-->Now all the elements of array is even.\\n-->Then we store this Element in set.\\n\\n**Step2:-**\\n-->We know that for any array Deviation is difference btween maximum element of array and minimum element of array.\\n-->so,To minimize our deviation. We should make our maximum value of array as much close to minimum value.\\n\\n**Now ,understand what we are doing inside while loop:-**\\n*Before that I want to explain two things.*\\n1.) begin():-Returns an iterator to the first element in the set. Tc=O(log(n))\\n2.) rbegin():-Returns a reverse iterator pointing to the last element in the container. Tc=O(log(n))\\nAs we know set store element in sorted order.\\nSo, value at  begin() is minimum value in set.\\nand value at rbegin is maximum value of set.\\n\\nOne more thing you should know ,that ,In C++ Set doesn\\'t allow us to modify any value.\\nInsted of that you can remove that value and insert the modified value.\\n\\n**Now,Understand What Happening inside while loop.**\\n-->We calculate the deviation for that itration.(Calculating the difference btween maximum and minimum.)\\n-->Compare it with minimum deviation.-->Upgrade our minimum deviation.\\n\\n**Now,**\\n-->If our maximum value in set is Even means We can futher Reduce it.\\n-->So we divide it by two.\\nAnd We insert that modified vlaue in set.\\nAfter this Calculation Maximum value of set will Change,And It is always not necessary that It become previous maximum_value/2.\\n\\n\\n-->Else if our maximum value is Odd ,Means We can\\'t further minimize our Maximum value.\\nSo we break the Loop.\\n\\nIn the End return our minimum deviation value.\\n\\nWorst caseTime Complexity= O(nlog(n));\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n=nums.size();\\n        set<int>maxh; //Set for calculation.\\n        /*Step1:-Making Every odd element even. And storing all the element in set.*/\\n        for(int i=0;i<n;i++)\\n        {\\n            if((nums[i]&1)!=0)\\n                maxh.insert(nums[i]*2);\\n            else\\n                maxh.insert(nums[i]);\\n        }\\n        \\n        /*Step2*/\\n        int mn_deviation=INT_MAX;\\n        while(true)\\n        {\\n           int deviation=(*(maxh.rbegin())-*(maxh.begin())); //store the deviation\\n            \\n            mn_deviation=min(mn_deviation,deviation); //Update our minimum deviation.\\n            \\n            int max_value=*(maxh.rbegin()); //Maximum value.\\n            if((max_value & 1)==0)\\n            {\\n                /*If maximum value is Even,Minimize it further.*/\\n                maxh.erase(max_value);\\n                maxh.insert(max_value/2);\\n            }\\n            else\\n                break;\\n        }\\n            return mn_deviation;\\n    }\\n};\\n```\\n*If you find it helpful.Please Upvote.*",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n=nums.size();\\n        set<int>maxh; //Set for calculation.\\n        /*Step1:-Making Every odd element even. And storing all the element in set.*/\\n        for(int i=0;i<n;i++)\\n        {\\n            if((nums[i]&1)!=0)\\n                maxh.insert(nums[i]*2);\\n            else\\n                maxh.insert(nums[i]);\\n        }\\n        \\n        /*Step2*/\\n        int mn_deviation=INT_MAX;\\n        while(true)\\n        {\\n           int deviation=(*(maxh.rbegin())-*(maxh.begin())); //store the deviation\\n            \\n            mn_deviation=min(mn_deviation,deviation); //Update our minimum deviation.\\n            \\n            int max_value=*(maxh.rbegin()); //Maximum value.\\n            if((max_value & 1)==0)\\n            {\\n                /*If maximum value is Even,Minimize it further.*/\\n                maxh.erase(max_value);\\n                maxh.insert(max_value/2);\\n            }\\n            else\\n                break;\\n        }\\n            return mn_deviation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782398,
                "title": "notagenius-thought-process-and-solution-in-java",
                "content": "Hi everyone! The forum has several excellent solutions, but as always I like to give my own because I think some of these geniuses here don\\'t understand how we normal people think ;)\\n\\nAlright so... the problem is asking to minimize the maximum difference between any two elements in the array. I think the first realization we need to arrive at is that this maximum difference will be between the minimum element in the array and the maximum element in the array.\\n\\nSo my first thought was... we can keep operating on the min and max value in the array and calculating their difference - the expensive part of this approach is either recalculating min and max after each step, or keeping the array sorted.\\n\\nAn intuition at this point was to use a BST: we can remove the value to increase or decrease from the tree, increase it or decrease it, and put it back in the tree, in logarithmic time (if the tree is balanced, which, it should be).\\n\\nSo that was my first solution, using a Java `TreeSet<Integer>` and operating as described. This has the extra benefit of eliminating any duplicates. And this works for many inputs. However, it runs into the following question:\\n\\n- When the min element is even and the max element is odd, we cannot continue processing because we cannot increase even values or decrease odd values (alright)\\n- When both elements are odd, we have to increase the min to get them closer (increasing the max would only make the gap bigger, and we cannot decrease it) (alright)\\n- When both elements are even, we have to decrease the max to get them closer (as explained above) (alright)\\n- When the min element is odd and the max element is even though... there is a choice to make. We can make the min bigger or the max smaller. Which one do you choose? (Not alright!)\\n\\nSo my initial approach was to always choose to make the min bigger in this case. But the truth is, none of this approaches works for every possible input.\\n\\nAnd also... it falls into LOOPS.\\n\\nConsider this example: `[3,4,5]` (assume we put the elements into a TreeSet)\\n\\nWe get the min (`3`) and the max (`5`)\\nWe make the min bigger (`6`) and put it back in the tree\\n\\nThis results in `[4,5,6]`\\n\\nWhen we apply the algorithm again, we realize that both min and max are even, which per rules above we advance by halving the max, so we go back to `[3,4,5]`!!\\n\\nI spent some time here, because these loops are hard to detect... there can be some easy solutions for 1-step loops like this one, but some loops are longer and would demand us to code DFS with loop detection, essentially. I\\'m pretty sure that would TLE.\\n\\nThinking deeper, the problem behind these loops is that we don\\'t remember that in `[3,4,5]` the `3` that converts to a `6` and back to a `3` is always originated by the same element... if we had that memory, we could stop processing when we find a number that we have already moved in that direction. So that\\'s an option, I guess. \\n\\nAnother way that I thought to try to eliminate loops is to divide all even numbers by 2 as much as we can (to some sort of \"canonical\" form), and start processing from there just making numbers bigger and never smaller. This is an interesting idea, but it fails for the following reason: if a number has 2 as a factor more than once (for example 96 is 2^5 * 3, so 2 is 5 times there) we will arrive at some odd number (3 in the example) and the number won\\'t be able to grow anymore. This can be a problem. Consider:\\n\\n`[96, 41]`\\n\\nIf we preprocess this array the way we described, we arrive at `[3, 41]`. We would like now to make `3` bigger, so we go to `[6, 41]` and now we have to stop because `6` is even. So this idea is dumb, but it made me think about trying the opposite: making the odd numbers as big as we can and only proceed by making numbers smaller. This works because **we can only make each number bigger once**. Why? Because we make numbers bigger by multiplying them by 2, which makes them even, which forces us to stop.\\n\\nAlrighty then, we have a solution!\\n\\n- Put all elements of the array into a TreeSet. If the element is odd, add its double instead.\\n- While not finished (more on this later), read the max and the min from the tree and see if their diff bests our best result so far\\n- Remove the max, divide it by 2 and insert it back into the tree\\n\\nSo when are we done? When we get to a diff of `0` (we can\\'t optimize further), or when the max in the tree is odd (we can\\'t make it smaller).\\n\\nCool then! Here is the code:\\n\\n```java\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for(int num : nums) {\\n            if (isEven(num)) tree.add(num);\\n            else tree.add(num*2);\\n        }\\n        \\n        int min = tree.first();\\n        int max = tree.last();\\n        int result = max-min;\\n        \\n        while (!finished(min, max, result)) {\\n            tree.remove(max);\\n            tree.add(max/2);\\n            min = tree.first();\\n            max = tree.last();\\n            result = Math.min(result, max-min);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean finished(int min, int max, int result) {\\n        return result == 0 || isOdd(max);\\n    }\\n    \\n    private boolean isEven(int num) {\\n        return num % 2 == 0;\\n    }\\n    \\n    private boolean isOdd(int num) {\\n        return num % 2 != 0;\\n    }\\n}\\n```\\n\\nThe runtime complexity of this approach is \\n\\n- `O(nlogn)` for adding all elements to the BST\\n- `O(nlogn)` for removing all the elements from the tree once, decreasing them, and putting them back (worst case)\\n\\nso `O(nlogn)` overall (actually I was wrong with this, if the max value is a power of 2, you will have to keep dividing it many times. Anyway, the actual complexity will end up being `O(nlognlogm)` with m being the highest power of 2 present in the array - the point stands though that this is a linearithmic algorithm). \\n\\nIf you submit this solution, it will pass all testcases and perform well. It can be optimized a bit more. If interested, keep reading.\\n\\nSince we always operate on the max, we know what the min is, it\\'s either the previous min or the max/2 that we are inserting into the tree. So instead of fetching the min, we can just memorize it. This has the same runtime complexity as the previous approach, but a better constant factor (one less BST operation per loop execution).\\n\\n\\n```java\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for(int num : nums) {\\n            if (isEven(num)) tree.add(num);\\n            else tree.add(num*2);\\n        }\\n        \\n        int min = tree.first();\\n        int max = tree.last();\\n        int result = max-min;\\n        \\n        while (!finished(min, max, result)) {\\n            tree.remove(max);\\n            tree.add(max/2);\\n            min = Math.min(min, max/2);\\n            max = tree.last();\\n            result = Math.min(result, max-min);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean finished(int min, int max, int result) {\\n        return result == 0 || isOdd(max);\\n    }\\n    \\n    private boolean isEven(int num) {\\n        return num % 2 == 0;\\n    }\\n    \\n    private boolean isOdd(int num) {\\n        return num % 2 != 0;\\n    }\\n}\\n```\\n\\nBut then this leads to another possibility: if we care about max only, we can use a max-heap instead of a BST! Same code, but changing the data structure. Which yields the following solution:\\n\\n```java\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>(Collections.reverseOrder());\\n        int min = Integer.MAX_VALUE;\\n        for(int num : nums) {\\n            if (isEven(num)) heap.add(num);\\n            else {\\n                num*=2;\\n                heap.add(num);\\n            }\\n            min = Math.min(min, num);\\n        }\\n        \\n        int max = heap.poll();\\n        int result = max-min;\\n        \\n        while (!finished(min, max, result)) {\\n            heap.add(max/2);\\n            min = Math.min(min, max/2);\\n            max = heap.poll();\\n            result = Math.min(result, max-min);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean finished(int min, int max, int result) {\\n        return result == 0 || isOdd(max);\\n    }\\n    \\n    private boolean isEven(int num) {\\n        return num % 2 == 0;\\n    }\\n    \\n    private boolean isOdd(int num) {\\n        return num % 2 != 0;\\n    }\\n}\\n```\\n\\nThis has the same runtime complexity as the BST solution, but the heap is faster because it\\'s implemented as an array under the hood, while the BST is nodes and pointers, so the heap is bound the be faster. Keep in mind that `PriorityQueue` in Java is a min-heap, so use a reverse comparator to turn it into a max-heap as we need here.\\n\\nHope this helps! Enjoy programming!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for(int num : nums) {\\n            if (isEven(num)) tree.add(num);\\n            else tree.add(num*2);\\n        }\\n        \\n        int min = tree.first();\\n        int max = tree.last();\\n        int result = max-min;\\n        \\n        while (!finished(min, max, result)) {\\n            tree.remove(max);\\n            tree.add(max/2);\\n            min = tree.first();\\n            max = tree.last();\\n            result = Math.min(result, max-min);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean finished(int min, int max, int result) {\\n        return result == 0 || isOdd(max);\\n    }\\n    \\n    private boolean isEven(int num) {\\n        return num % 2 == 0;\\n    }\\n    \\n    private boolean isOdd(int num) {\\n        return num % 2 != 0;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for(int num : nums) {\\n            if (isEven(num)) tree.add(num);\\n            else tree.add(num*2);\\n        }\\n        \\n        int min = tree.first();\\n        int max = tree.last();\\n        int result = max-min;\\n        \\n        while (!finished(min, max, result)) {\\n            tree.remove(max);\\n            tree.add(max/2);\\n            min = Math.min(min, max/2);\\n            max = tree.last();\\n            result = Math.min(result, max-min);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean finished(int min, int max, int result) {\\n        return result == 0 || isOdd(max);\\n    }\\n    \\n    private boolean isEven(int num) {\\n        return num % 2 == 0;\\n    }\\n    \\n    private boolean isOdd(int num) {\\n        return num % 2 != 0;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>(Collections.reverseOrder());\\n        int min = Integer.MAX_VALUE;\\n        for(int num : nums) {\\n            if (isEven(num)) heap.add(num);\\n            else {\\n                num*=2;\\n                heap.add(num);\\n            }\\n            min = Math.min(min, num);\\n        }\\n        \\n        int max = heap.poll();\\n        int result = max-min;\\n        \\n        while (!finished(min, max, result)) {\\n            heap.add(max/2);\\n            min = Math.min(min, max/2);\\n            max = heap.poll();\\n            result = Math.min(result, max-min);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean finished(int min, int max, int result) {\\n        return result == 0 || isOdd(max);\\n    }\\n    \\n    private boolean isEven(int num) {\\n        return num % 2 == 0;\\n    }\\n    \\n    private boolean isOdd(int num) {\\n        return num % 2 != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781862,
                "title": "c-priority-queue-easy",
                "content": "\\u2714\\uFE0F **Question Conclusion**\\n* If the element is even, divide it by 2\\n* If the element is odd, multiply it by 2\\nConvert odd numbers to even numbers by doubling it only once. Similarly, an even number can be divided multiple times to get an odd number. Therefore, the value of even numbers can never be increased.\\n**Data Structure used: Priority Queue (Max Heap)\\nAlgorithm:**\\n* Convert all odd numbers to even by multiplying it by 2 once\\n* Push all the elements into the priority queue\\n* While the queue is not empty and the maximum value is even, do:\\n* Update the difference (maxval - minval) constantly, while reducing the maxval/2.\\n* Push maxval/2 onto the heap.\\n* Similarly, update the minval on each operation.\\n* Return the minimum value between difference and the (value of top of queue - minval).\\n![image](https://assets.leetcode.com/users/images/1c8061a8-32d8-4743-94f1-0ca770d96f37_1645241683.8619225.png)\\n![image](https://assets.leetcode.com/users/images/b7b82f04-7a7b-49b7-8da2-977ff774f663_1645241711.911504.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n       priority_queue<int> pq;\\n        int minval = INT_MAX;\\n        for(int i : nums){\\n            if(i%2==1) i*=2;\\n            minval = min(minval,i);\\n            pq.push(i);\\n        }\\n        int diff = INT_MAX;\\n        while( pq.top()%2==0){\\n            int maxval = pq.top();\\n            pq.pop();\\n            diff = min(diff,maxval-minval);\\n            minval = min(minval,maxval/2);\\n            pq.push(maxval/2);\\n        }\\n        return min(diff,pq.top()-minval);\\n    }\\n};\\n```\\nTime Complexity : O(N(logN)(logM))\\nSpace Complexity : O(N)\\nWhere M = max. element present in the array\\n\\nPlease Upvote, if found useful!!\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n       priority_queue<int> pq;\\n        int minval = INT_MAX;\\n        for(int i : nums){\\n            if(i%2==1) i*=2;\\n            minval = min(minval,i);\\n            pq.push(i);\\n        }\\n        int diff = INT_MAX;\\n        while( pq.top()%2==0){\\n            int maxval = pq.top();\\n            pq.pop();\\n            diff = min(diff,maxval-minval);\\n            minval = min(minval,maxval/2);\\n            pq.push(maxval/2);\\n        }\\n        return min(diff,pq.top()-minval);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952866,
                "title": "easiest-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeviation(vector<int>& nums) {\\n        set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]%2==0?nums[i]:nums[i]*2);//insert even directly and odd with one time multiplication and it will become even.\\n        }\\n        int diff=*s.rbegin()-*s.begin();\\n        while(*s.rbegin()%2==0){//run the loop untill difference is minimized\\n            int x=*s.rbegin();\\n            s.erase(x);\\n            s.insert(x/2);\\n            diff = min(diff,*s.rbegin()-*s.begin());\\n        }\\n        return diff;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeviation(vector<int>& nums) {\\n        set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]%2==0?nums[i]:nums[i]*2);//insert even directly and odd with one time multiplication and it will become even.\\n        }\\n        int diff=*s.rbegin()-*s.begin();\\n        while(*s.rbegin()%2==0){//run the loop untill difference is minimized\\n            int x=*s.rbegin();\\n            s.erase(x);\\n            s.insert(x/2);\\n            diff = min(diff,*s.rbegin()-*s.begin());\\n        }\\n        return diff;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952819,
                "title": "python-priority-queue-and-record-the-lower-and-upper-bound",
                "content": "The key is to record the range of lower and upper bound for each number.\\nEach time pop out the smallest number and double it and push it back to the priority queue.\\nUntil we can no longer increase the smallest element.\\nUse a separate variable maxx to record the maximum number in the priority queue.\\n\\n\\tclass Solution:\\n\\t\\tdef minimumDeviation(self, nums: List[int]) -> int:\\n\\t\\t\\tpq = []\\n\\n\\t\\t\\t# record the lower and upper bound for each number\\n\\t\\t\\tfor i, n in enumerate(nums):\\n\\t\\t\\t\\tif n % 2 == 0:\\n\\t\\t\\t\\t\\tupper = n\\n\\t\\t\\t\\t\\twhile n % 2 == 0:\\n\\t\\t\\t\\t\\t\\tn //= 2\\n\\t\\t\\t\\t\\tpq.append([n, upper])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpq.append([n, n*2])\\n\\n\\t\\t\\t# determine the miminum upper bound for each even number\\n\\t\\t\\tmaxx = max([val[0] for val in pq])\\n\\n\\t\\t\\theapq.heapify(pq)\\n\\n\\t\\t\\tres = maxx - pq[0][0]\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tval, bound = heapq.heappop(pq)\\n\\t\\t\\t\\tif val >= bound:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tmaxx = max(val*2, maxx)\\n\\t\\t\\t\\theapq.heappush(pq, [val*2, bound])\\n\\n\\t\\t\\t\\tres = min(res, maxx-pq[0][0])\\n\\n\\n\\t\\t\\treturn res\\n\\n\\n",
                "solutionTags": [],
                "code": "The key is to record the range of lower and upper bound for each number.\\nEach time pop out the smallest number and double it and push it back to the priority queue.\\nUntil we can no longer increase the smallest element.\\nUse a separate variable maxx to record the maximum number in the priority queue.\\n\\n\\tclass Solution:\\n\\t\\tdef minimumDeviation(self, nums: List[int]) -> int:\\n\\t\\t\\tpq = []\\n\\n\\t\\t\\t# record the lower and upper bound for each number\\n\\t\\t\\tfor i, n in enumerate(nums):\\n\\t\\t\\t\\tif n % 2 == 0:\\n\\t\\t\\t\\t\\tupper = n\\n\\t\\t\\t\\t\\twhile n % 2 == 0:\\n\\t\\t\\t\\t\\t\\tn //= 2\\n\\t\\t\\t\\t\\tpq.append([n, upper])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpq.append([n, n*2])\\n\\n\\t\\t\\t# determine the miminum upper bound for each even number\\n\\t\\t\\tmaxx = max([val[0] for val in pq])\\n\\n\\t\\t\\theapq.heapify(pq)\\n\\n\\t\\t\\tres = maxx - pq[0][0]\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tval, bound = heapq.heappop(pq)\\n\\t\\t\\t\\tif val >= bound:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tmaxx = max(val*2, maxx)\\n\\t\\t\\t\\theapq.heappush(pq, [val*2, bound])\\n\\n\\t\\t\\t\\tres = min(res, maxx-pq[0][0])\\n\\n\\n\\t\\t\\treturn res\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1782626,
                "title": "python-simple-python-solution-by-sortedlist",
                "content": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef minimumDeviation(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tfrom sortedcontainers import SortedList\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\n\\t\\t\\t\\tif nums[i]%2!=0:\\n\\t\\t\\t\\t\\tnums[i]=nums[i]*2\\n\\n\\t\\t\\tnums = SortedList(nums)\\n\\n\\t\\t\\tresult = 100000000000\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tmin_value = nums[0]\\n\\t\\t\\t\\tmax_value = nums[-1]\\n\\n\\t\\t\\t\\tif max_value % 2 == 0:\\n\\t\\t\\t\\t\\tnums.pop()\\n\\t\\t\\t\\t\\tnums.add(max_value // 2)\\n\\t\\t\\t\\t\\tmax_value = nums[-1]\\n\\t\\t\\t\\t\\tmin_value = nums[0]\\n\\n\\t\\t\\t\\t\\tresult = min(result , max_value - min_value)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult = min(result , max_value - min_value)\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn result\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef minimumDeviation(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tfrom sortedcontainers import SortedList\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\n\\t\\t\\t\\tif nums[i]%2!=0:\\n\\t\\t\\t\\t\\tnums[i]=nums[i]*2\\n\\n\\t\\t\\tnums = SortedList(nums)\\n\\n\\t\\t\\tresult = 100000000000\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tmin_value = nums[0]\\n\\t\\t\\t\\tmax_value = nums[-1]\\n\\n\\t\\t\\t\\tif max_value % 2 == 0:\\n\\t\\t\\t\\t\\tnums.pop()\\n\\t\\t\\t\\t\\tnums.add(max_value // 2)\\n\\t\\t\\t\\t\\tmax_value = nums[-1]\\n\\t\\t\\t\\t\\tmin_value = nums[0]\\n\\n\\t\\t\\t\\t\\tresult = min(result , max_value - min_value)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult = min(result , max_value - min_value)\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn result\\n",
                "codeTag": "Java"
            },
            {
                "id": 954526,
                "title": "c-o-n-log-n-log-max-using-priority-queue-and-sorted-set",
                "content": ".NET 6 - Using Priority Queue\\n\\n```csharp\\npublic int MinimumDeviation(int[] nums)\\n{\\n\\tPriorityQueue<int, int> pq = new PriorityQueue<int, int>(Comparer<int>.Create((x,y) => y.CompareTo(x)));\\n\\tint min = int.MaxValue;\\n\\n\\tforeach (var num in nums)\\n\\t{\\n\\t\\tint current = num;\\n\\n\\t\\tif (num % 2 == 1)\\n\\t\\t{\\n\\t\\t\\tcurrent *= 2;                \\n\\t\\t}\\n\\n\\t\\tpq.Enqueue(current, current);            \\n\\t\\tmin = Math.Min(min, current);\\n\\t}\\n\\n\\tint result = pq.Peek() - min;\\n\\n\\twhile (pq.Count > 0 && pq.Peek() % 2 == 0)\\n\\t{\\n\\t\\tint max = pq.Dequeue();\\n\\t\\tint half = max / 2;\\n\\n\\t\\tpq.Enqueue(half, half);\\n\\t\\tmin = Math.Min(min, half);\\n\\n\\t\\tresult = Math.Min(result, pq.Peek() - min);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\nOriginal answer using Sorted Set:\\n\\n```csharp\\npublic int MinimumDeviation(int[] nums)\\n{\\n\\tSortedSet<int> set = new SortedSet<int>();\\n\\n\\tforeach (var num in nums)\\n\\t{\\n\\t\\tif (num % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tset.Add(num);\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tset.Add(num * 2);\\n\\t\\t}\\n\\t}\\n\\n\\tint result = set.Max - set.Min;\\n\\twhile (set.Max % 2 == 0)\\n\\t{\\n\\t\\tint last = set.Max;\\n\\t\\tset.Remove(last);\\n\\t\\tset.Add(last / 2);\\n\\t\\tresult = Math.Min(result, set.Max - set.Min);\\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinimumDeviation(int[] nums)\\n{\\n\\tPriorityQueue<int, int> pq = new PriorityQueue<int, int>(Comparer<int>.Create((x,y) => y.CompareTo(x)));\\n\\tint min = int.MaxValue;\\n\\n\\tforeach (var num in nums)\\n\\t{\\n\\t\\tint current = num;\\n\\n\\t\\tif (num % 2 == 1)\\n\\t\\t{\\n\\t\\t\\tcurrent *= 2;                \\n\\t\\t}\\n\\n\\t\\tpq.Enqueue(current, current);            \\n\\t\\tmin = Math.Min(min, current);\\n\\t}\\n\\n\\tint result = pq.Peek() - min;\\n\\n\\twhile (pq.Count > 0 && pq.Peek() % 2 == 0)\\n\\t{\\n\\t\\tint max = pq.Dequeue();\\n\\t\\tint half = max / 2;\\n\\n\\t\\tpq.Enqueue(half, half);\\n\\t\\tmin = Math.Min(min, half);\\n\\n\\t\\tresult = Math.Min(result, pq.Peek() - min);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\n```csharp\\npublic int MinimumDeviation(int[] nums)\\n{\\n\\tSortedSet<int> set = new SortedSet<int>();\\n\\n\\tforeach (var num in nums)\\n\\t{\\n\\t\\tif (num % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tset.Add(num);\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tset.Add(num * 2);\\n\\t\\t}\\n\\t}\\n\\n\\tint result = set.Max - set.Min;\\n\\twhile (set.Max % 2 == 0)\\n\\t{\\n\\t\\tint last = set.Max;\\n\\t\\tset.Remove(last);\\n\\t\\tset.Add(last / 2);\\n\\t\\tresult = Math.Min(result, set.Max - set.Min);\\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042500,
                "title": "minimize-deviation-in-array-detailed-explanation",
                "content": "***Idea:***\\n\\nThe hints in this case are a little backwards. Since it\\'s only ever possible to perform the multiply operation once (as the number will then be an even number), but you can potentially perform the division operation many times, it\\'s far better to start from the maximum value for each **nums[i]** and work downward.\\n\\nIf you started from the minimum value, as the hints suggest, then you\\'d have to separately keep track of the max value for each element so that you don\\'t multiply past that amount while moving upward.\\n\\nThe idea is actually very simple from there. Find the max possible value for each **nums[i]**, then keep taking the largest one and dividing by **2** if it\\'s even. At each step, check to see if you\\'ve found a new best **ans** (highest value - lowest value). If the largest number is odd, you can\\'t divide it by **2**, which means it\\'s impossible to reach a better number than you\\'ve already found, so return your best **ans**.\\n\\n` `\\n***Implementation:***\\n\\nSince we need sorted data, but we only ever need the modify the max value at any time, we should use a **max-heap** or **priority queue** structure. We will need the smallest value of **nums**, but we don\\'t actually need to modify that element, so we can just keep track of it in **min** as we go.\\n\\nFirst, we need to iterate through **nums**, multiply any odd numbers by **2**, then insert them into **heap** or **pq** while making sure to update **min** if necessary.\\n\\nThen, while the largest value in **heap**/**pq** is even, we can take it out, divide it by **2**, update our **ans** and **min** if necessary, and reinsert it back into the **heap**/**pq**.\\n\\nOnce we reach an odd number at the top of **heap**/**pq**, return the best **ans**.\\n\\n` `\\n***Javascript Code w/ MinPriorityQueue():***\\n\\nThis code is easier to read, but less efficient.\\n\\nThe best result for the code below is **360ms / 82.8MB** (beats 58% / 27%)\\n```\\nvar minimumDeviation = function(nums) {\\n    let pq = new MaxPriorityQueue({priority: x => x})\\n    for (let n of nums) {\\n        if (n % 2) n *= 2\\n        pq.enqueue(n)\\n    }\\n    let ans = pq.front().element - pq.back().element\\n    while (pq.front().element % 2 === 0) {\\n        pq.enqueue(pq.dequeue().element / 2)\\n        ans = Math.min(ans, pq.front().element - pq.back().element)\\n    }\\n    return ans\\n};\\n```\\n` `\\n**Javascript Code w/ Max-Heap Implementation:**\\n\\nThe best result for the code below is **128ms / 52.7MB** (beats 97% / 85%)\\n```\\nvar minimumDeviation = function(nums) {\\n    let len = nums.length, min = Infinity,\\n        heap = new Uint32Array(len+1), hix = 1\\n    heap[0] = 2e9\\n    const heapify = val => {\\n        let i = hix, par = i >> 1, temp\\n        heap[hix++] = val\\n        while (heap[par] < heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const extract = () => {\\n        let max = heap[1], left, right, temp,\\n            i = 1, child = heap[3] > heap[2] ? 3 : 2\\n        heap[1] = heap[--hix], heap[hix] = 0\\n        while (heap[i] < heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] > heap[left] ? right : left\\n        }\\n        return max\\n    }\\n    for (let i = 0, n = nums[0]; i < len; n = nums[++i]) {\\n        if (n % 2) n *= 2\\n        if (n < min) min = n\\n        heapify(n)\\n    }\\n    let curr = extract(), ans = curr - min\\n    while (curr % 2 === 0) {\\n        curr /= 2\\n        if (curr < min) min = curr\\n        heapify(curr)\\n        curr = extract()\\n        ans = Math.min(ans, curr - min)\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumDeviation = function(nums) {\\n    let pq = new MaxPriorityQueue({priority: x => x})\\n    for (let n of nums) {\\n        if (n % 2) n *= 2\\n        pq.enqueue(n)\\n    }\\n    let ans = pq.front().element - pq.back().element\\n    while (pq.front().element % 2 === 0) {\\n        pq.enqueue(pq.dequeue().element / 2)\\n        ans = Math.min(ans, pq.front().element - pq.back().element)\\n    }\\n    return ans\\n};\\n```\n```\\nvar minimumDeviation = function(nums) {\\n    let len = nums.length, min = Infinity,\\n        heap = new Uint32Array(len+1), hix = 1\\n    heap[0] = 2e9\\n    const heapify = val => {\\n        let i = hix, par = i >> 1, temp\\n        heap[hix++] = val\\n        while (heap[par] < heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const extract = () => {\\n        let max = heap[1], left, right, temp,\\n            i = 1, child = heap[3] > heap[2] ? 3 : 2\\n        heap[1] = heap[--hix], heap[hix] = 0\\n        while (heap[i] < heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] > heap[left] ? right : left\\n        }\\n        return max\\n    }\\n    for (let i = 0, n = nums[0]; i < len; n = nums[++i]) {\\n        if (n % 2) n *= 2\\n        if (n < min) min = n\\n        heapify(n)\\n    }\\n    let curr = extract(), ans = curr - min\\n    while (curr % 2 === 0) {\\n        curr /= 2\\n        if (curr < min) min = curr\\n        heapify(curr)\\n        curr = extract()\\n        ans = Math.min(ans, curr - min)\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042240,
                "title": "c-explanation-intuitive-priority-queue-solution",
                "content": "**Priority Queue**\\n                                                                             \\nEach element in the array can be transformed based on its parity:\\n                                                                             \\n- Odd elements can be multiplied by 2. But an odd element multiplied by 2 becomes even.\\n- Even elements can only be divided by 2. But they can only be divided until they reach an odd number, 1 if it is a power of 2.\\n                                                                             \\nTherefore, each element in the input array can only be transformed within some range:\\n                                                                             \\n- The lowest value is the last value until it becomes odd when dividing by 2.\\n- The highest value is itself if it is even, or its double if it is odd.\\n                                                                             \\nFor instance:\\n                                                                             \\n- 3: [3, 6]\\n- 4: [1, 2, 4]\\n- 5: [5, 10]\\n- 6: [3, 6]\\n                                                                             \\nNow, the question is to find which element to chose in each range to minimize the global deviation. One strategy is to start with an initial configuration and improve the deviation at each step:\\n                                                                             \\n- Set all the elements to their highest values: this is the current chosen set to compute the deviation. Maintain the minimum element among the currently chosen values.\\n- Pick the highest element and compute the difference with the minimum value. This is the maximum deviation for the current set of elements.\\n- To reduce it, the only thing you can try is replacing the highest element with the previous value in its range, if any. To find the previous value in a range, you only need to divide the current value by 2 if it is even, otherwise there is no remaining element, and you can\\'t improve the deviation further.\\n                                                                             \\nRetrieving the maximum value from a collection and inserting new elements in it is implemented efficiently by heaps (or priority queues).\\n                                                                             \\nIf the maximum element is `m`, the number of candidates in its range is at most `log(m)`, which happens when it is a power of 2. There are `n` elements, for a maximum of `nlog(m)` candidates. At each step, a new element is inserted into the priority queue with a time complexity of `O(log(n))`.\\n                                                                             \\nComplexity: `O(nlog(m)log(n))` time, `O(n)` space.\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint minimumDeviation(vector<int>& nums) {\\n\\t\\tint mini = INT_MAX;\\n\\t\\tpriority_queue<int> pq;\\n\\n\\t\\tfor (auto n : nums) {\\n\\t\\t\\tif (n % 2 == 1) {\\n\\t\\t\\t\\tn *= 2;\\n\\t\\t\\t}\\n\\t\\t\\tmini = min(mini, n);\\n\\t\\t\\tpq.push(n);\\n\\t\\t}\\n\\n\\t\\tint res = INT_MAX;\\n\\n\\t\\twhile (true) {\\n\\t\\t\\tint n = pq.top();\\n\\t\\t\\tpq.pop();\\n\\n\\t\\t\\tres = min(res, n - mini);\\n\\n\\t\\t\\tif (n % 2 == 1) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmini = min(mini, n / 2);\\n\\t\\t\\tpq.push(n / 2);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n};\\n```\\n\\nIf you appreciate this solution, please **upvote**!",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\tint minimumDeviation(vector<int>& nums) {\\n\\t\\tint mini = INT_MAX;\\n\\t\\tpriority_queue<int> pq;\\n\\n\\t\\tfor (auto n : nums) {\\n\\t\\t\\tif (n % 2 == 1) {\\n\\t\\t\\t\\tn *= 2;\\n\\t\\t\\t}\\n\\t\\t\\tmini = min(mini, n);\\n\\t\\t\\tpq.push(n);\\n\\t\\t}\\n\\n\\t\\tint res = INT_MAX;\\n\\n\\t\\twhile (true) {\\n\\t\\t\\tint n = pq.top();\\n\\t\\t\\tpq.pop();\\n\\n\\t\\t\\tres = min(res, n - mini);\\n\\n\\t\\t\\tif (n % 2 == 1) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmini = min(mini, n / 2);\\n\\t\\t\\tpq.push(n / 2);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782189,
                "title": "c-intuition-and-example-easy-to-understand",
                "content": "\\n\\n### **Explanation**\\nPoints to note: \\n1. If a number is **even**, it can only be **reduced** (by dividing it by 2). \\n2. If a number is **odd**, then we can only once multiply it by 2. Then it becomes even. So, we **cannot increase it further**.\\n\\nNote that if all numbers are even then, we can only reduce them. But if some numbers are odd, we can increase them only once (because they become even after that).\\n\\nWhat if we make all of them even?\\uD83E\\uDD14\\nThen we only have to work with even numbers and reduce the largest number. Max-heap can help us in getting the largest number. Also, we need to keep track of the minimum number to calculate the minimum deviation. \\n\\nBut when should we end our search? Let\\'s understand this with an example:\\n\\n\\nnums=[5, 3, 2, 8]\\n\\n1. Multiplying odd numbers by 2.\\n\\tnums=[10, 6, 2, 8]\\n\\tInitialisiation: \\n\\tminimum number = INFINITY, min deviation till now= INFINITY\\n\\t\\n2. Now push all of them in a max-heap:\\n\\theap= [10, 8, 6, 2], \\n\\tminimum number= 2, min deviation till now= 8\\n\\t \\n3. Let\\'s pop out the top of heap and insert it\\'s half in the heap\\n\\theap=[8, 6, 5, 2]\\t\\n\\tminimum number=2, min deviation till now= min(8, 8-2)=6\\n\\t\\n4. Again doing the same as step 3:\\n\\theap= [6, 5, 4, 2]\\n\\tminimum number=2, min deviation till now= min(6, 6-2) = 4\\n\\t\\n5. Again doing the same as step 3:\\n\\theap= [5, 4, 3, 2]\\n\\tminimum number=2, min deviation till now= min(4, 5-2)= 3\\n\\n6. Now, if we again try doing the same as step 3 we can\\'t because the top is odd. Multiplying it by 2 won\\'t do any good as the difference will increase. \\nWhat if we try to divide the minimum number by 2?\\n\\theap = [5, 4, 3, 1]\\n\\tminimum number=1, min deviation till now= min(3, 5-1) = 3 [Same as in step 5]\\n\\tThe difference is increasing, so this will do no good to us. \\n\\t\\nWhat if there is a case when the minimum number is odd, and we could multiply it by 2 to increase it and decrease the difference? \\nWell, if the smallest number is odd, then it means we have already seen its multiplication with 2 in the previous steps [Remember that we started with all even numbers]. \\n\\n**So we can conclude that we have to stop when we encounter an odd number at the top of our heap.** \\u270C\\uFE0F\\n\\n### **Code**\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int>pq;\\n        int minnum=INT_MAX, ans=INT_MAX;\\n        \\n        for(int n:nums){\\n            if(n&1) n=n*2; //if n is odd multiply it by 2\\n            pq.push(n);\\n            minnum=min(minnum,n);\\n        }\\n        \\n        while(!(pq.top()&1)){ //while the top element is even\\n            int now=pq.top();\\n            pq.pop();\\n            ans=min(ans,now-minnum); // update the ans if current max deviation is less than previous ones\\n            minnum=min(minnum,now/2); //update the minimum number if now/2 is smaller\\n            pq.push(now/2);\\n        }\\n        ans=min(ans,pq.top()-minnum);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int>pq;\\n        int minnum=INT_MAX, ans=INT_MAX;\\n        \\n        for(int n:nums){\\n            if(n&1) n=n*2; //if n is odd multiply it by 2\\n            pq.push(n);\\n            minnum=min(minnum,n);\\n        }\\n        \\n        while(!(pq.top()&1)){ //while the top element is even\\n            int now=pq.top();\\n            pq.pop();\\n            ans=min(ans,now-minnum); // update the ans if current max deviation is less than previous ones\\n            minnum=min(minnum,now/2); //update the minimum number if now/2 is smaller\\n            pq.push(now/2);\\n        }\\n        ans=min(ans,pq.top()-minnum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224159,
                "title": "just-1-sort-no-pq-no-orderedset-beats-99",
                "content": "# Please upvote if learned something new / unique. \\uD83D\\uDE07\\n\\n# Approach\\n- \\n  No need of priority Queue.\\n  Just few time back I post brief explanation. I deleted that, After relasing there are tons of explanation available. Let me just show you my solution where I have not used PQ using circular dependency trick.\\n- Look at the problem in a different way. Say we have all even numbers we can devide them by 2 until it becomes odd.\\n- Rest of everything similar to what it is explained in other blogs/solutions.\\n\\n**is circular dependency always available ?**\\nNo ! to achieve circular dependency of adjacent maximum minimum. You would have to make all number close to maximum or minimum.\\n\\n```\\nfor (int i = n - 1 ; i>= 0; i--) {\\n        while (a[i] % 2 == 0 and a[i]/2 >= mn) a[i] >>= 1;\\n}\\n```\\n<h2>Why Not Priority Queue ?</h4>\\n\\npriority queue is good when we have randomness in ordering.\\nLet me give an example.\\n\\nX = [16, 18, 44 80]\\nhere I as I mentioned before. We would assume we can only have even and we  can keep reducing untill becomes odd.\\nso for X array maximum value if 80 right ?\\nIf we devide by 2 for 80, it would be 40, but you see you can further reduce this and to 20 right ? then to 10 ?\\nAnd also for the current scenario our minimum 16.\\nSo with all other numbers we would try to reach 16 as close as possible but will not cross it. By crossing I meant the reduced value should not be < 16.\\n\\nso after approaching 16. Array X looks like - [16, 18, 22, 20]\\nNow lets sort it  - [16, 18, 20, 22]\\nnow you see this particular array is arraged such a way that even the biggest number in the array (i.e 22) if it is devided by 2 then it would be lesser than 16.\\nso [16, 18, 20, 22] - lets halve last (3rd) index.\\n-> [16, 18, 20, 11] - you see current array new minimum is 3rd index and new maximum 2nd index.\\n-> now lets halve 20.\\n-> [16, 18, 10, 11] - you see current array new minimum is 2nd index and\\nnew maximum is 1st index.\\n-> and so on....\\nSo you can see there is adjacent Minimum Maximum existance.\\n\\n```\\nAfter dividing the ith index, the ith index is becoming minimum \\nand the (i - 1)th index maximum except for i = 0, where (i - 1)th index\\nwill be actually the last index which can be taken care of by ( % arr length )\\n```\\n\\n# Complexity\\n- Time complexity: O(Nlog(Max(Ai))) where Max(Ai) -> Maximum of all the elements.\\n- Space O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int minimumDeviation(vector<int>& a) {\\n            int n = a.size(); \\n            int mn = INT_MAX;  \\n            for (int i = 0 ; i<n ; i++) {\\n                  if (a[i] & 1) a[i] *= 2;\\n                  mn = min(mn, a[i]);\\n            }  \\n            for (int i = n - 1 ; i>= 0; i--) {\\n                  while (a[i] % 2 == 0 and a[i]/2 >= mn) a[i] >>= 1;\\n            }\\n            sort(a.begin(), a.end()); \\n            int ans = a[n - 1] - a[0]; \\n            int i = n - 1; \\n            while (a[i] % 2 == 0) { \\n                  a[i] /= 2;\\n                  ans = min(ans, a[(i - 1 + n) % n] - a[i]); \\n                  i = (i - 1 + n) % n;\\n            } \\n            return (int)ans; \\n      }\\n};\\n```\\n# Please upvote if learned something new / unique. \\uD83D\\uDE07",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nfor (int i = n - 1 ; i>= 0; i--) {\\n        while (a[i] % 2 == 0 and a[i]/2 >= mn) a[i] >>= 1;\\n}\\n```\n```\\nAfter dividing the ith index, the ith index is becoming minimum \\nand the (i - 1)th index maximum except for i = 0, where (i - 1)th index\\nwill be actually the last index which can be taken care of by ( % arr length )\\n```\n```\\nclass Solution {\\npublic:\\n      int minimumDeviation(vector<int>& a) {\\n            int n = a.size(); \\n            int mn = INT_MAX;  \\n            for (int i = 0 ; i<n ; i++) {\\n                  if (a[i] & 1) a[i] *= 2;\\n                  mn = min(mn, a[i]);\\n            }  \\n            for (int i = n - 1 ; i>= 0; i--) {\\n                  while (a[i] % 2 == 0 and a[i]/2 >= mn) a[i] >>= 1;\\n            }\\n            sort(a.begin(), a.end()); \\n            int ans = a[n - 1] - a[0]; \\n            int i = n - 1; \\n            while (a[i] % 2 == 0) { \\n                  a[i] /= 2;\\n                  ans = min(ans, a[(i - 1 + n) % n] - a[i]); \\n                  i = (i - 1 + n) % n;\\n            } \\n            return (int)ans; \\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781727,
                "title": "python-two-heaps-solution-beat-92-both-time-and-space",
                "content": "The core logic is that: \\nWhen max is an even, try to reduce it until max becomes an odd;\\nWhen min is an odd, try to increase it until min becomes an even.\\nDuring this process, keep updating min, max and smallest deviation.\\n\\n```\\nimport heapq\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        dev = max(nums) - min(nums)\\n        cur_max = max(nums)\\n\\t\\t#some preparation before increasing min\\n        small = []\\n        for num in nums:\\n            heapq.heappush(small, num)\\n\\t\\t#here starts increase min\\n        cur = heapq.heappop(small)\\n        while cur % 2 == 1:\\n            heapq.heappush(small, cur * 2)\\n            cur_max = max(cur_max, cur * 2)\\n            cur = heapq.heappop(small)\\n            dev = min(dev, abs(cur_max - cur))\\n        heapq.heappush(small, cur)\\n\\t\\t#some preparation before reducing max\\n        cur_min = cur\\n        big = []\\n        for num in small:\\n            heapq.heappush(big, -1 * num)\\n\\t\\t#here starts reducing max\\n        cur = heapq.heappop(big)\\n        while cur % 2 == 0:\\n            heapq.heappush(big, cur // 2)\\n            cur_min = min(cur_min, cur * -1 // 2)\\n            cur = heapq.heappop(big)\\n            dev = min(dev, abs(-1 * cur - cur_min))\\n        return dev",
                "solutionTags": [],
                "code": "The core logic is that: \\nWhen max is an even, try to reduce it until max becomes an odd;\\nWhen min is an odd, try to increase it until min becomes an even.\\nDuring this process, keep updating min, max and smallest deviation.\\n\\n```\\nimport heapq\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        dev = max(nums) - min(nums)\\n        cur_max = max(nums)\\n\\t\\t#some preparation before increasing min\\n        small = []\\n        for num in nums:\\n            heapq.heappush(small, num)\\n\\t\\t#here starts increase min\\n        cur = heapq.heappop(small)\\n        while cur % 2 == 1:\\n            heapq.heappush(small, cur * 2)\\n            cur_max = max(cur_max, cur * 2)\\n            cur = heapq.heappop(small)\\n            dev = min(dev, abs(cur_max - cur))\\n        heapq.heappush(small, cur)\\n\\t\\t#some preparation before reducing max\\n        cur_min = cur\\n        big = []\\n        for num in small:\\n            heapq.heappush(big, -1 * num)\\n\\t\\t#here starts reducing max\\n        cur = heapq.heappop(big)\\n        while cur % 2 == 0:\\n            heapq.heappush(big, cur // 2)\\n            cur_min = min(cur_min, cur * -1 // 2)\\n            cur = heapq.heappop(big)\\n            dev = min(dev, abs(-1 * cur - cur_min))\\n        return dev",
                "codeTag": "Java"
            },
            {
                "id": 1053053,
                "title": "ruby-working-with-priority-queue-in-ruby-one-approach",
                "content": "### Note about Priority Queues in Ruby\\n\\nThere are no built in Priority Queue in Ruby. If you need one can use initialy sorted array and use method `Array#bsearch_index` to find element.\\n\\n### Optimization\\n\\nChange odd numbers to even initially to have one type of tranformation -- divide any even number by two.\\n\\n### Algorithm\\n\\nDivide maximum number by two while its even each time check for `max - min` diff. When maximum is odd we stop: cannot decrease max num.\\n\\n### Implementation\\n\\nStore numbers in Priority Queue - sorted array. Pop max number, divide by two, put back in priority queue.\\nHere used helper method to put an element in ASC sorted array (sort of a min-heap), but we `pop` element from the end of an array.\\n\\n```ruby\\n# Insert value into ASC sorted array (min-heap). Change to `y <= x` for max-heap.\\ndef heappush(arr, x)\\n  idx = arr.bsearch_index { |y| y >= x } || arr.size\\n  arr.insert(idx, x)\\nend\\n\\ndef minimum_deviation(nums)\\n  (0...nums.size).each { |i| nums[i] *= 2 if nums[i].odd? }\\n  nums.sort!\\n  res = nums.last - nums.first\\n\\n  while (mx = nums.pop).even?\\n    heappush(nums, mx / 2)\\n    res = [res, nums.last - nums.first].min\\n  end\\n  res\\nend\\n```\\n\\n### Same with sort of a max-heap\\n\\nNow sort array nums in descending order.\\nChange `y => x` to `y <= x`, `nums.pop` to `nums.shift` and `nums.last - nums.first` to `nums.first - nums.last`\\n\\n```ruby\\n# Insert value into DESC sorted array (sort of a max-heap)\\ndef heappush(arr, x)\\n  idx = arr.bsearch_index { |y| y <= x } || arr.size\\n  arr.insert(idx, x)\\nend\\n\\ndef minimum_deviation(nums)\\n  (0...nums.size).each { |i| nums[i] *= 2 if nums[i].odd? }\\n  nums.sort_by!(&:-@) # Same as `nums.sort!.reverse!`\\n  res = nums.first - nums.last\\n\\n  while (mx = nums.shift).even?\\n    heappush(nums, mx / 2)\\n    res = [res, nums.first - nums.last].min\\n  end\\n  res\\nend\\n```\\n\\nNOTE: this version gives TLE. Apparenlty `Array#pop` is faster then `Array#shift`\\n\\n### One general approach (variant) to work with Priority Queue in Ruby\\n\\nTwo handy helper methods to work with ascending sorted array (sort of a min-heap)\\n\\n```ruby\\n# Insert element into ASC sorted array.\\ndef heappush(arr, x)\\n  idx = arr.bsearch_index { |y| (y <=> x) >= 0 } || arr.size\\n  arr.insert(idx, x)\\nend\\n# Remove element from ASC sorted array if the element is present.\\ndef heappop(arr, x)\\n  idx = arr.bsearch_index { |y| (y <=> x) >= 0 }\\n  arr.delete_at(idx) if idx && arr[idx] == x\\nend\\n```\\n\\nSame for descending sorted array\\n\\n```ruby\\n# Insert element into DESC sorted array.\\ndef heappush(arr, x)\\n  idx = arr.bsearch_index { |y| (y <=> x) <= 0 } || arr.size\\n  arr.insert(idx, x)\\nend\\n# Remove element from DESC sorted array if the element is present.\\ndef heappop(arr, x)\\n  idx = arr.bsearch_index { |y| (y <=> x) <= 0 }\\n  arr.delete_at(idx) if idx && arr[idx] == x\\nend\\n```\\n\\n### UPDATE: Another solution without Heap\\n\\nStoring extracted maximums divided by 2 in another array `q`.\\n\\n```ruby\\ndef minimum_deviation(nums)\\n  nums.each_with_index {|x, i| nums[i] *= 2 if x.odd? }\\n  nums.sort!\\n  res = nums.last - nums.first\\n  q = []\\n\\n  while [nums.last, q.first].compact.max&.even?\\n    if nums.any? && (q.empty? || q.first < nums.last)\\n      m = nums.pop\\n    else\\n      m = q.shift\\n    end\\n    q << m/2\\n    res = [res, [nums.last, q.first].compact.max - [nums.first, q.last].compact.min].min\\n  end\\n  res\\nend\\n```\\n\\nTime complexity: `O(n * log n)`",
                "solutionTags": [
                    "Ruby",
                    "Heap (Priority Queue)"
                ],
                "code": "```ruby\\n# Insert value into ASC sorted array (min-heap). Change to `y <= x` for max-heap.\\ndef heappush(arr, x)\\n  idx = arr.bsearch_index { |y| y >= x } || arr.size\\n  arr.insert(idx, x)\\nend\\n\\ndef minimum_deviation(nums)\\n  (0...nums.size).each { |i| nums[i] *= 2 if nums[i].odd? }\\n  nums.sort!\\n  res = nums.last - nums.first\\n\\n  while (mx = nums.pop).even?\\n    heappush(nums, mx / 2)\\n    res = [res, nums.last - nums.first].min\\n  end\\n  res\\nend\\n```\n```ruby\\n# Insert value into DESC sorted array (sort of a max-heap)\\ndef heappush(arr, x)\\n  idx = arr.bsearch_index { |y| y <= x } || arr.size\\n  arr.insert(idx, x)\\nend\\n\\ndef minimum_deviation(nums)\\n  (0...nums.size).each { |i| nums[i] *= 2 if nums[i].odd? }\\n  nums.sort_by!(&:-@) # Same as `nums.sort!.reverse!`\\n  res = nums.first - nums.last\\n\\n  while (mx = nums.shift).even?\\n    heappush(nums, mx / 2)\\n    res = [res, nums.first - nums.last].min\\n  end\\n  res\\nend\\n```\n```ruby\\n# Insert element into ASC sorted array.\\ndef heappush(arr, x)\\n  idx = arr.bsearch_index { |y| (y <=> x) >= 0 } || arr.size\\n  arr.insert(idx, x)\\nend\\n# Remove element from ASC sorted array if the element is present.\\ndef heappop(arr, x)\\n  idx = arr.bsearch_index { |y| (y <=> x) >= 0 }\\n  arr.delete_at(idx) if idx && arr[idx] == x\\nend\\n```\n```ruby\\n# Insert element into DESC sorted array.\\ndef heappush(arr, x)\\n  idx = arr.bsearch_index { |y| (y <=> x) <= 0 } || arr.size\\n  arr.insert(idx, x)\\nend\\n# Remove element from DESC sorted array if the element is present.\\ndef heappop(arr, x)\\n  idx = arr.bsearch_index { |y| (y <=> x) <= 0 }\\n  arr.delete_at(idx) if idx && arr[idx] == x\\nend\\n```\n```ruby\\ndef minimum_deviation(nums)\\n  nums.each_with_index {|x, i| nums[i] *= 2 if x.odd? }\\n  nums.sort!\\n  res = nums.last - nums.first\\n  q = []\\n\\n  while [nums.last, q.first].compact.max&.even?\\n    if nums.any? && (q.empty? || q.first < nums.last)\\n      m = nums.pop\\n    else\\n      m = q.shift\\n    end\\n    q << m/2\\n    res = [res, [nums.last, q.first].compact.max - [nums.first, q.last].compact.min].min\\n  end\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1042361,
                "title": "java-82ms-heap-greedy-comments-explanation-proof",
                "content": "Greedy method: for an array of numbers, if we want to decrease the deviation, we can do it in only two ways:\\n1. increase the minimal number.\\n2. decrease the maximal number.\\n\\nNow since every number can be increased at most once but can be decreased at uncertain times, we simply increase every number to its maximum and then start decrease the maximal number in a greedy manner to find answer.\\n\\nWith heap, we can do it (find the maximal number and decrease it) in logarithmic time.\\n\\nProof of correctness:\\nFor every state we can get during the process, if we can increase the minimal number, the minimal number must be the newest-added number which came from diving the last maximal number by 2, in last iteration.\\nHence, if we increase this minimal number, we will get the last state which we have already made comparison with.\\nThus, we do not need to increase the minimal number during the greedy approach.\\nTherefore, keep decreasing the maximal number until we cannot is enough to get the minimum deviation.\\n\\nEdit:\\nThanks to kartik for pointing out the omission in the time comlexity. The actual worst-case time complexity should be O(N*logM*logN).\\n\\n```\\nclass Solution {\\n    // heap + greedy\\n    // time: O(N*logM*logN) where N is the number of elements, and M is the size of the elements.\\n    // memory: O(N)\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> maxPq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        int min = Integer.MAX_VALUE;\\n\\n        // increase every number to its maximum\\n        for (int num: nums) {\\n            if (num % 2 == 1) num <<= 1;// multiple odd number by 2\\n            \\n            min = Math.min(min, num);// update min\\n\\n            maxPq.offer(num);// add in max-heap  \\n        }\\n        \\n        // start decrease the maximal number and make comparison\\n        int ans = Integer.MAX_VALUE;\\n        while (maxPq.peek() % 2 == 0) {// until max is odd\\n            int down = maxPq.poll() / 2;// poll and divide max by 2\\n            \\n            min = Math.min(min, down);// update min\\n            \\n            maxPq.offer(down);// add new number\\n            \\n            ans = Math.min(ans, maxPq.peek() - min);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // heap + greedy\\n    // time: O(N*logM*logN) where N is the number of elements, and M is the size of the elements.\\n    // memory: O(N)\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> maxPq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        int min = Integer.MAX_VALUE;\\n\\n        // increase every number to its maximum\\n        for (int num: nums) {\\n            if (num % 2 == 1) num <<= 1;// multiple odd number by 2\\n            \\n            min = Math.min(min, num);// update min\\n\\n            maxPq.offer(num);// add in max-heap  \\n        }\\n        \\n        // start decrease the maximal number and make comparison\\n        int ans = Integer.MAX_VALUE;\\n        while (maxPq.peek() % 2 == 0) {// until max is odd\\n            int down = maxPq.poll() / 2;// poll and divide max by 2\\n            \\n            min = Math.min(min, down);// update min\\n            \\n            maxPq.offer(down);// add new number\\n            \\n            ans = Math.min(ans, maxPq.peek() - min);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041757,
                "title": "c-using-set-easiest-solution-minimize-deviation-in-array",
                "content": "Upvote if u like :)\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set <int> st;\\n        for(auto i: nums){\\n            st.insert(i % 2 ? i*2 : i);\\n        }\\n        int res = *st.rbegin() - * st.begin();\\n        while(*st.rbegin() % 2 == 0){\\n            st.insert(*st.rbegin() / 2);\\n            st.erase(*st.rbegin());\\n            res = min(res ,*st.rbegin() - *st.begin());\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set <int> st;\\n        for(auto i: nums){\\n            st.insert(i % 2 ? i*2 : i);\\n        }\\n        int res = *st.rbegin() - * st.begin();\\n        while(*st.rbegin() % 2 == 0){\\n            st.insert(*st.rbegin() / 2);\\n            st.erase(*st.rbegin());\\n            res = min(res ,*st.rbegin() - *st.begin());\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 954165,
                "title": "python3-priority-queue",
                "content": "**Algo** \\nConvert all numbers to even. Then, we don\\'t have to worry about 2nd operation entirely. Maintain a max heap and progressively divide the largest number by 2 until one cannot. The minimum deviation generation in this process is the required answer. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        pq = [-2*x if x&1 else -x for x in nums]\\n        heapify(pq)\\n        most = max(pq)\\n        ans = most - pq[0]\\n        while not pq[0]&1: \\n            x = heappop(pq)//2\\n            heappush(pq, x)\\n            most = max(most, x)\\n            ans = min(ans, most - pq[0])\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        pq = [-2*x if x&1 else -x for x in nums]\\n        heapify(pq)\\n        most = max(pq)\\n        ans = most - pq[0]\\n        while not pq[0]&1: \\n            x = heappop(pq)//2\\n            heappush(pq, x)\\n            most = max(most, x)\\n            ans = min(ans, most - pq[0])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224278,
                "title": "2-easiest-java-solution-o-nlogn-explained-treeset-priority-queue",
                "content": "**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved based on the following observations:\\n\\n1. Even numbers can be divided multiple times until it converts to an odd number.\\n2. Odd numbers can be doubled only once as it converts to an even number.\\nTherefore, even numbers can never be increased.\\n\\n# Approach-1\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse the array and double all the odd array elements. This nullifies the requirement for the 2nd operation.\\n2. Now, decrease the largest array element while it\\u2019s even.\\n3. To store the array elements in sorted manner, insert all array elements into a Set.\\n4. Greedily reduce the maximum element present in the Set\\n5. If the maximum element present in the Set is odd, break the loop.\\n6. return the minimum deviation obtained\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        return util(nums, nums.length);\\n    }\\n\\n    private int util(int A[], int N)\\n{\\n   \\n    // Store all array elements\\n    // in sorted order\\n    TreeSet<Integer> s = new TreeSet<Integer>();\\n    for (int i = 0; i < N; i++)\\n    {\\n \\n        if (A[i] % 2 == 0)\\n            s.add(A[i]);\\n \\n        // Odd number are transformed\\n        // using 2nd operation\\n        else\\n            s.add(2 * A[i]);\\n    }\\n \\n    // (Maximum - Minimum)\\n    int diff =  s.last() -  s.first() ;\\n \\n    // Check if the size of set is > 0 and\\n    // the maximum element is divisible by 2\\n    while ((s.last() % 2 == 0))\\n    {\\n \\n        // Maximum element of the set\\n        int maxEl = s.last();\\n \\n        // Erase the maximum element\\n        s.remove(maxEl);\\n \\n        // Using operation 1\\n        s.add(maxEl / 2);\\n \\n        // (Maximum - Minimum)\\n        diff = Math.min(diff, s.last() -  s.first());\\n    }\\n \\n    // Print the Minimum\\n    // Deviation Obtained\\n    return (diff);\\n}\\n \\n}\\n```\\n\\n# Approach-2\\n1. Create a max heap and a variable to keep track of the minimum value in the array.\\n2. For each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\n3. Also, update the minimum value if necessary.\\n4. Initialize a variable to keep track of the minimum deviation.\\n5. While the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\n6. If the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\n7. Return the minimum deviation.\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int minVal = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1)\\n                num = num * 2;\\n            pq.offer(num);\\n            minVal = Math.min(minVal, num);\\n        }\\n        int minDeviation = Integer.MAX_VALUE;\\n        while (true) {\\n            int maxVal = pq.poll();\\n            minDeviation = Math.min(minDeviation, maxVal - minVal);\\n            if (maxVal % 2 == 1)\\n                break;\\n            maxVal = maxVal / 2;\\n            minVal = Math.min(minVal, maxVal);\\n            pq.offer(maxVal);\\n        }\\n        return minDeviation;\\n    }\\n}\\n```\\n\\n**Don\\'t forget to upvote if this helped**\\nComment down ur quesries\\n\\n![image.png](https://assets.leetcode.com/users/images/cf515647-8640-45fa-a16a-b1b535af7555_1677223213.7584326.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        return util(nums, nums.length);\\n    }\\n\\n    private int util(int A[], int N)\\n{\\n   \\n    // Store all array elements\\n    // in sorted order\\n    TreeSet<Integer> s = new TreeSet<Integer>();\\n    for (int i = 0; i < N; i++)\\n    {\\n \\n        if (A[i] % 2 == 0)\\n            s.add(A[i]);\\n \\n        // Odd number are transformed\\n        // using 2nd operation\\n        else\\n            s.add(2 * A[i]);\\n    }\\n \\n    // (Maximum - Minimum)\\n    int diff =  s.last() -  s.first() ;\\n \\n    // Check if the size of set is > 0 and\\n    // the maximum element is divisible by 2\\n    while ((s.last() % 2 == 0))\\n    {\\n \\n        // Maximum element of the set\\n        int maxEl = s.last();\\n \\n        // Erase the maximum element\\n        s.remove(maxEl);\\n \\n        // Using operation 1\\n        s.add(maxEl / 2);\\n \\n        // (Maximum - Minimum)\\n        diff = Math.min(diff, s.last() -  s.first());\\n    }\\n \\n    // Print the Minimum\\n    // Deviation Obtained\\n    return (diff);\\n}\\n \\n}\\n```\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int minVal = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1)\\n                num = num * 2;\\n            pq.offer(num);\\n            minVal = Math.min(minVal, num);\\n        }\\n        int minDeviation = Integer.MAX_VALUE;\\n        while (true) {\\n            int maxVal = pq.poll();\\n            minDeviation = Math.min(minDeviation, maxVal - minVal);\\n            if (maxVal % 2 == 1)\\n                break;\\n            maxVal = maxVal / 2;\\n            minVal = Math.min(minVal, maxVal);\\n            pq.offer(maxVal);\\n        }\\n        return minDeviation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975487,
                "title": "javascript-max-heap-solution-beats-100",
                "content": "```js\\nfunction swap(nums, x, y) {\\n    var tmp = nums[x];\\n    nums[x] = nums[y];\\n    nums[y] = tmp;\\n}\\n\\nfunction maxHeapSort(nums, n, parent) {\\n    var left = parent * 2 + 1;\\n    while (left < n) {\\n        var maxChild = left;\\n        var right = left + 1;\\n        if (right < n && nums[right] > nums[left]) {\\n            maxChild = right;\\n        }\\n        if (nums[maxChild] <= nums[parent]) {\\n            return;\\n        }\\n        swap(nums, parent, maxChild);\\n        parent = maxChild;\\n        left = parent * 2 + 1;\\n    }\\n}\\n\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDeviation = function(nums) {\\n    var n = nums.length;\\n    if (n < 2) return 0;\\n    nums.forEach((v, i) => (v % 2 === 1) && (nums[i] *= 2));\\n    for (var i = (n - 1) >> 1; i >= 0; i--) {\\n        maxHeapSort(nums, n, i);\\n    }\\n    var min = Math.min(...nums);\\n    var max = nums[0];\\n    var ans = max - min;\\n    while (max % 2 === 0) {\\n        max /= 2;\\n        min = Math.min(max, min);\\n        nums[0] = max;\\n        maxHeapSort(nums, n, 0);\\n        max = nums[0];\\n        ans = Math.min(ans, max - min);\\n    }\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```js\\nfunction swap(nums, x, y) {\\n    var tmp = nums[x];\\n    nums[x] = nums[y];\\n    nums[y] = tmp;\\n}\\n\\nfunction maxHeapSort(nums, n, parent) {\\n    var left = parent * 2 + 1;\\n    while (left < n) {\\n        var maxChild = left;\\n        var right = left + 1;\\n        if (right < n && nums[right] > nums[left]) {\\n            maxChild = right;\\n        }\\n        if (nums[maxChild] <= nums[parent]) {\\n            return;\\n        }\\n        swap(nums, parent, maxChild);\\n        parent = maxChild;\\n        left = parent * 2 + 1;\\n    }\\n}\\n\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDeviation = function(nums) {\\n    var n = nums.length;\\n    if (n < 2) return 0;\\n    nums.forEach((v, i) => (v % 2 === 1) && (nums[i] *= 2));\\n    for (var i = (n - 1) >> 1; i >= 0; i--) {\\n        maxHeapSort(nums, n, i);\\n    }\\n    var min = Math.min(...nums);\\n    var max = nums[0];\\n    var ans = max - min;\\n    while (max % 2 === 0) {\\n        max /= 2;\\n        min = Math.min(max, min);\\n        nums[0] = max;\\n        maxHeapSort(nums, n, 0);\\n        max = nums[0];\\n        ans = Math.min(ans, max - min);\\n    }\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1782768,
                "title": "greedy-set-with-intuition-photos-easy-understanding-c",
                "content": "You can use multiset also. Works same\\nIntuition : \\n\\n### **Keep the array sorted, in the left half, greedily make all the odd numbers into even numbers by multiplying them by 2, in the right half, greedily try to make all the even numbers as half of it so that on the left side you increase the low and on the right side you increase the high.**\\n## \\n\\n# **** APPROACH****\\n\\nFirst, try to make all of the odd as even, we are doing this as we are processing the odd numbers first by making them even as we are allowed to make them even, so we are making them believing in the fact that, if needed, once again we can make them odd by dividing them again by 2. so we are not at loss, if initially we make all the odd even.\\n\\nThis is where your intuition will develop.\\nNow try to keep the array sorted, for that we will use RED BLACK TREES (SET) in order to maintain the array sorted,\\nwe will first insert all the elements into the set, after that, if we see in set, we have some odd number, we remove that and insert 2 times its value i.e. an even number in the set. The set has a beutiful property that it will keep it sorted and no repeat numbers will be there.\\nYou can use multiset if you dont want to keep same elements. (WONT MAKE A DIFFERENCE)\\n\\nThen what you do, you try to reduce the upper limit as initially by inserting the 2*odd you already attempted for increasing the lower limit of your set. \\nNow keep on reducing the rightmost element of your set till it becoms odd. and try to do that again and again.\\n\\nAt one time, you will see that the last or rightmost element of your set is indeed odd.\\nYou will stop there.\\n\\nAt every point of your while loop you will keep on updating the min deviation of your set, that would be the difference of your last and first element of your set.\\n\\nIT WOULD BE MORE CLEAR WITH THESE PICTURES\\n\\n\\n![image](https://assets.leetcode.com/users/images/addc3962-f8a3-4095-bd1d-745a7fe0095d_1645270871.523419.png)\\n\\n![image](https://assets.leetcode.com/users/images/911fda92-1abd-4380-8771-67e726306566_1645270881.9688013.png)\\n\\n![image](https://assets.leetcode.com/users/images/4f3ec741-4e39-4684-9002-a60337b95b7f_1645270892.1677568.png)\\n\\n![image](https://assets.leetcode.com/users/images/d8896dee-3dda-470a-a0e0-545e6c3f75e6_1645270900.8156424.png)\\n\\n![image](https://assets.leetcode.com/users/images/f11074bc-8bc5-4f27-ad93-65ff075cc7a3_1645270910.574225.png)\\n\\n\\n\\nCODE:\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {   \\n        set<int> s;\\n        for(auto i: nums) s.insert(i); //insert everything into a set\\n        int dev= *s.rbegin()-*s.begin(); //difference between max and min\\n        for(auto i: nums) if(i&1){ s.erase(i);s.insert(i<<=1);} //remove all odds, add 2*odd\\n        while(!((*s.rbegin())&1)){ //while last element does not become odd\\n            int a=(*s.rbegin());\\n            s.erase(a); //remove last\\n            s.insert(a>>=1); //insert last/2\\n            dev=min(dev,*s.rbegin()-*s.begin()); //update min deviation\\n        }\\n        return dev;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {   \\n        set<int> s;\\n        for(auto i: nums) s.insert(i); //insert everything into a set\\n        int dev= *s.rbegin()-*s.begin(); //difference between max and min\\n        for(auto i: nums) if(i&1){ s.erase(i);s.insert(i<<=1);} //remove all odds, add 2*odd\\n        while(!((*s.rbegin())&1)){ //while last element does not become odd\\n            int a=(*s.rbegin());\\n            s.erase(a); //remove last\\n            s.insert(a>>=1); //insert last/2\\n            dev=min(dev,*s.rbegin()-*s.begin()); //update min deviation\\n        }\\n        return dev;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782183,
                "title": "java-explained-in-detail-priority-queue-easy",
                "content": "Intuition behind this is tricky at first.\\n1. We can only multiply a odd number once because after that it becomes even.\\n2. We can divide a even number multiple times until it becomes odd.\\n3. There is one issue of doing the same operation again and again, for eg: we have 10, we divided it by 2 , and then again in the next step we multiplied it by 2. It\\'s not required. For that reason we will use a MAX Priority Queue. (You can also use min priority queue).\\n\\nSteps:\\n1. Change all the odd elements in the array to even. As multiplication can only be done once, we will not use multiplication further after this step. This solves the issue of repeating.\\n2. Add all the elements into the Queue. Store the min value of the array in a variable.\\n3. Now we have a priority queue with max value which is even at the top.\\n4. we will run a loop until the max value becomes odd by dividing the max value by 2. Parallelly we will update our diff of max and min. You can understand the loop by looking at the code. \\n5. Finally we will return the min between the diff and queues max-min.\\n\\nLook through the code. It\\'ll be easier if you dry run this.\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i : nums){\\n            if(i % 2 == 1) i *= 2;\\n            \\n            pq.add(i);\\n            min = Math.min(min, i);\\n        }\\n        int diff = Integer.MAX_VALUE;\\n        \\n        while(pq.peek() % 2 == 0){\\n            int max = pq.remove();\\n            diff = Math.min(diff, max - min);\\n            \\n            max /= 2;\\n            min = Math.min(min, max);\\n            pq.add(max);\\n        }\\n        return Math.min(diff, pq.peek() - min);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i : nums){\\n            if(i % 2 == 1) i *= 2;\\n            \\n            pq.add(i);\\n            min = Math.min(min, i);\\n        }\\n        int diff = Integer.MAX_VALUE;\\n        \\n        while(pq.peek() % 2 == 0){\\n            int max = pq.remove();\\n            diff = Math.min(diff, max - min);\\n            \\n            max /= 2;\\n            min = Math.min(min, max);\\n            pq.add(max);\\n        }\\n        return Math.min(diff, pq.peek() - min);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045133,
                "title": "java-priority-queue-with-clear-explanation",
                "content": "**Please Upvote if u find Useful**\\ncredits - @kartik135065\\nyou can\\'t increase an even number given the invariant which is an important observation so you can go from 1 -> 2 but not 2 -> 4.\\nThis is why in the solution we have an upper limit after converting the array to all even numbers. Then we begin to reduce the gap by halving max as long as we can i.e. until we encounter an odd number as max (this odd can only be increased which will increase the gap so we return the answer from here)\\nSteps:\\n* make all odd no Even.\\n* using pq decrese half the max no each time and restore it in pq.\\n* this reduces ```min_dev``` each time .\\n* if max. no is odd , then we know that this is lowest possible ```min_dev``` .\\n```\\na[]=[9,20,14,16]\\n[18,20,14,16] //h=20 ,l=14\\n[18,10,14,16]\\n[9,10,14,16]\\n[9,10,14,8]\\n[9,10,7,8] //h=10 l=7\\n[9,5,7,8] // we see that pq.poll() now is odd so tis is min_dev\\n```\\n\\nJava Code:\\n```\\npublic int minimumDeviation(int[] a) {\\n\\t\\tPriorityQueue<Integer> pq=new PriorityQueue<>((o1,o2)->o2-o1);\\n\\t\\tint min=intege;\\n\\t\\t for(int i=0;i<a.length;i++) {\\n\\t\\t\\tif(a[i]%2==1)a[i]=a[i]*2;\\n\\t\\t\\tpq.offer(a[i]);\\n\\t\\t\\tmin=Math.min(min, a[i]);\\n\\t\\t}\\n\\t\\t int min_dev=Integer.MAX_VALUE;\\n\\t\\t while(!pq.isEmpty()) {\\n\\t\\t\\t int h=pq.peek();\\n\\t\\t\\t int d=h-min;\\n\\t\\t\\t min_dev=Math.min(min_dev, d);\\n\\t\\t\\t if(h%2==1)break;\\n\\t\\t\\t pq.poll();\\n\\t\\t\\t pq.offer(h/2);\\n\\t\\t\\t min=Math.min(min, h/2);\\n\\t\\t }\\n\\t\\t\\t \\n\\t\\treturn min_dev;\\n    }\\n```\\n```time - O(nlognlogm)```\\n\\n**Please Upvote if u find Useful**",
                "solutionTags": [],
                "code": "```min_dev```\n```min_dev```\n```\\na[]=[9,20,14,16]\\n[18,20,14,16] //h=20 ,l=14\\n[18,10,14,16]\\n[9,10,14,16]\\n[9,10,14,8]\\n[9,10,7,8] //h=10 l=7\\n[9,5,7,8] // we see that pq.poll() now is odd so tis is min_dev\\n```\n```\\npublic int minimumDeviation(int[] a) {\\n\\t\\tPriorityQueue<Integer> pq=new PriorityQueue<>((o1,o2)->o2-o1);\\n\\t\\tint min=intege;\\n\\t\\t for(int i=0;i<a.length;i++) {\\n\\t\\t\\tif(a[i]%2==1)a[i]=a[i]*2;\\n\\t\\t\\tpq.offer(a[i]);\\n\\t\\t\\tmin=Math.min(min, a[i]);\\n\\t\\t}\\n\\t\\t int min_dev=Integer.MAX_VALUE;\\n\\t\\t while(!pq.isEmpty()) {\\n\\t\\t\\t int h=pq.peek();\\n\\t\\t\\t int d=h-min;\\n\\t\\t\\t min_dev=Math.min(min_dev, d);\\n\\t\\t\\t if(h%2==1)break;\\n\\t\\t\\t pq.poll();\\n\\t\\t\\t pq.offer(h/2);\\n\\t\\t\\t min=Math.min(min, h/2);\\n\\t\\t }\\n\\t\\t\\t \\n\\t\\treturn min_dev;\\n    }\\n```\n```time - O(nlognlogm)```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042557,
                "title": "python-cleanest-solution-sorted-list",
                "content": "The easiest way to solve this problem is to convert all numbers to even numbers and add them to a sorted container. Then just keep on reducing the maximum difference between them.\\n\\nThere are two ways to reduce their distance:\\n1. Keep increasing smallest number (multiplying by 2)\\n2. Keep decreasing largest number (divide by 2)\\n\\nIn this solution we pick approach 2, as it is easier to implement and comes more naturally due to the boundary conditions. So we just minimise the difference and update the maximum number by dividing it with 2 for every iteration. We use a sorted list to maintain the sorted order so that we can get the minimum and maximum easily in each iteration.\\n```\\nSorted container = [min, ... other elements..., max]\\n```\\nWe keep on doing this until we can, i.e until the max element can be halved (note: only an even number can be halved without losing precision if we want to keep only the integer part).\\n\\nPython Code Below:\\n(Please do upvote)\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        sl = SortedList([i*2 if i%2==1 else i for i in nums])\\n        diff = float(\\'inf\\')\\n        while sl[-1] % 2 == 0:\\n            diff = min(diff, sl[-1]-sl[0])\\n            sl.add(sl.pop(-1) // 2)\\n        return min(diff, sl[-1]-sl[0])\\n```",
                "solutionTags": [],
                "code": "```\\nSorted container = [min, ... other elements..., max]\\n```\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        sl = SortedList([i*2 if i%2==1 else i for i in nums])\\n        diff = float(\\'inf\\')\\n        while sl[-1] % 2 == 0:\\n            diff = min(diff, sl[-1]-sl[0])\\n            sl.add(sl.pop(-1) // 2)\\n        return min(diff, sl[-1]-sl[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042102,
                "title": "c-sorted-set-explained",
                "content": "The general idea is:\\n1. Convert all numbers to its maximum possible values.\\n\\tOne thing to keep in mind, is that odd numbers can only have 2 possible values, the original odd value (minimum) and twice its value (maximum), then is even and can only be divided.\\n\\tThe even numbers already have its possible maximum value and can be divided until become odd.\\n2. Then while the maximum value is divisible by 2, divide and repeat with the resulting maximum value. \\n3. On each operation keep track of the minimum difference between the maximum and minimum values, that minimum difference will be the answer.\\n\\n```\\npublic class Solution {\\n    public int MinimumDeviation(int[] nums) {\\n        var n = nums.Length;\\n        var set = new SortedSet<int>();\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] % 2 == 0)\\n                set.Add(nums[i]); // already maximum value\\n            else\\n                set.Add(nums[i]*2); // maximum value of odd number\\n        \\n        var min = set.Max - set.Min;\\n        while(set.Max % 2 == 0)\\n        {\\n            var max = set.Max;\\n            set.Remove(max);\\n            set.Add(max/2);\\n            min = Math.Min(min, set.Max-set.Min);\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumDeviation(int[] nums) {\\n        var n = nums.Length;\\n        var set = new SortedSet<int>();\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] % 2 == 0)\\n                set.Add(nums[i]); // already maximum value\\n            else\\n                set.Add(nums[i]*2); // maximum value of odd number\\n        \\n        var min = set.Max - set.Min;\\n        while(set.Max % 2 == 0)\\n        {\\n            var max = set.Max;\\n            set.Remove(max);\\n            set.Add(max/2);\\n            min = Math.Min(min, set.Max-set.Min);\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223659,
                "title": "c-priority-queue-faster-easy-to-understand",
                "content": "* ***Using Priority Queue***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // find maci and mini\\n        \\n        int maxi = INT_MIN;\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[i] % 2 != 0)\\n            {\\n                arr[i] = 2 * arr[i];\\n            }\\n            \\n            maxi = max(maxi, arr[i]);\\n            \\n            mini = min(mini, arr[i]);\\n        }\\n        \\n        // declare a max heap\\n        \\n        priority_queue<int> pq;\\n        \\n        // push the elements into pq\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push(arr[i]);\\n        }\\n        \\n        // find min_deviation\\n        \\n        int min_deviation = maxi - mini;\\n        \\n        int top = 0;\\n        \\n        while(pq.top() % 2 == 0)\\n        {\\n            top = pq.top();\\n            \\n            pq.pop();\\n            \\n            min_deviation = min(min_deviation, top - mini);\\n            \\n            mini = min(mini, top / 2);\\n            \\n            pq.push(top / 2);\\n        }\\n        \\n        top = pq.top();\\n        \\n        min_deviation = min(min_deviation, top - mini);\\n        \\n        return min_deviation;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // find maci and mini\\n        \\n        int maxi = INT_MIN;\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[i] % 2 != 0)\\n            {\\n                arr[i] = 2 * arr[i];\\n            }\\n            \\n            maxi = max(maxi, arr[i]);\\n            \\n            mini = min(mini, arr[i]);\\n        }\\n        \\n        // declare a max heap\\n        \\n        priority_queue<int> pq;\\n        \\n        // push the elements into pq\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push(arr[i]);\\n        }\\n        \\n        // find min_deviation\\n        \\n        int min_deviation = maxi - mini;\\n        \\n        int top = 0;\\n        \\n        while(pq.top() % 2 == 0)\\n        {\\n            top = pq.top();\\n            \\n            pq.pop();\\n            \\n            min_deviation = min(min_deviation, top - mini);\\n            \\n            mini = min(mini, top / 2);\\n            \\n            pq.push(top / 2);\\n        }\\n        \\n        top = pq.top();\\n        \\n        min_deviation = min(min_deviation, top - mini);\\n        \\n        return min_deviation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223479,
                "title": "python3-683-ms-faster-than-94-03-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/53584f09-ffd2-4806-b234-4e2c9eec1c99_1677197885.228521.png)\\n```\\ndef minimumDeviation(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            nums[i] = -((nums[i] << 1) if nums[i] & 1 == 1 else nums[i])\\n\\n        min_num = -max(nums)\\n        max_nums = nums\\n        heapq.heapify(max_nums)\\n\\n        min_deviation = math.inf\\n        while True:\\n            max_num = -max_nums[0]\\n            deviation = max_num - min_num\\n\\n            if deviation < min_deviation:\\n                min_deviation = deviation\\n                if min_deviation == 0:\\n                    break\\n\\n            if max_num & 1 == 1:\\n                break\\n\\n            max_num >>= 1\\n            heapq.heapreplace(max_nums, -max_num)\\n            if max_num < min_num:\\n                min_num = max_num\\n\\n        return min_deviation\\n```\\n\\nHere is a step-by-step explanation of the code:\\n1. The input array is modified to turn every odd number negative and double its value. This is done by iterating over every element of the input array, checking if it\\'s odd or even, and applying the appropriate operation using bitwise operators. This is done so that we can perform only the \"divide by 2\" operation in the following steps, which simplifies the problem.\\n1. The maximum number in the modified array is assigned to a variable named \"minNum\". This is because we want to minimize the deviation of the array, and having a larger minimum number in the array would increase the deviation.\\n1. A heap is created from the modified array. The heap is used to keep track of the maximum value in the array, which we can modify by dividing it by 2.\\n1. A variable named \"minDeviation\" is initialized to infinity. This variable will be used to keep track of the minimum deviation we have encountered so far.\\n1. We enter a while loop that will terminate only when we have found the minimum deviation or when we can no longer perform any operations.\\n1. The maximum value in the heap is extracted and assigned to a variable named \"maxNum\".\\n1. The deviation of the array is calculated as the difference between the maximum value (after dividing by 2 if it\\'s even) and the minimum value.\\n1. If the deviation is less than the minimum deviation seen so far, it is updated as the new minimum deviation.\\n1. If the maximum value is odd, we can no longer perform any operations and we break out of the while loop.\\n1. If the maximum value is even, we divide it by 2 and replace the maximum value in the heap with the new value.\\n1. If the new maximum value is less than the current minimum value, we update the minimum value to be the new maximum value.\\n1. The loop continues until we have found the minimum deviation or can no longer perform any operations.\\n1. The minimum deviation is returned as the final result.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef minimumDeviation(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            nums[i] = -((nums[i] << 1) if nums[i] & 1 == 1 else nums[i])\\n\\n        min_num = -max(nums)\\n        max_nums = nums\\n        heapq.heapify(max_nums)\\n\\n        min_deviation = math.inf\\n        while True:\\n            max_num = -max_nums[0]\\n            deviation = max_num - min_num\\n\\n            if deviation < min_deviation:\\n                min_deviation = deviation\\n                if min_deviation == 0:\\n                    break\\n\\n            if max_num & 1 == 1:\\n                break\\n\\n            max_num >>= 1\\n            heapq.heapreplace(max_nums, -max_num)\\n            if max_num < min_num:\\n                min_num = max_num\\n\\n        return min_deviation\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1782149,
                "title": "python3-heap-solution",
                "content": "```\\nMAX = 10**20\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = []\\n        answer = MAX\\n        array_length = len(nums)\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                heappush(heap, -num)\\n            else:\\n                heappush(heap, -num*2)\\n        \\n        _min = -max(heap)\\n\\n        while True:\\n            _max = -heappop(heap)\\n            answer = min(answer, _max-_min)\\n            \\n            if _max % 2:\\n                break\\n\\n            heappush(heap, -_max//2)\\n            _min = min(_min, _max//2)\\n\\n        return answer\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nMAX = 10**20\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = []\\n        answer = MAX\\n        array_length = len(nums)\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                heappush(heap, -num)\\n            else:\\n                heappush(heap, -num*2)\\n        \\n        _min = -max(heap)\\n\\n        while True:\\n            _max = -heappop(heap)\\n            answer = min(answer, _max-_min)\\n            \\n            if _max % 2:\\n                break\\n\\n            heappush(heap, -_max//2)\\n            _min = min(_min, _max//2)\\n\\n        return answer\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781986,
                "title": "c-tried-my-best-to-explain",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        /*\\n        since we need to find the minimum deviation, there are two things that \\n        we can certainly do : minimize the max and maximize the min.\\n        Agree???\\n        Now the real deal is how to find this max and how to find this min?\\n        \\n        Now you know that if the number is odd, you have to multiply it by 2\\n        and this is the only way to maximize the odd number. After multiplying the odd\\n        by 2, you are not allowed to furthur multiply coz now its even number now\\n        and even number can only be divided by 2. (refer to the first for  loop in the code )\\n        \\n        So till this point you have maximized all the odd numbers. Why maximize\\n        all the odd numbers because i told you that you have to maximize\\n        every number possible and here in this problem the possibility of maximizing\\n        the numbers lies with the case of odd numbers.\\n        \\n        and while doing this maximization step, we will keep finding our minimum\\n        value. Notice here that in minimum value , we will be having minimal even\\n        number. Do you agree?\\n        \\n        Now here comes the part of minimization, now which values you can minimize?\\n        Those values which are even . Correct??\\n        \\n        And you will say, that at this moment, all values present in the array are\\n        even and i wiil say yes you are right.\\n\\t\\tAt this point , things may not  make some sense. But keep reading thoroughly ,\\n\\t\\tyou will understand it.\\n        Now we will put these values in the max heap so that we can always get the\\n        maximum number by doing o(1) operation and we will keep dividing this \\n        maximum number by 2 and will keep a note of min deviation.We will stop to \\n        a point where the max value is odd coz it can not be minimized further.\\n        \\n        Lets jump to the code to make some sense out of this story.\\n        */\\n        priority_queue<int>max_heap;\\n        //step 1 : maximization\\n        int minimum_value=INT_MAX;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i] &1){ //that is odd \\n                nums[i]*=2;\\n            }\\n            //keeping a check on minimum value\\n            minimum_value=min(minimum_value,nums[i]);\\n            max_heap.push(nums[i]);\\n        }\\n        //after this loop every element present in array will be even\\n        int deviation=INT_MAX;\\n        //step 2 : Minimization\\n        //every time we will pick up the maximum value , will calculate the\\n        //deviation and will minimize it\\n        while(!max_heap.empty() && max_heap.top()%2==0){\\n            int maximum_value=max_heap.top();\\n            max_heap.pop();\\n            deviation=min(deviation,maximum_value-minimum_value);\\n            //check if we have another minimum_value when we divide this no. by 2\\n            minimum_value=min(minimum_value,maximum_value/2);\\n            max_heap.push(maximum_value/2);\\n            \\n        }\\n        return min(deviation, max_heap.top()-minimum_value);\\n        \\n    }\\n};\\n\\nAgain in the first go, it may not make sense, but read the explanation, dry run the code and read the explanation again. You will understand it.\\nAlso, the purpose of max heap or priority queue is to get the maximum number in one go. So , you can also use set for this purpose as set stores elements in sorted order\\n\\nLet me know if you have any queries or suggestions or any optimization that can be done.\\nFeel free to comment and discuss.\\nif this solution helped, please upvote !! Thanks !!",
                "solutionTags": [
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        /*\\n        since we need to find the minimum deviation, there are two things that \\n        we can certainly do : minimize the max and maximize the min.\\n        Agree???\\n        Now the real deal is how to find this max and how to find this min?\\n        \\n        Now you know that if the number is odd, you have to multiply it by 2\\n        and this is the only way to maximize the odd number. After multiplying the odd\\n        by 2, you are not allowed to furthur multiply coz now its even number now\\n        and even number can only be divided by 2. (refer to the first for  loop in the code )\\n        \\n        So till this point you have maximized all the odd numbers. Why maximize\\n        all the odd numbers because i told you that you have to maximize\\n        every number possible and here in this problem the possibility of maximizing\\n        the numbers lies with the case of odd numbers.\\n        \\n        and while doing this maximization step, we will keep finding our minimum\\n        value. Notice here that in minimum value , we will be having minimal even\\n        number. Do you agree?\\n        \\n        Now here comes the part of minimization, now which values you can minimize?\\n        Those values which are even . Correct??\\n        \\n        And you will say, that at this moment, all values present in the array are\\n        even and i wiil say yes you are right.\\n\\t\\tAt this point , things may not  make some sense. But keep reading thoroughly ,\\n\\t\\tyou will understand it.\\n        Now we will put these values in the max heap so that we can always get the\\n        maximum number by doing o(1) operation and we will keep dividing this \\n        maximum number by 2 and will keep a note of min deviation.We will stop to \\n        a point where the max value is odd coz it can not be minimized further.\\n        \\n        Lets jump to the code to make some sense out of this story.\\n        */\\n        priority_queue<int>max_heap;\\n        //step 1 : maximization\\n        int minimum_value=INT_MAX;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i] &1){ //that is odd \\n                nums[i]*=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1781708,
                "title": "this-is-an-independent-solution-that-i-came-up-with",
                "content": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for (int num : nums)\\n            set.add(num);\\n\\n        int min = set.last() - set.first();\\n        \\n        while (set.first() % 2 == 1) {\\n            set.add(set.first() * 2);\\n            set.remove(set.first());\\n            min = Math.min(min, set.last() - set.first());\\n        }\\n\\n        while (set.last() % 2 == 0) {\\n            set.add(set.last() / 2);\\n            set.remove(set.last());\\n            min = Math.min(min, set.last() - set.first());\\n        }  \\n        \\n        \\n        return min;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for (int num : nums)\\n            set.add(num);\\n\\n        int min = set.last() - set.first();\\n        \\n        while (set.first() % 2 == 1) {\\n            set.add(set.first() * 2);\\n            set.remove(set.first());\\n            min = Math.min(min, set.last() - set.first());\\n        }\\n\\n        while (set.last() % 2 == 0) {\\n            set.add(set.last() / 2);\\n            set.remove(set.last());\\n            min = Math.min(min, set.last() - set.first());\\n        }  \\n        \\n        \\n        return min;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042804,
                "title": "javascript-using-max-priority-queue-with-comments",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDeviation = function(nums) {\\n  // https://github.com/datastructures-js/priority-queue\\n  const mpq = new MaxPriorityQueue();\\n  \\n  // Convert all the numbers to even and enqueue them\\n  nums.forEach((num) => {\\n    if (num % 2 !== 0) {\\n      const value = num * 2;\\n      \\n      mpq.enqueue(value, value);\\n    } else {\\n      mpq.enqueue(num, num);\\n    }\\n  });\\n\\n  // Get difference between max and min values\\n  let deviation = mpq.front().element - mpq.back().element;\\n  \\n  // Loop until we have any max even number left in the queue\\n  while(mpq.front().element % 2 === 0) {\\n    // Get max even value\\n    const { element } = mpq.dequeue();\\n\\t\\n\\t// Convert it to odd number and enqueue again\\n    mpq.enqueue(element/2, element/2);\\n    \\n\\t// Get minimum between previous deviation and after above conversion\\n    deviation = Math.min(deviation, mpq.front().element - mpq.back().element);\\n  }\\n  \\n  return deviation;\\n};\\n```\\n\\n> **NOTE: We can also use heap sort to sort the values and get difference between min and max value of the array. I used max priority queue which uses max heap.**",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDeviation = function(nums) {\\n  // https://github.com/datastructures-js/priority-queue\\n  const mpq = new MaxPriorityQueue();\\n  \\n  // Convert all the numbers to even and enqueue them\\n  nums.forEach((num) => {\\n    if (num % 2 !== 0) {\\n      const value = num * 2;\\n      \\n      mpq.enqueue(value, value);\\n    } else {\\n      mpq.enqueue(num, num);\\n    }\\n  });\\n\\n  // Get difference between max and min values\\n  let deviation = mpq.front().element - mpq.back().element;\\n  \\n  // Loop until we have any max even number left in the queue\\n  while(mpq.front().element % 2 === 0) {\\n    // Get max even value\\n    const { element } = mpq.dequeue();\\n\\t\\n\\t// Convert it to odd number and enqueue again\\n    mpq.enqueue(element/2, element/2);\\n    \\n\\t// Get minimum between previous deviation and after above conversion\\n    deviation = Math.min(deviation, mpq.front().element - mpq.back().element);\\n  }\\n  \\n  return deviation;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041955,
                "title": "100-faster-time-n-logm-logn-space-o-n-explained-approach",
                "content": "```\\npublic class Solution {\\n    // Time Complexity => (n*logm*logn) || Space Complexity => O(n)\\n    public int MinimumDeviation(int[] nums) {\\n        /* Since we have two options to transform array by either to dividing even nums by 2\\n         * or we can multiple odd nums by 2 (max 1 opteration as num becomes even than)\\n         * \\n         * Approach is to stick to any one of the 2 avaliable options,\\n         * Below approach uses first option (even no can be divided by 2, untill they become odd)\\n         * \\n         * Traverse thru array and add each element to MaxHeap based upon:\\n         *      if odd => multiple num*2 & add to MaxHeap (as it can we reduced later)\\n         *      if even simply add to heap\\n         * also maintain MinValue which is added to Heap\\n         * \\n         * Set deviation to int.MaxValue\\n         * Now Extract top from MaxHeap untill Heap is Not empty\\n         *      ans = Math.Min(ans,HeapTop-min)\\n         *  \\n         *  if HeapTop is even reinsert it back to heap as HeapTop/2\\n         *      also update min = Math.Min(min,HeapTop/2);\\n         *  else if HeapTop is odd, break out of loop as odd number can\\'t be further reduced\\n         */\\n        long min = long.MaxValue;\\n        MaxHeap h = new MaxHeap(nums.Length);\\n        for (int i = 0; i < nums.Length; i++)                   // O(n)\\n            if (nums[i] % 2 == 0)\\n            {\\n                h.Insert(nums[i]);                              // O(logn)\\n                min = Math.Min(min, nums[i]);\\n            }\\n            else\\n            {\\n                h.Insert(nums[i] * 2);                          // O(logn)\\n                min = Math.Min(min, nums[i] * 2);\\n            }\\n\\n        long deviation = long.MaxValue;\\n        // Worst case time complexity would be when all nums are maximum possible numbers of powers of 2\\n        // Lets we consider that large possible number high power of 2 is \\'m\\'\\n        // we would extract and reinsert \\'m\\' logm times untill its finally reduced \\'1\\'\\n        // and since there are total \\'n\\' nums Heapify operation would take logn time\\n        // Time Complexity => (n*logm*logn)\\n        // Space Complexity => O(n)\\n        while (h.Count > 0)\\n        {\\n            long max = h.ExtractMax();\\n            deviation = Math.Min(deviation, max - min);\\n\\n            // found odd number break out\\n            if (max % 2 == 1) break;\\n\\n            h.Insert(max / 2);\\n            min = Math.Min(min, max / 2);\\n        }\\n        return (int)deviation;\\n    }\\n    // C# doesnt have Heap ADT, hence created one\\n    public class MaxHeap\\n    {\\n        public long[] arr;\\n        public int Count = 0;\\n        public MaxHeap(int size)\\n        {\\n            arr = new long[size];\\n        }\\n        public int LeftChild(int x) => 2 * x + 1;\\n        public int RtChild(int x) => LeftChild(x) + 1;\\n        public int Parent(int x) => (x - 1) / 2;\\n        public void Insert(long val)\\n        {\\n            int i = Count++;\\n            arr[i] = val;\\n            while (i != 0 && arr[Parent(i)] < arr[i])\\n            {\\n                int parent = Parent(i);\\n\\n                // Swap child node with parent\\n                var temp = arr[parent];\\n                arr[parent] = arr[i];\\n                arr[i] = temp;\\n\\n                i = parent;\\n            }\\n        }\\n        public void MaxHeapify(int i = 0)\\n        {\\n            while (i < Count)\\n            {\\n                //For empty or Heap with single element we need not perform any operation\\n                if (Count < 2) return;\\n\\n                int largest = i;\\n                int left = LeftChild(i), rt = RtChild(i);\\n\\n                if (left < Count && arr[left] > arr[i])\\n                    largest = left;\\n                if (rt < Count && arr[rt] > arr[largest])\\n                    largest = rt;\\n                if (largest != i)\\n                {\\n                    // Swap root node with larger child\\n                    var temp = arr[largest];\\n                    arr[largest] = arr[i];\\n                    arr[i] = temp;\\n\\n                    // Heapify child nodes to re-order subtree and maintain MinHeap integrity\\n                    i = largest;\\n                }\\n                else break;\\n            }\\n        }\\n        public long ExtractMax()\\n        {\\n            if (Count <= 0) throw new InvalidOperationException(\"Extract-Max cannot be performed on Empty Heap\");\\n            var ans = arr[0];\\n            arr[0] = arr[--Count];\\n            MaxHeapify();\\n            return ans;\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/452767ba-1382-4e6f-8bb4-925961d24696_1612011529.8093626.png)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    // Time Complexity => (n*logm*logn) || Space Complexity => O(n)\\n    public int MinimumDeviation(int[] nums) {\\n        /* Since we have two options to transform array by either to dividing even nums by 2\\n         * or we can multiple odd nums by 2 (max 1 opteration as num becomes even than)\\n         * \\n         * Approach is to stick to any one of the 2 avaliable options,\\n         * Below approach uses first option (even no can be divided by 2, untill they become odd)\\n         * \\n         * Traverse thru array and add each element to MaxHeap based upon:\\n         *      if odd => multiple num*2 & add to MaxHeap (as it can we reduced later)\\n         *      if even simply add to heap\\n         * also maintain MinValue which is added to Heap\\n         * \\n         * Set deviation to int.MaxValue\\n         * Now Extract top from MaxHeap untill Heap is Not empty\\n         *      ans = Math.Min(ans,HeapTop-min)\\n         *  \\n         *  if HeapTop is even reinsert it back to heap as HeapTop/2\\n         *      also update min = Math.Min(min,HeapTop/2);\\n         *  else if HeapTop is odd, break out of loop as odd number can\\'t be further reduced\\n         */\\n        long min = long.MaxValue;\\n        MaxHeap h = new MaxHeap(nums.Length);\\n        for (int i = 0; i < nums.Length; i++)                   // O(n)\\n            if (nums[i] % 2 == 0)\\n            {\\n                h.Insert(nums[i]);                              // O(logn)\\n                min = Math.Min(min, nums[i]);\\n            }\\n            else\\n            {\\n                h.Insert(nums[i] * 2);                          // O(logn)\\n                min = Math.Min(min, nums[i] * 2);\\n            }\\n\\n        long deviation = long.MaxValue;\\n        // Worst case time complexity would be when all nums are maximum possible numbers of powers of 2\\n        // Lets we consider that large possible number high power of 2 is \\'m\\'\\n        // we would extract and reinsert \\'m\\' logm times untill its finally reduced \\'1\\'\\n        // and since there are total \\'n\\' nums Heapify operation would take logn time\\n        // Time Complexity => (n*logm*logn)\\n        // Space Complexity => O(n)\\n        while (h.Count > 0)\\n        {\\n            long max = h.ExtractMax();\\n            deviation = Math.Min(deviation, max - min);\\n\\n            // found odd number break out\\n            if (max % 2 == 1) break;\\n\\n            h.Insert(max / 2);\\n            min = Math.Min(min, max / 2);\\n        }\\n        return (int)deviation;\\n    }\\n    // C# doesnt have Heap ADT, hence created one\\n    public class MaxHeap\\n    {\\n        public long[] arr;\\n        public int Count = 0;\\n        public MaxHeap(int size)\\n        {\\n            arr = new long[size];\\n        }\\n        public int LeftChild(int x) => 2 * x + 1;\\n        public int RtChild(int x) => LeftChild(x) + 1;\\n        public int Parent(int x) => (x - 1) / 2;\\n        public void Insert(long val)\\n        {\\n            int i = Count++;\\n            arr[i] = val;\\n            while (i != 0 && arr[Parent(i)] < arr[i])\\n            {\\n                int parent = Parent(i);\\n\\n                // Swap child node with parent\\n                var temp = arr[parent];\\n                arr[parent] = arr[i];\\n                arr[i] = temp;\\n\\n                i = parent;\\n            }\\n        }\\n        public void MaxHeapify(int i = 0)\\n        {\\n            while (i < Count)\\n            {\\n                //For empty or Heap with single element we need not perform any operation\\n                if (Count < 2) return;\\n\\n                int largest = i;\\n                int left = LeftChild(i), rt = RtChild(i);\\n\\n                if (left < Count && arr[left] > arr[i])\\n                    largest = left;\\n                if (rt < Count && arr[rt] > arr[largest])\\n                    largest = rt;\\n                if (largest != i)\\n                {\\n                    // Swap root node with larger child\\n                    var temp = arr[largest];\\n                    arr[largest] = arr[i];\\n                    arr[i] = temp;\\n\\n                    // Heapify child nodes to re-order subtree and maintain MinHeap integrity\\n                    i = largest;\\n                }\\n                else break;\\n            }\\n        }\\n        public long ExtractMax()\\n        {\\n            if (Count <= 0) throw new InvalidOperationException(\"Extract-Max cannot be performed on Empty Heap\");\\n            var ans = arr[0];\\n            arr[0] = arr[--Count];\\n            MaxHeapify();\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041838,
                "title": "minimize-deviation-in-array-fast-python-heap-explained-beats-99",
                "content": "### **Idea**\\nObserve that we can *only* increase value (by x2) for odd numbers. That means for an odd number like `3`, possible values we can reach are `{3, 6}`; and for an even number like 8, possible values we can reach are `{1, 2, 4, 8}`. We can unify both cases by starting from the largest reachable value (`6` and `8`) and only consider the \"//2\" (divide by 2) operation.\\n\\nSince now numbers can only decrease, the *only* sensible move is to take the largest number and half it. Otherwise, we face the risk of lower the minimum without lowering the maximum. \\n\\nWhat data structure should we use? Halving the largest number will surely lower the maximum but would also create a new minimum. So we would like something that would efficiently keep track of both the max and min values. If you browse other posts, you will see people use a binary search tree for this, but a *heap / priority queue* that only tracks the max value will also suffice for this problem.\\n\\nThis is because, in each step, we a new minimum is only possible from halving the current maximum (heap top). So we can keep a variable `mi` for this and update it along with each operation. \\n\\n### **Optimazations / implementation choices**\\n- We only need to consider unique values from the input as diverging from the same starting values won\\'t make a solution any better. (`heap = list(set(...))`)\\n- Negate the values to have a max heap.\\n- For the current max value, we can just take `heap[0]`.\\n- The process ends when it is impossible to reduce the max value, i.e. `heap[0] % 2 == 0` does not hold.\\n\\n### **Code**\\n```python\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = list(set(-(x * 2 if x & 1 else x) for x in nums))\\n        heapify(heap)\\n        ma, mi = -heap[0], -max(heap)\\n        ans = ma - mi\\n        while heap[0] % 2 == 0:\\n            x = heappop(heap) // 2\\n            heappush(heap, x)\\n            ma, mi = -heap[0], min(mi, -x)\\n            ans = min(ans, ma - mi)\\n        return ans\\n```\\n\\n### **Complexity**\\n- O(n) space. The heap contains all the input elements when they are all unique.\\n- O(n (log m) (log n)) time, where `m = max(nums)`. The heap is O(n) size, so it takes O(log n) time for each push and pop. How many steps do we need to take? That is how many times we can reduce the max value, which is again bounded by the number of reachable values for each input element. The max number of reachable values is for some 2^k that is as big as the limit for input values m. The reachable values for it will be 1, 2, ..., 2^(k-1), 2^k --- (log m) of them. Thus, we will need to do O(n log m) steps in the worst case.\\n\\n### **Further optimizations**\\nI personally think the following optimizations hurt readability a bit, so I didn\\'t include them in the primary solution. None of them affects the big-O notation complexity, but they can save us some time that hides as \"negligible factors\".\\n- Have signs reversed during the computation and only correct it before returning the `ans`. This makes it cleaner with less `-` (negation) and presumably saves computation.\\n- Reuse `ma` for `heap[0]` look-ups.\\n- This one probably saves the most computation time: use `heapq.heapreplace()` ([python doc](https://docs.python.org/3/library/heapq.html#heapq.heapreplace)) instad of `heappop()` followed by `heappush()`. [This stackoverflow post](https://stackoverflow.com/a/46031391) explains a bit more why `heapreplace()` can be more efficient.\\n\\n### **Code 2**\\n```python\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = list(set(-(x * 2 if x & 1 else x) for x in nums))\\n        heapify(heap)\\n        ma, mi = heap[0], max(heap)\\n        ans = ma - mi\\n        while ma % 2 == 0:\\n            x = ma // 2\\n            heapreplace(heap, x)\\n            ma, mi = heap[0], max(mi, x)\\n            ans = max(ans, ma - mi)\\n        return -ans\\n```\\n\\n### **Submission stats**\\nRuntime: 836 ms (beats 99.15%)\\nMemory Usage: 30.7 MB (beats 30.77%)\\n\\n---\\nIf you find this helpful, please **upvote**! It will greatly encourage me to write more like this in the future. Thank you! \\uD83E\\uDD17\\n\\n[20210201] Wording.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = list(set(-(x * 2 if x & 1 else x) for x in nums))\\n        heapify(heap)\\n        ma, mi = -heap[0], -max(heap)\\n        ans = ma - mi\\n        while heap[0] % 2 == 0:\\n            x = heappop(heap) // 2\\n            heappush(heap, x)\\n            ma, mi = -heap[0], min(mi, -x)\\n            ans = min(ans, ma - mi)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = list(set(-(x * 2 if x & 1 else x) for x in nums))\\n        heapify(heap)\\n        ma, mi = heap[0], max(heap)\\n        ans = ma - mi\\n        while ma % 2 == 0:\\n            x = ma // 2\\n            heapreplace(heap, x)\\n            ma, mi = heap[0], max(mi, x)\\n            ans = max(ans, ma - mi)\\n        return -ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953875,
                "title": "c-solution-using-sets-with-clear-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set<int> s; //Set is used to remove simlar elements and avoids TLE\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] %2 == 1)\\n                s.insert(nums[i]*2); \\n            // If a element is odd it is multiplied by 2 and added in set\\n            else\\n                s.insert(nums[i]);\\n        }\\n        //s.rbegin() points to the last element of the array\\n        //s.begin() points to the first element of the array\\n        //We are storing the deviation in res\\n        int res = *s.rbegin() - *s.begin();\\n        // We are iterating until the last element comes out to be odd\\n        // We are updating res if we got any deviation less than the current Deviation\\n        while (*s.rbegin() % 2 == 0) {\\n            s.insert(*s.rbegin() / 2);\\n            s.erase(*s.rbegin());\\n            res = min(res, *s.rbegin() - *s.begin());\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set<int> s; //Set is used to remove simlar elements and avoids TLE\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] %2 == 1)\\n                s.insert(nums[i]*2); \\n            // If a element is odd it is multiplied by 2 and added in set\\n            else\\n                s.insert(nums[i]);\\n        }\\n        //s.rbegin() points to the last element of the array\\n        //s.begin() points to the first element of the array\\n        //We are storing the deviation in res\\n        int res = *s.rbegin() - *s.begin();\\n        // We are iterating until the last element comes out to be odd\\n        // We are updating res if we got any deviation less than the current Deviation\\n        while (*s.rbegin() % 2 == 0) {\\n            s.insert(*s.rbegin() / 2);\\n            s.erase(*s.rbegin());\\n            res = min(res, *s.rbegin() - *s.begin());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953159,
                "title": "python-100-trick-treat-every-number-as-an-even-number-and-use-max-heap",
                "content": "I saw a lot of solutions using min-heap and for that you need to first factor a = 2\\u207F  * k where k is an odd number. However if you use max-heap and *only* go downward (in an ideal world where every given number is even, we only need to divide by 2), such a factorization is not necessary. \\n\\nSo how do you arrive at the ideal world? \\n**Observation**: the answer won\\'t change if an odd number `k` is replaced by `2k`. (because `2k` can only be changed to `k` and vice versa.) So that\\'s it. \\n\\n```\\n    def minimumDeviation(self, A: List[int]) -> int:\\n        A = [-a * (1 + a%2) for a in A] # multiply odd number by 2. negative sign is only for max heap.\\n        m = -max(A)                     # min of the new list.\\n        heapq.heapify(A)                # now it\\'s a heap in the \"ideal world\".\\n        res = math.inf\\n        while True:\\n            a = -heapq.heappop(A)\\n            res = min(res, a-m)\\n            if a & 1: \\n                return res\\n            a >>= 1\\n            m = min(m, a)\\n            heapq.heappush(A, -a)\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumDeviation(self, A: List[int]) -> int:\\n        A = [-a * (1 + a%2) for a in A] # multiply odd number by 2. negative sign is only for max heap.\\n        m = -max(A)                     # min of the new list.\\n        heapq.heapify(A)                # now it\\'s a heap in the \"ideal world\".\\n        res = math.inf\\n        while True:\\n            a = -heapq.heappop(A)\\n            res = min(res, a-m)\\n            if a & 1: \\n                return res\\n            a >>= 1\\n            m = min(m, a)\\n            heapq.heappush(A, -a)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3563938,
                "title": "c-easy-to-understand-heap",
                "content": "in this question we can multiply odd no by 2 only once so we make all element of array even.\\n\\nget minimum possible element from all even nos.\\n\\ndivide max possible even no from heap untill we cann\\'t get max odd no.\\nafter divide get minimum element.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int x = INT_MAX;\\n        priority_queue<int> pq;//make max heap\\n        for(auto &i: nums){\\n            if(i&1){\\n                i <<= 1;\\n            }\\n            pq.push(i);\\n            x = min(x,i);\\n        }\\n        int ans = INT_MAX,y;\\n        while(!(pq.top()&1)){//untill top element is even\\n            y = pq.top();\\n            pq.pop();\\n            ans = min(ans,abs(y-x));\\n            pq.push(y/2);//we divide an element by 2\\n            x = min(x,y/2);//so y/2 will be minimum no\\n        }\\n        ans = min(ans,abs(pq.top()-x));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int x = INT_MAX;\\n        priority_queue<int> pq;//make max heap\\n        for(auto &i: nums){\\n            if(i&1){\\n                i <<= 1;\\n            }\\n            pq.push(i);\\n            x = min(x,i);\\n        }\\n        int ans = INT_MAX,y;\\n        while(!(pq.top()&1)){//untill top element is even\\n            y = pq.top();\\n            pq.pop();\\n            ans = min(ans,abs(y-x));\\n            pq.push(y/2);//we divide an element by 2\\n            x = min(x,y/2);//so y/2 will be minimum no\\n        }\\n        ans = min(ans,abs(pq.top()-x));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556978,
                "title": "short-python-greedy",
                "content": "We first multiply our odd elements by two and sort the new array. So now we are left with one operation, dividing even number by two. Record current deviation `nums[-1] - nums[0]`, then keep dividing maximal number by two and update the min deviation with the new difference `nums[-1] - nums[0]` in new nums array. At some moment you will stop, thus return the min deviation you was tracking.\\n\\nWith this greedy algorithm all possible maximal right ends will be visited, and the left end for it will be minimal possible. Therefore, greedy will work correctly. Short python code below:\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumDeviation(self, nums):\\n        def even(k):\\n            return 2 * k if k % 2 == 1 else k\\n        nums = SortedList([even(k) for k in nums])\\n        minn = nums[-1] - nums[0]\\n        while nums[-1] % 2 == 0:\\n            nums.add(nums[-1] // 2)\\n            nums.pop(-1)\\n            minn = min(minn, nums[-1] - nums[0])\\n        return minn\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumDeviation(self, nums):\\n        def even(k):\\n            return 2 * k if k % 2 == 1 else k\\n        nums = SortedList([even(k) for k in nums])\\n        minn = nums[-1] - nums[0]\\n        while nums[-1] % 2 == 0:\\n            nums.add(nums[-1] // 2)\\n            nums.pop(-1)\\n            minn = min(minn, nums[-1] - nums[0])\\n        return minn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044718,
                "title": "simple-java-solution-with-explaination-using-heap",
                "content": "1.\\tMax deviation in an array can be obtained by just sorting the array and find the first and last element difference.\\n2.\\tThe catch here is that we can perform operations -> if num is odd* 2. And if number is even/2.\\n3.\\tBy using above operations we want to make max deviation as minimum as possible.\\n4.\\tNow, we can observe that if we multiply odd number by 2 it will become even. So, as a first step we can convert all odd number to even to eliminate one operation i.e. multiply by 2.\\n5.\\tTo maintain sorted data everytime after every divide operation we can make use of maxheap. ( we can use maxHeap to return max element of updated set and will keep track of min using 1 variable min)\\nAlgo->\\n1. iterate array and start adding element to maxheap. If number is odd add num* 2 heap else num directly. To calculate difference. Find the minimum element of the entire array also.\\n2. now,  iterate till heap is not empty.\\n3. inside loop. Get max element from heap and calculate diff=Math.min(diff,max-min). in this way we will maintain minimum diff everytime. Now if current element is even just add num/2 again into heap. And update min by checking if num/2 is less then current min.\\n4. the above loop will break if max received from heap.poll is odd itself. As we now know we cannot further decrease the max deviation if max element itself is odd.\\n5. return diff. \\n\\n```\\npublic int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1,o2)->o2-o1);\\n        int min = Integer.MAX_VALUE;\\n        int diff=min;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]%2==1) {\\n                nums[i]*=2;\\n            }\\n            maxHeap.add(nums[i]);\\n            min=Math.min(min,nums[i]);\\n        }\\n        \\n        while(!maxHeap.isEmpty()) {\\n            int max = maxHeap.poll();\\n            diff=Math.min(diff,max-min);\\n            if(max%2==1) {\\n                break;\\n            }\\n            maxHeap.add(max/2);\\n            min=Math.min(min,max/2);\\n        }\\n        return diff;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1,o2)->o2-o1);\\n        int min = Integer.MAX_VALUE;\\n        int diff=min;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]%2==1) {\\n                nums[i]*=2;\\n            }\\n            maxHeap.add(nums[i]);\\n            min=Math.min(min,nums[i]);\\n        }\\n        \\n        while(!maxHeap.isEmpty()) {\\n            int max = maxHeap.poll();\\n            diff=Math.min(diff,max-min);\\n            if(max%2==1) {\\n                break;\\n            }\\n            maxHeap.add(max/2);\\n            min=Math.min(min,max/2);\\n        }\\n        return diff;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042048,
                "title": "c-nlogn-solution-using-multiset-with-inline-comments",
                "content": "To reduce the deviation, we can either increase the minimum value or decrease the maximum value.\\nAlso, based on the conditions, only odd elements can be increased (multiplied by 2) and only even elements can be reduced (divided by 2).\\n\\nThe first loop takes care of increasing the min value to as much as possible and the second loop takes care of decreasing the max value to as much as possible.\\n\\nComplexity : NLogN\\n\\n```\\n    int minimumDeviation(vector<int>& nums) {\\n\\n        multiset<int> mset;\\n\\n        //insert elements in multiset\\n        //here, we look to increase the min elements as much as possible\\n        //only the odd elemnts can be increased (multiply by 2) and that too only once (since it becomes even after that)\\n        //even elements are inserted as is and odd elements are inserted after multiplying by 2\\n        // if odd elements become greater than the actual max, after multiplication, don\\'t worry, it will be reduced while decreasing the max element in the later loop. \\n\\n        for(auto n:nums){\\n            n % 2 == 0 ? mset.insert(n) : mset.insert(n << 1);\\n        }\\n\\n        //get the max value\\n        int maxi = *mset.rbegin();\\n        \\n        //initialize ans to max - min value \\n        int ans = maxi - *mset.begin();\\n\\n        //Decrease the max element (if it is even) till the max can\\'t be further reduced (till max is odd)\\n        while(maxi % 2 == 0){\\n            mset.erase(maxi);\\n            mset.insert(maxi / 2);\\n            maxi = *mset.rbegin();\\n            ans = min (ans, (maxi - *mset.begin()));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumDeviation(vector<int>& nums) {\\n\\n        multiset<int> mset;\\n\\n        //insert elements in multiset\\n        //here, we look to increase the min elements as much as possible\\n        //only the odd elemnts can be increased (multiply by 2) and that too only once (since it becomes even after that)\\n        //even elements are inserted as is and odd elements are inserted after multiplying by 2\\n        // if odd elements become greater than the actual max, after multiplication, don\\'t worry, it will be reduced while decreasing the max element in the later loop. \\n\\n        for(auto n:nums){\\n            n % 2 == 0 ? mset.insert(n) : mset.insert(n << 1);\\n        }\\n\\n        //get the max value\\n        int maxi = *mset.rbegin();\\n        \\n        //initialize ans to max - min value \\n        int ans = maxi - *mset.begin();\\n\\n        //Decrease the max element (if it is even) till the max can\\'t be further reduced (till max is odd)\\n        while(maxi % 2 == 0){\\n            mset.erase(maxi);\\n            mset.insert(maxi / 2);\\n            maxi = *mset.rbegin();\\n            ans = min (ans, (maxi - *mset.begin()));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041751,
                "title": "c-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int x = INT_MAX, res;\\n        priority_queue<int> pq;\\n        \\n        for (auto& n:nums) {\\n            if (n&1) {\\n                pq.push(n*2);\\n                x = min(x, n*2);\\n            } else {\\n                pq.push(n);\\n                x = min(x, n);\\n            }\\n        }\\n        \\n        res = pq.top() - x;\\n        while (!(pq.top()&1)) {\\n            int temp  = pq.top()/2; pq.pop();\\n            x = min(x, temp);\\n            pq.push(temp);\\n            res = min(res, pq.top() - x);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int x = INT_MAX, res;\\n        priority_queue<int> pq;\\n        \\n        for (auto& n:nums) {\\n            if (n&1) {\\n                pq.push(n*2);\\n                x = min(x, n*2);\\n            } else {\\n                pq.push(n);\\n                x = min(x, n);\\n            }\\n        }\\n        \\n        res = pq.top() - x;\\n        while (!(pq.top()&1)) {\\n            int temp  = pq.top()/2; pq.pop();\\n            x = min(x, temp);\\n            pq.push(temp);\\n            res = min(res, pq.top() - x);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953269,
                "title": "c-sliding-window-approach",
                "content": "We can get all the numbers which a given number can be converted to based depending on its parity .So we can store array of pair of value and its original index.\\n\\nNow our problem reduces to find the window which contains each index from (0 to n-1) at least once.And the window which has the smallest difference between the extremes values is our answer window.\\n\\nFor e.g\\n\\n[4,1,5,20,3]\\nFor the given array\\n\\nvalues 4 can attain are 4,2,1\\nvalues 1 can attain are 1,2\\nsimilarly for 5 are 5,10 and for 20 are 20,10,5 and 3,6\\n\\nSo our pair array looks like\\n( 1,0 ) ( 1,1 ) ( 2,0 ) ( 2,1 ) ( 3,4 ) ( 4,0 ) ( 5,2 ) ( 5,3 ) ( 6,4 ) ( 10,2 ) ( 10,3 ) ( 20,3 ) \\n\\nwhere first argument is the value and second argument is the index it belongs to.\\nSo if we observe the  window from position  3 to 9 contains at each index from 0 to n-1 at least once. And deviation is the difference between values at the start and the end of the window so our answer is (5-2) = 3.\\n\\nImplementation: \\n\\nI got TLE with the vector, so used an array implementation and defined the array size as 31 N because log2(1e9) is almost 30, so that means, in the worst case a number can be divided by 2 almost 30 times, hence an index can have at most 30 occurances of it in our pair array, so 31 n size of the array is sufficient.\\n```\\nCode:\\nclass Solution {\\npublic:\\n\\tint minimumDeviation(vector<int> &a) {\\n\\t\\n\\t\\tint n = a.size();\\n\\t\\tarray<int, 2>v[31 * n];\\n\\t\\tint j = 0;\\n\\n\\t\\tfo(i, 0, n - 1)\\n\\t\\t{\\n\\t\\t\\tint x = a[i];\\n\\n\\t\\t\\tif (x & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tv[j++] = {x, i};\\n\\t\\t\\t\\tv[j++] = {2 * x, i};\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile (!(x & 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv[j++] = {x, i};\\n\\t\\t\\t\\t\\tx /= 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tv[j++] = {x, i};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsort(v,v+j);\\n\\t\\tint ans = 1e9 + 7;\\n\\t\\tint cnt = 0;\\n\\t\\tvector<int> in(n, 0);\\n\\t\\tint sz = j;\\n\\t\\tj = 0;\\n\\t\\n\\t\\tfo(i, 0, sz - 1)\\n\\t\\t{\\n\\t\\t\\tif (in[v[i][1]] == 0) cnt++;\\n\\t\\t\\tin[v[i][1]]++;\\n\\t\\t\\t\\n\\t\\t\\twhile (in[v[j][1]] > 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tin[v[j][1]]--;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tif (cnt == n) ans = min(ans, v[i][0] - v[j][0]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nCode:\\nclass Solution {\\npublic:\\n\\tint minimumDeviation(vector<int> &a) {\\n\\t\\n\\t\\tint n = a.size();\\n\\t\\tarray<int, 2>v[31 * n];\\n\\t\\tint j = 0;\\n\\n\\t\\tfo(i, 0, n - 1)\\n\\t\\t{\\n\\t\\t\\tint x = a[i];\\n\\n\\t\\t\\tif (x & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tv[j++] = {x, i};\\n\\t\\t\\t\\tv[j++] = {2 * x, i};\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile (!(x & 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv[j++] = {x, i};\\n\\t\\t\\t\\t\\tx /= 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tv[j++] = {x, i};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsort(v,v+j);\\n\\t\\tint ans = 1e9 + 7;\\n\\t\\tint cnt = 0;\\n\\t\\tvector<int> in(n, 0);\\n\\t\\tint sz = j;\\n\\t\\tj = 0;\\n\\t\\n\\t\\tfo(i, 0, sz - 1)\\n\\t\\t{\\n\\t\\t\\tif (in[v[i][1]] == 0) cnt++;\\n\\t\\t\\tin[v[i][1]]++;\\n\\t\\t\\t\\n\\t\\t\\twhile (in[v[j][1]] > 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tin[v[j][1]]--;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tif (cnt == n) ans = min(ans, v[i][0] - v[j][0]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226817,
                "title": "java-priority-queue-13-lines-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimumDeviation(int[] nums) {\\n    var q = new PriorityQueue<Integer>(Collections.reverseOrder());\\n    var low = Integer.MAX_VALUE;\\n\\n    for (var n : nums) {\\n      if (n % 2 == 1) n *= 2;\\n      q.offer(n);\\n      low = Math.min(low, n);\\n    }\\n    var diff = q.peek() - low;\\n\\n    while (q.peek() % 2 == 0) {\\n      var a = q.poll() / 2;\\n      q.offer(a);\\n      low = Math.min(low, a);\\n      diff = Math.min(diff, q.peek() - low);\\n    }\\n    return diff;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  public int minimumDeviation(int[] nums) {\\n    var q = new PriorityQueue<Integer>(Collections.reverseOrder());\\n    var low = Integer.MAX_VALUE;\\n\\n    for (var n : nums) {\\n      if (n % 2 == 1) n *= 2;\\n      q.offer(n);\\n      low = Math.min(low, n);\\n    }\\n    var diff = q.peek() - low;\\n\\n    while (q.peek() % 2 == 0) {\\n      var a = q.poll() / 2;\\n      q.offer(a);\\n      low = Math.min(low, a);\\n      diff = Math.min(diff, q.peek() - low);\\n    }\\n    return diff;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225135,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& arr) {\\n        int n = arr.size();\\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[i] % 2 != 0)\\n            {\\n                arr[i] = 2 * arr[i];\\n            }\\n            maxi = max(maxi, arr[i]);\\n            mini = min(mini, arr[i]);\\n        }\\n        priority_queue<int> pq;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push(arr[i]);\\n        }\\n        int min_deviation = maxi - mini;\\n        int top = 0; \\n        while(pq.top() % 2 == 0)\\n        {\\n            top = pq.top();\\n            pq.pop();\\n            min_deviation = min(min_deviation, top - mini);\\n            mini = min(mini, top / 2);\\n            pq.push(top / 2);\\n        }\\n        top = pq.top();\\n        min_deviation = min(min_deviation, top - mini);\\n        return min_deviation;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& arr) {\\n        int n = arr.size();\\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[i] % 2 != 0)\\n            {\\n                arr[i] = 2 * arr[i];\\n            }\\n            maxi = max(maxi, arr[i]);\\n            mini = min(mini, arr[i]);\\n        }\\n        priority_queue<int> pq;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push(arr[i]);\\n        }\\n        int min_deviation = maxi - mini;\\n        int top = 0; \\n        while(pq.top() % 2 == 0)\\n        {\\n            top = pq.top();\\n            pq.pop();\\n            min_deviation = min(min_deviation, top - mini);\\n            mini = min(mini, top / 2);\\n            pq.push(top / 2);\\n        }\\n        top = pq.top();\\n        min_deviation = min(min_deviation, top - mini);\\n        return min_deviation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224150,
                "title": "c-java-python-solution-in-o-n-log-n-log-max-element-time-and-o-n-space-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We can start by making all odd elements even by multiplying them with \\n2. Then, we can try to divide the maximum element by 2 as many times as possible to minimize the deviation.\\n3. After each division, we need to keep track of the minimum deviation we have seen so far.\\n4. Repeat step 2 and 3 until we can no longer divide the maximum element by 2.\\n\\n- # Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Multiply all odd elements by 2 and add them to a priority queue\\n2. Initialize the minimum deviation to be the difference between the maximum element and the top element of the priority queue.\\n3. Repeat the following until the maximum element is even:\\n    - Remove the maximum element from the priority queue.\\n    - Divide it by 2 and add it to the priority queue.\\n    - Update the minimum deviation if the difference between the maximum element and the top element of the priority queue is smaller than the current minimum deviation.\\n4. Return the minimum deviation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    - The multiplication of odd numbers takes O(n) time.\\n    - The priority queue operations take O(log n) time each.\\n    - We can divide the maximum element by 2 at most log(maximum element) times.\\n    - Therefore, the overall time complexity is O(n log n log(maximum element)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    - We need to store all odd elements in the priority queue, which takes O(n) space.\\n![upvote.jpeg](https://assets.leetcode.com/users/images/43535e4a-38e5-4a4a-ad13-f5138446b4c8_1677219960.6525292.jpeg)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int mini = INT_MAX;\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num *= 2;\\n            }\\n            pq.push(num);\\n            mini = min(mini, num);\\n        }\\n        int res = INT_MAX;\\n        while (true) {\\n            int maxi = pq.top();\\n            pq.pop();\\n            res = min(res, maxi - mini);\\n            if (maxi % 2 == 1) {\\n                break;\\n            }\\n            maxi /= 2;\\n            mini = min(mini, maxi);\\n            pq.push(maxi);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        int mini = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num *= 2;\\n            }\\n            pq.offer(num);\\n            mini = Math.min(mini, num);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        while (true) {\\n            int maxi = pq.poll();\\n            res = Math.min(res, maxi - mini);\\n            if (maxi % 2 == 1) {\\n                break;\\n            }\\n            maxi /= 2;\\n            mini = Math.min(mini, maxi);\\n            pq.offer(maxi);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n# Python Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        pq = []\\n        mini = float(\\'inf\\')\\n        for num in nums:\\n            if num % 2 == 1:\\n                num *= 2\\n            heapq.heappush(pq, -num)\\n            mini = min(mini, num)\\n        res = float(\\'inf\\')\\n        while True:\\n            maxi = -heapq.heappop(pq)\\n            res = min(res, maxi - mini)\\n            if maxi % 2 == 1:\\n                break\\n            maxi //= 2\\n            mini = min(mini, maxi)\\n            heapq.heappush(pq, -maxi)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int mini = INT_MAX;\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num *= 2;\\n            }\\n            pq.push(num);\\n            mini = min(mini, num);\\n        }\\n        int res = INT_MAX;\\n        while (true) {\\n            int maxi = pq.top();\\n            pq.pop();\\n            res = min(res, maxi - mini);\\n            if (maxi % 2 == 1) {\\n                break;\\n            }\\n            maxi /= 2;\\n            mini = min(mini, maxi);\\n            pq.push(maxi);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        int mini = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num *= 2;\\n            }\\n            pq.offer(num);\\n            mini = Math.min(mini, num);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        while (true) {\\n            int maxi = pq.poll();\\n            res = Math.min(res, maxi - mini);\\n            if (maxi % 2 == 1) {\\n                break;\\n            }\\n            maxi /= 2;\\n            mini = Math.min(mini, maxi);\\n            pq.offer(maxi);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nimport heapq\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        pq = []\\n        mini = float(\\'inf\\')\\n        for num in nums:\\n            if num % 2 == 1:\\n                num *= 2\\n            heapq.heappush(pq, -num)\\n            mini = min(mini, num)\\n        res = float(\\'inf\\')\\n        while True:\\n            maxi = -heapq.heappop(pq)\\n            res = min(res, maxi - mini)\\n            if maxi % 2 == 1:\\n                break\\n            maxi //= 2\\n            mini = min(mini, maxi)\\n            heapq.heappush(pq, -maxi)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224075,
                "title": "kotlin-2-priorityqueue-one-min-and-one-max-100",
                "content": "# Approach\\n1. Create 2 PriorityQueue, one min and one max\\n2. Loop until max value is odd, means we can\\'t divide / perform any operations further\\n3. The minDeviation will keep updating with `max-min`\\n\\n# Code\\n```\\nclass Solution {\\n    fun minimumDeviation(nums: IntArray): Int {\\n        val maxQueue = PriorityQueue<Int>(Collections.reverseOrder())\\n        val minQueue = PriorityQueue<Int>()\\n        nums.forEach {\\n            maxQueue.offer(if (it % 2 != 0) it * 2 else it)\\n            minQueue.offer(if (it % 2 != 0) it * 2 else it)\\n        }\\n\\n        var max = maxQueue.poll()\\n        var minDeviation = max - minQueue.peek()\\n        while (max % 2 == 0) {\\n            max /= 2\\n            maxQueue.offer(max)\\n            minQueue.offer(max)\\n            max = maxQueue.poll()\\n            minDeviation = Math.min(minDeviation, max - minQueue.peek())\\n        }\\n\\n        return minDeviation\\n    }\\n}\\n```\\n![f6db4696-26ce-4e27-b643-307f2490f3c9_1677214295.1615763.jpeg](https://assets.leetcode.com/users/images/88816fe5-aabf-4119-9ae2-168fde46da36_1677218605.6817346.jpeg)\\n\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minimumDeviation(nums: IntArray): Int {\\n        val maxQueue = PriorityQueue<Int>(Collections.reverseOrder())\\n        val minQueue = PriorityQueue<Int>()\\n        nums.forEach {\\n            maxQueue.offer(if (it % 2 != 0) it * 2 else it)\\n            minQueue.offer(if (it % 2 != 0) it * 2 else it)\\n        }\\n\\n        var max = maxQueue.poll()\\n        var minDeviation = max - minQueue.peek()\\n        while (max % 2 == 0) {\\n            max /= 2\\n            maxQueue.offer(max)\\n            minQueue.offer(max)\\n            max = maxQueue.poll()\\n            minDeviation = Math.min(minDeviation, max - minQueue.peek())\\n        }\\n\\n        return minDeviation\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223673,
                "title": "rust-with-binaryheap-87-ms",
                "content": "\\n\\n```\\nuse std::collections::BinaryHeap;\\nuse std::cmp;\\n\\nimpl Solution {\\n\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let mut queue = BinaryHeap::with_capacity(nums.len());\\n        let mut min_n = i32::MAX;\\n        nums.into_iter()\\n            .map(|n| if n % 2 == 0 { n } else { n * 2 })\\n            .for_each(|n| {\\n                min_n = cmp::min(min_n, n);\\n                queue.push(n);\\n            });\\n\\n        let mut min_diff = i32::MAX;\\n        while let Some(max_n) = queue.pop() {\\n            min_diff = cmp::min(min_diff, max_n - min_n);\\n            if max_n % 2 != 0 {\\n                break;\\n            }\\n            let div_val = max_n / 2;\\n            min_n = cmp::min(min_n, div_val);\\n            queue.push(div_val);\\n        }\\n\\n        min_diff\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\nuse std::cmp;\\n\\nimpl Solution {\\n\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let mut queue = BinaryHeap::with_capacity(nums.len());\\n        let mut min_n = i32::MAX;\\n        nums.into_iter()\\n            .map(|n| if n % 2 == 0 { n } else { n * 2 })\\n            .for_each(|n| {\\n                min_n = cmp::min(min_n, n);\\n                queue.push(n);\\n            });\\n\\n        let mut min_diff = i32::MAX;\\n        while let Some(max_n) = queue.pop() {\\n            min_diff = cmp::min(min_diff, max_n - min_n);\\n            if max_n % 2 != 0 {\\n                break;\\n            }\\n            let div_val = max_n / 2;\\n            min_n = cmp::min(min_n, div_val);\\n            queue.push(div_val);\\n        }\\n\\n        min_diff\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783960,
                "title": "python-short-solutiion-5-lines",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        S, ans = SortedList(i*2 if i & 1 else i for i in nums), 10**9\\n        while not S[-1] & 1:\\n            ans = min(ans, S[-1] - S[0])\\n            S.add(S.pop() // 2)\\n        return min(ans, S[-1] - S[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        S, ans = SortedList(i*2 if i & 1 else i for i in nums), 10**9\\n        while not S[-1] & 1:\\n            ans = min(ans, S[-1] - S[0])\\n            S.add(S.pop() // 2)\\n        return min(ans, S[-1] - S[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783703,
                "title": "c-maxheap-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) \\n    {\\n        //diamond notes \\n        //maximise the odd elements by multiplying with 2 \\n        //and then make a priority queue and check the diff of maxh.top and min and then divide the element which is in top by 2 and then add it in heap and store difference \\n        priority_queue<int>maxh;\\n        int n=nums.size();\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]&1)\\n            {\\n                nums[i]*=2;\\n            }\\n            mini=min(mini,nums[i]);\\n            maxh.push(nums[i]);\\n        }\\n        int diff=INT_MAX;\\n        while(!maxh.empty())\\n        {\\n            int curr=maxh.top();\\n            maxh.pop();\\n            diff=min(diff,curr-mini);\\n            if(curr&1)break;\\n            curr/=2;\\n            maxh.push(curr);\\n            if(curr<mini)\\n            {\\n                mini=curr;\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) \\n    {\\n        //diamond notes \\n        //maximise the odd elements by multiplying with 2 \\n        //and then make a priority queue and check the diff of maxh.top and min and then divide the element which is in top by 2 and then add it in heap and store difference \\n        priority_queue<int>maxh;\\n        int n=nums.size();\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]&1)\\n            {\\n                nums[i]*=2;\\n            }\\n            mini=min(mini,nums[i]);\\n            maxh.push(nums[i]);\\n        }\\n        int diff=INT_MAX;\\n        while(!maxh.empty())\\n        {\\n            int curr=maxh.top();\\n            maxh.pop();\\n            diff=min(diff,curr-mini);\\n            if(curr&1)break;\\n            curr/=2;\\n            maxh.push(curr);\\n            if(curr<mini)\\n            {\\n                mini=curr;\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783067,
                "title": "python-beat-93-time-simple-heap-solution",
                "content": "Here is my solution based on minHeap & maxHeap\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        minHeap = []\\n        maxHeap = []\\n        for n in nums:\\n            heapq.heappush(minHeap,n)\\n            heapq.heappush(maxHeap,-n)\\n        ans = abs(-maxHeap[0] - minHeap[0])\\n        \\n        while minHeap[0] % 2 == 1:\\n            minVal = 2 * heapq.heappop(minHeap)\\n            heapq.heappush(minHeap,minVal)\\n            heapq.heappush(maxHeap,-minVal)\\n            ans = min(ans, abs(-maxHeap[0] - minHeap[0]))\\n            \\n        while (-maxHeap[0]) % 2 == 0:\\n            maxVal = heapq.heappop(maxHeap)//2\\n            heapq.heappush(maxHeap,maxVal)\\n            heapq.heappush(minHeap,-maxVal)\\n            ans = min(ans, abs(-maxHeap[0] - minHeap[0]))\\n        \\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "Here is my solution based on minHeap & maxHeap\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        minHeap = []\\n        maxHeap = []\\n        for n in nums:\\n            heapq.heappush(minHeap,n)\\n            heapq.heappush(maxHeap,-n)\\n        ans = abs(-maxHeap[0] - minHeap[0])\\n        \\n        while minHeap[0] % 2 == 1:\\n            minVal = 2 * heapq.heappop(minHeap)\\n            heapq.heappush(minHeap,minVal)\\n            heapq.heappush(maxHeap,-minVal)\\n            ans = min(ans, abs(-maxHeap[0] - minHeap[0]))\\n            \\n        while (-maxHeap[0]) % 2 == 0:\\n            maxVal = heapq.heappop(maxHeap)//2\\n            heapq.heappush(maxHeap,maxVal)\\n            heapq.heappush(minHeap,-maxVal)\\n            ans = min(ans, abs(-maxHeap[0] - minHeap[0]))\\n        \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1782818,
                "title": "c-easy-understanding-using-set-fully-explained-aprroach",
                "content": "# Approch: \\nThe approach that we saw over here can be null down to\\n\\n* Make all odd values even\\n* Take minimum of all values\\n* Find Max & difference & update max/2, till the max is even\\n* Otherwise difference is the result\\n```\\n//Please upvote if u like my solution :)\\nint minimumDeviation(vector<int>& nums) {\\n        set<int> ss;\\n        for(auto it:nums){\\n            if(it & 1) ss.insert(it*2);\\n            else ss.insert(it);\\n        }\\n        int maxi = *ss.rbegin();   // will give iterator of the largest element\\n        int mini = *ss.begin();   // will give iterator of the smallest element\\n        int ans = INT_MAX;\\n        while(*ss.rbegin()%2==0){\\n            int currMax = *ss.rbegin();\\n            ss.erase(currMax);\\n            ss.insert(currMax/2);\\n            ans = min(ans,*ss.rbegin()-*ss.begin());\\n        }\\n        return ans;\\n    }\\n//Please upvote if u like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n//Please upvote if u like my solution :)\\nint minimumDeviation(vector<int>& nums) {\\n        set<int> ss;\\n        for(auto it:nums){\\n            if(it & 1) ss.insert(it*2);\\n            else ss.insert(it);\\n        }\\n        int maxi = *ss.rbegin();   // will give iterator of the largest element\\n        int mini = *ss.begin();   // will give iterator of the smallest element\\n        int ans = INT_MAX;\\n        while(*ss.rbegin()%2==0){\\n            int currMax = *ss.rbegin();\\n            ss.erase(currMax);\\n            ss.insert(currMax/2);\\n            ans = min(ans,*ss.rbegin()-*ss.begin());\\n        }\\n        return ans;\\n    }\\n//Please upvote if u like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1782389,
                "title": "c-solution-simple-explanation-using-priority-queue",
                "content": "##### Explanation:-\\n\\u2022 For any given configuration of nums the deviation is equal to (maxx - minn)\\n\\u2022 To decrease the deviation either increase the minn or decrease the maxx.\\n\\u2022 Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\\n\\u2022 since every element is as maximum as possible , you can not increase any number further\\n\\u2022 Now we are left with just one operation decrease the maxx\\n\\u2022 So perform this operation as many times as u can and keep track of the min_deviation\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        // Step 1:- Increase all elements to as maximum as it can and track the minimum number and also the result.\\n        int n = nums.size();\\n        int maxx = INT_MIN, minn = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]%2 == 1)\\n                nums[i] = nums[i]*2;\\n            maxx = max(maxx, nums[i]);\\n            minn = min(minn, nums[i]);\\n        }\\n        int min_deviation = maxx - minn;\\n        \\n        //Step 2:- Insert into max_heap and try to decrease the maxx as much as you can\\n        priority_queue<int> pq;\\n        for(int i=0; i<n; i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while((pq.top())%2 == 0){\\n            int top = pq.top();\\n            pq.pop();\\n            min_deviation = min(min_deviation, top - minn);\\n            top = top/2;\\n            minn = min(minn, top);\\n            pq.push(top);\\n        }\\n        min_deviation = min(min_deviation, pq.top() - minn);\\n        \\n        //Step 3:- return maxx - minn\\n        return min_deviation;\\n    }\\n};\\n```\\n**Do upvote, if somewhere it helped you :)**\\n*Happy Coding.*",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        // Step 1:- Increase all elements to as maximum as it can and track the minimum number and also the result.\\n        int n = nums.size();\\n        int maxx = INT_MIN, minn = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]%2 == 1)\\n                nums[i] = nums[i]*2;\\n            maxx = max(maxx, nums[i]);\\n            minn = min(minn, nums[i]);\\n        }\\n        int min_deviation = maxx - minn;\\n        \\n        //Step 2:- Insert into max_heap and try to decrease the maxx as much as you can\\n        priority_queue<int> pq;\\n        for(int i=0; i<n; i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while((pq.top())%2 == 0){\\n            int top = pq.top();\\n            pq.pop();\\n            min_deviation = min(min_deviation, top - minn);\\n            top = top/2;\\n            minn = min(minn, top);\\n            pq.push(top);\\n        }\\n        min_deviation = min(min_deviation, pq.top() - minn);\\n        \\n        //Step 3:- return maxx - minn\\n        return min_deviation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782166,
                "title": "rust-heap",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl4/lc1675)\\n\\nProblem List related to #Heap - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/heap)\\n\\n```\\nuse std::collections::BinaryHeap;\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimize-deviation-in-array/\\n/// Time Complexity:    O(`_len_n` * lg(`_len_n`))\\n/// Space Complexity:   O(`_len_n`)\\n/// Reference:\\n/// https://leetcode.com/problems/minimize-deviation-in-array/discuss/952857/JavaC%2B%2BPython-Priority-Queue\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let _len_n: usize = nums.len();\\n        let mut heap: BinaryHeap<i32> = BinaryHeap::new();\\n        let mut min_odd: i32 = i32::MAX;\\n        let mut ans: i32 = i32::MAX;\\n        for num in nums {\\n            let odd = if num % 2 == 1 { num * 2 } else { num };\\n            heap.push(odd);\\n            min_odd = std::cmp::min(min_odd, odd);\\n        }\\n        loop {\\n            if let Some(top) = heap.pop() {\\n                ans = std::cmp::min(ans, top - min_odd);\\n                if top % 2 == 1 {\\n                    break;\\n                }\\n                min_odd = std::cmp::min(min_odd, top / 2);\\n                heap.push(top / 2);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::BinaryHeap;\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimize-deviation-in-array/\\n/// Time Complexity:    O(`_len_n` * lg(`_len_n`))\\n/// Space Complexity:   O(`_len_n`)\\n/// Reference:\\n/// https://leetcode.com/problems/minimize-deviation-in-array/discuss/952857/JavaC%2B%2BPython-Priority-Queue\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let _len_n: usize = nums.len();\\n        let mut heap: BinaryHeap<i32> = BinaryHeap::new();\\n        let mut min_odd: i32 = i32::MAX;\\n        let mut ans: i32 = i32::MAX;\\n        for num in nums {\\n            let odd = if num % 2 == 1 { num * 2 } else { num };\\n            heap.push(odd);\\n            min_odd = std::cmp::min(min_odd, odd);\\n        }\\n        loop {\\n            if let Some(top) = heap.pop() {\\n                ans = std::cmp::min(ans, top - min_odd);\\n                if top % 2 == 1 {\\n                    break;\\n                }\\n                min_odd = std::cmp::min(min_odd, top / 2);\\n                heap.push(top / 2);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1782034,
                "title": "easy-explained-minimize-deviation-in-array",
                "content": "**NOTE :**\\n* If the element is even, divide it by 2.\\n* If the element is odd, multiply it by 2.\\n* Also ![image](https://assets.leetcode.com/users/images/5354c083-4e18-4544-bd17-41449fe5fb15_1645247965.4044886.png)\\n\\n**IDEA :**\\n1. So for the first time if we multiply it by 2 then all odd become even and no odd numbers will be there in the array. (Main motive to do so that we need not to multipy further array elements, and can get the min element from that).\\n1. Find min element **\\'mi\\'** from the array.\\n1. Now find the max element \\'ma\\' from the array and store the diff \\'d\\' among **ma - mi**(max-min).\\n1. Repeat step 2 until the max becomes odd (so we can not divide it further on).\\n1. Also, we have to check whether the **ma/2** is not less than **mi**, if it is so then mi = ma/2.\\n\\n**IF WE LINEARLY FIND MAX FOR ALL THE TIME THEN IT WILL GIVE TLE**\\nSo we have to use concept like **PRIORITY QUEUE**, the idea is of **MAX-HEAP** (the topmost element is the largest element among all, and the leaf element has the smallest element).\\n\\n**CODE : **\\n```\\nint minimumDeviation(vector<int>& a)\\n    {\\n        int n=a.size();\\n        priority_queue<int> pq;\\n\\t\\t// changing odd to even and also storing to the priority_queue.\\n        for(int i=0; i<n; i++)\\n        {\\n            if(a[i]%2!=0)\\n                a[i]*=2;\\n            pq.push(a[i]);\\n        }\\n\\t\\t// finding minimum element \\n        int mi=*min_element(a.begin(), a.end());\\n        int d = INT_MAX;\\n\\t\\t\\n\\t\\t//always find max untill max/2!=0\\n        while(pq.top()%2==0)\\n        {\\n\\t\\t\\t// removing the max element from the priority queue and finding the diff.\\n            int ma = pq.top();\\n            pq.pop();\\n            d = min(d, ma - mi);\\n\\t\\t\\t//updating the minimum.\\n            mi = min(mi, ma/2);\\n\\t\\t\\t//pushing max/2 to the MAX-HEAP.\\n            pq.push(ma/2);\\n            \\n        }\\n        return min(d, pq.top() - mi);\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "**NOTE :**\\n* If the element is even, divide it by 2.\\n* If the element is odd, multiply it by 2.\\n* Also ![image](https://assets.leetcode.com/users/images/5354c083-4e18-4544-bd17-41449fe5fb15_1645247965.4044886.png)\\n\\n**IDEA :**\\n1. So for the first time if we multiply it by 2 then all odd become even and no odd numbers will be there in the array. (Main motive to do so that we need not to multipy further array elements, and can get the min element from that).\\n1. Find min element **\\'mi\\'** from the array.\\n1. Now find the max element \\'ma\\' from the array and store the diff \\'d\\' among **ma - mi**(max-min).\\n1. Repeat step 2 until the max becomes odd (so we can not divide it further on).\\n1. Also, we have to check whether the **ma/2** is not less than **mi**, if it is so then mi = ma/2.\\n\\n**IF WE LINEARLY FIND MAX FOR ALL THE TIME THEN IT WILL GIVE TLE**\\nSo we have to use concept like **PRIORITY QUEUE**, the idea is of **MAX-HEAP** (the topmost element is the largest element among all, and the leaf element has the smallest element).\\n\\n**CODE : **\\n```\\nint minimumDeviation(vector<int>& a)\\n    {\\n        int n=a.size();\\n        priority_queue<int> pq;\\n\\t\\t// changing odd to even and also storing to the priority_queue.\\n        for(int i=0; i<n; i++)\\n        {\\n            if(a[i]%2!=0)\\n                a[i]*=2;\\n            pq.push(a[i]);\\n        }\\n\\t\\t// finding minimum element \\n        int mi=*min_element(a.begin(), a.end());\\n        int d = INT_MAX;\\n\\t\\t\\n\\t\\t//always find max untill max/2!=0\\n        while(pq.top()%2==0)\\n        {\\n\\t\\t\\t// removing the max element from the priority queue and finding the diff.\\n            int ma = pq.top();\\n            pq.pop();\\n            d = min(d, ma - mi);\\n\\t\\t\\t//updating the minimum.\\n            mi = min(mi, ma/2);\\n\\t\\t\\t//pushing max/2 to the MAX-HEAP.\\n            pq.push(ma/2);\\n            \\n        }\\n        return min(d, pq.top() - mi);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1042777,
                "title": "golang-solution-with-explanation-100",
                "content": "Solution summary : Change all numbers to their possible max value, then keeps on reducing max value\\n\\n1. The number of operations on each number are limited, which are X2 on odd number and /2 on even number, for example : \\n\\t5 can be changed to 5, 10\\n\\t12 can be changed to 12, 6, 3\\n2. Since it\\'s hard to manage 2 operations at the same time, we may consider to change all numbers to their possible max value \\n3. We just need to keep on reducing the max value to find out the min range (till the max value is an odd number), as reduce other values won\\'t help on reduce range\\n4. During the process, maintain the min value and calculate min range\\n\\nHow to dynamically maintain the max value of a list? Here I choose to use heap.\\n\\n```\\nfunc minimumDeviation(nums []int) int {\\n    res := 2<<32\\n    MIN := 2<<32\\n    //*2 on all odd numbers and maintain MIN number\\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] % 2 == 1 {\\n            nums[i] *= 2\\n        }\\n        MIN = min(MIN, nums[i]) \\n    }\\n    \\n    //generate a max root heap\\n    genHeap(nums)\\n    \\n    //divide heap root by 2 if it\\'s even number, re-do heap, maintain the MIN and result in the process\\n    for nums[0] % 2 == 0 {\\n        nums[0] /= 2\\n        MIN = min(nums[0], MIN)\\n        heapify(nums, len(nums), 0)\\n        res = min(res, (nums[0] - MIN))\\n    }\\n    return res\\n}\\n\\nfunc genHeap(nums []int) {\\n    for i := len(nums) / 2; i >= 0; i-- {\\n        heapify(nums, len(nums), i)\\n    }\\n    return\\n}\\n\\nfunc heapify(nums []int, n, i int) {\\n    c1 := i * 2 + 1\\n    c2 := i * 2 + 2\\n    max := i\\n    if c1 < n && nums[c1] > nums[max] {\\n        max = c1\\n    }\\n    if c2 < n && nums[c2] > nums[max] {\\n        max = c2\\n    }\\n    if max != i {\\n        swap(nums, max, i)\\n        heapify(nums, len(nums), max)\\n    }\\n    return\\n}\\n\\nfunc swap(nums []int, a, b int) {\\n    temp := nums[a]\\n    nums[a] = nums[b]\\n    nums[b] = temp\\n    return\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunc minimumDeviation(nums []int) int {\\n    res := 2<<32\\n    MIN := 2<<32\\n    //*2 on all odd numbers and maintain MIN number\\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] % 2 == 1 {\\n            nums[i] *= 2\\n        }\\n        MIN = min(MIN, nums[i]) \\n    }\\n    \\n    //generate a max root heap\\n    genHeap(nums)\\n    \\n    //divide heap root by 2 if it\\'s even number, re-do heap, maintain the MIN and result in the process\\n    for nums[0] % 2 == 0 {\\n        nums[0] /= 2\\n        MIN = min(nums[0], MIN)\\n        heapify(nums, len(nums), 0)\\n        res = min(res, (nums[0] - MIN))\\n    }\\n    return res\\n}\\n\\nfunc genHeap(nums []int) {\\n    for i := len(nums) / 2; i >= 0; i-- {\\n        heapify(nums, len(nums), i)\\n    }\\n    return\\n}\\n\\nfunc heapify(nums []int, n, i int) {\\n    c1 := i * 2 + 1\\n    c2 := i * 2 + 2\\n    max := i\\n    if c1 < n && nums[c1] > nums[max] {\\n        max = c1\\n    }\\n    if c2 < n && nums[c2] > nums[max] {\\n        max = c2\\n    }\\n    if max != i {\\n        swap(nums, max, i)\\n        heapify(nums, len(nums), max)\\n    }\\n    return\\n}\\n\\nfunc swap(nums []int, a, b int) {\\n    temp := nums[a]\\n    nums[a] = nums[b]\\n    nums[b] = temp\\n    return\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041875,
                "title": "go-simulation-heap",
                "content": "```\\n// An IntHeap is a min-heap of ints.\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype MaxHeap struct {\\n\\tIntHeap\\n}\\n\\nfunc (h MaxHeap) Less(i, j int) bool { return h.IntHeap[i] > h.IntHeap[j] }\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc minimumDeviation(nums []int) int {    \\n    minimum := math.MaxInt64\\n    evens := &MaxHeap{[]int{}}\\n    heap.Init(evens)\\n\\n    for _, num := range nums {\\n        if num % 2 == 0 {\\n            heap.Push(evens, num)\\n            minimum = min(minimum, num)\\n        } else {\\n            heap.Push(evens, num * 2)\\n            minimum = min(minimum, num * 2)\\n        }\\n    }\\n    \\n    minDeviation := math.MaxInt64\\n    \\n    for evens.Len() > 0 {\\n        currentValue := heap.Pop(evens).(int)\\n        minDeviation = min(minDeviation, currentValue - minimum)\\n        \\n        if currentValue % 2 == 0 {\\n            heap.Push(evens, currentValue / 2)\\n            minimum = min(minimum, currentValue / 2)\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    return minDeviation\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// An IntHeap is a min-heap of ints.\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype MaxHeap struct {\\n\\tIntHeap\\n}\\n\\nfunc (h MaxHeap) Less(i, j int) bool { return h.IntHeap[i] > h.IntHeap[j] }\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc minimumDeviation(nums []int) int {    \\n    minimum := math.MaxInt64\\n    evens := &MaxHeap{[]int{}}\\n    heap.Init(evens)\\n\\n    for _, num := range nums {\\n        if num % 2 == 0 {\\n            heap.Push(evens, num)\\n            minimum = min(minimum, num)\\n        } else {\\n            heap.Push(evens, num * 2)\\n            minimum = min(minimum, num * 2)\\n        }\\n    }\\n    \\n    minDeviation := math.MaxInt64\\n    \\n    for evens.Len() > 0 {\\n        currentValue := heap.Pop(evens).(int)\\n        minDeviation = min(minDeviation, currentValue - minimum)\\n        \\n        if currentValue % 2 == 0 {\\n            heap.Push(evens, currentValue / 2)\\n            minimum = min(minimum, currentValue / 2)\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    return minDeviation\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041814,
                "title": "simple-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        //by default a max-heap\\n        priority_queue<int> pq;\\n        \\n        //keep track of minimjum element and result\\n        int mini = INT_MAX, res = INT_MAX;\\n        \\n        for(auto &x : nums) {\\n            x = x & 1 ? x * 2 : x;\\n            pq.push(x);\\n            mini = min(x, mini);\\n        }\\n        \\n        while(pq.top() % 2 == 0) {\\n            int x = pq.top();\\n            pq.pop();\\n            res = min(res, x - mini);\\n            mini = min(mini, x/2);\\n            pq.push(x/2);\\n        }\\n        \\n        return min(res, pq.top() - mini);\\n    }\\n};\\n\\n/* \\n\\nAlgorithm and thinking :\\n\\nThe main idea is to convert every element if odd to even (as only once an odd can be multiplied by 2 then becomes even)\\nNow the whole array has the maximum possible form of each element \\nNow calculate the minimum to find the deviation \\n\\nUse a priority queue (max-heap) and push all the elements in it\\nNow max-element if even can be reduced to smaller form but if odd it cannot and \\nthus if the priority queue contains odd number as its max-element then it is the final max-element used to calculate deviation along with the current min-element\\nWe do this in a loop till we encounter max-odd-element at the top of the priority queue by simultaneously keeping track of the minimum element and the resulting deviation\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        //by default a max-heap\\n        priority_queue<int> pq;\\n        \\n        //keep track of minimjum element and result\\n        int mini = INT_MAX, res = INT_MAX;\\n        \\n        for(auto &x : nums) {\\n            x = x & 1 ? x * 2 : x;\\n            pq.push(x);\\n            mini = min(x, mini);\\n        }\\n        \\n        while(pq.top() % 2 == 0) {\\n            int x = pq.top();\\n            pq.pop();\\n            res = min(res, x - mini);\\n            mini = min(mini, x/2);\\n            pq.push(x/2);\\n        }\\n        \\n        return min(res, pq.top() - mini);\\n    }\\n};\\n\\n/* \\n\\nAlgorithm and thinking :\\n\\nThe main idea is to convert every element if odd to even (as only once an odd can be multiplied by 2 then becomes even)\\nNow the whole array has the maximum possible form of each element \\nNow calculate the minimum to find the deviation \\n\\nUse a priority queue (max-heap) and push all the elements in it\\nNow max-element if even can be reduced to smaller form but if odd it cannot and \\nthus if the priority queue contains odd number as its max-element then it is the final max-element used to calculate deviation along with the current min-element\\nWe do this in a loop till we encounter max-odd-element at the top of the priority queue by simultaneously keeping track of the minimum element and the resulting deviation\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966548,
                "title": "c-solution-using-priority-queue",
                "content": "```\\nlass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        for(int& i : nums) {\\n            if(i & 1) {\\n                i *= 2;\\n            }\\n        }\\n        priority_queue<int> q;\\n        int small = *min_element(nums.begin(), nums.end());\\n        for(int i : nums)\\n            q.push(i);\\n        int ans = INT_MAX;\\n        while(1) {\\n            int top = q.top();\\n            q.pop();\\n            ans = min(ans, abs(top - small));\\n            if(top % 2 == 0) {\\n                top = top / 2;\\n                small = min(small, top);\\n                q.push(top);\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        for(int& i : nums) {\\n            if(i & 1) {\\n                i *= 2;\\n            }\\n        }\\n        priority_queue<int> q;\\n        int small = *min_element(nums.begin(), nums.end());\\n        for(int i : nums)\\n            q.push(i);\\n        int ans = INT_MAX;\\n        while(1) {\\n            int top = q.top();\\n            q.pop();\\n            ans = min(ans, abs(top - small));\\n            if(top % 2 == 0) {\\n                top = top / 2;\\n                small = min(small, top);\\n                q.push(top);\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961590,
                "title": "o-n-algorithm-c-196ms-beats-100",
                "content": "Analysis: https://github.com/hqztrue/LeetCodeSolutions/blob/master/1601-1700/1675.%20Minimize%20Deviation%20in%20Array.pdf\\np.s. a hard input that can make lots of accepted algorithms with running time O(n log n log U) Time Limit Exceeded: https://github.com/hqztrue/shared_materials/blob/master/tmp/LeetCode/1675.in\\n\\n```\\nconst int N=100005,W=32,inf=~0u>>2;\\nint b[N];\\nclass Solution {\\npublic:\\n\\tint minimumDeviation(vector<int>& a) {\\n\\t\\tint n=a.size(),ma=0,mi=inf;\\n\\t\\tint vmin[W+1],vmax[W+1],can[W+1];\\n\\t\\tfor (int i=0;i<=W;++i)vmin[i]=inf,vmax[i]=0,can[i]=1;\\n        for (int i=0;i<n;++i)b[i]=a[i]&1?a[i]*2:a[i];\\n\\t\\tfor (int i=0;i<n;++i)a[i]>>=__builtin_ctz(a[i]),ma=max(ma,a[i]);\\n\\t\\tint c=__builtin_clz(ma);\\n\\t\\tfor (int i=0;i<n;++i){\\n\\t\\t\\ta[i]<<=__builtin_clz(a[i])-c;\\n\\t\\t\\tif (a[i]>ma)a[i]>>=1;\\n            a[i]=min(a[i],b[i]);\\n\\t\\t\\tmi=min(mi,a[i]);\\n\\t\\t}\\n\\t\\tint ans=ma-mi;\\n\\t\\tfor (int i=0;i<n;++i){\\n\\t\\t\\tint j=a[i]==mi?32:__builtin_clz(a[i]-mi);\\n\\t\\t\\tvmin[j]=min(vmin[j],a[i]); vmax[j]=max(vmax[j],a[i]);\\n\\t\\t\\tif (a[i]*2>b[i])can[j]=0;\\n\\t\\t}\\n\\t\\tfor (int i=W,j,flag=can[W];;i=j,flag&=can[j]){\\n\\t\\t\\tfor (j=i-1;j&&!vmax[j];--j);\\n\\t\\t\\tif (!vmax[j]||!flag)break;\\n\\t\\t\\tans=min(ans,2*vmax[i]-vmin[j]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N=100005,W=32,inf=~0u>>2;\\nint b[N];\\nclass Solution {\\npublic:\\n\\tint minimumDeviation(vector<int>& a) {\\n\\t\\tint n=a.size(),ma=0,mi=inf;\\n\\t\\tint vmin[W+1],vmax[W+1],can[W+1];\\n\\t\\tfor (int i=0;i<=W;++i)vmin[i]=inf,vmax[i]=0,can[i]=1;\\n        for (int i=0;i<n;++i)b[i]=a[i]&1?a[i]*2:a[i];\\n\\t\\tfor (int i=0;i<n;++i)a[i]>>=__builtin_ctz(a[i]),ma=max(ma,a[i]);\\n\\t\\tint c=__builtin_clz(ma);\\n\\t\\tfor (int i=0;i<n;++i){\\n\\t\\t\\ta[i]<<=__builtin_clz(a[i])-c;\\n\\t\\t\\tif (a[i]>ma)a[i]>>=1;\\n            a[i]=min(a[i],b[i]);\\n\\t\\t\\tmi=min(mi,a[i]);\\n\\t\\t}\\n\\t\\tint ans=ma-mi;\\n\\t\\tfor (int i=0;i<n;++i){\\n\\t\\t\\tint j=a[i]==mi?32:__builtin_clz(a[i]-mi);\\n\\t\\t\\tvmin[j]=min(vmin[j],a[i]); vmax[j]=max(vmax[j],a[i]);\\n\\t\\t\\tif (a[i]*2>b[i])can[j]=0;\\n\\t\\t}\\n\\t\\tfor (int i=W,j,flag=can[W];;i=j,flag&=can[j]){\\n\\t\\t\\tfor (j=i-1;j&&!vmax[j];--j);\\n\\t\\t\\tif (!vmax[j]||!flag)break;\\n\\t\\t\\tans=min(ans,2*vmax[i]-vmin[j]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952852,
                "title": "c-priority-queue",
                "content": "for each element in list, insert max possible value after operations in priority queue (max heap).\\nNow remember min element of priority queue and result of current state will be difference in max and min element in heap. At each step remove the max element, if element is even insert element/2 in priority queue else break.\\n```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int x, y;\\n        int mn=INT_MAX;\\n        for (int i:nums){\\n            if (i&1) i*=2;\\n            pq.push(i);\\n            if (i<mn) mn=i;\\n        }\\n        int res=INT_MAX;\\n        while (true){\\n            x=pq.top();\\n            pq.pop();\\n            res=min(res, x-mn);\\n            if (x&1) break;\\n            x/=2;\\n            pq.push(x);\\n            if (x<mn) mn=x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int x, y;\\n        int mn=INT_MAX;\\n        for (int i:nums){\\n            if (i&1) i*=2;\\n            pq.push(i);\\n            if (i<mn) mn=i;\\n        }\\n        int res=INT_MAX;\\n        while (true){\\n            x=pq.top();\\n            pq.pop();\\n            res=min(res, x-mn);\\n            if (x&1) break;\\n            x/=2;\\n            pq.push(x);\\n            if (x<mn) mn=x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3226322,
                "title": "python-short-and-clean-2-approaches-priorityqueue-heap-orderedset-sortedlist",
                "content": "# Approach\\n1. Notice that an odd number, say `k`, can only be reduced to `k` or `k * 2`\\n\\n2. Let\\'s start off with `nums` where all odd numbers are reduced to even by multiplying with `2`.\\n    This essentially eliminates `rule of odds`, as all numbers are `even`.\\n    Note that this doesn\\'t affect the answer.\\n\\n3. The `min_deviation` right now is `max_value - min_value`.\\n\\n3. Take the largest number, say `m`, and apply the `even rule`, i.e `m // 2`. Update the `min_deviation` if it\\'s decreased.\\n\\n4. Now do the same with the current largest number.\\n\\n5. Keep doing this until the largest number `m` is not `even` anymore.\\n\\n6. To repeatedly fetch the largest number, modify it, put it back in sorted order. We can either use a `Heap / PriorityQueue` or `OrderedSet / SortedList`. Both solutions are shown below.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(m * n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`n is number of elements in nums`,\\n`m is the maximum value element in nums`.\\n\\n# Code\\nHeap / PriorityQueue solution:\\n```python\\nclass Solution:\\n    def minimumDeviation(self, nums: list[int]) -> int:\\n        hq = [-n * 2 if n % 2 else -n for n in nums]\\n        heapify(hq)\\n\\n        min_ = -min(hq, key=neg)\\n        min_deviation = -hq[0] - min_\\n\\n        while hq and hq[0] % 2 == 0:\\n            n = heappop(hq) // 2\\n            heappush(hq, n)\\n            min_ = min(min_, -n)\\n            min_deviation = min(min_deviation, - hq[0] - min_)\\n        \\n        return min_deviation\\n\\n\\n```\\nOrderedSet / SortedList solution:\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: list[int]) -> int:\\n        sl = SortedList(n * 2 if n % 2 else n for n in nums)\\n\\n        min_deviation = sl[-1] - sl[0]\\n        while sl[-1] % 2 == 0:\\n            sl.add(sl.pop() // 2)\\n            min_deviation = min(min_deviation, sl[-1] - sl[0])\\n        return min_deviation\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumDeviation(self, nums: list[int]) -> int:\\n        hq = [-n * 2 if n % 2 else -n for n in nums]\\n        heapify(hq)\\n\\n        min_ = -min(hq, key=neg)\\n        min_deviation = -hq[0] - min_\\n\\n        while hq and hq[0] % 2 == 0:\\n            n = heappop(hq) // 2\\n            heappush(hq, n)\\n            min_ = min(min_, -n)\\n            min_deviation = min(min_deviation, - hq[0] - min_)\\n        \\n        return min_deviation\\n\\n\\n```\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: list[int]) -> int:\\n        sl = SortedList(n * 2 if n % 2 else n for n in nums)\\n\\n        min_deviation = sl[-1] - sl[0]\\n        while sl[-1] % 2 == 0:\\n            sl.add(sl.pop() // 2)\\n            min_deviation = min(min_deviation, sl[-1] - sl[0])\\n        return min_deviation\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225856,
                "title": "short-concise-greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        for(int &i : nums) {\\n            if(i % 2) i *= 2;\\n        }\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        int mn = *min_element(nums.begin(), nums.end()), ans = 1e9;\\n\\n        while(pq.top() % 2 == 0) {\\n            int a = pq.top(); pq.pop();\\n            ans = min(ans, a - mn);\\n            mn = min(mn, a / 2);\\n            pq.push(a / 2);\\n        }\\n        ans = min(ans, pq.top() - mn);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        for(int &i : nums) {\\n            if(i % 2) i *= 2;\\n        }\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        int mn = *min_element(nums.begin(), nums.end()), ans = 1e9;\\n\\n        while(pq.top() % 2 == 0) {\\n            int a = pq.top(); pq.pop();\\n            ans = min(ans, a - mn);\\n            mn = min(mn, a / 2);\\n            pq.push(a / 2);\\n        }\\n        ans = min(ans, pq.top() - mn);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225594,
                "title": "heap-priority-queue",
                "content": "# Intuition & Approach\\nhttps://youtu.be/O5b8QIV2Gic\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int mn = INT_MAX;\\n        priority_queue<int> pq;\\n        \\n        for (int &num : nums) {\\n            if (num & 1)\\n                num <<= 1;\\n            \\n            mn = min(mn, num);\\n            pq.push(num);\\n        }\\n\\n        int res = INT_MAX;\\n        while (true) {\\n            int mx = pq.top();\\n            pq.pop();\\n\\n            res = min(res, mx - mn);\\n\\n            if (mx & 1)\\n                break;\\n            \\n            mn = min(mn, mx >> 1);\\n            pq.push(mx >> 1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int mn = INT_MAX;\\n        priority_queue<int> pq;\\n        \\n        for (int &num : nums) {\\n            if (num & 1)\\n                num <<= 1;\\n            \\n            mn = min(mn, num);\\n            pq.push(num);\\n        }\\n\\n        int res = INT_MAX;\\n        while (true) {\\n            int mx = pq.top();\\n            pq.pop();\\n\\n            res = min(res, mx - mn);\\n\\n            if (mx & 1)\\n                break;\\n            \\n            mn = min(mn, mx >> 1);\\n            pq.push(mx >> 1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225160,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int m = INT_MAX;\\n        for(int i=0; i < nums.size(); i++) {\\n            if(nums[i] % 2 == 0) {\\n                pq.push(nums[i]);\\n                m = min(m, nums[i]);\\n            }\\n            else{\\n                pq.push(nums[i]*2);\\n                m = min(m, nums[i]*2);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        while(!pq.empty()) {\\n            int top = pq.top();\\n            pq.pop();\\n            ans = min(ans,top-m);\\n            if(top % 2 != 0) {\\n                break;\\n            }\\n            m = min(m, top/2);\\n            pq.push(top/2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int m = INT_MAX;\\n        for(int i=0; i < nums.size(); i++) {\\n            if(nums[i] % 2 == 0) {\\n                pq.push(nums[i]);\\n                m = min(m, nums[i]);\\n            }\\n            else{\\n                pq.push(nums[i]*2);\\n                m = min(m, nums[i]*2);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        while(!pq.empty()) {\\n            int top = pq.top();\\n            pq.pop();\\n            ans = min(ans,top-m);\\n            if(top % 2 != 0) {\\n                break;\\n            }\\n            m = min(m, top/2);\\n            pq.push(top/2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225119,
                "title": "o-nlogn-solution-with-approach",
                "content": "**1.We create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.**\\n\\n**2.We iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.**\\n\\n**3.We initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.**\\n\\n**4.Once we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer.**\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int min=Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num*=2;\\n            }\\n            pq.offer(num);\\n            min=Math.min(min,num);\\n        }\\n        int minDev=Integer.MAX_VALUE;\\n        while(pq.peek()%2==0){\\n            int max=pq.remove();\\n            int element=max/2;\\n            minDev=Math.min(minDev,max-min);\\n            min=Math.min(element,min);\\n            pq.offer(element);\\n        }\\n        return Math.min(minDev,pq.peek()-min);\\n    }\\n}\\n```\\n# **UPVOTING IS MUCH APPRECIATED**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int min=Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num*=2;\\n            }\\n            pq.offer(num);\\n            min=Math.min(min,num);\\n        }\\n        int minDev=Integer.MAX_VALUE;\\n        while(pq.peek()%2==0){\\n            int max=pq.remove();\\n            int element=max/2;\\n            minDev=Math.min(minDev,max-min);\\n            min=Math.min(element,min);\\n            pq.offer(element);\\n        }\\n        return Math.min(minDev,pq.peek()-min);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224674,
                "title": "scala-solution-using-priority-queue",
                "content": "# Intuition\\nTo Solve this Question Either All number has to be even or odd.\\n \\n\\n# Approach\\nAs Given in Question we can divide a even number by 2 and multiply an odd number by 2. \\nBut dividing an even number by 2 does not ensure an odd number ,but multiplying an odd number by 2 ensures always an even number.So we convert all numbers to even format.\\nThen we find the current diff.Now using a max_heap we update \\nour diff and pushing in max_heap ( heap_top/2).\\nWhen we encounter an odd number in we stop because this will the least number as odd number can be multiplied only. So our diff will only increase\\n\\n \\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nobject Solution {\\n    def minimumDeviation(nums: Array[Int]): Int = {\\n        \\n        import scala.collection.mutable.PriorityQueue \\n        // Max_heap\\n        val mx = new PriorityQueue[Int]()\\n        var x : Array[Int] = \\n        for (i <- nums )\\n           yield \\n              if( i%2 == 0) i\\n              else i*2\\n        for ( i <- x) mx+=i      \\n       // Vec is min element which we have\\n        var vec = x.reduceLeft(_ min _)\\n        // Initialising ans\\n        var ans = Int.MaxValue\\n       // head of queue ->largest element\\n        while( mx.head % 2 == 0){\\n            val xx = mx.dequeue \\n            ans = Math.min( ans, xx-vec)\\n            // we are trying to minimise our diff\\n            mx.enqueue(xx/2)\\n            vec = Math.min( vec, xx/2)\\n        }\\n        Math.min(ans, mx.dequeue-vec);\\n\\n        \\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minimumDeviation(nums: Array[Int]): Int = {\\n        \\n        import scala.collection.mutable.PriorityQueue \\n        // Max_heap\\n        val mx = new PriorityQueue[Int]()\\n        var x : Array[Int] = \\n        for (i <- nums )\\n           yield \\n              if( i%2 == 0) i\\n              else i*2\\n        for ( i <- x) mx+=i      \\n       // Vec is min element which we have\\n        var vec = x.reduceLeft(_ min _)\\n        // Initialising ans\\n        var ans = Int.MaxValue\\n       // head of queue ->largest element\\n        while( mx.head % 2 == 0){\\n            val xx = mx.dequeue \\n            ans = Math.min( ans, xx-vec)\\n            // we are trying to minimise our diff\\n            mx.enqueue(xx/2)\\n            vec = Math.min( vec, xx/2)\\n        }\\n        Math.min(ans, mx.dequeue-vec);\\n\\n        \\n         \\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3223768,
                "title": "c-priority-queue-best-short-code-with-explaination-java-python-super-simple",
                "content": "# Intuition\\n![LeetCode_Sharing.png](https://assets.leetcode.com/users/images/ccf10325-417c-4184-90fc-5a1aeb69fc89_1677211887.514805.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is quite simple. We need to find max Deviation which is nothing but maxEle-minEle. \\nThis is too basic. We only need to minimize this deviation and we have infinite operations. So relax, think how you can decrease the max and increase the min. :)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplementation part is a bit tricky, but when we see the words min and max, we may think of something called HEAP. So lets build it!\\n1. We know that if ele is odd, we can multiply it by 2, and this will make the ele even. So lets push all ele in maxHeap, and if ele is odd, multiply by 2 and then push.\\n2. Make sure you also keep a track of the miniVal while pushing in heap\\n3. Now see the ele at top of heap, and calc the deviation i.e. `maxVal-minVal` do this and store minDev.\\n4. Divide maxVal by 2 and again push in heap\\n5. Here also keep track of minVal\\n6. Now if the maxVal comes out to be odd, then you need to break, as we cannot further divide it by 2 as odd num cannot produce whole num when divided by 2\\n7. Keep doing this and once we finish the loop, return minDev\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int>pq;\\n        int mini = INT_MAX;\\n        for(auto num : nums){\\n            if(num%2) num*=2;\\n            pq.push(num);\\n            mini = min(mini,num);\\n        }\\n        int minDev = INT_MAX;\\n        while(1){\\n            int maxVal = pq.top();\\n            pq.pop();\\n            minDev = min(maxVal-mini,minDev);\\n            if(maxVal%2) break;\\n            maxVal/=2;\\n            mini = min(mini,maxVal);\\n            pq.push(maxVal);\\n        }\\n        return minDev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int>pq;\\n        int mini = INT_MAX;\\n        for(auto num : nums){\\n            if(num%2) num*=2;\\n            pq.push(num);\\n            mini = min(mini,num);\\n        }\\n        int minDev = INT_MAX;\\n        while(1){\\n            int maxVal = pq.top();\\n            pq.pop();\\n            minDev = min(maxVal-mini,minDev);\\n            if(maxVal%2) break;\\n            maxVal/=2;\\n            mini = min(mini,maxVal);\\n            pq.push(maxVal);\\n        }\\n        return minDev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223759,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set=new TreeSet<>();\\n        \\n        for(int i:nums){\\n            if(i%2==1) i*=2;\\n            set.add(i);\\n        }\\n        \\n        int diff=Integer.MAX_VALUE;\\n        while(true){\\n            int max=set.last();\\n            int min=set.first();\\n            diff=Math.min(diff,max-min);\\n            if(max%2==0){\\n                set.remove(max);\\n                set.add(max/2);\\n            }else {\\n                break;\\n            }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set=new TreeSet<>();\\n        \\n        for(int i:nums){\\n            if(i%2==1) i*=2;\\n            set.add(i);\\n        }\\n        \\n        int diff=Integer.MAX_VALUE;\\n        while(true){\\n            int max=set.last();\\n            int min=set.first();\\n            diff=Math.min(diff,max-min);\\n            if(max%2==0){\\n                set.remove(max);\\n                set.add(max/2);\\n            }else {\\n                break;\\n            }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223737,
                "title": "easy-c-solution-using-max-heap",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Did all odd no. as even by multiplying by 2 and pushing all to priority queue.\\n2. performing while operation until top element dont become odd,\\n3. In while we taking top element as `max` then popping it out and pushing its half back in and also checking for `ans` by seeing if `max-min` is less then `ans` or not and also same for `min` if `num/2` gets less then `min` making it `min`.\\n4. In end returning `ans`.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int mn=INT_MAX,ans=INT_MAX,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==1) nums[i]*=2;\\n            mn = min(mn,nums[i]);\\n            pq.push(nums[i]);\\n        }\\n        while(pq.top()%2==0){\\n            int mx = pq.top();\\n            pq.pop();\\n            ans = min(ans,mx-mn);\\n            mn = min(mn,mx/2);\\n            pq.push(mx/2);\\n        }\\n        ans=min(ans,pq.top()-mn);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int mn=INT_MAX,ans=INT_MAX,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==1) nums[i]*=2;\\n            mn = min(mn,nums[i]);\\n            pq.push(nums[i]);\\n        }\\n        while(pq.top()%2==0){\\n            int mx = pq.top();\\n            pq.pop();\\n            ans = min(ans,mx-mn);\\n            mn = min(mn,mx/2);\\n            pq.push(mx/2);\\n        }\\n        ans=min(ans,pq.top()-mn);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223681,
                "title": "rust-greedy-solution",
                "content": "\\n```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let mut min = i32::MAX;\\n        let mut max_heap: BinaryHeap<i32> = BinaryHeap::new();\\n\\n        for mut num in nums.into_iter() {\\n            if num % 2 == 1 {\\n                num = num * 2;\\n            }\\n\\n            min = min.min(num);\\n            max_heap.push(num);\\n        }\\n\\n        let mut res = max_heap.peek().unwrap() - min;\\n\\n        while max_heap.peek().unwrap() % 2 == 0 {\\n            let num = max_heap.pop().unwrap() / 2;\\n            max_heap.push(num);\\n\\n            min = min.min(num);\\n            res = res.min(max_heap.peek().unwrap() - min);\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let mut min = i32::MAX;\\n        let mut max_heap: BinaryHeap<i32> = BinaryHeap::new();\\n\\n        for mut num in nums.into_iter() {\\n            if num % 2 == 1 {\\n                num = num * 2;\\n            }\\n\\n            min = min.min(num);\\n            max_heap.push(num);\\n        }\\n\\n        let mut res = max_heap.peek().unwrap() - min;\\n\\n        while max_heap.peek().unwrap() % 2 == 0 {\\n            let num = max_heap.pop().unwrap() / 2;\\n            max_heap.push(num);\\n\\n            min = min.min(num);\\n            res = res.min(max_heap.peek().unwrap() - min);\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3223535,
                "title": "short-clean-explained-java-solution",
                "content": "# Approach\\n1. Make all odd numbers even by multiplying them by 2.\\n2. Add all numbers to a priority queue (max heap).\\n3. Keep track of the minimum value in the array (mi) as elements are added to the priority queue.\\n4. Repeatedly perform the following steps until an odd element is encountered:\\n    - Remove the maximum element (num) from the priority queue.\\n    - Calculate the new deviation as the difference between the maximum element and the minimum element (mi).\\n    - Update the minimum deviation if the new deviation is less than the current deviation.\\n    - If the maximum element is even, divide it by 2 and add it back to the priority queue.\\n    - Update the minimum element (mi) if necessary.\\n5. The final deviation is the minimum deviation that the array can have after performing some number of operations.\\n# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        int mi = Integer.MAX_VALUE, res = Integer.MAX_VALUE;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int num: nums){\\n            if(num % 2 == 1)    num *= 2;\\n            pq.add(num);\\n            mi = Math.min(mi,num);\\n        }\\n        while(true){\\n            int num = pq.poll();\\n            res = Math.min(res, num - mi);\\n            if(num % 2 == 1) break;\\n            mi = Math.min(mi,num/2);\\n            pq.add(num/2);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        int mi = Integer.MAX_VALUE, res = Integer.MAX_VALUE;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int num: nums){\\n            if(num % 2 == 1)    num *= 2;\\n            pq.add(num);\\n            mi = Math.min(mi,num);\\n        }\\n        while(true){\\n            int num = pq.poll();\\n            res = Math.min(res, num - mi);\\n            if(num % 2 == 1) break;\\n            mi = Math.min(mi,num/2);\\n            pq.add(num/2);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223451,
                "title": "daily-leetcoding-challenge-february-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1785424,
                "title": "c-solution",
                "content": "this data structure is called SMMH\\nhope this is help for you\\n```\\n#define SWAP(x, y) (x ^= y ^= x ^= y)\\n#define MIN(a,b) ((a<b)? a:b)\\n\\nvoid checkBigger(int *h, int posi){\\n    for(int comp; posi >= 4; posi = comp){\\n        comp = (posi>>2<<1)+1;\\n        if(h[posi] > h[comp])\\n            SWAP(h[posi], h[comp]);\\n        else break;\\n    }\\n}\\nvoid checkSmaller(int *h, int posi){\\n    for(int comp; posi >= 4; posi = comp){\\n        comp = posi>>2<<1;\\n        if(h[posi] < h[comp])\\n            SWAP(h[posi], h[comp]);\\n        else break;\\n    }\\n}\\nvoid insert(int *h, int top, int data){\\n    h[top] = data;\\n    if(!(top&1)){           //is left\\n        if(h[top] > h[top>>1])\\n            checkBigger(h,top);\\n        else\\n            checkSmaller(h,top);\\n    }\\n    else{                       //is right\\n        if(h[top] < h[top-1]){\\n            SWAP(h[top], h[top-1]);\\n            checkSmaller(h,top-1);\\n        }\\n        else  checkBigger(h,top);\\n    }\\n}\\n\\nvoid deleteMax(int *h, int *top){\\n    h[3] = h[(*top)--];\\n    int par = 3, chi = 5;\\n    while (chi <= (*top)){\\n        if(chi+2 <= (*top) && h[chi+2]>h[chi])  //\\u9078\\u8F03\\u5927\\u7684\\n            chi += 2;\\n        if(h[chi] > h[par]){\\n            SWAP(h[chi], h[par]);\\n            par = chi;\\n            chi = (chi<<1)-1;\\n        }\\n        else break;\\n    }\\n    if(h[par] < h[par-1])\\n        SWAP(h[par], h[par-1]);\\n}\\n\\nint minimumDeviation(int* nums, int size){\\n    int h[size+2], top=1, ans;  //heap, the h[0] & h[1] is no number\\n    for(int i=0; i<size; i++){\\n        if(nums[i]&1)    //is odd\\n            nums[i] <<= 1;\\n        insert(h, ++top, nums[i]);\\n    }\\n    \\n    ans = h[3]-h[2];\\n    while (!(h[3]&1)){    //while the max value is even \\n        int t = h[3]>>1;\\n        deleteMax(h, &top);\\n        insert(h, ++top, t);\\n        ans = MIN(ans, h[3]-h[2]);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define SWAP(x, y) (x ^= y ^= x ^= y)\\n#define MIN(a,b) ((a<b)? a:b)\\n\\nvoid checkBigger(int *h, int posi){\\n    for(int comp; posi >= 4; posi = comp){\\n        comp = (posi>>2<<1)+1;\\n        if(h[posi] > h[comp])\\n            SWAP(h[posi], h[comp]);\\n        else break;\\n    }\\n}\\nvoid checkSmaller(int *h, int posi){\\n    for(int comp; posi >= 4; posi = comp){\\n        comp = posi>>2<<1;\\n        if(h[posi] < h[comp])\\n            SWAP(h[posi], h[comp]);\\n        else break;\\n    }\\n}\\nvoid insert(int *h, int top, int data){\\n    h[top] = data;\\n    if(!(top&1)){           //is left\\n        if(h[top] > h[top>>1])\\n            checkBigger(h,top);\\n        else\\n            checkSmaller(h,top);\\n    }\\n    else{                       //is right\\n        if(h[top] < h[top-1]){\\n            SWAP(h[top], h[top-1]);\\n            checkSmaller(h,top-1);\\n        }\\n        else  checkBigger(h,top);\\n    }\\n}\\n\\nvoid deleteMax(int *h, int *top){\\n    h[3] = h[(*top)--];\\n    int par = 3, chi = 5;\\n    while (chi <= (*top)){\\n        if(chi+2 <= (*top) && h[chi+2]>h[chi])  //\\u9078\\u8F03\\u5927\\u7684\\n            chi += 2;\\n        if(h[chi] > h[par]){\\n            SWAP(h[chi], h[par]);\\n            par = chi;\\n            chi = (chi<<1)-1;\\n        }\\n        else break;\\n    }\\n    if(h[par] < h[par-1])\\n        SWAP(h[par], h[par-1]);\\n}\\n\\nint minimumDeviation(int* nums, int size){\\n    int h[size+2], top=1, ans;  //heap, the h[0] & h[1] is no number\\n    for(int i=0; i<size; i++){\\n        if(nums[i]&1)    //is odd\\n            nums[i] <<= 1;\\n        insert(h, ++top, nums[i]);\\n    }\\n    \\n    ans = h[3]-h[2];\\n    while (!(h[3]&1)){    //while the max value is even \\n        int t = h[3]>>1;\\n        deleteMax(h, &top);\\n        insert(h, ++top, t);\\n        ans = MIN(ans, h[3]-h[2]);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783912,
                "title": "javascript-with-explanation-easier-to-understand-custom-priority-queue",
                "content": "Ok, for this question, you are concerned about the spread between the smallest and largest values.\\n\\nYou have to keep in mind the rest of the values, because as you change the smallest or largest, one of the others could take its place.\\n\\nThe other languages have built in priority maps, however JS doesn\\'t so it\\'s a litle bit more of a challenge.  Infact I don\\'t see any JS explanations.\\n\\nSo, first, sort your initial array so you\\'ll have min and max values.\\n\\nFirst focus on the left side of the array, increasing odd elements and moving them forward if the value is now larger than its neighbor.  I simply used a linear loop, moving new (doubled) values to the right.  I could have used binary search to place it, as I did with max values, but it\\'s done less often, and wasnt necessary.\\n\\nIn the case of the max value, I do the same thing, divide even values by 2, and re-inserting them into the array.  Here I used a binary search for the index as doing a linear search resulted in a TLE.\\n\\nI also check the spread/deviation multiple places as the array keeps changing.  \\n\\n```\\nvar minimumDeviation = function(nums) {\\n  nums = nums.sort((a,b)=>a-b); \\n  const r=nums.length-1;\\n  let i, move, mid, left, right;\\n  let diff = nums[r] - nums[0];\\n  \\n  while(nums[0]%2) { //first work on increasing the left side of the array by doubling odd edge.\\n    nums[0] *=2; \\n    if (nums[0]>nums[1]) { //if new value is larger than parent, will need to reorder\\n      move = nums.shift();  //remove it from array\\n      i=0;\\n      while (nums[i]<move) i++; //find new place\\n      nums.splice(i,0,move); //insert back to array\\n    }\\n  }\\n  diff = Math.min(nums[r]-nums[0], diff);\\n    \\n  while(nums[r]%2==0) { //now focus on right edge of array, if even, divide by 2 \\n    nums[r] /=2;\\n    if (nums[r]<nums[r-1]) {//will need to reorder element into array\\n      move = nums.pop();  //remove\\n      left=0, right=r-1; \\n      while (left<right) {  // find new index via a binary search\\n        mid = (left+right) >>> 1;\\n        if (move>nums[mid])\\n          left=mid+1;\\n        else\\n          right=mid;\\n      }\\n      nums.splice(left,0,move);\\n    }\\n    diff = Math.min(nums[r]-nums[0], diff);\\n  }\\n  return Math.min(nums[r]-nums[0], diff); \\n};\\n```\\n\\nIf this explanation helped you in any way, please upvote so others can also find it.  thanks!",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar minimumDeviation = function(nums) {\\n  nums = nums.sort((a,b)=>a-b); \\n  const r=nums.length-1;\\n  let i, move, mid, left, right;\\n  let diff = nums[r] - nums[0];\\n  \\n  while(nums[0]%2) { //first work on increasing the left side of the array by doubling odd edge.\\n    nums[0] *=2; \\n    if (nums[0]>nums[1]) { //if new value is larger than parent, will need to reorder\\n      move = nums.shift();  //remove it from array\\n      i=0;\\n      while (nums[i]<move) i++; //find new place\\n      nums.splice(i,0,move); //insert back to array\\n    }\\n  }\\n  diff = Math.min(nums[r]-nums[0], diff);\\n    \\n  while(nums[r]%2==0) { //now focus on right edge of array, if even, divide by 2 \\n    nums[r] /=2;\\n    if (nums[r]<nums[r-1]) {//will need to reorder element into array\\n      move = nums.pop();  //remove\\n      left=0, right=r-1; \\n      while (left<right) {  // find new index via a binary search\\n        mid = (left+right) >>> 1;\\n        if (move>nums[mid])\\n          left=mid+1;\\n        else\\n          right=mid;\\n      }\\n      nums.splice(left,0,move);\\n    }\\n    diff = Math.min(nums[r]-nums[0], diff);\\n  }\\n  return Math.min(nums[r]-nums[0], diff); \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783030,
                "title": "javascript-solution-with-maxheap",
                "content": "Algorithm: \\nInitialize variables: maxHeap and min\\n\\nFirst, iterate over input array, we\\'ll take any odd number, and multiply it by two. We\\'ll also update the global min variable, and add every number (after transformation) to the maxHeap. O(n)\\n\\nSecond, while the maxHeap has elements in it, we\\'ll extract the max element from the maxHeap. We\\'ll compare that maxVaue with our globalMin value and calculate the currentDeviation. If this currentDeviation is lower that the globalDeviation, we update it. O(logn)\\n\\nNow, if this maxElement we extract from the maxHeap is even, we will divide it by two, update the min (if it is lower), and add it back to the heap. And keep repeating. O(logn)\\n\\nOtherwise, we have taken all the even elements in the heap, halved them, and can no longer process anything else so we break. \\nreturn minDeviation.\\n\\n```\\nvar minimumDeviation = function(nums) {\\n    let maxHeap = new MaxPriorityQueue();\\n    let min = Infinity;\\n    for(let num of nums){\\n        if(num % 2 === 1){ \\n            num *= 2;\\n        }\\n        min = Math.min(min, num); \\n        maxHeap.enqueue(num); \\n    }\\n    let minDeviation = Infinity;\\n    while(maxHeap.size()){\\n        let max = maxHeap.dequeue().element; \\n        let currDev = max-min; \\n        minDeviation = Math.min(minDeviation, currDev); \\n        if(max % 2 === 0){ \\n            max = max/2; \\n            min = Math.min(min, max); \\n            maxHeap.enqueue(max); \\n        } else {\\n            break; \\n        }\\n    }\\n    return minDeviation;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumDeviation = function(nums) {\\n    let maxHeap = new MaxPriorityQueue();\\n    let min = Infinity;\\n    for(let num of nums){\\n        if(num % 2 === 1){ \\n            num *= 2;\\n        }\\n        min = Math.min(min, num); \\n        maxHeap.enqueue(num); \\n    }\\n    let minDeviation = Infinity;\\n    while(maxHeap.size()){\\n        let max = maxHeap.dequeue().element; \\n        let currDev = max-min; \\n        minDeviation = Math.min(minDeviation, currDev); \\n        if(max % 2 === 0){ \\n            max = max/2; \\n            min = Math.min(min, max); \\n            maxHeap.enqueue(max); \\n        } else {\\n            break; \\n        }\\n    }\\n    return minDeviation;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1782906,
                "title": "c-solution-using-set-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int minimumDeviation(vector<int>& nums) {\\n        set<int> s;\\n        for (int i : nums)\\n            s.insert(i % 2 ? i * 2 : i);\\n        int res = *s.rbegin() - *s.begin();\\n        while (*s.rbegin() % 2 == 0) {\\n            s.insert(*s.rbegin() / 2);\\n            s.erase(*s.rbegin());\\n            res = min(res, *s.rbegin() - *s.begin());\\n        }\\n        return res;\\n    }\\n};\\n// if(find helpful) {\\ndo upvote(); // thanks\\n}",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumDeviation(vector<int>& nums) {\\n        set<int> s;\\n        for (int i : nums)\\n            s.insert(i % 2 ? i * 2 : i);\\n        int res = *s.rbegin() - *s.begin();\\n        while (*s.rbegin() % 2 == 0) {\\n            s.insert(*s.rbegin() / 2);\\n            s.erase(*s.rbegin());\\n            res = min(res, *s.rbegin() - *s.begin());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1782704,
                "title": "java-2-approaches",
                "content": "Approach 1:Using PriorityQueue\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>((a,b)->b-a);\\n        int min=Integer.MAX_VALUE;\\n        for(int i:nums){\\n            if(i%2==1) i*=2;\\n            min=Math.min(min,i);\\n            q.add(i);\\n        }\\n        int diff=Integer.MAX_VALUE;\\n        while(q.peek()%2==0){\\n            int max=q.remove();\\n            diff=Math.min(diff,max-min);\\n            min=Math.min(min,max/2);\\n            q.add(max/2);\\n        }\\n        \\n        return Math.min(diff,q.peek()-min);\\n    }\\n}\\n```\\n\\nApproach 2:Using TreeSet\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set=new TreeSet<>();\\n        \\n        for(int i:nums){\\n            if(i%2==1) i*=2;\\n            set.add(i);\\n        }\\n        \\n        int diff=Integer.MAX_VALUE;\\n        while(true){\\n            int max=set.last();\\n            int min=set.first();\\n            diff=Math.min(diff,max-min);\\n            if(max%2==0){\\n                set.remove(max);\\n                set.add(max/2);\\n            }else {\\n                break;\\n            }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>((a,b)->b-a);\\n        int min=Integer.MAX_VALUE;\\n        for(int i:nums){\\n            if(i%2==1) i*=2;\\n            min=Math.min(min,i);\\n            q.add(i);\\n        }\\n        int diff=Integer.MAX_VALUE;\\n        while(q.peek()%2==0){\\n            int max=q.remove();\\n            diff=Math.min(diff,max-min);\\n            min=Math.min(min,max/2);\\n            q.add(max/2);\\n        }\\n        \\n        return Math.min(diff,q.peek()-min);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set=new TreeSet<>();\\n        \\n        for(int i:nums){\\n            if(i%2==1) i*=2;\\n            set.add(i);\\n        }\\n        \\n        int diff=Integer.MAX_VALUE;\\n        while(true){\\n            int max=set.last();\\n            int min=set.first();\\n            diff=Math.min(diff,max-min);\\n            if(max%2==0){\\n                set.remove(max);\\n                set.add(max/2);\\n            }else {\\n                break;\\n            }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782649,
                "title": "c-using-set-12-lines-of-code-with-explanation",
                "content": "\\tclass Solution \\n\\t{\\n\\t\\tpublic:\\n\\n\\tint minimumDeviation(vector<int>& nums){\\n\\t\\n        // inorder to store element in sorted order using set\\n\\t\\tset<int>s;\\n        for(auto i:nums)\\n        {\\n            if(i%2==0)s.insert(i);\\n            else s.insert(i*2);\\n        }\\n        \\n        \\n        /*\\n        \\n        *s.rbegin() will give last element of set that is max\\n            and\\n        *s.begin() will give first element of set that will be minimum    \\n        \\n        */\\n        int maximum=*s.rbegin();\\n        int minimum=*s.begin();\\n        \\n        int diff=maximum-minimum;\\n        \\n        // now main functionality will be to reduce to find min deviation\\n        \\n        \\n        while(*s.rbegin() % 2 == 0)\\n        {\\n            //delete the max from set\\n            int temp=*s.rbegin();\\n            \\n            s.erase(temp);\\n            \\n            //divide max by 2 and push it back unless made odd\\n            s.insert(temp/2);\\n            //find diff again\\n            \\n             diff = min(diff, *s.rbegin() - *s.begin());\\n        }\\n        return diff;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution \\n\\t{\\n\\t\\tpublic:\\n\\n\\tint minimumDeviation(vector<int>& nums){\\n\\t\\n        // inorder to store element in sorted order using set\\n\\t\\tset<int>s;\\n        for(auto i:nums)\\n        {\\n            if(i%2==0)s.insert(i);\\n            else s.insert(i*2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1782328,
                "title": "easy-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n= nums.size();\\n        int mn=INT_MAX;\\n        int mx = INT_MIN;\\n        \\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2!=0){\\n                nums[i] *=2;\\n            }\\n            mn = min(nums[i],mn);\\n            mx =max(nums[i],mx);\\n            pq.push(nums[i]);\\n        }\\n        int min_deviation = mx-mn;\\n\\t\\t\\n        //hear in loop we are only trying to deal with max elements and trying to minimize them\\n         while((pq.top()) % 2 == 0)\\n        {\\n            int top = pq.top();\\n            pq.pop(); \\n\\t\\t\\t// popped the top element\\n            \\n            min_deviation = min(min_deviation, top - mn);\\n            top /= 2;\\n            mn = min(mn, top);  \\n\\t\\t\\t// updating min\\n            \\n\\t\\t\\tpq.push(top);   \\n\\t\\t\\t// pushing again the top as we have to minimize the max\\n        }\\n        \\n        min_deviation = min(min_deviation,pq.top()-mn);\\n        \\n        return min_deviation;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n= nums.size();\\n        int mn=INT_MAX;\\n        int mx = INT_MIN;\\n        \\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2!=0){\\n                nums[i] *=2;\\n            }\\n            mn = min(nums[i],mn);\\n            mx =max(nums[i],mx);\\n            pq.push(nums[i]);\\n        }\\n        int min_deviation = mx-mn;\\n\\t\\t\\n        //hear in loop we are only trying to deal with max elements and trying to minimize them\\n         while((pq.top()) % 2 == 0)\\n        {\\n            int top = pq.top();\\n            pq.pop(); \\n\\t\\t\\t// popped the top element\\n            \\n            min_deviation = min(min_deviation, top - mn);\\n            top /= 2;\\n            mn = min(mn, top);  \\n\\t\\t\\t// updating min\\n            \\n\\t\\t\\tpq.push(top);   \\n\\t\\t\\t// pushing again the top as we have to minimize the max\\n        }\\n        \\n        min_deviation = min(min_deviation,pq.top()-mn);\\n        \\n        return min_deviation;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782146,
                "title": "java-solution-with-explaination-maxheap",
                "content": "1.\\tMax deviation in an array can be obtained by just sorting the array and find the first and last element difference.\\n2.\\tThe catch here is that we can perform operations -> if num is odd* 2. And if number is even/2.\\n3.\\tBy using above operations we want to make max deviation as minimum as possible.\\n4.\\tNow, we can observe that if we multiply odd number by 2 it will become even. So, as a first step we can convert all odd number to even to eliminate one operation i.e. multiply by 2.\\n5.\\tTo maintain sorted data everytime after every divide operation we can make use of maxheap. ( we can use maxHeap to return max element of updated set and will keep track of min using 1 variable min)\\nAlgo->\\n1. iterate array and start adding element to maxheap. If number is odd add num* 2 heap else num directly. To calculate difference. Find the minimum element of the entire array also.\\n2. now,  iterate till heap is not empty.\\n3. inside loop. Get max element from heap and calculate diff=Math.min(diff,max-min). in this way we will maintain minimum diff everytime. Now if current element is even just add num/2 again into heap. And update min by checking if num/2 is less then current min.\\n4. the above loop will break if max received from heap.poll is odd itself. As we now know we cannot further decrease the max deviation if max element itself is odd.\\n5. return diff. \\n\\n```\\npublic int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1,o2)->o2-o1);\\n        int min = Integer.MAX_VALUE;\\n        int diff=min;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]%2==1) {\\n                nums[i]*=2;\\n            }\\n            maxHeap.add(nums[i]);\\n            min=Math.min(min,nums[i]);\\n        }\\n        \\n        while(!maxHeap.isEmpty()) {\\n            int max = maxHeap.poll();\\n            diff=Math.min(diff,max-min);\\n            if(max%2==1) {\\n                break;\\n            }\\n            maxHeap.add(max/2);\\n            min=Math.min(min,max/2);\\n        }\\n        return diff;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1,o2)->o2-o1);\\n        int min = Integer.MAX_VALUE;\\n        int diff=min;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]%2==1) {\\n                nums[i]*=2;\\n            }\\n            maxHeap.add(nums[i]);\\n            min=Math.min(min,nums[i]);\\n        }\\n        \\n        while(!maxHeap.isEmpty()) {\\n            int max = maxHeap.poll();\\n            diff=Math.min(diff,max-min);\\n            if(max%2==1) {\\n                break;\\n            }\\n            maxHeap.add(max/2);\\n            min=Math.min(min,max/2);\\n        }\\n        return diff;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1781732,
                "title": "c-simple-solution-using-priority-queue-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int>maxh;\\n\\t    int curMin = INT_MAX;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(nums[i]%2) nums[i]*=2;\\n            curMin = min(curMin,nums[i]);\\n            maxh.push(nums[i]);\\n        }\\n        int ans = maxh.top()-curMin;\\n        while(maxh.top()%2==0){\\n            int curMax = maxh.top();\\n            maxh.pop();\\n            maxh.push(curMax/2);\\n            curMin = min(curMin,curMax/2);\\n            ans = min(ans, maxh.top()-curMin);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int>maxh;\\n\\t    int curMin = INT_MAX;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(nums[i]%2) nums[i]*=2;\\n            curMin = min(curMin,nums[i]);\\n            maxh.push(nums[i]);\\n        }\\n        int ans = maxh.top()-curMin;\\n        while(maxh.top()%2==0){\\n            int curMax = maxh.top();\\n            maxh.pop();\\n            maxh.push(curMax/2);\\n            curMin = min(curMin,curMax/2);\\n            ans = min(ans, maxh.top()-curMin);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273341,
                "title": "o-n-time-o-1-memory-100ms-js-solution-with-detailed-explanation",
                "content": "The first thing to realize is that you can safely double every odd without changing the answer. This is because you can always just half them later. This reduces the problem to just halfing even numbers.\\n\\nFor example inputs of [16, 5, 3, 4], and [16, 10, 6, 4] will give the same answer guaranteed.\\n\\nThis new array has a max and a min. Let\\'s try to reduce the max as much as possible without reducing the min. To do this, let\\'s keep halfing every even number without ever reducing a number below that minimum\\n\\nFor example [16, 10, 6, 4] is reduced [4, 5, 6, 4]. **A candidate solution is 6 - 4 = 2**.\\n\\nWe may not be done yet. We reduced the max as much as possible in the previous step. Let\\'s reduce the min *as little as possible* in the next step. We can achieve this by halving the largest number(s).\\n\\nIn this case [4, 5, 6, 4] is reduced to [4, 5, 3, 4].\\n\\nNow we repeat the previous step.\\n\\nIts impossible to reduce the max without also reducing the min so [4, 5, 3, 4] remains [4, 5, 3, 4].\\n\\n**Another candidate solution is 5 - 3 = 2.**\\n\\nNow we attempt to reduce the min but the largest number is an odd number so there is no point in reducing the array further; it can only make things worse. We are done.\\n\\nThe final solution is the minimum of the candidates. min(2, 2) = **2**;\\n\\nFor N integers of size K, we at most half the N integers log(K) times. Since K is bounded to a 32bit integer. The **final time complexity is O(N)**. And we did the calculation with the original array so **O(1) extra memory**.\\n\\nCode:\\n```\\nvar minimumDeviation = function(nums) {\\n    \\n    // Double all odd number so that all numbers are even.\\n    // After this, we can focus on halfing numbers until we\\n    // find the optimal solution\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] % 2 === 1) {\\n            nums[i] *= 2\\n        }\\n    }\\n    \\n    let best = Infinity;\\n    let done = false\\n    while (!done) {\\n        // Reduce the array such that all the values are as close as possible\\n        // to the minimum value. This will become a candidate solution\\n        const min = Math.min(...nums);\\n        for (let i = 0; i < nums.length; i++) {\\n            while (nums[i] % 2 === 0 && nums[i] / 2 >= min) {\\n                nums[i] /= 2;\\n            }\\n        }\\n\\n        // Now let\\'s reduce the array by the smallest amount possible\\n        // This is achieved halving the largest number\\n        const max = Math.max(...nums);\\n        best = Math.min(best, max - min);\\n        done = true;\\n        for (let i = 0; i < nums.length; i++) {\\n            if (nums[i] === max && nums[i] % 2 === 0) {\\n                // if this code block is never hit, it means the maximum is odd \\n                // and we can no longer reduce the array; we are done.\\n                done = false;\\n                nums[i] /= 2;\\n            }    \\n        }\\n    }\\n    return best;\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nvar minimumDeviation = function(nums) {\\n    \\n    // Double all odd number so that all numbers are even.\\n    // After this, we can focus on halfing numbers until we\\n    // find the optimal solution\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] % 2 === 1) {\\n            nums[i] *= 2\\n        }\\n    }\\n    \\n    let best = Infinity;\\n    let done = false\\n    while (!done) {\\n        // Reduce the array such that all the values are as close as possible\\n        // to the minimum value. This will become a candidate solution\\n        const min = Math.min(...nums);\\n        for (let i = 0; i < nums.length; i++) {\\n            while (nums[i] % 2 === 0 && nums[i] / 2 >= min) {\\n                nums[i] /= 2;\\n            }\\n        }\\n\\n        // Now let\\'s reduce the array by the smallest amount possible\\n        // This is achieved halving the largest number\\n        const max = Math.max(...nums);\\n        best = Math.min(best, max - min);\\n        done = true;\\n        for (let i = 0; i < nums.length; i++) {\\n            if (nums[i] === max && nums[i] % 2 === 0) {\\n                // if this code block is never hit, it means the maximum is odd \\n                // and we can no longer reduce the array; we are done.\\n                done = false;\\n                nums[i] /= 2;\\n            }    \\n        }\\n    }\\n    return best;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1117169,
                "title": "java-treeset",
                "content": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 != 0) nums[i] *= 2;\\n            set.add(nums[i]);\\n        }\\n        if(set.size() == 1) return 0;\\n        int ans = Integer.MAX_VALUE;\\n        while(set.size() != 1) {\\n            int smallest = set.first();\\n            int highest = set.last();\\n            ans = Math.min(ans, highest - smallest);\\n            set.remove(highest);\\n            if(highest % 2 == 0) {\\n                if(highest /2 == smallest && set.size() == 1) return 0;\\n                set.add(highest/2);\\n            }else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 != 0) nums[i] *= 2;\\n            set.add(nums[i]);\\n        }\\n        if(set.size() == 1) return 0;\\n        int ans = Integer.MAX_VALUE;\\n        while(set.size() != 1) {\\n            int smallest = set.first();\\n            int highest = set.last();\\n            ans = Math.min(ans, highest - smallest);\\n            set.remove(highest);\\n            if(highest % 2 == 0) {\\n                if(highest /2 == smallest && set.size() == 1) return 0;\\n                set.add(highest/2);\\n            }else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042737,
                "title": "c-99-runtime-solution-with-details-o-n-log-n-log-m",
                "content": "If we double the odd values in `nums`, they will become even.\\n\\nBecause we are only allowed to halve even numbers, **any number that is even cannot become larger**.\\n\\nTherefore, by doubling the odd numbers once, we simplify things by eliminating one of the possible operations; we only need to focus on halving numbers from now on, as they\\'re all even.\\n\\nFrom this point on, we continuously halve the current largest number in `nums` until the largest number in `nums` is odd. While doing this, we store the lowest deviation we find along the way, so that we can return it.\\n\\n---\\n\\nAs explained, we will be continuously querying the current largest number in `nums` so that we can halve it. To avoid the `O(n)` cost of looping through `nums` each time, we can instead use a max-heap (`std::priority_queue`), where querying the largest number is an `O(1)` operation.\\n\\nThe trade-off, however, is that updating values in the heap is `O(log(n))`, rather than the `O(1)` we\\'re used to; this still ends up being faster than the alternative approach for this problem, though.\\n\\nDo note however, that the initial cost of turning our `nums` into a heap (_heapification_) is `O(n)`, which is less than the `O(n*log(n))` cost you might expect. [This is done by passing `nums` through `std::priority_queue`\\'s constructor](https://en.cppreference.com/w/cpp/container/priority_queue/priority_queue).\\n\\nThe following is an implementation of the above approach:\\n\\n```\\nclass Solution {\\npublic:\\n    auto minimumDeviation(vector<int>& nums) const -> int\\n    {\\n        for (int& x : nums)\\n            x *= (x % 2) + 1;\\n\\n        const auto [minIt, maxIt] = minmax_element(cbegin(nums), cend(nums));\\n        int minVal = *minIt\\n\\t\\tint result = *maxIt - minVal;\\n        priority_queue<int> heap(less<int>(), move(nums));\\n\\n        while (heap.top() % 2 == 0) {\\n            const int newVal = heap.top() / 2;\\n\\t\\t\\tconst int newMin = min(minVal, newVal);\\n            heap.pop();\\n            heap.push(newVal);\\n            if (result >= heap.top() - newMin) {\\n                minVal = newMin;\\n                result = heap.top() - newMin;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n\\nWhere `n` is `nums.size()`, and `m` is the max value in `nums` after the `for` loop at the top:\\n\\n**Time complexity**: `O(n*log(n)*log(m))`.\\n**Space complexity**: `O(n)` if including `nums`; `O(1)` otherwise. _(our `priority_queue` doesn\\'t allocate extra memory for storage, instead using the storage already allocated for `nums` thanks to `std::move(nums)`)_",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    auto minimumDeviation(vector<int>& nums) const -> int\\n    {\\n        for (int& x : nums)\\n            x *= (x % 2) + 1;\\n\\n        const auto [minIt, maxIt] = minmax_element(cbegin(nums), cend(nums));\\n        int minVal = *minIt\\n\\t\\tint result = *maxIt - minVal;\\n        priority_queue<int> heap(less<int>(), move(nums));\\n\\n        while (heap.top() % 2 == 0) {\\n            const int newVal = heap.top() / 2;\\n\\t\\t\\tconst int newMin = min(minVal, newVal);\\n            heap.pop();\\n            heap.push(newVal);\\n            if (result >= heap.top() - newMin) {\\n                minVal = newMin;\\n                result = heap.top() - newMin;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041971,
                "title": "minimize-deviation-in-array-python-with-priority-queue-heap",
                "content": "1. Create a max heap(negative min heap) of nums with maximum possible values.\\n2. In a loop, Keep track of minimum deviation:\\na. Pick the max(top) element from heap. Divide it by 2. If it\\'s greater than min, reduce it to lowest number greater than min.\\nb. Terminate the loop when the top element is odd,\\n\\nTime: Beats 97%, Memorry: Beats 34%\\n\\n```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = [-n*2  if n%2 else -n for n in set(nums)]\\n        heapify(heap)\\n\\n        min_n, max_n = -max(heap), -heap[0]\\n        min_dev = max_n - min_n\\n\\n        while max_n % 2 == 0:\\n            new_n = max_n // 2\\n            while new_n&1 == 0 and new_n>>1 > min_n:\\n                new_n >>= 1\\n\\n            heapreplace(heap, -new_n)\\n            min_n, max_n = min(new_n, min_n), -heap[0]\\n            min_dev = min(max_n - min_n, min_dev)\\n        return min_dev\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = [-n*2  if n%2 else -n for n in set(nums)]\\n        heapify(heap)\\n\\n        min_n, max_n = -max(heap), -heap[0]\\n        min_dev = max_n - min_n\\n\\n        while max_n % 2 == 0:\\n            new_n = max_n // 2\\n            while new_n&1 == 0 and new_n>>1 > min_n:\\n                new_n >>= 1\\n\\n            heapreplace(heap, -new_n)\\n            min_n, max_n = min(new_n, min_n), -heap[0]\\n            min_dev = min(max_n - min_n, min_dev)\\n        return min_dev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041832,
                "title": "kotlin-implementation",
                "content": "```\\nclass Solution {\\n  fun minimumDeviation(nums: IntArray): Int {\\n    val s = TreeSet<Int>()\\n    for (i in nums) {\\n      s.add(i)\\n    }\\n\\n    var best = s.last() - s.first()\\n\\n    while (isOdd(s.first())) {\\n      s.add(s.pollFirst() * 2)\\n      best = Math.min(best, s.last() - s.first())\\n    }\\n\\n    while (isEven(s.last())) {\\n      s.add(s.pollLast() / 2)\\n      best = Math.min(best, s.last() - s.first())\\n    }\\n\\n    return best\\n  }\\n\\n  private fun isEven(x: Int): Boolean {\\n    return (x % 2) == 0\\n  }\\n\\n  private fun isOdd(x: Int): Boolean {\\n    return (x % 2) == 1\\n  }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n  fun minimumDeviation(nums: IntArray): Int {\\n    val s = TreeSet<Int>()\\n    for (i in nums) {\\n      s.add(i)\\n    }\\n\\n    var best = s.last() - s.first()\\n\\n    while (isOdd(s.first())) {\\n      s.add(s.pollFirst() * 2)\\n      best = Math.min(best, s.last() - s.first())\\n    }\\n\\n    while (isEven(s.last())) {\\n      s.add(s.pollLast() / 2)\\n      best = Math.min(best, s.last() - s.first())\\n    }\\n\\n    return best\\n  }\\n\\n  private fun isEven(x: Int): Boolean {\\n    return (x % 2) == 0\\n  }\\n\\n  private fun isOdd(x: Int): Boolean {\\n    return (x % 2) == 1\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994062,
                "title": "c-sortedset",
                "content": "```\\npublic class Solution\\n{\\n  public int MinimumDeviation(int[] nums)\\n  {\\n    var arr = new SortedSet<(int n, int max)>();\\n\\n    // reduce arr elements to their min values\\n    // also saving max possible values\\n    for (var i = 0; i < nums.Length; i++)\\n    {\\n      var value = nums[i];\\n\\n      if (value % 2 == 0)\\n      {\\n        while (value % 2 == 0)\\n          value /= 2;\\n\\n        arr.Add((value, nums[i]));\\n      }\\n      else\\n      {\\n        arr.Add((value, nums[i] * 2));\\n      }\\n    }\\n\\n    var ans = arr.Max.n - arr.Min.n;\\n\\n    // try increment minimum element\\n    while (true)\\n    {\\n      if (arr.Min.n == arr.Min.max)\\n        break;\\n\\n      var min = arr.Min.n;\\n      min <<= 1;\\n\\n      var el = arr.Min;\\n      arr.Remove(el);\\n      arr.Add((n : min, max: el.max));\\n\\n      ans = Math.Min(ans, arr.Max.n - arr.Min.n);\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n  public int MinimumDeviation(int[] nums)\\n  {\\n    var arr = new SortedSet<(int n, int max)>();\\n\\n    // reduce arr elements to their min values\\n    // also saving max possible values\\n    for (var i = 0; i < nums.Length; i++)\\n    {\\n      var value = nums[i];\\n\\n      if (value % 2 == 0)\\n      {\\n        while (value % 2 == 0)\\n          value /= 2;\\n\\n        arr.Add((value, nums[i]));\\n      }\\n      else\\n      {\\n        arr.Add((value, nums[i] * 2));\\n      }\\n    }\\n\\n    var ans = arr.Max.n - arr.Min.n;\\n\\n    // try increment minimum element\\n    while (true)\\n    {\\n      if (arr.Min.n == arr.Min.max)\\n        break;\\n\\n      var min = arr.Min.n;\\n      min <<= 1;\\n\\n      var el = arr.Min;\\n      arr.Remove(el);\\n      arr.Add((n : min, max: el.max));\\n\\n      ans = Math.Min(ans, arr.Max.n - arr.Min.n);\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965043,
                "title": "python3",
                "content": "\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        # convert all numbers to even and put into max heap\\n        pq = [-x * 2 if x % 2 == 1 else -x for x in nums]\\n        heapify(pq)  # now pq is max heap (with negative values)\\n\\n        min_n = -max(pq)  # negative max is min of original values\\n        dev = -pq[0] - min_n # current deviation is max - min\\n\\n        # while we can still divide the max element by 2\\n        while pq[0] % 2 == 0:\\n            x = heappop(pq)  # take the max value\\n            half_x = x // 2  # divide by 2\\n            heappush(pq, half_x)  # put it back\\n            min_n = min(min_n, -half_x)  # update min\\n            dev = min(dev, -pq[0] - min_n) \\n\\n        return dev\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop, heapify\\n\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        # convert all numbers to even and put into max heap\\n        pq = [-x * 2 if x % 2 == 1 else -x for x in nums]\\n        heapify(pq)  # now pq is max heap (with negative values)\\n\\n        min_n = -max(pq)  # negative max is min of original values\\n        dev = -pq[0] - min_n # current deviation is max - min\\n\\n        # while we can still divide the max element by 2\\n        while pq[0] % 2 == 0:\\n            x = heappop(pq)  # take the max value\\n            half_x = x // 2  # divide by 2\\n            heappush(pq, half_x)  # put it back\\n            min_n = min(min_n, -half_x)  # update min\\n            dev = min(dev, -pq[0] - min_n) \\n\\n        return dev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953113,
                "title": "c-solution-with-priority-queue-with-comments",
                "content": "```\\nint minimumDeviation(vector<int>& nums) \\n{\\n\\tint result=2147483647,minimum=2147483647,maximum=-2147483648,n=nums.size();\\n\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n\\t//sort from small to large by smallest number (eg. first element of each pair should be odd)\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tif(nums[i]%2==0)\\n\\t\\t{\\n\\t\\t\\tint original=nums[i];\\n\\t\\t\\twhile(nums[i]%2==0)\\n\\t\\t\\t\\tnums[i]>>=1;\\n\\t\\t\\tq.push({nums[i],original}); //{13,52} if original nums[i]=52\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tq.push({nums[i],nums[i]<<1}); //{13,26} if original nums[i]=13\\n\\n\\t\\tmaximum=max(maximum,nums[i]);\\n\\t\\tminimum=min(minimum,nums[i]);\\n\\t}\\n\\tresult=maximum-minimum;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tpair<int,int> p=q.top();\\n\\t\\tq.pop();\\n\\t\\tif(p.first==p.second) //the minimum can no longer be smaller\\n\\t\\t\\treturn min(result,maximum-p.first);\\n\\n\\t\\tresult=min(result,maximum-p.first); //update the minimum possible deviation\\n\\t\\tp.first<<=1; //update the minimum number of the pair\\n\\t\\tq.push(p);\\n\\t\\tmaximum=max(maximum,p.first); //update the maximum (because p.first is part of the current sets, so maximum should be updated as p.first being updated)\\n\\t}\\n\\treturn -1; //will not reach this statement\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeviation(vector<int>& nums) \\n{\\n\\tint result=2147483647,minimum=2147483647,maximum=-2147483648,n=nums.size();\\n\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n\\t//sort from small to large by smallest number (eg. first element of each pair should be odd)\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tif(nums[i]%2==0)\\n\\t\\t{\\n\\t\\t\\tint original=nums[i];\\n\\t\\t\\twhile(nums[i]%2==0)\\n\\t\\t\\t\\tnums[i]>>=1;\\n\\t\\t\\tq.push({nums[i],original}); //{13,52} if original nums[i]=52\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tq.push({nums[i],nums[i]<<1}); //{13,26} if original nums[i]=13\\n\\n\\t\\tmaximum=max(maximum,nums[i]);\\n\\t\\tminimum=min(minimum,nums[i]);\\n\\t}\\n\\tresult=maximum-minimum;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tpair<int,int> p=q.top();\\n\\t\\tq.pop();\\n\\t\\tif(p.first==p.second) //the minimum can no longer be smaller\\n\\t\\t\\treturn min(result,maximum-p.first);\\n\\n\\t\\tresult=min(result,maximum-p.first); //update the minimum possible deviation\\n\\t\\tp.first<<=1; //update the minimum number of the pair\\n\\t\\tq.push(p);\\n\\t\\tmaximum=max(maximum,p.first); //update the maximum (because p.first is part of the current sets, so maximum should be updated as p.first being updated)\\n\\t}\\n\\treturn -1; //will not reach this statement\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033140,
                "title": "unique-treeset-solution",
                "content": "we will start by making every number even in the array\\n\\nthen we will add those numbers in the array\\n\\nnow we will start to compare ther min and max in the treeset\\n\\nand start dividing the max by 2 (since even numbers are supposed to be divided by 2)\\n\\nonce we cannot make the max any smaller, we stop from there\\n\\nhope you understood\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        return util2(nums);\\n    }\\n    // TreeSet solution\\n    public int util2(int arr[]) {\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for (int i : arr) {\\n            if (i % 2 == 0) {\\n                ts.add(i);\\n            } else {\\n                ts.add(i * 2);\\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        while (true) {\\n            int max = ts.last();\\n            int min = ts.first();\\n            ans = Math.min(ans, (max - min));\\n            if (max % 2 != 0) {\\n                return ans;\\n            } else {\\n                ts.remove(max);\\n                max /= 2;\\n                ts.add(max);\\n            }\\n        }\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\xAF\\n",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        return util2(nums);\\n    }\\n    // TreeSet solution\\n    public int util2(int arr[]) {\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for (int i : arr) {\\n            if (i % 2 == 0) {\\n                ts.add(i);\\n            } else {\\n                ts.add(i * 2);\\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        while (true) {\\n            int max = ts.last();\\n            int min = ts.first();\\n            ans = Math.min(ans, (max - min));\\n            if (max % 2 != 0) {\\n                return ans;\\n            } else {\\n                ts.remove(max);\\n                max /= 2;\\n                ts.add(max);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230639,
                "title": "100-solution-explained",
                "content": "# Step by Step Explanation\\nCheck out this video where I have explained the problem statement, intuition behind the soln and code along with Time and Space complexity.\\n\\nhttps://youtu.be/G14YPVZDrgc\\n\\n# Code\\n```\\n//Steps:\\n//1. Make all the odd numbers into even, by multiply 2\\n//2. Calcuate the devation\\n//3. Divide the largest number by 2 and than re-calcuate the devation\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n\\n        //1. Make all the odd numbers into even, by multiply 2\\n        for(int i = 0; i< nums.size(); i++){\\n            if(nums[i]%2!=0)\\n                nums[i] = nums[i] * 2;\\n            mini = min (mini, nums[i]);\\n            maxi = max (maxi, nums[i]);\\n        }\\n\\n        int deviation = maxi - mini; \\n        priority_queue<int> pq;\\n\\n        for(auto x: nums)\\n            pq.push(x);\\n\\n        while(pq.top()%2==0){\\n            int maxi = pq.top();\\n            pq.pop();\\n            deviation = min(deviation, maxi - mini);\\n\\n            int newNum = maxi/2;\\n            pq.push(newNum);\\n            mini = min (mini, newNum);\\n        }\\n\\n        deviation = min(deviation, pq.top() - mini);\\n        return deviation;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//Steps:\\n//1. Make all the odd numbers into even, by multiply 2\\n//2. Calcuate the devation\\n//3. Divide the largest number by 2 and than re-calcuate the devation\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n\\n        //1. Make all the odd numbers into even, by multiply 2\\n        for(int i = 0; i< nums.size(); i++){\\n            if(nums[i]%2!=0)\\n                nums[i] = nums[i] * 2;\\n            mini = min (mini, nums[i]);\\n            maxi = max (maxi, nums[i]);\\n        }\\n\\n        int deviation = maxi - mini; \\n        priority_queue<int> pq;\\n\\n        for(auto x: nums)\\n            pq.push(x);\\n\\n        while(pq.top()%2==0){\\n            int maxi = pq.top();\\n            pq.pop();\\n            deviation = min(deviation, maxi - mini);\\n\\n            int newNum = maxi/2;\\n            pq.push(newNum);\\n            mini = min (mini, newNum);\\n        }\\n\\n        deviation = min(deviation, pq.top() - mini);\\n        return deviation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226633,
                "title": "scala-solution-using-sortedset",
                "content": "# Intuition\\nIntuition is...Think that what will give you the best answer if you converted all your array element to even or odd.\\nSo, if I converted all my array element to odd and sort it then calculate the deviation (max element,min element ) then it will give you the answer but not always right because you have to minimise you deviation.So we can convert all our array element to even.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to convert our odd array element to even so that whole array become even and then sort the array.Deviation is (Max element - Min element) so store that difference to any variable(res) and then you need to minimize that deviation but do not forget the condition of Deviation(max element - min element).So for minimization you can do another operation (maximum element)/2 and put that element to your array and delete the maximum element from the array.Then again sort the updated array and minimize you difference. Do the same process until your largest element is even and then break the loop because if your largest element is odd then you cannot do any further operations to minimize your ans. \\n\\nHere instead of array you can use extra space O(n) priority queue or SortedSet so that it will sort automatically.\\n\\nIn my solution I am using sortedSet(In scala Set will not sort automaticaly you need to use SortedSet.)\\n\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport scala.collection.mutable.SortedSet\\nobject Solution {\\n    def minimumDeviation(nums: Array[Int]): Int = {\\n        //Creation of Sortedset\\n        var s:SortedSet[Int]=SortedSet()\\n        for(i<-nums)\\n        yield\\n            if (i%2==1) //converting all odd elemnt to even\\n                s+=i*2      //storing elements to Set\\n            else s+=i\\n\\n        var res=s.last-s.head; //Max deviation Calculation\\n        while(s.last%2==0)   //until you largest element is even\\n        {\\n            \\n            s+=s.last/2       //even element by 2 to reduse the answer\\n            s-=s.last          //deletion largest element \\n            res=Math.min(res,s.last-s.head) //Minimizing the difference\\n            // println(s)\\n\\n        }\\n        return res; //required answer\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.mutable.SortedSet\\nobject Solution {\\n    def minimumDeviation(nums: Array[Int]): Int = {\\n        //Creation of Sortedset\\n        var s:SortedSet[Int]=SortedSet()\\n        for(i<-nums)\\n        yield\\n            if (i%2==1) //converting all odd elemnt to even\\n                s+=i*2      //storing elements to Set\\n            else s+=i\\n\\n        var res=s.last-s.head; //Max deviation Calculation\\n        while(s.last%2==0)   //until you largest element is even\\n        {\\n            \\n            s+=s.last/2       //even element by 2 to reduse the answer\\n            s-=s.last          //deletion largest element \\n            res=Math.min(res,s.last-s.head) //Minimizing the difference\\n            // println(s)\\n\\n        }\\n        return res; //required answer\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3226226,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n    int res = INT_MAX, min_n = INT_MAX;\\n    priority_queue<int> pq;\\n    for (auto n : nums) {\\n        n = n % 2 ? n * 2 : n;\\n        pq.push(n);\\n        min_n = min(min_n, n); \\n    }\\n    while (pq.top() % 2 == 0) {\\n        res = min(res, pq.top() - min_n);\\n        min_n = min(min_n, pq.top() / 2);\\n        pq.push(pq.top() / 2);\\n        pq.pop();\\n    }\\n    return min(res, pq.top() - min_n);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n    int res = INT_MAX, min_n = INT_MAX;\\n    priority_queue<int> pq;\\n    for (auto n : nums) {\\n        n = n % 2 ? n * 2 : n;\\n        pq.push(n);\\n        min_n = min(min_n, n); \\n    }\\n    while (pq.top() % 2 == 0) {\\n        res = min(res, pq.top() - min_n);\\n        min_n = min(min_n, pq.top() / 2);\\n        pq.push(pq.top() / 2);\\n        pq.pop();\\n    }\\n    return min(res, pq.top() - min_n);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226009,
                "title": "minimum-deviation-in-array-c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we have two operation:\\n1. Multiply odd number\\n2. Divide even number \\nIn 1. we think that multiplying the number will increase the number always and will never decrease the number, Similarly in 2. divide will decrease the number always never increase so from here we conclude that we have have to make all numebr even so that we get the minimum deviation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the array completely even, by multiplying odd numbers by 2 and then find the max and the min number in the array.\\nAs deviation is difference of max and min.\\nAlso put all the numbers into the maxheap(priority_queue).\\n\\nAfter this untill the maximum number of array become odd we have to run the loop , divide the top element i.e. the maximum number by 2 of maxheap and update the minmum number also.\\n\\nThen return the ans;\\n\\n# Complexity\\n- Time complexity: O(nlogn) iterating once to complete array to make odd number even.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) as we created priority queue which will take all the inputs of array size n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<int> pq;\\n        int maxi = INT_MIN, mini = INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            //Converting odd to even\\n            if(nums[i]%2 != 0)\\n            nums[i] *=2;\\n            \\n            maxi = max(maxi, nums[i]); //Maximum\\n            mini = min(mini, nums[i]); //Minimum\\n            pq.push(nums[i]);\\n        }\\n\\n        int ans = maxi - mini;\\n\\n        while(pq.top()%2 == 0)\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n\\n            ans = min(ans, top - mini); //Update ans everytime to get minimum deviaton.\\n\\n            top /= 2;\\n            pq.push(top);\\n            mini = min(mini, top);\\n        }\\n\\n        ans = min(ans, pq.top() - mini);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<int> pq;\\n        int maxi = INT_MIN, mini = INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            //Converting odd to even\\n            if(nums[i]%2 != 0)\\n            nums[i] *=2;\\n            \\n            maxi = max(maxi, nums[i]); //Maximum\\n            mini = min(mini, nums[i]); //Minimum\\n            pq.push(nums[i]);\\n        }\\n\\n        int ans = maxi - mini;\\n\\n        while(pq.top()%2 == 0)\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n\\n            ans = min(ans, top - mini); //Update ans everytime to get minimum deviaton.\\n\\n            top /= 2;\\n            pq.push(top);\\n            mini = min(mini, top);\\n        }\\n\\n        ans = min(ans, pq.top() - mini);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225998,
                "title": "bad-practices-long-no-max-heap-here-javascript-not-optimized-dont-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- lower max -> lift min\\n- Lift min -> lower max\\n- special cases:\\n  - all evens -> keep divide to 2 until find odd number\\n  - all odds -> lift min \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet onlyMin = (map) => {\\n    let minDeviation = Number.MAX_SAFE_INTEGER;\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    while(min%2!==0) {\\n        delete map[min];\\n        map[min*2] = 1;\\n        sortedArr = Object.keys(map);\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n    }\\n    return minDeviation;\\n}\\n\\nlet onlyMax = (map) => {\\n    let minDeviation = Number.MAX_SAFE_INTEGER;\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    while(max%2===0) {\\n        delete map[max];\\n        map[max/2] = 1;\\n        sortedArr = Object.keys(map);\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n    }\\n    return minDeviation;\\n}\\n\\nlet minThenMax = (map) => {\\n    let minDeviation = Number.MAX_SAFE_INTEGER;\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    let bpMap = null;\\n    while(min%2!==0) {\\n        delete map[min];\\n        map[min*2] = 1;\\n        sortedArr = Object.keys(map);\\n        if(min > sortedArr) bpMap = {...map};\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n    }\\n    map = bpMap || map;\\n    while(max%2===0) {\\n        delete map[max];\\n        map[max/2] = 1;\\n        sortedArr = Object.keys(map);\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n        // console.log(min, max)\\n    }\\n    return minDeviation;\\n}\\nlet maxThenMin = (map) => {\\n    let minDeviation = Number.MAX_SAFE_INTEGER;\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    let bpMap = null;\\n    while(max%2===0) {\\n        delete map[max];\\n        map[max/2] = 1;\\n        sortedArr = Object.keys(map);\\n        if(max < sortedArr[sortedArr.length-1]) bpMap = {...map};\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n        // console.log(min, max)\\n    }\\n    // console.log(minDeviation)\\n    map = bpMap || map;\\n    \\n    while(min%2!==0) {\\n        delete map[min];\\n        map[min*2] = 1;\\n        sortedArr = Object.keys(map);\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n    }\\n    return minDeviation;\\n}\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDeviation = function(nums) {\\n    let map = [];\\n    let alreadyUpper = true;\\n    let alreadyLower = true;\\n    for(let n of nums) {\\n        if(n%2===0) alreadyLower = false;\\n        else alreadyUpper = false;\\n        map[n] = 1;\\n    }\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    let minDeviation = max-min;\\n    // console.log(sortedArr.length)\\n    while(alreadyUpper) {\\n        for(let n of sortedArr) {\\n            delete map[n];\\n            map[n/2] = 1;\\n            n = n/2;\\n            if(n%2 !== 0) alreadyUpper = false;\\n        }\\n        sortedArr = Object.keys(map);\\n    }\\n    if(alreadyLower) return Math.min(minDeviation, onlyMin({...map}))\\n    // console.log(nums.length);\\n    // console.log(sortedArr.slice(0,2000))\\n    // console.log(sortedArr.slice(49900))\\n    // console.log(minDeviation)\\n    minDeviation = Math.min(minDeviation, minThenMax({...map}))\\n    minDeviation = Math.min(minDeviation, maxThenMin({...map}))\\n    return minDeviation;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet onlyMin = (map) => {\\n    let minDeviation = Number.MAX_SAFE_INTEGER;\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    while(min%2!==0) {\\n        delete map[min];\\n        map[min*2] = 1;\\n        sortedArr = Object.keys(map);\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n    }\\n    return minDeviation;\\n}\\n\\nlet onlyMax = (map) => {\\n    let minDeviation = Number.MAX_SAFE_INTEGER;\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    while(max%2===0) {\\n        delete map[max];\\n        map[max/2] = 1;\\n        sortedArr = Object.keys(map);\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n    }\\n    return minDeviation;\\n}\\n\\nlet minThenMax = (map) => {\\n    let minDeviation = Number.MAX_SAFE_INTEGER;\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    let bpMap = null;\\n    while(min%2!==0) {\\n        delete map[min];\\n        map[min*2] = 1;\\n        sortedArr = Object.keys(map);\\n        if(min > sortedArr) bpMap = {...map};\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n    }\\n    map = bpMap || map;\\n    while(max%2===0) {\\n        delete map[max];\\n        map[max/2] = 1;\\n        sortedArr = Object.keys(map);\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n        // console.log(min, max)\\n    }\\n    return minDeviation;\\n}\\nlet maxThenMin = (map) => {\\n    let minDeviation = Number.MAX_SAFE_INTEGER;\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    let bpMap = null;\\n    while(max%2===0) {\\n        delete map[max];\\n        map[max/2] = 1;\\n        sortedArr = Object.keys(map);\\n        if(max < sortedArr[sortedArr.length-1]) bpMap = {...map};\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n        // console.log(min, max)\\n    }\\n    // console.log(minDeviation)\\n    map = bpMap || map;\\n    \\n    while(min%2!==0) {\\n        delete map[min];\\n        map[min*2] = 1;\\n        sortedArr = Object.keys(map);\\n        min = sortedArr[0];\\n        max = sortedArr[sortedArr.length-1];\\n        minDeviation = Math.min(max-min, minDeviation);\\n    }\\n    return minDeviation;\\n}\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDeviation = function(nums) {\\n    let map = [];\\n    let alreadyUpper = true;\\n    let alreadyLower = true;\\n    for(let n of nums) {\\n        if(n%2===0) alreadyLower = false;\\n        else alreadyUpper = false;\\n        map[n] = 1;\\n    }\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    let minDeviation = max-min;\\n    // console.log(sortedArr.length)\\n    while(alreadyUpper) {\\n        for(let n of sortedArr) {\\n            delete map[n];\\n            map[n/2] = 1;\\n            n = n/2;\\n            if(n%2 !== 0) alreadyUpper = false;\\n        }\\n        sortedArr = Object.keys(map);\\n    }\\n    if(alreadyLower) return Math.min(minDeviation, onlyMin({...map}))\\n    // console.log(nums.length);\\n    // console.log(sortedArr.slice(0,2000))\\n    // console.log(sortedArr.slice(49900))\\n    // console.log(minDeviation)\\n    minDeviation = Math.min(minDeviation, minThenMax({...map}))\\n    minDeviation = Math.min(minDeviation, maxThenMin({...map}))\\n    return minDeviation;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3225969,
                "title": "java-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n        public int minimumDeviation(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        int n = A.length, mi = Integer.MAX_VALUE, res = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            if (a % 2 == 1) a *= 2;\\n            pq.add(-a);\\n            mi = Math.min(mi, a);\\n        }\\n        while (true) {\\n            int a = -pq.poll();\\n            res = Math.min(res, a - mi);\\n            if (a % 2 == 1) break;\\n            mi = Math.min(mi, a / 2);\\n            pq.add(-a / 2);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int minimumDeviation(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        int n = A.length, mi = Integer.MAX_VALUE, res = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            if (a % 2 == 1) a *= 2;\\n            pq.add(-a);\\n            mi = Math.min(mi, a);\\n        }\\n        while (true) {\\n            int a = -pq.poll();\\n            res = Math.min(res, a - mi);\\n            if (a % 2 == 1) break;\\n            mi = Math.min(mi, a / 2);\\n            pq.add(-a / 2);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225951,
                "title": "easy-solution-for-absolute-beginners-who-has-basic-concept-of-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncreate a set and take the min deviation from it\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\neasily explained in the code\\n\\n# Complexity\\n- Time complexity: O(nlog n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        //create a set st\\n        set<int> st;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            // if the element is odd, multiply it by 2 and feed it in set\\n            if(nums[i] % 2!=0)\\n            nums[i] = nums[i] * 2;\\n            st.insert(nums[i]);\\n        }\\n// st.rbegin = max value, st.begin = min value\\n        int minDev = *st.rbegin() - *st.begin();\\n        // while max value in set is even\\n        while(*st.rbegin() % 2 == 0)\\n        {\\n            // remove the max value from set\\n            int temp = *st.rbegin();\\n            st.erase(temp);\\n            // divide it by 2\\n            temp = temp/2;\\n            // then feed it in set\\n            st.insert(temp);\\n            // put min deviation in minDev\\n            minDev = min(minDev, *st.rbegin() - *st.begin());\\n        }\\n        // return it\\n        return minDev;\\n    }\\n};\\n\\n```\\n\\nIF YOU LIKE IT PLEASE UPVOTE\\uD83D\\uDE0A\\uD83D\\uDC4D\\uD83E\\uDDE1",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        //create a set st\\n        set<int> st;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            // if the element is odd, multiply it by 2 and feed it in set\\n            if(nums[i] % 2!=0)\\n            nums[i] = nums[i] * 2;\\n            st.insert(nums[i]);\\n        }\\n// st.rbegin = max value, st.begin = min value\\n        int minDev = *st.rbegin() - *st.begin();\\n        // while max value in set is even\\n        while(*st.rbegin() % 2 == 0)\\n        {\\n            // remove the max value from set\\n            int temp = *st.rbegin();\\n            st.erase(temp);\\n            // divide it by 2\\n            temp = temp/2;\\n            // then feed it in set\\n            st.insert(temp);\\n            // put min deviation in minDev\\n            minDev = min(minDev, *st.rbegin() - *st.begin());\\n        }\\n        // return it\\n        return minDev;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225808,
                "title": "c-priority-queue-heap-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int m = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                pq.push(nums[i]);\\n                m = min(m,nums[i]);\\n            }\\n            else{\\n                pq.push(nums[i]*2);\\n                m = min(m,nums[i]*2);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        while(!pq.empty()){\\n            int top = pq.top();\\n            pq.pop();\\n            ans = min(ans,top-m);\\n            if(top%2!=0){\\n                break;\\n            }\\n            m = min(m,top/2);\\n            pq.push(top/2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int m = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                pq.push(nums[i]);\\n                m = min(m,nums[i]);\\n            }\\n            else{\\n                pq.push(nums[i]*2);\\n                m = min(m,nums[i]*2);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        while(!pq.empty()){\\n            int top = pq.top();\\n            pq.pop();\\n            ans = min(ans,top-m);\\n            if(top%2!=0){\\n                break;\\n            }\\n            m = min(m,top/2);\\n            pq.push(top/2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225646,
                "title": "c-ts-o-n-log-mn-time-o-1-space-without-data-structure",
                "content": "\\nI see many solutions using a heap (or priority queue) and their time complexity is actually $O(n\\\\log(m)\\\\log(n))$ where $m$ is the size of `nums[i]`.\\nHere I\\'m going to share a theoretically faster solution.\\n\\n# Intuition \\nIf our final array has only even numbers, we can always divide them by 2 to also half the deviation. Thus, our final array always has an odd number. (Though not in our test cases, there is another way to deal with arrays that contain 0.)\\nAssuming $x$ is an odd number in our final array, there will not be any even numbers $\\\\geq 2x$ in our final array because we always divide them to have smaller deviation. By dividing those numbers in advanced, we reduce the time complexity from $O(\\\\log(m)\\\\log(n))$ to $O(\\\\log(m))$. \\nThe rest is just like other heap solutions, but now we are sure to have $O(n)$ iterations rather than $O(n \\\\log(m))$ because we have $x$ and every number is $<2x$.\\n\\n# Complexity\\n- Time complexity: $O(n\\\\log(mn))$\\n\\n- Space complexity: $O(1)$\\n\\n(assuming heap sort)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        // Step 1: shift right until odd and find the maximum (simulation)\\n        int maxOdd = 0;\\n        for (int n : nums) {\\n            while ((n & 1) == 0) n >>= 1;\\n            if (n > maxOdd) maxOdd = n;\\n        }\\n\\n        // Step 2: shift left every odd nums\\n        // Step 3: shift right until it will be less than {maxOdd}\\n        for (int i = 0; i < nums.size(); i++) {\\n            if ((nums[i] & 1)) nums[i] <<= 1;        \\n            while ((nums[i] & 1) == 0) {\\n                if (nums[i] >> 1 < maxOdd) break;\\n                nums[i] >>= 1;\\n            }\\n        }\\n\\n        // Step 4: sort\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Step 5: brute force every possible answer (only shift right)\\n        int i = nums.size() - 1;\\n        int ans = nums[i] - nums[0];\\n        while (1) {\\n            int max = nums[i--];\\n            if (max & 1) break;\\n            max >>= 1;\\n            int min = nums[0] < max ? nums[0] : max;\\n            int delta = nums[i] - min;\\n            if (delta < ans) ans = delta;\\n        }    \\n        return ans;\\n    }\\n};\\n```\\n```typescript []\\nfunction minimumDeviation (nums: number[]): number {\\n    let maxOdd = 0\\n    nums.forEach(v => {\\n        while ((v & 1) === 0) v >>= 1\\n        maxOdd = Math.max(v, maxOdd)\\n    })\\n    nums.forEach((v, i) => {\\n        if ((nums[i] & 1) === 1) nums[i] <<= 1\\n        while ((nums[i] & 1) === 0) {\\n            if (nums[i] >> 1 < maxOdd) break \\n            nums[i] >>= 1\\n        }\\n    })\\n    nums.sort((a, b) => a - b)\\n    let ans = nums.at(-1) - nums.at(0)\\n    while (true) {\\n        const max = nums.pop()\\n        if ((max & 1) === 1) break\\n        const min = Math.min(nums.at(0), max >> 1)\\n        ans = Math.min(ans, nums.at(-1) - min)\\n    }    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        // Step 1: shift right until odd and find the maximum (simulation)\\n        int maxOdd = 0;\\n        for (int n : nums) {\\n            while ((n & 1) == 0) n >>= 1;\\n            if (n > maxOdd) maxOdd = n;\\n        }\\n\\n        // Step 2: shift left every odd nums\\n        // Step 3: shift right until it will be less than {maxOdd}\\n        for (int i = 0; i < nums.size(); i++) {\\n            if ((nums[i] & 1)) nums[i] <<= 1;        \\n            while ((nums[i] & 1) == 0) {\\n                if (nums[i] >> 1 < maxOdd) break;\\n                nums[i] >>= 1;\\n            }\\n        }\\n\\n        // Step 4: sort\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Step 5: brute force every possible answer (only shift right)\\n        int i = nums.size() - 1;\\n        int ans = nums[i] - nums[0];\\n        while (1) {\\n            int max = nums[i--];\\n            if (max & 1) break;\\n            max >>= 1;\\n            int min = nums[0] < max ? nums[0] : max;\\n            int delta = nums[i] - min;\\n            if (delta < ans) ans = delta;\\n        }    \\n        return ans;\\n    }\\n};\\n```\n```typescript []\\nfunction minimumDeviation (nums: number[]): number {\\n    let maxOdd = 0\\n    nums.forEach(v => {\\n        while ((v & 1) === 0) v >>= 1\\n        maxOdd = Math.max(v, maxOdd)\\n    })\\n    nums.forEach((v, i) => {\\n        if ((nums[i] & 1) === 1) nums[i] <<= 1\\n        while ((nums[i] & 1) === 0) {\\n            if (nums[i] >> 1 < maxOdd) break \\n            nums[i] >>= 1\\n        }\\n    })\\n    nums.sort((a, b) => a - b)\\n    let ans = nums.at(-1) - nums.at(0)\\n    while (true) {\\n        const max = nums.pop()\\n        if ((max & 1) === 1) break\\n        const min = Math.min(nums.at(0), max >> 1)\\n        ans = Math.min(ans, nums.at(-1) - min)\\n    }    \\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225623,
                "title": "easy-python-pq-solution",
                "content": "# **PLEASE UPVOTE :)**\\n# Code\\n```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap=[]\\n        mx=[]\\n        for i in nums:\\n            if i&1:\\n                # heapq.heappush(heap,i*2)\\n                heapq.heappush(mx,-i*2)\\n            else:\\n                # heapq.heappush(heap,i)\\n                heapq.heappush(mx,-i)\\n        # print(mx)\\n        mnn=-max(mx)\\n        diff=float(\\'inf\\')\\n        while(len(nums)==len(mx)):\\n            # mn=heapq.heappop(heap)\\n            mxx=-heapq.heappop(mx)\\n            diff=min(diff,mxx-mnn)\\n            if mxx%2==0:\\n                mnn=min(mxx//2,mnn)\\n                heapq.heappush(mx,-mxx//2)\\n            else:\\n                break\\n            # print(mx,diff,mnn)\\n        return diff\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap=[]\\n        mx=[]\\n        for i in nums:\\n            if i&1:\\n                # heapq.heappush(heap,i*2)\\n                heapq.heappush(mx,-i*2)\\n            else:\\n                # heapq.heappush(heap,i)\\n                heapq.heappush(mx,-i)\\n        # print(mx)\\n        mnn=-max(mx)\\n        diff=float(\\'inf\\')\\n        while(len(nums)==len(mx)):\\n            # mn=heapq.heappop(heap)\\n            mxx=-heapq.heappop(mx)\\n            diff=min(diff,mxx-mnn)\\n            if mxx%2==0:\\n                mnn=min(mxx//2,mnn)\\n                heapq.heappush(mx,-mxx//2)\\n            else:\\n                break\\n            # print(mx,diff,mnn)\\n        return diff\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225611,
                "title": "c-most-efficient-solution-using-heap-data-structure-max-heap-priority-queue-code-quality",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<int> maxHeap;\\n        int mini = INT_MAX;\\n        int maxy;\\n        int diff = INT_MAX;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] % 2 == 1) nums[i] *= 2;\\n            mini = min(mini, nums[i]);\\n            maxHeap.push(nums[i]);\\n        }\\n        while (maxHeap.top() % 2 != 1) {\\n            maxy = maxHeap.top();\\n            maxHeap.pop();\\n            diff = min(diff, maxy - mini);\\n            maxy = maxy / 2;\\n            maxHeap.push(maxy);\\n            mini = min(maxy, mini);\\n        }\\n        diff = min(diff, maxHeap.top()-mini);\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<int> maxHeap;\\n        int mini = INT_MAX;\\n        int maxy;\\n        int diff = INT_MAX;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] % 2 == 1) nums[i] *= 2;\\n            mini = min(mini, nums[i]);\\n            maxHeap.push(nums[i]);\\n        }\\n        while (maxHeap.top() % 2 != 1) {\\n            maxy = maxHeap.top();\\n            maxHeap.pop();\\n            diff = min(diff, maxy - mini);\\n            maxy = maxy / 2;\\n            maxHeap.push(maxy);\\n            mini = min(maxy, mini);\\n        }\\n        diff = min(diff, maxHeap.top()-mini);\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225531,
                "title": "c-max-heap-easy-to-understand-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq; //declare a maxheap\\n        int mini=INT_MAX;\\n        for(int it:nums)\\n        {\\n            if(it%2==1)  //if element is odd make it even and push in max heap\\n                it*=2;\\n            mini=min(it,mini); //calculate the minimum of all elements\\n            pq.push(it);\\n        }\\n       \\n        int diff=INT_MAX;\\n        while(pq.top()%2==0)//perform until top of max heap is even\\n        {\\n            int t=pq.top();\\n            pq.pop();\\n            diff=min(diff,t-mini);\\n            mini=min(mini,t/2);\\n            pq.push(t/2);\\n        }\\n        \\n        return min(diff,pq.top()-mini);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq; //declare a maxheap\\n        int mini=INT_MAX;\\n        for(int it:nums)\\n        {\\n            if(it%2==1)  //if element is odd make it even and push in max heap\\n                it*=2;\\n            mini=min(it,mini); //calculate the minimum of all elements\\n            pq.push(it);\\n        }\\n       \\n        int diff=INT_MAX;\\n        while(pq.top()%2==0)//perform until top of max heap is even\\n        {\\n            int t=pq.top();\\n            pq.pop();\\n            diff=min(diff,t-mini);\\n            mini=min(mini,t/2);\\n            pq.push(t/2);\\n        }\\n        \\n        return min(diff,pq.top()-mini);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225523,
                "title": "python-easy-to-understand-max-heap",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n###### Create a `Max_Heap` having maximum possible value for each element. Repeatedly pop the `top` (max element) of the heap and divide it by 2 until the `top` of the heap is even and update the minimum deviation for each step.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        maxHeap = [-x*2 if x % 2 != 0 else -x for x in nums]\\n        heapify(maxHeap)\\n        ans, minItem = maxsize, -max(maxHeap)\\n        while maxHeap[0] % 2 == 0:\\n            maxItem = -heappop(maxHeap)\\n            ans = min(ans, maxItem - minItem)\\n            maxItem //= 2\\n            minItem = min(minItem, maxItem)\\n            heappush(maxHeap, -maxItem)\\n        ans = min(ans, -maxHeap[0] - minItem)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        maxHeap = [-x*2 if x % 2 != 0 else -x for x in nums]\\n        heapify(maxHeap)\\n        ans, minItem = maxsize, -max(maxHeap)\\n        while maxHeap[0] % 2 == 0:\\n            maxItem = -heappop(maxHeap)\\n            ans = min(ans, maxItem - minItem)\\n            maxItem //= 2\\n            minItem = min(minItem, maxItem)\\n            heappush(maxHeap, -maxItem)\\n        ans = min(ans, -maxHeap[0] - minItem)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225506,
                "title": "bring-odd-number-to-even-and-even-number-to-odd-inorder-to-normalize-it",
                "content": "so idea is to understand that we can only increase odd number until it becomes even and we can only decrease even number until it becomes odd. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& a) {\\n        \\n        int mn = INT_MAX;\\n        priority_queue<int> pq;\\n        int ans = INT_MAX;\\n        int mx = INT_MIN;\\n        for(auto i: a)\\n        {\\n            if(i%2)\\n                i*=2;\\n            pq.push(i);\\n            mx = max(mx,i);\\n            mn = min(mn,i);\\n        }\\n        \\n        ans = mx-mn;\\n        // cout<<ans<<endl;\\n        while(pq.top()%2==0)\\n        {\\n            int val = pq.top();\\n            \\n            ans = min(ans, val-mn);\\n            \\n            pq.pop();\\n            val/=2;\\n            pq.push(val);\\n            \\n            mn = min(mn,val);\\n            \\n            \\n        }\\n        \\n        mx = pq.top();\\n//         while(!pq.empty())\\n//         {\\n//             mn = min(mn,pq.top());\\n//             pq.pop();\\n//         }\\n                \\n        ans =min(ans, mx-mn);\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& a) {\\n        \\n        int mn = INT_MAX;\\n        priority_queue<int> pq;\\n        int ans = INT_MAX;\\n        int mx = INT_MIN;\\n        for(auto i: a)\\n        {\\n            if(i%2)\\n                i*=2;\\n            pq.push(i);\\n            mx = max(mx,i);\\n            mn = min(mn,i);\\n        }\\n        \\n        ans = mx-mn;\\n        // cout<<ans<<endl;\\n        while(pq.top()%2==0)\\n        {\\n            int val = pq.top();\\n            \\n            ans = min(ans, val-mn);\\n            \\n            pq.pop();\\n            val/=2;\\n            pq.push(val);\\n            \\n            mn = min(mn,val);\\n            \\n            \\n        }\\n        \\n        mx = pq.top();\\n//         while(!pq.empty())\\n//         {\\n//             mn = min(mn,pq.top());\\n//             pq.pop();\\n//         }\\n                \\n        ans =min(ans, mx-mn);\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3225462,
                "title": "simple-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n=nums.size();\\n        priority_queue<int>q;\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2!=0){\\n                nums[i]*=2;\\n            }\\n            q.push(nums[i]);\\n            mini=min(mini,nums[i]);\\n        }\\n        int deviation=INT_MAX;\\n        while(true){\\n            \\n            if(q.top()%2==0){\\n                int x=q.top();\\n                q.pop();\\n                x=x/2;\\n                if(x<mini) mini=x;\\n                q.push(x);\\n            }\\n            deviation=min(deviation,q.top()-mini);\\n            if(q.top()%2!=0) break;\\n        }\\n        return deviation;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n=nums.size();\\n        priority_queue<int>q;\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2!=0){\\n                nums[i]*=2;\\n            }\\n            q.push(nums[i]);\\n            mini=min(mini,nums[i]);\\n        }\\n        int deviation=INT_MAX;\\n        while(true){\\n            \\n            if(q.top()%2==0){\\n                int x=q.top();\\n                q.pop();\\n                x=x/2;\\n                if(x<mini) mini=x;\\n                q.push(x);\\n            }\\n            deviation=min(deviation,q.top()-mini);\\n            if(q.top()%2!=0) break;\\n        }\\n        return deviation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225416,
                "title": "priority-queue-c-easy-solution-rahul-mistry",
                "content": "\\n# Code\\n```\\n//Please upvote if it helps\\n// AUTHOR :: RAHUL MISTRY\\n// DATE   :: 24/02/2023\\n\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n = nums.size();\\n        int mx = INT_MIN, mn = INT_MAX;\\n        \\n        // Increasing all elements to as maximum as it can and tranck the minimum,\\n        // number and also the resutl\\n        for(int i = 0; i<n; ++i)\\n        {\\n            if((nums[i]%2) != 0)    // multiplication by 2 if nums[i] is odd\\n                nums[i] *= 2;   // maximising all odd numbers\\n\\n        \\n            mx = max(mx,nums[i]);\\n            mn = min(mn,nums[i]);\\n        }\\n        \\n        int min_deviation = mx - mn;\\n        \\n        priority_queue<int> pq;\\n        // Inserting into Priority queue (Max Heap) and try to decrease as much we can\\n        for(int i = 0; i<n; ++i)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        \\n        while((pq.top()) % 2 == 0)\\n        {\\n            int top = pq.top();\\n            pq.pop(); // popped the top element\\n            \\n            min_deviation = min(min_deviation, top - mn);\\n            top /= 2;\\n            mn = min(mn, top);  // updating min\\n            pq.push(top);   // pushing again the top as we have to minimize the max\\n        }\\n        \\n        min_deviation = min(min_deviation, pq.top() - mn);\\n        \\n        // we are returning mx - mn\\n        \\n        return min_deviation;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Please upvote if it helps\\n// AUTHOR :: RAHUL MISTRY\\n// DATE   :: 24/02/2023\\n\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int n = nums.size();\\n        int mx = INT_MIN, mn = INT_MAX;\\n        \\n        // Increasing all elements to as maximum as it can and tranck the minimum,\\n        // number and also the resutl\\n        for(int i = 0; i<n; ++i)\\n        {\\n            if((nums[i]%2) != 0)    // multiplication by 2 if nums[i] is odd\\n                nums[i] *= 2;   // maximising all odd numbers\\n\\n        \\n            mx = max(mx,nums[i]);\\n            mn = min(mn,nums[i]);\\n        }\\n        \\n        int min_deviation = mx - mn;\\n        \\n        priority_queue<int> pq;\\n        // Inserting into Priority queue (Max Heap) and try to decrease as much we can\\n        for(int i = 0; i<n; ++i)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        \\n        while((pq.top()) % 2 == 0)\\n        {\\n            int top = pq.top();\\n            pq.pop(); // popped the top element\\n            \\n            min_deviation = min(min_deviation, top - mn);\\n            top /= 2;\\n            mn = min(mn, top);  // updating min\\n            pq.push(top);   // pushing again the top as we have to minimize the max\\n        }\\n        \\n        min_deviation = min(min_deviation, pq.top() - mn);\\n        \\n        // we are returning mx - mn\\n        \\n        return min_deviation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225348,
                "title": "beats-100-maxheap-and-set",
                "content": "# Intuition\\nConvert all element to even then try to minimize the number until odd appears.\\n\\n# Complexity\\n- Time complexity: O(nlgn)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nclass maxheap {\\n    constructor() {\\n        this.items = [];\\n    }\\n\\n    add(x) {\\n        this.items.push(x);\\n        let len = this.items.length;\\n        let q = this.items;\\n\\n        let c = len - 1;\\n        while(c>=0) {\\n            let s = null;\\n            let p = Math.floor((c-1) / 2);\\n\\n            if(q[p] < q[c]) {\\n                s = true;\\n            }\\n\\n            if(!s) break;\\n            let temp = q[p];\\n            q[p] = q[c];\\n            q[c] = temp;\\n            c= p;\\n        }\\n    }\\n\\n    remove() {\\n        let q = this.items;\\n        if(q.length === 1) {\\n            return q.pop();\\n        }\\n        let res = q[0];\\n        q[0] = q[q.length - 1];\\n        q.pop();\\n        let len = q.length;\\n        let n = 0;\\n        while(true) {\\n            let l = 2*n + 1;\\n            let r = 2*n + 2;\\n            let s = null;\\n\\n            if(l < len && q[l] > q[n]) {\\n                s = l;\\n            }\\n            if((s && q[r] > q[s]) || (!s && q[r] > q[n])) {\\n                s = r\\n            }\\n\\n            if(!s) break;\\n            let temp = q[s];\\n            q[s] = q[n];\\n            q[n] = temp;\\n            n = s;\\n        }\\n        return res;\\n    }\\n}\\nvar minimumDeviation = function(nums) {\\n    let set = new Set();\\n    const h = new maxheap();\\n    for(let no of nums) {\\n        if(no%2 === 0) {\\n            set.add(no);\\n            h.add(no)\\n        } else {\\n            set.add(no*2);\\n            h.add(no*2);\\n        }\\n    }\\n    let min = Math.min(...set);\\n    let diff = h.items[0] - min;\\n\\n    while(set.size && h.items[0] %2 === 0) {\\n        let ele = h.remove();\\n\\n        set.delete(ele);\\n        let nEle = parseInt(ele/2);\\n        if(!set.has(nEle)) {\\n            set.add(nEle);\\n            h.add(nEle);\\n        }\\n        min = Math.min(nEle, min);\\n        diff = Math.min(diff, h.items[0] - min)\\n    }\\n    return diff\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nclass maxheap {\\n    constructor() {\\n        this.items = [];\\n    }\\n\\n    add(x) {\\n        this.items.push(x);\\n        let len = this.items.length;\\n        let q = this.items;\\n\\n        let c = len - 1;\\n        while(c>=0) {\\n            let s = null;\\n            let p = Math.floor((c-1) / 2);\\n\\n            if(q[p] < q[c]) {\\n                s = true;\\n            }\\n\\n            if(!s) break;\\n            let temp = q[p];\\n            q[p] = q[c];\\n            q[c] = temp;\\n            c= p;\\n        }\\n    }\\n\\n    remove() {\\n        let q = this.items;\\n        if(q.length === 1) {\\n            return q.pop();\\n        }\\n        let res = q[0];\\n        q[0] = q[q.length - 1];\\n        q.pop();\\n        let len = q.length;\\n        let n = 0;\\n        while(true) {\\n            let l = 2*n + 1;\\n            let r = 2*n + 2;\\n            let s = null;\\n\\n            if(l < len && q[l] > q[n]) {\\n                s = l;\\n            }\\n            if((s && q[r] > q[s]) || (!s && q[r] > q[n])) {\\n                s = r\\n            }\\n\\n            if(!s) break;\\n            let temp = q[s];\\n            q[s] = q[n];\\n            q[n] = temp;\\n            n = s;\\n        }\\n        return res;\\n    }\\n}\\nvar minimumDeviation = function(nums) {\\n    let set = new Set();\\n    const h = new maxheap();\\n    for(let no of nums) {\\n        if(no%2 === 0) {\\n            set.add(no);\\n            h.add(no)\\n        } else {\\n            set.add(no*2);\\n            h.add(no*2);\\n        }\\n    }\\n    let min = Math.min(...set);\\n    let diff = h.items[0] - min;\\n\\n    while(set.size && h.items[0] %2 === 0) {\\n        let ele = h.remove();\\n\\n        set.delete(ele);\\n        let nEle = parseInt(ele/2);\\n        if(!set.has(nEle)) {\\n            set.add(nEle);\\n            h.add(nEle);\\n        }\\n        min = Math.min(nEle, min);\\n        diff = Math.min(diff, h.items[0] - min)\\n    }\\n    return diff\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225278,
                "title": "easy-using-set-faster-than-95-beginner-friendly-with-intution",
                "content": "# Intuition\\n1. Insert the elements of vector in a set(elements will be ordered and only once in a set).\\n2. Create two iterators start and last and an integer variable min_ans where min_ans=*last -*start.\\n\\n3. update *start=*start*2 until*start%2!=0, so that smallest element will become even and cant be increased further. In each iteration update start again to set.begin(). And at each iteration calculate differnce of last and first element and update min_ans to min of differnce and min_ans.\\n4. Then update *last=*last/2 until *last%2==0, so that larget element will be divided. again update min_ans accordingly.\\n5. return min_ans;\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set<int> sorted_nums;\\n        for(auto num: nums){\\n            sorted_nums.insert(num);\\n        }\\n        set<int>:: iterator start=sorted_nums.begin();\\n        set<int>:: reverse_iterator last=sorted_nums.rbegin();\\n        int min_ans=*last-*start;\\n        while(*start%2!=0){\\n            int t=*start;\\n            sorted_nums.erase(t);\\n            sorted_nums.insert(2*t);\\n            start=sorted_nums.begin();\\n            int ans=*last-*start;\\n            min_ans=min(ans,min_ans);\\n        }\\n        while(*last%2==0){\\n            int t=*last;\\n            sorted_nums.erase(t);\\n            sorted_nums.insert(t/2);\\n            start=sorted_nums.begin();\\n            int ans=*last-*start;\\n            min_ans=min(ans,min_ans);\\n        }\\n        \\n        return min_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set<int> sorted_nums;\\n        for(auto num: nums){\\n            sorted_nums.insert(num);\\n        }\\n        set<int>:: iterator start=sorted_nums.begin();\\n        set<int>:: reverse_iterator last=sorted_nums.rbegin();\\n        int min_ans=*last-*start;\\n        while(*start%2!=0){\\n            int t=*start;\\n            sorted_nums.erase(t);\\n            sorted_nums.insert(2*t);\\n            start=sorted_nums.begin();\\n            int ans=*last-*start;\\n            min_ans=min(ans,min_ans);\\n        }\\n        while(*last%2==0){\\n            int t=*last;\\n            sorted_nums.erase(t);\\n            sorted_nums.insert(t/2);\\n            start=sorted_nums.begin();\\n            int ans=*last-*start;\\n            min_ans=min(ans,min_ans);\\n        }\\n        \\n        return min_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224922,
                "title": "rust-30ms-3mb-pretreatment-sorting-optimizing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMove all numbers in a tight range.\\nModify lower the highest values until the difference between the highest and lowest is minimized.\\n\\n# Approach\\nLimit the possible operations to division by 2.\\nDivide all even numbers that are bigger than minimum.\\nSort the array. The resulted array will have the propriety that highest/2 < lowest.\\n\\nTry to divide all the nubers from biggest to the lowest by 2.\\nWe can return early when we find an odd max value, we can\\'t divide it further and it will always stay as out biggest number in the array. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ + $$O(n)$$ + $$O(n*log(n))$$ + $$O(n)$$ = $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_deviation(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n\\n        // use all possible *2 operations\\n        let mut min = i32::MAX;\\n        for i in 0..n {\\n            if nums[i] % 2 == 1 {\\n                nums[i] = nums[i] * 2;\\n            }\\n            min = i32::min(min, nums[i]);\\n        }\\n\\n        // at this point we can do only /2 operations\\n        let mut max = i32::MIN;\\n        for i in 0..n {\\n            while nums[i] % 2 == 0 && nums[i] / 2 >= min {\\n                nums[i] = nums[i] / 2;\\n            }\\n            max = i32::max(max, nums[i]);\\n        }\\n\\n        let mut best = max - min;\\n        // early return in case we can\\'t optimize the solution\\n        if max % 2 == 1 {\\n            return best;\\n        }\\n\\n        // lowest to highest with the propriety that highest/2 < lowest\\n        nums.sort();\\n\\n        // otimize solution until we find an odd number\\n        let mut i = n - 1;\\n        while nums[i] % 2 == 0 {\\n            nums[i] = nums[i] / 2;\\n\\n            min = nums[i];\\n            max = if i == 0 { nums [n - 1] } else { nums[i - 1] };\\n            best = i32::min(best, max - min);\\n            i = (i + n - 1) % n;\\n        }\\n\\n        best\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_deviation(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n\\n        // use all possible *2 operations\\n        let mut min = i32::MAX;\\n        for i in 0..n {\\n            if nums[i] % 2 == 1 {\\n                nums[i] = nums[i] * 2;\\n            }\\n            min = i32::min(min, nums[i]);\\n        }\\n\\n        // at this point we can do only /2 operations\\n        let mut max = i32::MIN;\\n        for i in 0..n {\\n            while nums[i] % 2 == 0 && nums[i] / 2 >= min {\\n                nums[i] = nums[i] / 2;\\n            }\\n            max = i32::max(max, nums[i]);\\n        }\\n\\n        let mut best = max - min;\\n        // early return in case we can\\'t optimize the solution\\n        if max % 2 == 1 {\\n            return best;\\n        }\\n\\n        // lowest to highest with the propriety that highest/2 < lowest\\n        nums.sort();\\n\\n        // otimize solution until we find an odd number\\n        let mut i = n - 1;\\n        while nums[i] % 2 == 0 {\\n            nums[i] = nums[i] / 2;\\n\\n            min = nums[i];\\n            max = if i == 0 { nums [n - 1] } else { nums[i - 1] };\\n            best = i32::min(best, max - min);\\n            i = (i + n - 1) % n;\\n        }\\n\\n        best\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224867,
                "title": "1675-minimize-deviation-in-array-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq =new <Integer>PriorityQueue<Integer>((a,b)->(b-a));\\n        int min=Integer.MAX_VALUE,ans=Integer.MAX_VALUE;\\n        for(int i:nums)\\n        {\\n            if((i&1)==1)\\n               i= i<<1;\\n            pq.add(i);\\n            min=Math.min(min,i);\\n        }\\n        while(pq.size()!=0)\\n        {\\n            int cur=pq.poll();\\n            ans=Math.min(ans,cur-min);\\n            if((cur&1)==1)\\n                break;\\n            cur=cur>>1;\\n            min=Math.min(min,cur);\\n            pq.add(cur);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq =new <Integer>PriorityQueue<Integer>((a,b)->(b-a));\\n        int min=Integer.MAX_VALUE,ans=Integer.MAX_VALUE;\\n        for(int i:nums)\\n        {\\n            if((i&1)==1)\\n               i= i<<1;\\n            pq.add(i);\\n            min=Math.min(min,i);\\n        }\\n        while(pq.size()!=0)\\n        {\\n            int cur=pq.poll();\\n            ans=Math.min(ans,cur-min);\\n            if((cur&1)==1)\\n                break;\\n            cur=cur>>1;\\n            min=Math.min(min,cur);\\n            pq.add(cur);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224770,
                "title": "java-solution-treeset",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    // Technique is that will first convert all the odds into even no.\\n    // then work on even no only.\\n    // will take min and max from that no so that deviation can be found\\n    // if max is even so that we can divide that to minimize the deviation.\\n\\n\\n    public int minimumDeviation(int[] nums) {\\n\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int num : nums){\\n            if(num%2!=0){\\n                num= num*2;\\n            }\\n            set.add(num);\\n        }\\n\\n        int diff = Integer.MAX_VALUE;\\n\\n      while(true){\\n        int min = set.first();\\n        int max = set.last();\\n        diff = Math.min(diff, max-min);\\n        \\n        // if true we have a chance to reduce deviation so we can divide the max\\n        if(max%2==0){\\n            set.remove(max);\\n            set.add(max/2);\\n        }else{\\n            break;\\n        }\\n      } \\n\\n      return diff;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Technique is that will first convert all the odds into even no.\\n    // then work on even no only.\\n    // will take min and max from that no so that deviation can be found\\n    // if max is even so that we can divide that to minimize the deviation.\\n\\n\\n    public int minimumDeviation(int[] nums) {\\n\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int num : nums){\\n            if(num%2!=0){\\n                num= num*2;\\n            }\\n            set.add(num);\\n        }\\n\\n        int diff = Integer.MAX_VALUE;\\n\\n      while(true){\\n        int min = set.first();\\n        int max = set.last();\\n        diff = Math.min(diff, max-min);\\n        \\n        // if true we have a chance to reduce deviation so we can divide the max\\n        if(max%2==0){\\n            set.remove(max);\\n            set.add(max/2);\\n        }else{\\n            break;\\n        }\\n      } \\n\\n      return diff;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224644,
                "title": "minimize-deviation-in-array-python-heap-solution",
                "content": "# Approach\\nWe will use priority heap.\\n\\n1. Multiply all odd numbers by 2 => we get maximum possible values of all numbers in nums. Now all numbers are even.\\n\\n2. We will use priotrity heap. But we need multiply all numbers by (-1), because we will take maximum element of heap, not minimum.\\n\\n3. Keep track min number in heap. Don\\'t forget to multiply it by (-1).\\n\\n4. Take max number from heap(remember about (-1)). While it is even, divide it by 2 and put it back to heap. Since max number is odd we stop.\\n\\n5. Keep the min difference between max number and min number as a result. And update min number every step.\\n\\n# Complexity\\n- Time complexity: $$O(n logn)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfrom heapq import heappop, heappush\\n\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        result = float(\\'inf\\')\\n        heap = []  \\n        for n in set(nums):\\n            if n % 2 == 0:\\n                heappush(heap, (-1) * n)\\n            else:\\n                heappush(heap, (-2) * n)\\n        heap_min = (-1) * max(heap)\\n        while heap[0] % 2 == 0:\\n            heap_max = (-1) * heappop(heap)\\n            heappush(heap, (-1) * heap_max // 2)\\n            result = min(result, heap_max - heap_min)\\n            heap_min = min(heap_min, heap_max // 2)\\n        heap_max = (-1) * heappop(heap)\\n        result = min(result, heap_max - heap_min)\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappop, heappush\\n\\n\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        result = float(\\'inf\\')\\n        heap = []  \\n        for n in set(nums):\\n            if n % 2 == 0:\\n                heappush(heap, (-1) * n)\\n            else:\\n                heappush(heap, (-2) * n)\\n        heap_min = (-1) * max(heap)\\n        while heap[0] % 2 == 0:\\n            heap_max = (-1) * heappop(heap)\\n            heappush(heap, (-1) * heap_max // 2)\\n            result = min(result, heap_max - heap_min)\\n            heap_min = min(heap_min, heap_max // 2)\\n        heap_max = (-1) * heappop(heap)\\n        result = min(result, heap_max - heap_min)\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224617,
                "title": "java-solution-using-priority-queue-easy-to-understand",
                "content": "\\n\\n# Approach\\nfind the difference of minimum even element to maximun odd element in priority queue.\\n\\n# Complexity\\n- Time complexity:\\nO(nlognlogm)   // m = maximum elemenet\\n\\n- Space complexity:\\nO(n) \\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (b-a));\\n        int minValue = Integer.MAX_VALUE;\\n        for(int num : nums){\\n            if(num%2 != 0){\\n                num = 2*num;\\n            }\\n            minValue = Math.min(minValue, num);\\n            pq.add(num);\\n        }\\n        int n = nums.length;\\n        int diff = Integer.MAX_VALUE;\\n        while(pq.peek() %2 == 0){\\n            int maxTill = pq.poll();\\n            diff = Math.min(diff, maxTill-minValue);\\n            minValue = Math.min(minValue, maxTill / 2);\\n            pq.add(maxTill/2);\\n        }\\n        return Math.min(diff, pq.peek()-minValue);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (b-a));\\n        int minValue = Integer.MAX_VALUE;\\n        for(int num : nums){\\n            if(num%2 != 0){\\n                num = 2*num;\\n            }\\n            minValue = Math.min(minValue, num);\\n            pq.add(num);\\n        }\\n        int n = nums.length;\\n        int diff = Integer.MAX_VALUE;\\n        while(pq.peek() %2 == 0){\\n            int maxTill = pq.poll();\\n            diff = Math.min(diff, maxTill-minValue);\\n            minValue = Math.min(minValue, maxTill / 2);\\n            pq.add(maxTill/2);\\n        }\\n        return Math.min(diff, pq.peek()-minValue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224591,
                "title": "c-optimized-solution-100-100",
                "content": "# Intuition\\nNo one upvotes or comments my solutions so help yourselves :)\\n\\nSlava Ukraini!\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/e04ecccd-b3fd-4399-b565-7bf2305bd287_1677229968.369655.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n\\n        int upper_odd = 1;\\n        int lower = 1000000000;\\n        for (const auto& num: nums) {\\n            upper_odd = max(upper_odd, num / (num & (-num)));\\n            lower = min(lower, num << (num & 1));\\n        }\\n\\n        lower = min(lower, upper_odd);\\n        int lower2 = lower << 1;\\n        if (lower2 <= upper_odd) return upper_odd - lower;\\n\\n        vector<int> arr({upper_odd});\\n        for (const auto& num: nums) {\\n            int a = num << 1;\\n            while (a >= lower2) a >>= 1;\\n            if (a > upper_odd) arr.push_back(a);\\n        }\\n\\n        sort(++arr.begin(), arr.end());\\n\\n        //print_arr(arr);\\n\\n        int div = arr.back() - lower;\\n        for (int i = arr.size() - 1; i > 0; --i) {\\n            div = min(div, arr[i-1] - (arr[i] >> 1));\\n        }\\n        \\n        return div;\\n    }\\n\\nprivate:\\n    void print_arr(vector<int>& nums) {\\n        for (auto& num: nums) cout << num << \", \";\\n        cout << endl;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n\\n        int upper_odd = 1;\\n        int lower = 1000000000;\\n        for (const auto& num: nums) {\\n            upper_odd = max(upper_odd, num / (num & (-num)));\\n            lower = min(lower, num << (num & 1));\\n        }\\n\\n        lower = min(lower, upper_odd);\\n        int lower2 = lower << 1;\\n        if (lower2 <= upper_odd) return upper_odd - lower;\\n\\n        vector<int> arr({upper_odd});\\n        for (const auto& num: nums) {\\n            int a = num << 1;\\n            while (a >= lower2) a >>= 1;\\n            if (a > upper_odd) arr.push_back(a);\\n        }\\n\\n        sort(++arr.begin(), arr.end());\\n\\n        //print_arr(arr);\\n\\n        int div = arr.back() - lower;\\n        for (int i = arr.size() - 1; i > 0; --i) {\\n            div = min(div, arr[i-1] - (arr[i] >> 1));\\n        }\\n        \\n        return div;\\n    }\\n\\nprivate:\\n    void print_arr(vector<int>& nums) {\\n        for (auto& num: nums) cout << num << \", \";\\n        cout << endl;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3224532,
                "title": "minimize-deviation-in-array-easy-java-sol",
                "content": "# Approach\\n1. make all odd value even\\n2. take min of all value\\n3. find max and difference and update max/2 till the max is even\\n4. Otherwise differenc is the result \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogNlogM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using Tree Set\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> tr = new TreeSet<>();\\n        for(int num: nums){\\n            if(num%2 != 0){\\n                num = num*2;\\n            }\\n            tr.add(num);\\n        }\\n        int diff = Integer.MAX_VALUE;\\n        while(true){\\n            int min = tr.first();\\n            int max = tr.last();\\n            diff = Math.min(diff, max-min);\\n            if(max%2 == 0){\\n                tr.remove(max);\\n                tr.add(max/2);\\n            }else{\\n                break;\\n            }\\n        }\\n        return diff;\\n    }\\n}\\n```\\n# Code using Priority Queue\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        int min = Integer.MAX_VALUE;\\n        for(int num: nums){\\n            if(num%2 != 0){\\n                num = num*2;\\n            }\\n            min = Math.min(min, num);\\n            pq.add(num);\\n        }\\n        int diff = Integer.MAX_VALUE;\\n        while(pq.peek()%2 == 0){\\n            int max = pq.remove();\\n            diff = Math.min(diff, max-min);\\n            min = Math.min(max/2, min);\\n            pq.add(max/2);\\n        }\\n        return Math.min(diff, pq.peek() - min);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> tr = new TreeSet<>();\\n        for(int num: nums){\\n            if(num%2 != 0){\\n                num = num*2;\\n            }\\n            tr.add(num);\\n        }\\n        int diff = Integer.MAX_VALUE;\\n        while(true){\\n            int min = tr.first();\\n            int max = tr.last();\\n            diff = Math.min(diff, max-min);\\n            if(max%2 == 0){\\n                tr.remove(max);\\n                tr.add(max/2);\\n            }else{\\n                break;\\n            }\\n        }\\n        return diff;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        int min = Integer.MAX_VALUE;\\n        for(int num: nums){\\n            if(num%2 != 0){\\n                num = num*2;\\n            }\\n            min = Math.min(min, num);\\n            pq.add(num);\\n        }\\n        int diff = Integer.MAX_VALUE;\\n        while(pq.peek()%2 == 0){\\n            int max = pq.remove();\\n            diff = Math.min(diff, max-min);\\n            min = Math.min(max/2, min);\\n            pq.add(max/2);\\n        }\\n        return Math.min(diff, pq.peek() - min);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224411,
                "title": "beats-100-java-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n    static final int[] q = new int[1600000];\\n\\n    public int minimumDeviation(int[] nums) {\\n        final int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] % 2 == 1) {\\n                nums[i] *= 2;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        int qstart = 0;\\n        int qend = 0;\\n        int best = nums[n - 1] - nums[0];\\n        int numptr = n - 2;\\n        q[qend++] = nums[n - 1];\\n        int min = nums[0];\\n        while (true) {\\n            final int pick = numptr >= 0 && nums[numptr] > q[qstart] ? nums[numptr--] : q[qstart++];\\n            best = Math.min(best, pick - min);\\n            if (pick % 2 == 1) return best;\\n            min = Math.min(min, q[qend++] = pick / 2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    static final int[] q = new int[1600000];\\n\\n    public int minimumDeviation(int[] nums) {\\n        final int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] % 2 == 1) {\\n                nums[i] *= 2;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        int qstart = 0;\\n        int qend = 0;\\n        int best = nums[n - 1] - nums[0];\\n        int numptr = n - 2;\\n        q[qend++] = nums[n - 1];\\n        int min = nums[0];\\n        while (true) {\\n            final int pick = numptr >= 0 && nums[numptr] > q[qstart] ? nums[numptr--] : q[qstart++];\\n            best = Math.min(best, pick - min);\\n            if (pick % 2 == 1) return best;\\n            min = Math.min(min, q[qend++] = pick / 2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224267,
                "title": "simple-python-solution-using-heap-beats-94",
                "content": "# Approach\\nInitially push event elements in the heap (maxHeap).\\nWhile doing so if odd element is found double it and insert.\\nNow maintain currMin and currMax and after each iteration \\nans = min(ans, currMax-currMin).\\n\\nPop top element from the heap and that will be currMax, check for ans\\npush the element by dividing it by 2.\\nIf currMax is odd stop the loop as we are treating this element again that means we are in cycle and we will get same elements again.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = []\\n        ans = max(nums)+1\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                heappush(heap, -num)\\n            else:\\n                # push only even values\\n                heappush(heap, -num*2)\\n        currMax = 2\\n        currMin = -max(heap)\\n\\n        # currMax % 2. == 0 indicates we are doing only first operation on the element\\n        # on second operation it will be cyclic\\n        while currMax % 2 == 0:\\n            currMax = -heappop(heap)\\n            ans = min(ans, currMax-currMin)\\n            heappush(heap, -currMax//2)\\n            currMin = min(currMin, currMax//2)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        heap = []\\n        ans = max(nums)+1\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                heappush(heap, -num)\\n            else:\\n                # push only even values\\n                heappush(heap, -num*2)\\n        currMax = 2\\n        currMin = -max(heap)\\n\\n        # currMax % 2. == 0 indicates we are doing only first operation on the element\\n        # on second operation it will be cyclic\\n        while currMax % 2 == 0:\\n            currMax = -heappop(heap)\\n            ans = min(ans, currMax-currMin)\\n            heappush(heap, -currMax//2)\\n            currMin = min(currMin, currMax//2)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224170,
                "title": "max-heap-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> This Problem is can be solve using max heap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep-1. Traverse the array and if elemnt is odd then multiply it by 2 and also calculate the minimum element in array.\\n\\nStep-2. Push the array elements into the max heap.\\n\\nStep-3. Run a while loop until the top element of max heap will become odd.\\n\\nStep-4. Calculate the the diffrence between minimum element(in array) and the maximum element(in heap).\\n\\nStep-5. push the maximum element again into heap but ensure that is it divided by 2.\\n\\nStep-6. After while loop return the minimum of minimum diffrence and the thop element in heap - minimum element of array.\\n\\n# Complexity\\n- Time complexity:~O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:~O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int>pq;\\n        int mini = INT_MAX, diff = INT_MAX;\\n        for(auto i:nums){\\n            if(i%2 != 0){\\n                i*= 2;\\n            }\\n            mini = min(mini, i);\\n            pq.push(i);\\n        }\\n        while(pq.top()%2 == 0){\\n            int maxi = pq.top();\\n            pq.pop();\\n            diff = min(diff, maxi-mini);\\n            mini = min(mini, maxi/2);\\n            pq.push(maxi/2);\\n        }\\n        return min(diff, pq.top()-mini);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int>pq;\\n        int mini = INT_MAX, diff = INT_MAX;\\n        for(auto i:nums){\\n            if(i%2 != 0){\\n                i*= 2;\\n            }\\n            mini = min(mini, i);\\n            pq.push(i);\\n        }\\n        while(pq.top()%2 == 0){\\n            int maxi = pq.top();\\n            pq.pop();\\n            diff = min(diff, maxi-mini);\\n            mini = min(mini, maxi/2);\\n            pq.push(maxi/2);\\n        }\\n        return min(diff, pq.top()-mini);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224070,
                "title": "javascript-8-lines-greedy-no-pq-time-o-nlogn-space-o-1-100",
                "content": "# Approach\\n1. Go thru `nums` to double odd values & remove duplicates. Sort it in decreasing order.\\n2. Set variable `dev` as the difference between the first & last elements in `nums`.\\n3. While `nums[0]` contains an even value:\\n    1. Divide `nums[0]` by 2. If needed, move the element so that `nums` remains sorted.\\n    2. Set `dev` to the new difference between first & last `nums` if it is lower.\\n4. Return `dev`.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(1), beats 100%\\n\\n# Code\\n```\\nconst minimumDeviation = nums => {\\n    nums.forEach( (n,i) => n%2 && ( nums[i] *= 2 ) )\\n    nums = [ ...new Set(nums) ].sort( (n,m) => m-n )\\n    let l = nums.length-1, dev = nums[0]-nums[l], i\\n    while ( nums[0]%2 == 0 ) {\\n        if ( (nums[0] /= 2) < nums[1] )\\n            i = nums.findIndex( n => n < nums[0] ),\\n            nums.splice( i<0 ? l : i-1 , 0, nums.shift() )\\n        dev = Math.min( dev, nums[0]-nums[l] )\\n    }\\n    return dev\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nconst minimumDeviation = nums => {\\n    nums.forEach( (n,i) => n%2 && ( nums[i] *= 2 ) )\\n    nums = [ ...new Set(nums) ].sort( (n,m) => m-n )\\n    let l = nums.length-1, dev = nums[0]-nums[l], i\\n    while ( nums[0]%2 == 0 ) {\\n        if ( (nums[0] /= 2) < nums[1] )\\n            i = nums.findIndex( n => n < nums[0] ),\\n            nums.splice( i<0 ? l : i-1 , 0, nums.shift() )\\n        dev = Math.min( dev, nums[0]-nums[l] )\\n    }\\n    return dev\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224067,
                "title": "java-using-maxheap-prioirtyqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> p=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2!=0)nums[i]=2*nums[i];\\n            p.add(nums[i]);\\n        }\\n        Arrays.sort(nums);\\n        int min=nums[0];\\n        int ans=Integer.MAX_VALUE;\\n        while(true)\\n        {\\n            if(p.peek()%2!=0)break;\\n            ans=Math.min(ans,Math.abs(min-p.peek()));\\n            int val=p.peek()/2;\\n            min=Math.min(min,val);\\n            p.poll();\\n            p.add(val);\\n        }\\n        return Math.min(ans,Math.abs(p.peek()-min));\\n    } \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> p=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2!=0)nums[i]=2*nums[i];\\n            p.add(nums[i]);\\n        }\\n        Arrays.sort(nums);\\n        int min=nums[0];\\n        int ans=Integer.MAX_VALUE;\\n        while(true)\\n        {\\n            if(p.peek()%2!=0)break;\\n            ans=Math.min(ans,Math.abs(min-p.peek()));\\n            int val=p.peek()/2;\\n            min=Math.min(min,val);\\n            p.poll();\\n            p.add(val);\\n        }\\n        return Math.min(ans,Math.abs(p.peek()-min));\\n    } \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224061,
                "title": "c-multiset-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int mn = INT_MAX;\\n        multiset<int,greater<int>>s;\\n        for(auto x : nums){\\n            if(x&1){\\n                x*=2;\\n            }\\n            s.insert(x);\\n        }\\n        int res = INT_MAX;\\n        while(1){\\n            int t = *s.begin();\\n            int diff = *s.begin() - *s.rbegin();\\n            s.erase(s.begin());\\n            res = min(res,diff);\\n            if(t&1){\\n                break;\\n            }\\n\\n            s.insert(t/2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        int mn = INT_MAX;\\n        multiset<int,greater<int>>s;\\n        for(auto x : nums){\\n            if(x&1){\\n                x*=2;\\n            }\\n            s.insert(x);\\n        }\\n        int res = INT_MAX;\\n        while(1){\\n            int t = *s.begin();\\n            int diff = *s.begin() - *s.rbegin();\\n            s.erase(s.begin());\\n            res = min(res,diff);\\n            if(t&1){\\n                break;\\n            }\\n\\n            s.insert(t/2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223980,
                "title": "solutions-in-java-python-and-c-with-video-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by observing that if a number is even, we can divide it by 2 until it becomes odd. Therefore, we can transform the problem into finding the minimum deviation of an array of all odd numbers obtained by dividing the original numbers by the highest power of 2 they contain. Then, we can use a priority queue to keep track of the minimum element and the maximum element seen so far, and repeatedly replace the minimum element with its next highest power of 2 until we cannot reduce it any further. At each step, we compute the difference between the maximum and minimum elements and update the minimum deviation seen so far.\\n\\n# Video reference\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/u0n-6zBnohY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/2b37d2cc-3ca9-4b0c-866d-48abc59d8fa5_1677216789.1769023.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Divide all original numbers by the highest power of 2 they contain and obtain an array of all odd numbers.\\n2. Initialize a priority queue with all the elements in the array.\\n3. Initialize the minimum deviation to be the difference between the largest and smallest elements in the queue.\\n4. Repeatedly remove the smallest element from the queue, multiply it by 2, and add it back to the queue until we cannot reduce it any further.\\n5. At each step, update the minimum deviation to be the minimum of its current value and the difference between the largest and smallest elements in the queue.\\n\\n# Complexity\\n- Time complexity:\\n O(n log n), where n is the length of the input array. We need to sort the odd numbers using a priority queue, which takes O(n log n) time in the worst case. We also need to perform a constant number of operations on each element in the queue, which takes O(log max(a[i])) time per operation, where max(a[i]) is the largest element in the array.\\n- Space complexity: \\nO(n), where n is the length of the input array. We need to store all the odd numbers in the array and the priority queue.\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        // Divide all original numbers by the highest power of 2 they contain and obtain an array of all odd numbers.\\n        int[] oddNums = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] % 2 == 0) {\\n                nums[i] /= 2;\\n            }\\n            oddNums[i] = nums[i];\\n        }\\n        \\n        // Initialize a priority queue with all the elements in the array.\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int num : oddNums) {\\n            pq.offer(num);\\n        }\\n        \\n        // Initialize the minimum deviation to be the difference between the largest and smallest elements in the queue.\\n        int minDeviation = pq.peek() - pq.poll();\\n        \\n        // Repeatedly remove the smallest element from the queue, multiply it by 2, and add it back to the queue until we cannot reduce it any further.\\n        while (pq.peek() % 2 == 0) {\\n            int min = pq.poll();\\n            pq.offer(min * 2);\\n            // At each step, update the minimum deviation to be the minimum of its current value and the difference between the largest and smallest elements in the queue.\\n            minDeviation = Math.min(minDeviation, pq.peek() - min);\\n        }\\n        \\n        return minDeviation;\\n    }\\n}\\n\\n```\\n\\n# C++ code\\n```\\n#include <iostream>\\n#include <queue>\\n#include <set>\\n#include <algorithm>\\nusing namespace std;\\n\\nint minimumDeviation(vector<int>& nums) {\\n    int mn = *min_element(nums.begin(), nums.end());\\n    priority_queue<int> pq;\\n    for (auto x : nums) {\\n        if (x % 2 == 0) {\\n            pq.push(x);\\n        } else {\\n            pq.push(x * 2);\\n        }\\n    }\\n    int ans = INT_MAX;\\n    while (true) {\\n        int x = pq.top();\\n        pq.pop();\\n        ans = min(ans, x - mn);\\n        if (x % 2 == 1) {\\n            break;\\n        }\\n        pq.push(x / 2);\\n    }\\n    return ans;\\n}\\n\\nint main() {\\n    vector<int> nums = {1, 2, 3, 4};\\n    cout << minimumDeviation(nums) << endl;  // Output: 1\\n\\n    nums = {4, 1, 5, 20, 3};\\n    cout << minimumDeviation(nums) << endl;  // Output: 3\\n\\n    nums = {2, 10, 8};\\n    cout << minimumDeviation(nums) << endl;  // Output: 3\\n\\n    return 0;\\n}\\n\\n```\\n# Python Code\\n~~~\\nimport heapq\\n\\ndef minimumDeviation(nums: List[int]) -> int:\\n    mn = min(nums)\\n    pq = [-x if x % 2 else -x // 2 for x in nums]\\n    heapq.heapify(pq)\\n    ans = float(\\'inf\\')\\n    while True:\\n        x = -heapq.heappop(pq)\\n        ans = min(ans, x - mn)\\n        if x % 2 == 1:\\n            break\\n        heapq.heappush(pq, -x // 2)\\n    return ans\\n\\nnums = [1, 2, 3, 4]\\nprint(minimumDeviation(nums))  # Output: 1\\n\\nnums = [4, 1, 5, 20, 3]\\nprint(minimumDeviation(nums))  # Output: 3\\n\\nnums = [2, 10, 8]\\nprint(minimumDeviation(nums))  # Output: 3\\n\\n~~~",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        // Divide all original numbers by the highest power of 2 they contain and obtain an array of all odd numbers.\\n        int[] oddNums = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] % 2 == 0) {\\n                nums[i] /= 2;\\n            }\\n            oddNums[i] = nums[i];\\n        }\\n        \\n        // Initialize a priority queue with all the elements in the array.\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int num : oddNums) {\\n            pq.offer(num);\\n        }\\n        \\n        // Initialize the minimum deviation to be the difference between the largest and smallest elements in the queue.\\n        int minDeviation = pq.peek() - pq.poll();\\n        \\n        // Repeatedly remove the smallest element from the queue, multiply it by 2, and add it back to the queue until we cannot reduce it any further.\\n        while (pq.peek() % 2 == 0) {\\n            int min = pq.poll();\\n            pq.offer(min * 2);\\n            // At each step, update the minimum deviation to be the minimum of its current value and the difference between the largest and smallest elements in the queue.\\n            minDeviation = Math.min(minDeviation, pq.peek() - min);\\n        }\\n        \\n        return minDeviation;\\n    }\\n}\\n\\n```\n```\\n#include <iostream>\\n#include <queue>\\n#include <set>\\n#include <algorithm>\\nusing namespace std;\\n\\nint minimumDeviation(vector<int>& nums) {\\n    int mn = *min_element(nums.begin(), nums.end());\\n    priority_queue<int> pq;\\n    for (auto x : nums) {\\n        if (x % 2 == 0) {\\n            pq.push(x);\\n        } else {\\n            pq.push(x * 2);\\n        }\\n    }\\n    int ans = INT_MAX;\\n    while (true) {\\n        int x = pq.top();\\n        pq.pop();\\n        ans = min(ans, x - mn);\\n        if (x % 2 == 1) {\\n            break;\\n        }\\n        pq.push(x / 2);\\n    }\\n    return ans;\\n}\\n\\nint main() {\\n    vector<int> nums = {1, 2, 3, 4};\\n    cout << minimumDeviation(nums) << endl;  // Output: 1\\n\\n    nums = {4, 1, 5, 20, 3};\\n    cout << minimumDeviation(nums) << endl;  // Output: 3\\n\\n    nums = {2, 10, 8};\\n    cout << minimumDeviation(nums) << endl;  // Output: 3\\n\\n    return 0;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3223954,
                "title": "beats-98-c-implimentation-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing set, we go through the list and find the minimum Deviation.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. we iterate the set until we found a even number. when we found odd number we update min value and insert 2*odd into the set.\\n2. we interate the set from last to first until we found a odd number. when we found a even number we update min value and insert even/2 into the set.\\n3. copy 1st step. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m log(n))\\nwhere m always less than n.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for using set\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set<int>st;\\n        for(auto num : nums) st.insert(num);\\n        \\n        int mnDev = *st.rbegin() - *st.begin();\\n\\n        while(*st.begin() % 2 != 0){\\n            int x=*st.begin();\\n            st.erase(st.begin());\\n            st.insert(x*2);\\n            mnDev = min(mnDev, *st.rbegin() - *st.begin());\\n        }\\n\\n        while(*st.rbegin() % 2 == 0){\\n            auto itt=st.end(); itt--;\\n            int x=*itt;\\n            st.erase(itt);\\n            st.insert(x/2);\\n            mnDev = min(mnDev, *st.rbegin() - *st.begin());\\n        }\\n\\n        while(*st.begin() % 2 != 0){\\n            int x=*st.begin();\\n            st.erase(st.begin());\\n            st.insert(x*2);\\n            mnDev = min(mnDev, *st.rbegin() - *st.begin());\\n        }\\n\\n        return mnDev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        set<int>st;\\n        for(auto num : nums) st.insert(num);\\n        \\n        int mnDev = *st.rbegin() - *st.begin();\\n\\n        while(*st.begin() % 2 != 0){\\n            int x=*st.begin();\\n            st.erase(st.begin());\\n            st.insert(x*2);\\n            mnDev = min(mnDev, *st.rbegin() - *st.begin());\\n        }\\n\\n        while(*st.rbegin() % 2 == 0){\\n            auto itt=st.end(); itt--;\\n            int x=*itt;\\n            st.erase(itt);\\n            st.insert(x/2);\\n            mnDev = min(mnDev, *st.rbegin() - *st.begin());\\n        }\\n\\n        while(*st.begin() % 2 != 0){\\n            int x=*st.begin();\\n            st.erase(st.begin());\\n            st.insert(x*2);\\n            mnDev = min(mnDev, *st.rbegin() - *st.begin());\\n        }\\n\\n        return mnDev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223951,
                "title": "c-solution-using-priorityqueue-o-nlogn",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumDeviation(int[] nums) {\\n        int minValue = int.MaxValue;\\n        int minDeviation = int.MaxValue;\\n        PriorityQueue<int, int> pq = new PriorityQueue<int, int>();\\n\\n        for(int i=0; i<nums.Length; i++){\\n            if((nums[i]&1) != 0){\\n                nums[i] = (nums[i]<<1);\\n            }\\n\\n            minValue = Math.Min(minValue, nums[i]);\\n            pq.Enqueue(nums[i], -nums[i]);\\n        }\\n\\n        while((pq.Peek()&1) == 0){\\n            int maxValue = pq.Dequeue();\\n            minDeviation = Math.Min(minDeviation, maxValue - minValue);\\n\\n            if((maxValue&1) == 0){\\n                int newValue = (maxValue>>1);\\n                pq.Enqueue(newValue, -newValue);\\n                minValue = Math.Min(minValue, newValue);\\n            }\\n        }\\n\\n        return Math.Min(minDeviation, pq.Peek() - minValue);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumDeviation(int[] nums) {\\n        int minValue = int.MaxValue;\\n        int minDeviation = int.MaxValue;\\n        PriorityQueue<int, int> pq = new PriorityQueue<int, int>();\\n\\n        for(int i=0; i<nums.Length; i++){\\n            if((nums[i]&1) != 0){\\n                nums[i] = (nums[i]<<1);\\n            }\\n\\n            minValue = Math.Min(minValue, nums[i]);\\n            pq.Enqueue(nums[i], -nums[i]);\\n        }\\n\\n        while((pq.Peek()&1) == 0){\\n            int maxValue = pq.Dequeue();\\n            minDeviation = Math.Min(minDeviation, maxValue - minValue);\\n\\n            if((maxValue&1) == 0){\\n                int newValue = (maxValue>>1);\\n                pq.Enqueue(newValue, -newValue);\\n                minValue = Math.Min(minValue, newValue);\\n            }\\n        }\\n\\n        return Math.Min(minDeviation, pq.Peek() - minValue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223935,
                "title": "100-fast-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int x : nums)\\n            if (x%2 == 0)\\n                set.add(x);\\n            else\\n                set.add(x*2);\\n        int ans = Integer.MAX_VALUE;\\n        while (true) {\\n            int val = set.last();\\n            ans = Math.min(ans, val - set.first());\\n            if (val%2 == 0) {\\n                set.remove(val);\\n                set.add(val/2);\\n            } else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int x : nums)\\n            if (x%2 == 0)\\n                set.add(x);\\n            else\\n                set.add(x*2);\\n        int ans = Integer.MAX_VALUE;\\n        while (true) {\\n            int val = set.last();\\n            ans = Math.min(ans, val - set.first());\\n            if (val%2 == 0) {\\n                set.remove(val);\\n                set.add(val/2);\\n            } else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223893,
                "title": "begineer-friendly-solution-with-detailed-explaination-fastest-solution",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        # initialize a heap data structure to store the transformed values of the array elements\\n        heap = []\\n        \\n        for num in nums:\\n            # transform the number to an odd number if it is odd\\n            transformed_num = num\\n            while transformed_num % 2 == 0:\\n                transformed_num //= 2\\n            # append the tuple (transformed number, maximum limit) to the heap\\n            heap.append((transformed_num, max(num, transformed_num*2)))\\n        \\n        # find the maximum value in the heap\\n        max_num = max(i for i,j in heap)\\n        \\n        # convert the list to a heap data structure\\n        heapify(heap)\\n        \\n        # initialize the minimum deviation to be a large value\\n        min_deviation = float(\"inf\")\\n\\n        # loop until all the elements in the heap have been processed\\n        while len(heap) == len(nums):\\n            \\n            # pop the smallest element from the heap\\n            num, limit = heappop(heap)\\n            \\n            # update the minimum deviation\\n            min_deviation = min(min_deviation, max_num - num)\\n            \\n            # if the popped element can be doubled and still be within its limit, then push it back to the heap with the doubled value\\n            if num < limit:\\n                heappush(heap, (num*2, limit))\\n                max_num = max(max_num, num*2)\\n            \\n        # return the minimum deviation\\n        return min_deviation\\n```\\n**For Detailed Explaination Read this Blog:**\\nhttps://www.python-techs.com/2023/02/minimum-deviation-of-array-leetcode.html\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeviation(self, nums: List[int]) -> int:\\n        # initialize a heap data structure to store the transformed values of the array elements\\n        heap = []\\n        \\n        for num in nums:\\n            # transform the number to an odd number if it is odd\\n            transformed_num = num\\n            while transformed_num % 2 == 0:\\n                transformed_num //= 2\\n            # append the tuple (transformed number, maximum limit) to the heap\\n            heap.append((transformed_num, max(num, transformed_num*2)))\\n        \\n        # find the maximum value in the heap\\n        max_num = max(i for i,j in heap)\\n        \\n        # convert the list to a heap data structure\\n        heapify(heap)\\n        \\n        # initialize the minimum deviation to be a large value\\n        min_deviation = float(\"inf\")\\n\\n        # loop until all the elements in the heap have been processed\\n        while len(heap) == len(nums):\\n            \\n            # pop the smallest element from the heap\\n            num, limit = heappop(heap)\\n            \\n            # update the minimum deviation\\n            min_deviation = min(min_deviation, max_num - num)\\n            \\n            # if the popped element can be doubled and still be within its limit, then push it back to the heap with the doubled value\\n            if num < limit:\\n                heappush(heap, (num*2, limit))\\n                max_num = max(max_num, num*2)\\n            \\n        # return the minimum deviation\\n        return min_deviation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223843,
                "title": "java-c-100-solution-using-priority-queue-minimize-deviation-in-array",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nlog(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int minNum = Integer.MAX_VALUE, ans = Integer.MAX_VALUE;\\n\\n        for(int x:nums)\\n        {\\n            if(x%2==1)\\n                x*=2;\\n            pq.add(x);\\n\\n            minNum = Math.min(minNum,x);\\n        }\\n\\n        int top = pq.peek();\\n\\n        while(pq.peek()%2==0)\\n        {\\n            top = pq.poll();\\n\\n            ans = Math.min(ans,top-minNum);\\n\\n            minNum = Math.min(minNum,top/2); \\n            pq.add(top/2);\\n        }\\n        ans = Math.min(ans, pq.peek() - minNum); \\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int minNum = INT_MAX,ans = INT_MAX;\\n\\n        for(int x:nums)\\n        {\\n            if(x%2==1)\\n                x*=2;\\n            pq.push(x);\\n\\n            minNum = min(minNum,x);\\n        }\\n\\n        int top = pq.top();\\n\\n        while(pq.top()%2==0)\\n        {\\n            top = pq.top();\\n            pq.pop();\\n\\n            ans = min(ans,top-minNum);\\n\\n            minNum = min(minNum,top/2); \\n            pq.push(top/2);\\n        }\\n        ans = min(ans, pq.top() - minNum); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int minNum = Integer.MAX_VALUE, ans = Integer.MAX_VALUE;\\n\\n        for(int x:nums)\\n        {\\n            if(x%2==1)\\n                x*=2;\\n            pq.add(x);\\n\\n            minNum = Math.min(minNum,x);\\n        }\\n\\n        int top = pq.peek();\\n\\n        while(pq.peek()%2==0)\\n        {\\n            top = pq.poll();\\n\\n            ans = Math.min(ans,top-minNum);\\n\\n            minNum = Math.min(minNum,top/2); \\n            pq.add(top/2);\\n        }\\n        ans = Math.min(ans, pq.peek() - minNum); \\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        int minNum = INT_MAX,ans = INT_MAX;\\n\\n        for(int x:nums)\\n        {\\n            if(x%2==1)\\n                x*=2;\\n            pq.push(x);\\n\\n            minNum = min(minNum,x);\\n        }\\n\\n        int top = pq.top();\\n\\n        while(pq.top()%2==0)\\n        {\\n            top = pq.top();\\n            pq.pop();\\n\\n            ans = min(ans,top-minNum);\\n\\n            minNum = min(minNum,top/2); \\n            pq.push(top/2);\\n        }\\n        ans = min(ans, pq.top() - minNum); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223683,
                "title": "o-1-space-ternary-search-solution-beats-100-memory-and-65-runtime",
                "content": "# Intuition\\nKey phrase is \"minimum of maximum\".  Almost any time you see these two words together in a problem statement, some form of binary search can be used.  In this case, we use ternary search.\\n\\n# Approach\\nThe immediate thought that came to my head was that this must be a binary search type problem.  The general idea is that we are trying to \"reach\" some number (our mid) and we want all numbers to get as close as possible to that number.  \\n\\nAfter coding it out a bit, I realized I didn\\'t have anything to compare to know whether I should search left or right on my next iteration.  After some additional thought, I realized that use ternary search and compare in which side of the search we get a better result and continue our search there.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1) or O(N) if you count the input\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCount(int tar, vector<int>& nums){\\n        int lo = INT_MAX;\\n        int hi = INT_MIN;\\n        for(int i = 0;i<nums.size();i++){\\n            int cur = nums[i];\\n            if(cur%2==1){\\n                if(abs(tar-(cur*2))<abs(tar-(cur))){\\n                    cur*=2;\\n                }\\n            }\\n            else{\\n                while(cur%2==0&&abs(tar-(cur/2))<abs(tar-(cur))){\\n                    cur/=2;\\n                }\\n            }\\n            hi = max(hi,cur);\\n            lo = min(lo,cur);\\n        }\\n        return hi-lo;\\n    }\\n    int minimumDeviation(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l = 0;\\n        int r = nums[nums.size()-1];\\n        int mid1 = l + (r-l)/3;\\n        int mid2 = r - (r-l)/3; \\n        int mi = INT_MAX;\\n        while(l<=r){\\n            mid1 = l + (r-l)/3;\\n            mid2 = r - (r-l)/3; \\n            int c1 = getCount(mid1,nums);\\n            int c2 = getCount(mid2,nums);\\n            mi = min({mi,c1,c2});\\n            if(c1<c2){\\n                r = mid2-1;\\n            }\\n            else{\\n                l = mid1+1;\\n            }\\n        }\\n        return mi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCount(int tar, vector<int>& nums){\\n        int lo = INT_MAX;\\n        int hi = INT_MIN;\\n        for(int i = 0;i<nums.size();i++){\\n            int cur = nums[i];\\n            if(cur%2==1){\\n                if(abs(tar-(cur*2))<abs(tar-(cur))){\\n                    cur*=2;\\n                }\\n            }\\n            else{\\n                while(cur%2==0&&abs(tar-(cur/2))<abs(tar-(cur))){\\n                    cur/=2;\\n                }\\n            }\\n            hi = max(hi,cur);\\n            lo = min(lo,cur);\\n        }\\n        return hi-lo;\\n    }\\n    int minimumDeviation(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l = 0;\\n        int r = nums[nums.size()-1];\\n        int mid1 = l + (r-l)/3;\\n        int mid2 = r - (r-l)/3; \\n        int mi = INT_MAX;\\n        while(l<=r){\\n            mid1 = l + (r-l)/3;\\n            mid2 = r - (r-l)/3; \\n            int c1 = getCount(mid1,nums);\\n            int c2 = getCount(mid2,nums);\\n            mi = min({mi,c1,c2});\\n            if(c1<c2){\\n                r = mid2-1;\\n            }\\n            else{\\n                l = mid1+1;\\n            }\\n        }\\n        return mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223654,
                "title": "minimize-deviation-in-array-java-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsolve this problem, we need to perform the following steps:\\n\\nMultiply all odd numbers by 2 so that we can perform only even divisions later.\\n\\nCreate a max-heap of the modified array.\\n\\nWhile the maximum element of the heap is even, we can divide it by 2 and replace the maximum element with the result.\\n\\nKeep track of the minimum deviation during the above process.\\n\\nReturn the minimum deviation as the final answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(n log n), where n is the size of the input array. We perform n operations of adding and removing elements from a priority queue, each of which takes log n time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nSpace complexity: O(n), where n is the size of the input array. We need to store all elements of the input array in the priority queue.\\n\\nplease upvote if you find the soultion helpful.\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int minDeviation = Integer.MAX_VALUE;\\n        int minNum = Integer.MAX_VALUE;\\n        \\n        // Multiply all odd numbers by 2 and add to heap\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num *= 2;\\n            }\\n            pq.add(num);\\n            minNum = Math.min(minNum, num);\\n        }\\n        \\n        // Keep dividing maximum element by 2 until it becomes odd\\n        while (true) {\\n            int maxNum = pq.poll();\\n            minDeviation = Math.min(minDeviation, maxNum - minNum);\\n            \\n            if (maxNum % 2 == 1) {\\n                break;\\n            }\\n            maxNum /= 2;\\n            pq.add(maxNum);\\n            minNum = Math.min(minNum, maxNum);\\n        }\\n        \\n        return minDeviation;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int minDeviation = Integer.MAX_VALUE;\\n        int minNum = Integer.MAX_VALUE;\\n        \\n        // Multiply all odd numbers by 2 and add to heap\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num *= 2;\\n            }\\n            pq.add(num);\\n            minNum = Math.min(minNum, num);\\n        }\\n        \\n        // Keep dividing maximum element by 2 until it becomes odd\\n        while (true) {\\n            int maxNum = pq.poll();\\n            minDeviation = Math.min(minDeviation, maxNum - minNum);\\n            \\n            if (maxNum % 2 == 1) {\\n                break;\\n            }\\n            maxNum /= 2;\\n            pq.add(maxNum);\\n            minNum = Math.min(minNum, maxNum);\\n        }\\n        \\n        return minDeviation;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223622,
                "title": "golang-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Golang implementation of official solution from https://leetcode.com/problems/minimize-deviation-in-array/editorial/\\n\\n# Code\\n```\\ntype IntHeap []int\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\nfunc (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc minimumDeviation(nums []int) int {\\n    n, minNum, deviation := len(nums), math.MaxInt32, math.MaxInt32\\n    h := make(IntHeap, n)\\n    for i := range nums {\\n        if nums[i] % 2 == 0 {\\n            h[i] = nums[i]\\n        } else {\\n            h[i] = nums[i] * 2\\n        }\\n        minNum = min(minNum, h[i])\\n    }\\n\\theap.Init(&h)\\n    for {\\n        maxNum := heap.Pop(&h).(int)\\n        deviation = min(deviation, maxNum - minNum)\\n        if maxNum % 2 == 1 {\\n            break\\n        }\\n        maxNum >>= 1\\n        heap.Push(&h, maxNum)\\n        minNum = min(minNum, maxNum)\\n    }\\n    return deviation\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype IntHeap []int\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\nfunc (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc minimumDeviation(nums []int) int {\\n    n, minNum, deviation := len(nums), math.MaxInt32, math.MaxInt32\\n    h := make(IntHeap, n)\\n    for i := range nums {\\n        if nums[i] % 2 == 0 {\\n            h[i] = nums[i]\\n        } else {\\n            h[i] = nums[i] * 2\\n        }\\n        minNum = min(minNum, h[i])\\n    }\\n\\theap.Init(&h)\\n    for {\\n        maxNum := heap.Pop(&h).(int)\\n        deviation = min(deviation, maxNum - minNum)\\n        if maxNum % 2 == 1 {\\n            break\\n        }\\n        maxNum >>= 1\\n        heap.Push(&h, maxNum)\\n        minNum = min(minNum, maxNum)\\n    }\\n    return deviation\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3223572,
                "title": "rust-elixir-max-heap-solution",
                "content": "# Approach\\n1. multiply all odd elements in `nums` by 2, and then put all elements into a max heap.\\n2. Repeatedly extract the largest element, divide by 2, and put back into the heap, while keeping track of the minimum element and the minimum deviation (ie. answer).\\n3. Do 2. until the largest element cannot be divided by 2 (is odd).\\n# Rust\\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let mut low = i32::MAX;\\n        let mut heap = BinaryHeap::with_capacity(nums.len());\\n        for mut x in nums.into_iter() {\\n            if x & 1 == 1 {\\n                x <<= 1;\\n            }\\n            low = low.min(x);\\n            heap.push(x);\\n        }\\n        let mut ans = i32::MAX;\\n        loop {\\n            let high = heap.pop().unwrap();\\n            ans = ans.min(high - low);\\n            if high & 1 == 1 {\\n                break ans;\\n            }\\n            low = low.min(high >> 1);\\n            heap.push(high >> 1);\\n        }\\n    }\\n}\\n```\\n# Elixir\\nA `:gb_sets` is used instead of a heap.\\n```elixir\\ndefmodule Solution do\\n  @spec minimum_deviation(nums :: [integer]) :: integer\\n  def minimum_deviation(nums) do\\n    {nums, low} =\\n      Enum.map_reduce(nums, nil, fn x, low ->\\n        if rem(x, 2) == 0 do\\n          {x, min(low, x)}\\n        else\\n          {x * 2, min(low, x * 2)}\\n        end\\n      end)\\n    :gb_sets.from_list(nums)\\n    |> solve(low, nil)\\n  end\\n\\n  defp solve(set, low, ans) do\\n    {high, set} = :gb_sets.take_largest(set)\\n    ans = min(ans, high - low)\\n    if rem(high, 2) == 0 do\\n      half = div(high, 2)\\n      :gb_sets.add(half, set)\\n      |> solve(min(low, half), ans)\\n    else\\n      ans\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Heap (Priority Queue)"
                ],
                "code": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let mut low = i32::MAX;\\n        let mut heap = BinaryHeap::with_capacity(nums.len());\\n        for mut x in nums.into_iter() {\\n            if x & 1 == 1 {\\n                x <<= 1;\\n            }\\n            low = low.min(x);\\n            heap.push(x);\\n        }\\n        let mut ans = i32::MAX;\\n        loop {\\n            let high = heap.pop().unwrap();\\n            ans = ans.min(high - low);\\n            if high & 1 == 1 {\\n                break ans;\\n            }\\n            low = low.min(high >> 1);\\n            heap.push(high >> 1);\\n        }\\n    }\\n}\\n```\n```elixir\\ndefmodule Solution do\\n  @spec minimum_deviation(nums :: [integer]) :: integer\\n  def minimum_deviation(nums) do\\n    {nums, low} =\\n      Enum.map_reduce(nums, nil, fn x, low ->\\n        if rem(x, 2) == 0 do\\n          {x, min(low, x)}\\n        else\\n          {x * 2, min(low, x * 2)}\\n        end\\n      end)\\n    :gb_sets.from_list(nums)\\n    |> solve(low, nil)\\n  end\\n\\n  defp solve(set, low, ans) do\\n    {high, set} = :gb_sets.take_largest(set)\\n    ans = min(ans, high - low)\\n    if rem(high, 2) == 0 do\\n      half = div(high, 2)\\n      :gb_sets.add(half, set)\\n      |> solve(min(low, half), ans)\\n    else\\n      ans\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3223544,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        use std::collections::*;\\n        let mut heap = BinaryHeap::new();\\n        let mut result = i32::MAX;\\n        let mut min_n = i32::MAX;\\n        for i in 0..nums.len() {\\n            let n = if nums[i] % 2 == 0 {\\n                nums[i]\\n            } else {\\n                nums[i] * 2\\n            };\\n            min_n = min_n.min(n);\\n            heap.push(n);\\n        }\\n        while heap.peek().unwrap() % 2 == 0 {\\n            let &top = heap.peek().unwrap();\\n            result = result.min(top - min_n);\\n            let divided = top / 2;\\n            min_n = min_n.min(divided);\\n            heap.push(divided);\\n            heap.pop();\\n        }\\n        result.min(heap.peek().unwrap() - min_n)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        use std::collections::*;\\n        let mut heap = BinaryHeap::new();\\n        let mut result = i32::MAX;\\n        let mut min_n = i32::MAX;\\n        for i in 0..nums.len() {\\n            let n = if nums[i] % 2 == 0 {\\n                nums[i]\\n            } else {\\n                nums[i] * 2\\n            };\\n            min_n = min_n.min(n);\\n            heap.push(n);\\n        }\\n        while heap.peek().unwrap() % 2 == 0 {\\n            let &top = heap.peek().unwrap();\\n            result = result.min(top - min_n);\\n            let divided = top / 2;\\n            min_n = min_n.min(divided);\\n            heap.push(divided);\\n            heap.pop();\\n        }\\n        result.min(heap.peek().unwrap() - min_n)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3223530,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n)) ?$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::with_capacity(nums.len());\\n        let (mut min, mut ans) = (i32::MAX, i32::MAX);\\n        for mut num in nums {\\n            num = if num % 2 == 0 { num } else { num * 2 };\\n            min = i32::min(min, num);\\n            heap.push(num);\\n        }\\n\\n        while let Some(mut v) = heap.pop()  {\\n            if v % 2 == 1 {\\n                return i32::min(ans, v - min);\\n            } else {\\n                ans = i32::min(ans, v - min);\\n                v /= 2;\\n                min = i32::min(min, v);\\n                heap.push(v);\\n            }\\n        }\\n\\n        3 // Will never reach here\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::with_capacity(nums.len());\\n        let (mut min, mut ans) = (i32::MAX, i32::MAX);\\n        for mut num in nums {\\n            num = if num % 2 == 0 { num } else { num * 2 };\\n            min = i32::min(min, num);\\n            heap.push(num);\\n        }\\n\\n        while let Some(mut v) = heap.pop()  {\\n            if v % 2 == 1 {\\n                return i32::min(ans, v - min);\\n            } else {\\n                ans = i32::min(ans, v - min);\\n                v /= 2;\\n                min = i32::min(min, v);\\n                heap.push(v);\\n            }\\n        }\\n\\n        3 // Will never reach here\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3223485,
                "title": "most-readable-and-simple-c-code-using-set",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n\\n        int N = nums.size();\\n        set<int> s;\\n        for(int i = 0; i < N; i++) {\\n\\n            if (nums[i] & 1) {\\n                s.insert(nums[i] * 2);\\n            }\\n\\n            else {\\n                s.insert(nums[i]);\\n            }\\n        }\\n\\n        int cur_diff = *s.rbegin() - *s.begin();\\n\\n        while (*s.rbegin() % 2 == 0)\\n        {\\n            int div_eve = *s.rbegin();\\n            s.erase(div_eve);\\n            div_eve = div_eve / 2;\\n            s.insert(div_eve);\\n            \\n            cur_diff = min(cur_diff, *s.rbegin() - *s.begin());\\n        }\\n\\n        return cur_diff;\\n        \\n    }\\n};\\n```\\n\\nOther way of writing cur_diff: `distance(s.begin(), s.rbegin().base())`",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeviation(vector<int>& nums) {\\n\\n        int N = nums.size();\\n        set<int> s;\\n        for(int i = 0; i < N; i++) {\\n\\n            if (nums[i] & 1) {\\n                s.insert(nums[i] * 2);\\n            }\\n\\n            else {\\n                s.insert(nums[i]);\\n            }\\n        }\\n\\n        int cur_diff = *s.rbegin() - *s.begin();\\n\\n        while (*s.rbegin() % 2 == 0)\\n        {\\n            int div_eve = *s.rbegin();\\n            s.erase(div_eve);\\n            div_eve = div_eve / 2;\\n            s.insert(div_eve);\\n            \\n            cur_diff = min(cur_diff, *s.rbegin() - *s.begin());\\n        }\\n\\n        return cur_diff;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148690,
                "title": "easy-explanation-java-solution",
                "content": "**Method 1: Using Priority Queue**\\nFirst we store the elements of the array in a priority queue in decreasing order. If the element is odd, double it and store in the \\'pq\\'. Also keep a note of minimum element in the array.\\nThen we find the difference and to make the difference minimum, reduce the maximum element by half until it remains even.\\nAt last, return the minimum of \\'diff\\' and the difference of maximum element of \\'pq\\' and \\'min\\'\\n\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b-a);\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i : nums) {\\n            if(i%2 == 1)\\n                i *= 2;\\n            min = Math.min(min, i);\\n            pq.add(i);\\n        }\\n        \\n        int diff = Integer.MAX_VALUE;\\n        while(pq.peek()%2 == 0) {\\n            int max = pq.remove();\\n            diff = Math.min(diff, max-min);\\n            min = Math.min(min, max/2);\\n            pq.add(max/2);\\n        }\\n        \\n        return Math.min(diff, pq.peek()-min);\\n    }\\n}\\n```\\n\\nTime complexity: O(n(log(n))(log(m)))        [m --> highest value in the array]\\nSpace complexity: O(n)\\n\\n\\n\\n\\n**Method 2: Using Tree Set**\\nFirst we store the elements of the array in a Tree Set. If the element is odd, double it and store in the \\'pq\\'.\\nThen we find the difference between maximum and minimum element. Then to make the difference minimum, we reduce the maximum element by half if it is even else return the difference.\\n\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> ts = new TreeSet<>();        \\n        \\n        for(int i : nums) {\\n            if(i%2 == 1)\\n                i *= 2;            \\n            ts.add(i);\\n        }\\n        \\n        int diff = Integer.MAX_VALUE;\\n        while(true) {\\n            int max = ts.last();\\n            int min = ts.first();\\n            diff = Math.min(diff, max-min);\\n            if(max%2 == 0) {\\n                ts.remove(max);\\n                ts.add(max/2);\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return diff;\\n    }\\n}\\n```\\n\\nTime complexity: O(n(log(n))(log(m)))        [m --> highest value in the array]\\nSpace complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b-a);\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i : nums) {\\n            if(i%2 == 1)\\n                i *= 2;\\n            min = Math.min(min, i);\\n            pq.add(i);\\n        }\\n        \\n        int diff = Integer.MAX_VALUE;\\n        while(pq.peek()%2 == 0) {\\n            int max = pq.remove();\\n            diff = Math.min(diff, max-min);\\n            min = Math.min(min, max/2);\\n            pq.add(max/2);\\n        }\\n        \\n        return Math.min(diff, pq.peek()-min);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> ts = new TreeSet<>();        \\n        \\n        for(int i : nums) {\\n            if(i%2 == 1)\\n                i *= 2;            \\n            ts.add(i);\\n        }\\n        \\n        int diff = Integer.MAX_VALUE;\\n        while(true) {\\n            int max = ts.last();\\n            int min = ts.first();\\n            diff = Math.min(diff, max-min);\\n            if(max%2 == 0) {\\n                ts.remove(max);\\n                ts.add(max/2);\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1812872,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812567,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812677,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812801,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812953,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812564,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812581,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566023,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812563,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566703,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812872,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812567,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812677,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812801,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812953,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812564,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812581,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566023,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1812563,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566703,
                "content": [
                    {
                        "username": "imprayas12",
                        "content": "Today\\'s leetcode challenge: Find discussion tab"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Mansur121",
                        "content": "[@victorpichugov](/victorpichugov) liked this comment....."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Difficulty: Insane"
                    },
                    {
                        "username": "vin36",
                        "content": "Why on earth has the discussion section been moved down here?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "to get more premium users and more money obviously"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "GG to those who found discussions tab by themselves"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "GG to me \\uD83D\\uDE0E"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro I legit thought they removed the discussion tab lol"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i thought they put it behind a paywall for a sec lmao"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Problem: Find discussion section\nDifficulty: <b><span style='color:red'>VERY HARD</span></b>"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "How did you colored that in markdown?"
                    },
                    {
                        "username": "DKXVRT",
                        "content": "winter has arrived"
                    },
                    {
                        "username": "AKGamez",
                        "content": "Its time to get ready for the battle, comrade"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "??? wdym"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'m hoping I can solve the problem faster than I found the discussion section.... Otherwise my streak may die today."
                    },
                    {
                        "username": "flyg",
                        "content": "For 2nd test case, [4,1,5,20,3]. If 20 can transform to 5 by two operations, why can\\'t we mutiply 1 twice, it would become [4,4,5,5,3], then min dev would be 2. Isn\\'t that allowed?"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "This wording is VERY poor! Even the first hint makes it sound like you can repeatedly multiply by 2:\n\n    Hint 1: Assume you start with the minimum possible value\n    for each number so you can only multiply a number by 2\n    till it reaches its maximum possible value."
                    },
                    {
                        "username": "user8203f",
                        "content": "[@Lubron](/Lubron)  thank you, this reply help me a lot"
                    },
                    {
                        "username": "Lubron",
                        "content": "Because only odd number can be multiply by 2. 1 can only turn in to 2, or back to 1, not 4"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "another red day"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimize-deviation-in-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation + Heap\n\n  \n**Approach 2:** Pretreatment + Sorting + Sliding Window\n\n  \n**Approach 3:** Pretreatment + Heap + Sliding Window\n\n  \n**Approach 4:** Pretreatment + Heap + Pointers\n\n  \n**Approach 5:** Pretreatment + Sorting + Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1813469,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1813168,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1812984,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1812806,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1813415,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1813191,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1747486,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1813280,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1813198,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1813190,
                "content": [
                    {
                        "username": "133T_C0D3R",
                        "content": "For a moment I thought discussion is now a premium content."
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Am I the only one who gets annoyed by the way how some problems are changing definitions of the mathematical terms? \\uD83E\\uDD14\\n\\nThe maximum difference between any two elements is called **range**, deviation is a completely different thing \\uD83D\\uDE48"
                    },
                    {
                        "username": "meteogish",
                        "content": "Agree. \nAnd also, it has a bad effect. If you didn't know the meaning before now you think you know, what does it mean but it's wrong.                                                          "
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "Approach for this Problem:\\n\\nCreate a max heap and a variable to keep track of the minimum value in the array.\\nFor each number in the input array, if it is odd, multiply it by 2 and push it onto the heap. Otherwise, just push it onto the heap.\\nAlso, update the minimum value if necessary.\\nInitialize a variable to keep track of the minimum deviation.\\nWhile the maximum value in the heap is even, pop it off the heap, divide it by 2, and push it back onto the heap. Update the minimum deviation and the minimum value if necessary.\\nIf the maximum value in the heap is odd, we cannot reduce it any further by dividing by 2. In this case, break out of the loop.\\nReturn the minimum deviation.\\n\\nHope it helps\\uD83C\\uDF1D"
                    },
                    {
                        "username": "kandiana",
                        "content": "[@dsacj](/dsacj) \\nbut we then get all possible max values and start to decrease them, while hint says to get all possible min values and increase them.\\n\\nstill, I think I kind of start to understand why upproach with min values could work..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@KhacLong](/KhacLong) Since we want to minimize the deviation, it makes sense to try to reduce the difference between the maximum and minimum values as much as possible. Multiplying an odd number by 2 makes it even, which allows us to further reduce the maximum value of the array by dividing it by 2 in the subsequent steps.\\nSo, by multiplying odd elements by 2, we are effectively reducing the maximum value of the array, which in turn reduces the deviation."
                    },
                    {
                        "username": "malu137",
                        "content": "Thanks for the approach! Was able to solve this after many trials"
                    },
                    {
                        "username": "dsacj",
                        "content": "[@kandiana](/kandiana) In changing the odd values to even , aren\\'t we doing exactly what the hint asks us to do ? "
                    },
                    {
                        "username": "KhacLong",
                        "content": "can u explain why we need multi odd elements by 2 before pushing it\\n"
                    },
                    {
                        "username": "kandiana",
                        "content": "My idea was similar to yours: start with max values and decrease them while it\\'s possible. And it worked (:\\n\\nHints suggest to start with min values and multiply them, but I still have no idea, how to  implement this..."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is this question designed by Brock Lesnar? Because looks like it is going to break my streak today."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain cant handle more than 2 reds in a row pls Leetcode"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nWe create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.\\n\\nWe iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.\\n\\nWe initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.\\n\\nOnce we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "this is too confusing wording for me"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code If Anyone Want to check it:\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3225119/onlogn-solution-with-approach/"
                    },
                    {
                        "username": "nadeem",
                        "content": "1. To decrease the deviation either increase the minn or decrease the maxx.\n2. Now, Make every number as maximum as possible to eliminate one operation(increase the minn)\n3. since every element is as maximum as possible , you can not increase any number further\n4. Now we are left with just one operation decrease the maxx\n5. So perform this operation as many times as u can and keep track of the min_deviation\n\nNot sure if the solution is correct  using the algo suggested consider [1,3,8,9,17] of using priority queue or set\nso going by the transformation it becomes  he 1.Convert the odd to even ==> 2,6,8,18,34 == > after division by 2 ==> 34 becomes 17 so now max is 18 \n=> divide 18 /2 => 9 \n=> so finally the array is the following ==> 2,6,8,9,17 ==> and the ans is 15 \n\nnow looking at this input we could multiple by 2 , 2 times ==> 8 , 6,8,9,17 ==> 11 which should be the correct answer , anything is missing in the solution ?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "[@Brosario](/Brosario) Its not only by \"this\" logic. Although the question says that you can apply the operations on odd number, any number of times but since the odd number would become even after multiplication with 2 so essentially you can just apply this operation <i>once</i>."
                    },
                    {
                        "username": "Brosario",
                        "content": "You can only multiply odd numbers by 2. Once you multiply 1 by 2 a single time it will be 2 and thus be even and cannot be multiplied. By this logic all odd numbers can only be multiplied once."
                    },
                    {
                        "username": "never_quit_trying",
                        "content": "Guys, I got the discussion tab by accident and the best thing is i am not looking for it\\n"
                    },
                    {
                        "username": "vroy651",
                        "content": "same "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Problem Be Like : Can someone discuss me in the discuss tab instead of discussing about discussion tab."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Me after finally solving this question after so much efforts\\n![img](https://media.tenor.com/IrPvKoyAfmsAAAAC/master-oogway-kung-fu-panda.gif)"
                    }
                ]
            },
            {
                "id": 1813086,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1813059,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1813058,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1813048,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1812849,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1812812,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1812684,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1818715,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1813503,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1813436,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Ohh.. So here this bish was hiding"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "me to constraints dekhne aaya tha   "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "I was going to see the tag and found the discussion."
                    },
                    {
                        "username": "trpaslik",
                        "content": "PRO-TIP: If you are looking for the discussion tab, here it is. \\uD83D\\uDE43"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "The intuition behind this logic is to reduce the maximum difference between any two elements in the array by either decreasing the maximum value or increasing the minimum value.\\n\\nBy transforming all odd numbers to even numbers, we can always divide even numbers by 2, so the maximum value in the array can be reduced to its minimum possible value. We also keep track of the minimum value in the array, since we can only increase it by multiplying it by 2.\\n\\nWe then repeatedly pop the maximum value from the priority queue, which guarantees that we are always reducing the maximum value in the array. If the maximum value is odd, we can no longer divide it by 2, so we break out of the loop. Otherwise, we divide the maximum value by 2, which reduces the maximum value, and update the minimum value accordingly.\\n\\nBy doing this repeatedly, we can always reduce the maximum difference between any two elements in the array, and we keep track of the minimum deviation that we can achieve.\\n\\nPLEASE USE THE INTUITION TO SOLVE THE PROBLEM , IF NOT SOLVED THEN YOU CAN FIND MY SOLUTION HERE :\\nhttps://leetcode.com/problems/minimize-deviation-in-array/solutions/3224014/java-heaps/"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "red bloody days are coming.....\\n\\nI was like man where is discussion it\\'s the only place where I can find some humor"
                    },
                    {
                        "username": "vijay202",
                        "content": "Why in the world discussion tab is moved to down, I thought for real I had to get a premium just to see discussion tab. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this using binary search??"
                    },
                    {
                        "username": "charonme",
                        "content": "spoiler alert, I didn\\'t understand the given hints at all, but the one hint that immediately enabled me to find a solution was the realization that if needed, we can always divide a number back to its original value after we double it at first. Sadly I didn\\'t come up with it myself despite it being quite obvious."
                    },
                    {
                        "username": "Yongbi",
                        "content": "First understand the question, then go straight to the solution section to see how to implement!! Just kidding.\n\n```\nThe goal is to close the gap between the minimum and maximum bounds of nums. \nYou can multiply an odd number by 2 to increase, or divide an even number by 2 for to decrease. \nWhat we need is to converge all the numbers to _the smallest possible interval_, and returning this value.\n```\n\n``` Heap[]\n# Heap and priority queue:\n1. Initialize a heap from the given nums by multiplying all odd numbers by 2 and keeping the even integers.\n Arrange the heap in such a way that we can track on the largest value (negative order). \n\n2. Track the minimum and maximum value of the newly created PQ queue.\nFor the initial value, maxN= -queue[0], minN=min(queue), mindeviation=maxN-minN\n\n3. Iteration: \nDivide the largest number until the largest number is odd (cannot be divided anymore), then break the loop.\nUpdate min if maxN/2<minN\nUpdate minimum gap: mindeviation=maxN-minN every loop.\n\n 4. Return mindeviation.\n\nImprovement: using set for repeat numbers in the initialization priority queue (1st step).\n```\n\n\n\nGood luck."
                    }
                ]
            },
            {
                "id": 1813311,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 1813082,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 1812875,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 1812647,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 2015049,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 1982877,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 1959710,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 1817613,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 1814241,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 1813972,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "RIP daily streak"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Everybody\\'s complaining about the Discussion tab,\\nNobody is talking about how hard the question is\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "You are a ui developer or worked in ui if you guessed the place of discussion tab , when not found"
                    },
                    {
                        "username": "seankala",
                        "content": "I feel like there should be a condition stating that you have to perform the operations at least once."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "The hint:\n*\"Greedy\" topic may mislead you. For any set of operations that leads to the minimal deviation, a monotonous (in terms of intermediate deviation) operation order may not exist.*\n\nE.g.: starting from \n[16, 18] deviation is 2,\nthe best you can achieve \n[8, 9] deviation  is 1.\nBut to get this [8, 9] you must go through either \n[16, 9] deviation 7 or \n[8, 18] deviation 10."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[29, 68, 3, 30, 8, 50, 75, 1, 45, 34]\\n```\\n\\n```\\n[14, 42, 91, 95, 63, 39, 84, 99, 32, 62, 1, 62, 14, 23, 56, 57, 44, 49, 5, 95]\\n```\\n\\n```\\n[18681, 19753, 42862, 6934, 16840, 48077, 87042, 6217, 54181, 21125, 78979, 79781, 3994, 35391, 69957, 24439, 9703, 81543, 33833, 25279]\\n```\\n\\nPython code to generate test cases:\\n\\n```\\nlength = 50000\\nmin_val = 1\\nmax_val = 1000000000\\narr = [random.randint(min_val, max_val) for _ in range(length)]\\njson_str = json.dumps(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Ashh_87",
                        "content": "why cant we use binary search in this??"
                    },
                    {
                        "username": "rammanoj",
                        "content": "I have been trying to solve this for quite some time now, the only way to minimize the deviation is to increase the minimum number and decrease the maximum number. \\n\\nI am finding maximum odd number in array in the below format:\\nfor i in nums:\\n  if i% 2== 0:\\n   t = value obtained by removing all 2\\'s from i\\n   mao = max(mao, t)\\n  else:\\n   mao = max(mao, i)\\n\\nAny even number can be reduced to a odd number.\\n\\n\\nNow to calculate the minimum number, \\nfor i in nums:\\n  if i% 2 == 0:\\n   mio = min(mio, i)\\n  else:\\n   mio = min(mio, 2*i) // i.e. multiplying odd no\\'s by 2 so that they could move right\\n\\n\\nreturn mao - mio \\n\\nshouldn\\'t this give correct answer ? if not why ?"
                    },
                    {
                        "username": "devjak",
                        "content": "I get WA on 73rd test case \\uD83E\\uDD72\\nAPPROACH:\\nuse a priority queue and push all elements in priority queue and if a number is odd then insert it after multiply by 2.\\nuntil my max element is even i check difference  between max and min and if it is decrease then change max with max/2.\\n\\n `    int minimumDeviation(vector<int>& nums) {\\n        long long mx=0,mn=1e11;\\n\\n        priority_queue<long long> pq;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            long long x=nums[i];\\n\\n            if(x%2)\\n                x*=2;\\n\\n            pq.push(x);\\n            mx=max(mx,x);\\n            mn=min(mn,x);\\n        }\\n\\n        long long diff=mx-mn;\\n\\n        while(1){\\n            long long topp=pq.top();\\n\\n            if(topp%2)\\n                break;\\n            \\n            pq.pop();\\n            long long nmx=max(pq.top(),topp/2);\\n            long long nmn=min(mn,topp/2);\\n\\n            if(nmx-nmn <= diff)\\n            {\\n                pq.push(topp/2);\\n                mx=nmx;\\n                mn=nmn;\\n                diff=mx-mn;\\n            }\\n\\n            else{  \\n                pq.push(topp); \\n                break;}\\n        }\\n\\n    return diff;\\n    }`\\n\\n"
                    },
                    {
                        "username": "bac2qh",
                        "content": "I feel like I have seen something very much like this about min gap between the max and min of an array where you can change some numbers. Anyone knows what I am talking about? So bugged.."
                    }
                ]
            },
            {
                "id": 1813546,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813544,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813507,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813476,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813440,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813420,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813413,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813385,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813350,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813332,
                "content": [
                    {
                        "username": "coderboi329",
                        "content": "i don\\'t understand example 3. \\n\\n```\\nInput: nums = [2,10,8]\\nOutput: 3\\n```\\n\\ncan\\'t you deviate it to [4, 5, 4] where the deviation would be 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@coderboi329](/coderboi329) You r forgot something:\n```\n[2,10,8] cant not transform to [4,5,4], \nbecause 2 is even, it only divide by 2, 2->1\n```"
                    },
                    {
                        "username": "lindy2076",
                        "content": "For anyone having a TIME LIMIT on 75th test with python:\\nAdd a simple check before looping through the heap: is the `heap[0] - min_elem == 0`? If so, `return 0`. :)"
                    },
                    {
                        "username": "toomis",
                        "content": "Did the timeout get increased? My solution timed out at 72/75 last night, but is now accepted without any changes. "
                    },
                    {
                        "username": "shubhankit101",
                        "content": "So basically we can apply as many operation as we can but only on 2 specific elements of an array. Once we start operating on them we can not start to apply any operation on a 3rd element?"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "lmao, i made it to the discussion tab, even better than placements xD"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "so finally after long time figured the code but again hit with Time Limit Exceeded for last few tests. It was the same for yesterday\\'s question.\\n\\nIs it even possible to get TLE with Javascript?"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "[@siegen1192](/siegen1192) thanks i did. i learned to splice and shift the value instead of sorting it every loop which was giving me TLE. am a beginner so this was good mental challenge."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Its time to click on the `s*l*t*on` tab my friend"
                    },
                    {
                        "username": "jperrin36",
                        "content": "shouldnt the second test case answer be 1? [4,2,5,5,3] after SOME OPERATIONS the min deviation would be 1?"
                    },
                    {
                        "username": "ZapTap",
                        "content": "Remember you can only double odds and only halve evens. So the lowest value (2) cannot be multiplied and the highest (5) can\\'t be divided."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "the description can be confusing and does not mean least diff between any 2 values . it means the difference between max value - and min value of an array. if you are thinking to do 3*2 = 6 and 6 - 5 =1, its not what they are asking. its 5 - 3 = 2."
                    },
                    {
                        "username": "Helalmajeed",
                        "content": "can I go with O(N ^ 4) for this problem?\\nand what is the maximum solution time complexity?"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "For those who are from future wondering why discussion about discussion tab is here. This day they changed placement of discussion from easily visible position to bottom for placing Editorial(Which is mostly behind paywall)"
                    },
                    {
                        "username": "jperrin36",
                        "content": "I legit thought they made discussion a premium feature, i was so heart broken at first"
                    }
                ]
            },
            {
                "id": 1813330,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            },
            {
                "id": 1813293,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            },
            {
                "id": 1813249,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            },
            {
                "id": 1813209,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            },
            {
                "id": 1813147,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            },
            {
                "id": 1813084,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            },
            {
                "id": 1813051,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            },
            {
                "id": 1813047,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            },
            {
                "id": 1813002,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            },
            {
                "id": 1812966,
                "content": [
                    {
                        "username": "doublebean",
                        "content": "Why is every solution multiplying the odd number first? What if the odd number is the maximum and by multiplying it, we are increasing the deviation. It is not really an intuitive first step."
                    },
                    {
                        "username": "kandiana",
                        "content": "The idea is to perform only one type of operation while searching for the solution. Hence we either need to start with all possible max values and then decrease them step by step while updating the answer or we need to start with all possible min values and then increase them step by step while updating the answer.\n\nSince it is easy to understand when we have to stop decreasing (when number is odd we can't divide it anymore and need to break out of the cycle), a lot of people suggest to start with all possible max values. For that we need to multiply odd values.\n\nFor the case when odd value is the max, let's consider this example:\n[2,4,5]\n- first we change it to [2,4,10]\n- then we take out max value (10), calculate current answer (10 - 2 = 8). The value is even, so we can divide value by 2 and put it back - [2,4,5]\n- then we take out max value (5), calculate new current answer (min(8, 5 - 2) = 3). The value is odd, so we can't divide it by 2 and cycle stops here\n- then we return  3"
                    },
                    {
                        "username": "Mostafa_Zahran",
                        "content": "TestCase 75 is just  nums= \\nand its TLE\\nWTF !!\\nCould someone help me?"
                    },
                    {
                        "username": "ne_anasteisha",
                        "content": "Could anyone explain to me why I faled test 8 where [9,4,3,6,2] is given. \\nThe right answer id 7. But innitialy 9 - 6 = 3 is less then 7. "
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "initially it is 9-2 = 7, you have to do largest - smallest"
                    },
                    {
                        "username": "Subh001",
                        "content": "after 10 hours i am able to find discussion tab myself, i thought need premium to get it"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Turns out the discussion section still exists! "
                    },
                    {
                        "username": "lolopat2",
                        "content": "I finally found discussion tab"
                    },
                    {
                        "username": "masterphil",
                        "content": "I, for one, like the new place for the discussion section as I don\\'t have to navigate away from the problem description. All I would change now is the title of the tab from \\'Description\\' to \\'Problem\\' or something like that."
                    },
                    {
                        "username": "Umair9912",
                        "content": "has the discussion section moved down here for only premium problems?\\n"
                    },
                    {
                        "username": "gaurav98yadav",
                        "content": "my initial idea was to store elements in the tree set, get the min and max, if min is odd, make it even, if max is even, make it odd.\\nfind the diff b/w min and max in each iteration\\nif prev iteration\\'s diff is lesser than current iteration\\'s diff, then break.\\n\\nit passed 65/75 but it seems like we need to keep doubling the smallest, and reducing the highest irrespective of the diff value. we need to do it until we cant do it anymore"
                    },
                    {
                        "username": "watsize",
                        "content": "Did I miss something ?\\n\\nCase 1:\\n- nums = [136,465,87]\\n- expected = 329\\n\\nthe expected, is that comes from 465-136 = 329 ? why it can be that?\\n\\n===\\n\\nCase 2:\\n- nums = [10,4,3]\\n- expected = 2\\n\\n> [10, 4, 3]\\n> [5, 4, 3]\\n> 5 - 3 = 2 (as the expected)\\n\\nbut, can i do this instead?\\n> 3 (odd) * 2 = 6 then 6 - 5 = 1 is it the minimum deviation huh?\\n\\nThanks advance."
                    },
                    {
                        "username": "rm-rf",
                        "content": "Case 1:\n[136, 465, 87] → [136, 465, 174], the minimum deviation = 465 - 136.\n\nCase 2:\nIn this case, if [10,4,3] → [5,4,6], then the minimum deviation should also be 6-4 = 2, not 1."
                    }
                ]
            }
        ]
    }
]