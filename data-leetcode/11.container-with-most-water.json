[
    {
        "title": "Container With Most Water",
        "question_content": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\n&nbsp;\nExample 1:\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tn == height.length\n\t2 <= n <= 105\n\t0 <= height[i] <= 104",
        "solutions": [
            {
                "id": 6100,
                "title": "simple-and-clear-proof-explanation",
                "content": "I've seen some \"proofs\" for the common O(n) solution, but I found them very confusing and lacking. Some even didn't explain anything but just used lots of variables and equations and were like \"Tada! See?\". I think mine makes more sense:\\n\\n**Idea / Proof:**\\n\\n 1. The widest container (using first and last line) is a good candidate, because of its width. Its water level is the height of the smaller one of first and last line.\\n 2. All other containers are less wide and thus would need a higher water level in order to hold more water.\\n 3. The smaller one of first and last line doesn't support a higher water level and can thus be safely removed from further consideration.\\n\\n**Implementation:** (Python)\\n\\n    class Solution:\\n        def maxArea(self, height):\\n            i, j = 0, len(height) - 1\\n            water = 0\\n            while i < j:\\n                water = max(water, (j - i) * min(height[i], height[j]))\\n                if height[i] < height[j]:\\n                    i += 1\\n                else:\\n                    j -= 1\\n            return water\\n\\n**Further explanation:**\\n\\nVariables `i` and `j` define the container under consideration. We initialize them to first and last line, meaning the widest container. Variable `water` will keep track of the highest amount of water we managed so far. We compute `j - i`, the width of the current container, and `min(height[i], height[j])`, the water level that this container can support. Multiply them to get how much water this container can hold, and update `water` accordingly. Next remove the smaller one of the two lines from consideration, as justified above in \"Idea / Proof\". Continue until there is nothing left to consider, then return the result.",
                "solutionTags": [],
                "code": "I've seen some \"proofs\" for the common O(n) solution, but I found them very confusing and lacking. Some even didn't explain anything but just used lots of variables and equations and were like \"Tada! See?\". I think mine makes more sense:\\n\\n**Idea / Proof:**\\n\\n 1. The widest container (using first and last line) is a good candidate, because of its width. Its water level is the height of the smaller one of first and last line.\\n 2. All other containers are less wide and thus would need a higher water level in order to hold more water.\\n 3. The smaller one of first and last line doesn't support a higher water level and can thus be safely removed from further consideration.\\n\\n**Implementation:** (Python)\\n\\n    class Solution:\\n        def maxArea(self, height):\\n            i, j = 0, len(height) - 1\\n            water = 0\\n            while i < j:\\n                water = max(water, (j - i) * min(height[i], height[j]))\\n                if height[i] < height[j]:\\n                    i += 1\\n                else:\\n                    j -= 1\\n            return water\\n\\n**Further explanation:**\\n\\nVariables `i` and `j` define the container under consideration. We initialize them to first and last line, meaning the widest container. Variable `water` will keep track of the highest amount of water we managed so far. We compute `j - i`, the width of the current container, and `min(height[i], height[j])`, the water level that this container can support. Multiply them to get how much water this container can hold, and update `water` accordingly. Next remove the smaller one of the two lines from consideration, as justified above in \"Idea / Proof\". Continue until there is nothing left to consider, then return the result.",
                "codeTag": "Java"
            },
            {
                "id": 6099,
                "title": "yet-another-way-to-see-what-happens-in-the-o-n-algorithm",
                "content": "The O(n) solution with proof by contradiction doesn\\'t look intuitive enough to me. Before moving on, read any [example](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) of the algorithm first if you don\\'t know it yet.\\n\\nHere\\'s another way to see what happens in a matrix representation:\\n\\nDraw a matrix where rows correspond to the position of the left line, and columns corresponds to the position of the right line.\\n\\nFor example, say `n=6`. Element at `(2,4)` would corresponds to the case where the left line is at position `2` and the right line is at position `4`. The value of the element is the volume for the case.\\n\\nIn the figures below, `x` means we don\\'t need to compute the volume for that case, because:\\n1. on the diagonal, the two lines are overlapped;\\n2. the lower left triangle area of the matrix, the two lines are switched and the case is symmetric to the upper right area.\\n\\nWe start by computing the volume at `(1,6)`, denoted by `o`. Now if the left line is shorter than the right line, then moving the right line towards left would only decrease the volume, so all the elements left to `(1,6)` on the first row have smaller volume. Therefore, we don\\'t need to compute those cases (crossed by `---`).\\n \\n\\n      1 2 3 4 5 6\\n    1 x ------- o\\n    2 x x\\n    3 x x x \\n    4 x x x x\\n    5 x x x x x\\n    6 x x x x x x\\n\\nSo we can only move the left line towards right to `2` and compute `(2,6)`. Now if the right line is shorter, all cases below `(2,6)` are eliminated.\\n\\n      1 2 3 4 5 6\\n    1 x ------- o\\n    2 x x       o\\n    3 x x x     |\\n    4 x x x x   |\\n    5 x x x x x |\\n    6 x x x x x x\\nAnd no matter how this `o` path goes, we end up only need to find the max value on this path, which contains `n-1` cases.\\n\\n      1 2 3 4 5 6\\n    1 x ------- o\\n    2 x x - o o o\\n    3 x x x o | |\\n    4 x x x x | |\\n    5 x x x x x |\\n    6 x x x x x x\\nHope this helps. I feel more comfortable seeing things this way.",
                "solutionTags": [],
                "code": "The O(n) solution with proof by contradiction doesn\\'t look intuitive enough to me. Before moving on, read any [example](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) of the algorithm first if you don\\'t know it yet.\\n\\nHere\\'s another way to see what happens in a matrix representation:\\n\\nDraw a matrix where rows correspond to the position of the left line, and columns corresponds to the position of the right line.\\n\\nFor example, say `n=6`. Element at `(2,4)` would corresponds to the case where the left line is at position `2` and the right line is at position `4`. The value of the element is the volume for the case.\\n\\nIn the figures below, `x` means we don\\'t need to compute the volume for that case, because:\\n1. on the diagonal, the two lines are overlapped;\\n2. the lower left triangle area of the matrix, the two lines are switched and the case is symmetric to the upper right area.\\n\\nWe start by computing the volume at `(1,6)`, denoted by `o`. Now if the left line is shorter than the right line, then moving the right line towards left would only decrease the volume, so all the elements left to `(1,6)` on the first row have smaller volume. Therefore, we don\\'t need to compute those cases (crossed by `---`).\\n \\n\\n      1 2 3 4 5 6\\n    1 x ------- o\\n    2 x x\\n    3 x x x \\n    4 x x x x\\n    5 x x x x x\\n    6 x x x x x x\\n\\nSo we can only move the left line towards right to `2` and compute `(2,6)`. Now if the right line is shorter, all cases below `(2,6)` are eliminated.\\n\\n      1 2 3 4 5 6\\n    1 x ------- o\\n    2 x x       o\\n    3 x x x     |\\n    4 x x x x   |\\n    5 x x x x x |\\n    6 x x x x x x\\nAnd no matter how this `o` path goes, we end up only need to find the max value on this path, which contains `n-1` cases.\\n\\n      1 2 3 4 5 6\\n    1 x ------- o\\n    2 x x - o o o\\n    3 x x x o | |\\n    4 x x x x | |\\n    5 x x x x x |\\n    6 x x x x x x\\nHope this helps. I feel more comfortable seeing things this way.",
                "codeTag": "Unknown"
            },
            {
                "id": 6090,
                "title": "simple-and-fast-c-c-with-explanation",
                "content": "Start by evaluating the widest container, using the first and the last line. All other possible containers are less wide, so to hold more water, they need to be higher. Thus, after evaluating that widest container, skip lines at both ends that don't support a higher height. Then evaluate that new container we arrived at. Repeat until there are no more possible containers left.\\n\\n**C++**\\n\\n    int maxArea(vector<int>& height) {\\n        int water = 0;\\n        int i = 0, j = height.size() - 1;\\n        while (i < j) {\\n            int h = min(height[i], height[j]);\\n            water = max(water, (j - i) * h);\\n            while (height[i] <= h && i < j) i++;\\n            while (height[j] <= h && i < j) j--;\\n        }\\n        return water;\\n    }\\n\\n**C**\\n\\nA bit shorter and perhaps faster because I can use raw int pointers, but a bit longer because I don't have `min` and `max`.\\n\\n    int maxArea(int* heights, int n) {\\n        int water = 0, *i = heights, *j = i + n - 1;\\n        while (i < j) {\\n            int h = *i < *j ? *i : *j;\\n            int w = (j - i) * h;\\n            if (w > water) water = w;\\n            while (*i <= h && i < j) i++;\\n            while (*j <= h && i < j) j--;\\n        }\\n        return water;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Start by evaluating the widest container, using the first and the last line. All other possible containers are less wide, so to hold more water, they need to be higher. Thus, after evaluating that widest container, skip lines at both ends that don't support a higher height. Then evaluate that new container we arrived at. Repeat until there are no more possible containers left.\\n\\n**C++**\\n\\n    int maxArea(vector<int>& height) {\\n        int water = 0;\\n        int i = 0, j = height.size() - 1;\\n        while (i < j) {\\n            int h = min(height[i], height[j]);\\n            water = max(water, (j - i) * h);\\n            while (height[i] <= h && i < j) i++;\\n            while (height[j] <= h && i < j) j--;\\n        }\\n        return water;\\n    }\\n\\n**C**\\n\\nA bit shorter and perhaps faster because I can use raw int pointers, but a bit longer because I don't have `min` and `max`.\\n\\n    int maxArea(int* heights, int n) {\\n        int water = 0, *i = heights, *j = i + n - 1;\\n        while (i < j) {\\n            int h = *i < *j ? *i : *j;\\n            int w = (j - i) * h;\\n            if (w > water) water = w;\\n            while (*i <= h && i < j) i++;\\n            while (*j <= h && i < j) j--;\\n        }\\n        return water;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1915172,
                "title": "java-c-easiest-explanations",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e **Container With Most Water**\\n\\nOkay, so let\\'s understand what the problem statement is saying, \\n```\\nYou are given an integer array height of length n\\n\\nReturn the maximum amount of water a container can store.\\n```\\n\\nLet\\'s take one example in order to understand this problem,\\n**Input**: height = [1,8,6,2,5,4,8,3,7]\\n**Output**: 49\\n\\n![image](https://assets.leetcode.com/users/images/8e3e5a1c-7a11-401d-a4d7-03cce76fd7f3_1649120493.739683.png)\\n\\nSo, we need to find max area in which most water can contains, where **`area = width * height`**\\n\\nAs, **height** is already given in our Array!\\nBut what about **width?**\\n\\nSo, to find **width** of a container, all we have to do is get the difference of line.\\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t            ^                                       ^\\n```\\nSo, my one pointer is on index 1 & another pointer is on index 6\\n\\nTherefore, **`width = right - left`** i.e. **`6 - 1 => 5`**\\n\\nAnd if we look at height,\\n**`height = min(8, 8)`**\\nThus, area will be:-\\n**`area = 5 * 8 => 40`**\\n\\nNow you\\'ll ask why we are choosing the min height because, the water we fill in our container will got overflow, so to avoid that we are gabbing the min line.\\n\\nSo, now you ask. How do we solve this problem efficiently. We gonna solve this in linear time.\\n\\nSo, for that we have\\n```\\n> max area which is intially 0\\n> Then, we going to have 2 pointers. One in left start at 0th index & one right start from last index.\\n```\\n\\nNow, if I calculate the width & height our area will be:\\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 8 - 0 = 8\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(1, 7)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 8 * 1 = 8\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 0 -> max = 8\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t   ^                                                                ^\\n\\t  left                                                            right\\n```\\nBy this pretty much we have get one formula all it is **`area = width * height`**\\ni.e. **`area = (right - left) * min(height[left], height[right])`**\\n\\nSo, now you ask which pointer we suppose to move. It\\'s preety simple. We gonna move the smaller height pointer. **Why?**\\nBecause, we are trying to find very max. container\\n\\nIf we have smaller height on left or right we don\\'t care about it. We always want a higher height line on our left & right.\\n\\n**Okay, so now moving forward.** left pointer has smaller height, so it will move forward\\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 8 - 1 = 7\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(8, 7)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 7 * 7 = 49\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 8 -> max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t            ^                                                       ^\\n\\t           left                                                   right\\n```\\n**Okay, so now moving forward.** right pointer has smaller height, so it will move backward\\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 7 - 1 = 6\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(8, 3)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 6 * 3 = 18\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t            ^                                               ^\\n\\t           left                                           right\\n```\\n**Okay, so now moving forward.** right pointer has smaller height, so it will move backward\\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 6 - 1 = 5\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(8, 8)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 8 * 5 = 40\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t            ^                                       ^\\n\\t           left                                   right\\n```\\n**Okay, so now moving forward.**  now left & right pointer both have same height, so in this case we gonna move both the pointer\\'s!!\\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 5 - 2 = 3\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(4, 6)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 4 * 3 = 12\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t                    ^                       ^\\n\\t                   left                   right\\n```\\n**Okay, so now moving forward.** right pointer has smaller height, so it will move backward\\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 4 - 2 = 2\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(5, 6)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 5 * 2 = 10\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t                    ^               ^\\n\\t                   left           right\\n```\\n**Okay, so now moving forward.** right pointer has smaller height, so it will move backward\\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 3 - 2 = 1\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(2, 6)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 2 * 1 = 2\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t                    ^       ^\\n\\t                   left   right\\n```\\n\\nThe max area we get is **49**\\n\\nI hope so, ladies & gentlemen approach is clear, **Let\\'s code it**\\n\\n**Java**\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int max = 0;\\n        while(left < right){\\n            int w = right - left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = h * w;\\n            max = Math.max(max, area);\\n            if(height[left] < height[right]) left++;\\n            else if(height[left] > height[right]) right--;\\n            else {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxi = 0;\\n        while(left < right){\\n            int w = right - left;\\n            int h = min(height[left], height[right]);\\n            int area = h * w;\\n            maxi = max(maxi, area);\\n            if(height[left] < height[right]) left++;\\n            else if(height[left] > height[right]) right--;\\n            else {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space COmplexity :-** BigO(1)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nYou are given an integer array height of length n\\n\\nReturn the maximum amount of water a container can store.\\n```\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t            ^                                       ^\\n```\n```\\n> max area which is intially 0\\n> Then, we going to have 2 pointers. One in left start at 0th index & one right start from last index.\\n```\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 8 - 0 = 8\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(1, 7)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 8 * 1 = 8\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 0 -> max = 8\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t   ^                                                                ^\\n\\t  left                                                            right\\n```\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 8 - 1 = 7\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(8, 7)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 7 * 7 = 49\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 8 -> max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t            ^                                                       ^\\n\\t           left                                                   right\\n```\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 7 - 1 = 6\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(8, 3)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 6 * 3 = 18\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t            ^                                               ^\\n\\t           left                                           right\\n```\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 6 - 1 = 5\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(8, 8)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 8 * 5 = 40\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t            ^                                       ^\\n\\t           left                                   right\\n```\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 5 - 2 = 3\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(4, 6)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 4 * 3 = 12\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t                    ^                       ^\\n\\t                   left                   right\\n```\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 4 - 2 = 2\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(5, 6)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 5 * 2 = 10\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t                    ^               ^\\n\\t                   left           right\\n```\n```\\n8\\t\\t\\t\\t|\\t                                    |\\n7\\t\\t\\t\\t|\\t                                    |\\t            |                             width = 3 - 2 = 1\\n6\\t\\t\\t\\t|\\t    |\\t                            |\\t            |                             height = min(2, 6)\\n5\\t\\t\\t\\t|\\t    |\\t            |\\t            |\\t            |                             Area = 2 * 1 = 2\\n4\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t            |\\n3\\t\\t\\t\\t|\\t    |\\t            |\\t    |\\t    |\\t    |\\t    |                             max = 49\\n2\\t\\t\\t\\t|\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n1\\t   |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\t    |\\n       0        1       2       3       4       5       6       7       8\\n\\t                    ^       ^\\n\\t                   left   right\\n```\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int max = 0;\\n        while(left < right){\\n            int w = right - left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = h * w;\\n            max = Math.max(max, area);\\n            if(height[left] < height[right]) left++;\\n            else if(height[left] > height[right]) right--;\\n            else {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxi = 0;\\n        while(left < right){\\n            int w = right - left;\\n            int h = min(height[left], height[right]);\\n            int area = h * w;\\n            maxi = max(maxi, area);\\n            if(height[left] < height[right]) left++;\\n            else if(height[left] > height[right]) right--;\\n            else {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701708,
                "title": "best-method-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nThe two-pointer technique starts with the widest container and moves the pointers inward based on the comparison of heights. \\nIncreasing the width of the container can only lead to a larger area if the height of the new boundary is greater. By moving the pointers towards the center, we explore containers with the potential for greater areas.\\n\\n# Explanation:\\n1. Initialize the variables:\\n   - `left` to represent the left pointer, starting at the beginning of the container (index 0).\\n   - `right` to represent the right pointer, starting at the end of the container (index `height.size() - 1`).\\n   - `maxArea` to keep track of the maximum area found, initially set to 0.\\n\\n2. Enter a loop using the condition `left < right`, which means the pointers have not crossed each other yet.\\n\\n3. Calculate the current area:\\n   - Use the `min` function to find the minimum height between the `left` and `right` pointers.\\n   - Multiply the minimum height by the width, which is the difference between the indices of the pointers: `(right - left)`.\\n   - Store this value in the `currentArea` variable.\\n\\n4. Update the maximum area:\\n   - Use the `max` function to compare the `currentArea` with the `maxArea`.\\n   - If the `currentArea` is greater than the `maxArea`, update `maxArea` with the `currentArea`.\\n\\n5. Move the pointers inward: (Explained in detail below)\\n   - Check if the height at the `left` pointer is smaller than the height at the `right` pointer.\\n   - If so, increment the `left` pointer, moving it towards the center of the container.\\n   - Otherwise, decrement the `right` pointer, also moving it towards the center.\\n\\n6. Repeat steps 3 to 5 until the pointers meet (`left >= right`), indicating that all possible containers have been explored.\\n\\n7. Return the `maxArea`, which represents the maximum area encountered among all the containers.\\n\\n# Update the maximum area:\\nThe purpose of this condition is to determine which pointer to move inward, either the left pointer (`i`) or the right pointer (`j`), based on the comparison of heights at their respective positions.\\n\\nImagine you have two containers represented by the heights at the left and right pointers. The condition checks which container has a smaller height and moves the pointer corresponding to that container.\\n\\n1. If `height[i] > height[j]`:\\n   - This means that the height of the left container is greater than the height of the right container.\\n   - Moving the right pointer (`j`) would not increase the potential area because the height of the right container is the limiting factor.\\n   - So, to explore containers with the possibility of greater areas, we need to move the right pointer inward by decrementing `j`.\\n\\n2. If `height[i] <= height[j]`:\\n   - This means that the height of the left container is less than or equal to the height of the right container.\\n   - Moving the left pointer (`i`) would not increase the potential area because the height of the left container is the limiting factor.\\n   - So, to explore containers with the possibility of greater areas, we need to move the left pointer inward by incrementing `i`.\\n\\nBy making these pointer movements, we ensure that we are always exploring containers with the potential for larger areas. The approach is based on the observation that increasing the width of the container can only lead to a larger area if the height of the new boundary is greater.\\nBy following this condition and moving the pointers accordingly, the algorithm explores all possible containers and finds the one with the maximum area.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = Math.min(height[left], height[right]) * (right - left);\\n            maxArea = Math.max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height) - 1\\n        maxArea = 0\\n\\n        while left < right:\\n            currentArea = min(height[left], height[right]) * (right - left)\\n            maxArea = max(maxArea, currentArea)\\n\\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n        return maxArea\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/159f3912-a0d3-4723-a9d1-3a6a67e1450e_1688150480.977912.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = Math.min(height[left], height[right]) * (right - left);\\n            maxArea = Math.max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height) - 1\\n        maxArea = 0\\n\\n        while left < right:\\n            currentArea = min(height[left], height[right]) * (right - left)\\n            maxArea = max(maxArea, currentArea)\\n\\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n        return maxArea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6091,
                "title": "easy-concise-java-o-n-solution-with-proof-and-explanation",
                "content": "AKA, the general idea to find some max is to go through all cases where max value can possibly occur and keep updating the max value. The efficiency of the scan depends on the size of cases you plan to scan.\\nTo increase efficiency, all we need to do is to find a smart way of scan to cut off the useless cases and meanwhile 100% guarantee the max value can be reached through the rest of cases.\\n\\nIn this problem, the smart scan way is to set two pointers initialized at both ends of the array. Every time move the smaller value pointer to inner array. Then after the two pointers meet, all possible max cases have been scanned and the max situation is 100% reached somewhere in the scan. Following is a brief prove of this.\\n\\nGiven a1,a2,a3.....an as input array. Lets assume a10 and a20 are the max area situation. We need to prove that a10 can be reached by left pointer and during the time left pointer stays at a10, a20 can be reached by right pointer. That is to say, the core problem is to prove: when left pointer is at a10 and right pointer is at a21, the next move must be right pointer to a20. \\n\\nSince we are always moving the pointer with the smaller value, i.e. if a10 > a21, we should move pointer at a21 to a20, as we hope. Why a10 >a21? Because if a21>a10, then area of a10 and a20 must be less than area of a10 and a21. Because the area of a10 and a21 is at least height[a10] * (21-10) while the area of a10 and a20 is at most height[a10] * (20-10). So there is a contradiction of assumption a10 and a20 has the max area. So, a10 must be greater than a21, then next move a21 has to be move to a20. The max cases must be reached. \\n\\n    public int maxArea(int[] height) {\\n        int left = 0, right = height.length - 1;\\n\\t\\tint maxArea = 0;\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tmaxArea = Math.max(maxArea, Math.min(height[left], height[right])\\n\\t\\t\\t\\t\\t* (right - left));\\n\\t\\t\\tif (height[left] < height[right])\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tright--;\\n\\t\\t}\\n\\n\\t\\treturn maxArea;\\n    }",
                "solutionTags": [],
                "code": "AKA, the general idea to find some max is to go through all cases where max value can possibly occur and keep updating the max value. The efficiency of the scan depends on the size of cases you plan to scan.\\nTo increase efficiency, all we need to do is to find a smart way of scan to cut off the useless cases and meanwhile 100% guarantee the max value can be reached through the rest of cases.\\n\\nIn this problem, the smart scan way is to set two pointers initialized at both ends of the array. Every time move the smaller value pointer to inner array. Then after the two pointers meet, all possible max cases have been scanned and the max situation is 100% reached somewhere in the scan. Following is a brief prove of this.\\n\\nGiven a1,a2,a3.....an as input array. Lets assume a10 and a20 are the max area situation. We need to prove that a10 can be reached by left pointer and during the time left pointer stays at a10, a20 can be reached by right pointer. That is to say, the core problem is to prove: when left pointer is at a10 and right pointer is at a21, the next move must be right pointer to a20. \\n\\nSince we are always moving the pointer with the smaller value, i.e. if a10 > a21, we should move pointer at a21 to a20, as we hope. Why a10 >a21? Because if a21>a10, then area of a10 and a20 must be less than area of a10 and a21. Because the area of a10 and a21 is at least height[a10] * (21-10) while the area of a10 and a20 is at most height[a10] * (20-10). So there is a contradiction of assumption a10 and a20 has the max area. So, a10 must be greater than a21, then next move a21 has to be move to a20. The max cases must be reached. \\n\\n    public int maxArea(int[] height) {\\n        int left = 0, right = height.length - 1;\\n\\t\\tint maxArea = 0;\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tmaxArea = Math.max(maxArea, Math.min(height[left], height[right])\\n\\t\\t\\t\\t\\t* (right - left));\\n\\t\\t\\tif (height[left] < height[right])\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tright--;\\n\\t\\t}\\n\\n\\t\\treturn maxArea;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 200246,
                "title": "proof-by-formula",
                "content": "The max area is calculated by the following formula:\\n\\n```S = (j - i) * min(ai, aj)```\\n\\nWe should choose (i, j) so that S is max. Note that ```i, j``` go through the range (1, n) and j > i. That\\'s it.\\n\\nThe simple way is to take all possibilities of (i, j) and compare all obtained S. The time complexity is  ```n * (n-1) / 2```\\n\\nWhat we gonna do is to choose all possibilities of (i, j) in a wise way. I noticed that many submitted solutions here can\\'t explain why when :\\n* ```ai < aj``` we will check the next ```(i+1, j)``` (or move i to the right)\\n* ```ai >= aj``` we will check the next ```(i, j-1)``` (or move j to the left)\\n\\nHere is the explaination for that:\\n\\n* When ```ai < aj``` , we don\\'t need to calculate all ```(i, j-1)```, ```(i, j-2)```, .... Why? because these max areas are smaller than our S at ```(i, j)```\\n\\n**Proof**: Assume at ```(i, j-1)``` we have ```S\\'= (j-1-i) * min(ai, aj-1)```\\n```S\\'< (j-1-i) * ai < (j-i) * ai = S```, and when ```S\\'<S```, we don\\'t need to calculate\\nSimilar at ```(i, j-2)```, ```(i, j-3)```, etc.\\n\\nSo, that\\'s why when ```ai < aj```, we should check the next at ```(i+1, j)``` (or move i to the right)\\n\\n* When ```ai >= aj```, the same thing, all ```(i+1, j)```, ```(i+2, j)```, .... are not needed to calculate.\\n\\nWe should check the next at ```(i, j-1)``` (or move j to the left)\\n\\n```\\n\\t\\tint S = 0, i = 0, j = A.length -1;\\n        while (i < j) {\\n            S = Math.max(S, (j - i) * Math.min(A[i], A[j]));\\n            if (A[i] < A[j]) i++; else j--;\\n        }\\n        return S;\\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```S = (j - i) * min(ai, aj)```\n```i, j```\n```n * (n-1) / 2```\n```ai < aj```\n```(i+1, j)```\n```ai >= aj```\n```(i, j-1)```\n```ai < aj```\n```(i, j-1)```\n```(i, j-2)```\n```(i, j)```\n```(i, j-1)```\n```S\\'= (j-1-i) * min(ai, aj-1)```\n```S\\'< (j-1-i) * ai < (j-i) * ai = S```\n```S\\'<S```\n```(i, j-2)```\n```(i, j-3)```\n```ai < aj```\n```(i+1, j)```\n```ai >= aj```\n```(i+1, j)```\n```(i+2, j)```\n```(i, j-1)```\n```\\n\\t\\tint S = 0, i = 0, j = A.length -1;\\n        while (i < j) {\\n            S = Math.max(S, (j - i) * Math.min(A[i], A[j]));\\n            if (A[i] < A[j]) i++; else j--;\\n        }\\n        return S;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1069746,
                "title": "js-python-java-c-2-pointer-solution-w-visual-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nThe first thing we should realize is that the amount of water contained is always going to be a rectangle whose area is defined as **length * width**. The width of any container will be the difference between the index of the two lines (**i** and **j**), and the height will be whichever of the two sides is the lowest (**min(H[i], H[j])**).\\n\\nThe brute force approach would be to compare every single pair of indexes in **H**, but that would be far too slow. Instead, we can observe that if we start with the lines on the opposite ends and move inward, the only possible time the area could be larger is when the height increases, since the width will continuously get smaller.\\n\\nThis is very easily observed with the use of visuals. Let\\'s say we start with a graph of **H** like this:\\n\\n![Visual 1](https://i.imgur.com/2xU6MPx.png)\\n\\nThe first step would be to find our starting container described by the lines on either end:\\n\\n![Visual 2](https://i.imgur.com/bWpX3VY.png)\\n\\nWe can tell that the line on the right end will never make a better match, because any further match would have a smaller width and the container is already the maximum height that that line can support. That means that our next move should be to slide **j** to the left and pick a new line:\\n\\n![Visual 3](https://i.imgur.com/pcyUfzx.png)\\n\\nThis is a clear improvement over the last container. We only moved over one line, but we more than doubled the height. Now, it\\'s the line on the left end that\\'s the limiting factor, so the next step will be to slide **i** to the right. Just looking at the visual, however, it\\'s obvious that we can skip the next few lines because they\\'re already underwater, so we should go to the first line that\\'s larger than the current water height:\\n\\n![Visual 4](https://i.imgur.com/25MGHYY.png)\\n\\nThis time, it doesn\\'t look like we made much of a gain, despite the fact that the water level rose a bit, because we lost more in width than we made up for in height. That means that we always have to check at each new possible stop to see if the new container area is better than the current best. Just lik before we can slide **j** to the left again:\\n\\n![Visual 5](https://i.imgur.com/c4VBpqn.png)\\n\\nThis move also doesn\\'t appear to have led to a better container. But here we can see that it\\'s definitely possible to have to move the same side twice in a row, as the **j** line is still the lower of the two:\\n\\n![Visual 6](https://i.imgur.com/R6AAkNd.png)\\n\\nThis is obviously the last possible container to check, and like the last few before it, it doesn\\'t appear to be the best match. Still, we can understand that it\\'s entirely possible for the best container in a different example to be only one index apart, if both lines are extremely tall.\\n\\nPutting together everything, it\\'s clear that we need to make a **2-pointer sliding window solution**. We\\'ll start from either end and at each step we\\'ll check the container area, then we\\'ll shift the lower-valued pointer inward. Once the two pointers meet, we know that we must have exhausted all possible containers and we should **return** our answer (**ans**).\\n\\n---\\n\\n***Implementation:***\\n\\nJavascript was weirdly more performant when using both **Math.max()** and **Math.min()** rather than performing more basic comparisons, even with duplicated effort in the ternary.\\n\\nFor the other languages, it made more sense (and was ultimately more performant) to only have to do the basic comparisons once each.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 41.1MB** (beats 100% / 41%).\\n```javascript\\nvar maxArea = function(H) {\\n    let ans = 0, i = 0, j = H.length-1\\n    while (i < j) {\\n        ans = Math.max(ans, Math.min(H[i], H[j]) * (j - i))\\n        H[i] <= H[j] ? i++ : j--\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **140ms / 16.4MB** (beats 100% / 75%).\\n```python\\nclass Solution:\\n    def maxArea(self, H: List[int]) -> int:\\n        ans, i, j = 0, 0, len(H)-1\\n        while (i < j):\\n            if H[i] <= H[j]:\\n                res = H[i] * (j - i)\\n                i += 1\\n            else:\\n                res = H[j] * (j - i)\\n                j -= 1\\n            if res > ans: ans = res\\n        return ans\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **1ms / 40.3MB** (beats 100% / 88%).\\n```java\\nclass Solution {\\n    public int maxArea(int[] H) {\\n        int ans = 0, i = 0, j = H.length-1, res = 0;\\n        while (i < j) {\\n            if (H[i] <= H[j]) {\\n                res = H[i] * (j - i);\\n                i++;\\n            } else {\\n                res = H[j] * (j - i);\\n                j--;\\n            }\\n            if (res > ans) ans = res;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **12ms / 17.6MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& H) {\\n        int ans = 0, i = 0, j = H.size()-1, res = 0;\\n        while (i < j) {\\n            if (H[i] <= H[j]) {\\n                res = H[i] * (j - i);\\n                i++;\\n            } else {\\n                res = H[j] * (j - i);\\n                j--;\\n            }\\n            if (res > ans) ans = res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxArea = function(H) {\\n    let ans = 0, i = 0, j = H.length-1\\n    while (i < j) {\\n        ans = Math.max(ans, Math.min(H[i], H[j]) * (j - i))\\n        H[i] <= H[j] ? i++ : j--\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def maxArea(self, H: List[int]) -> int:\\n        ans, i, j = 0, 0, len(H)-1\\n        while (i < j):\\n            if H[i] <= H[j]:\\n                res = H[i] * (j - i)\\n                i += 1\\n            else:\\n                res = H[j] * (j - i)\\n                j -= 1\\n            if res > ans: ans = res\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int maxArea(int[] H) {\\n        int ans = 0, i = 0, j = H.length-1, res = 0;\\n        while (i < j) {\\n            if (H[i] <= H[j]) {\\n                res = H[i] * (j - i);\\n                i++;\\n            } else {\\n                res = H[j] * (j - i);\\n                j--;\\n            }\\n            if (res > ans) ans = res;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& H) {\\n        int ans = 0, i = 0, j = H.size()-1, res = 0;\\n        while (i < j) {\\n            if (H[i] <= H[j]) {\\n                res = H[i] * (j - i);\\n                i++;\\n            } else {\\n                res = H[j] * (j - i);\\n                j--;\\n            }\\n            if (res > ans) ans = res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915108,
                "title": "python3-greedy-two-pointers-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nFirst, we check the widest possible container starting from the first line to the last one. Next, we ask ourselves, how is it possible to form an even bigger container? Every time we narrow the container, the width becomes smaller so the only way to get a bigger area is to find higher lines. So why not just greedily shrink the container on the side that has a shorter line? Every time we shrink the container, we calculate the area and save the maximum.\\n\\nTime: **O(n)** \\nSpace: **O(1)**\\n\\nRuntime: 819 ms, faster than **75.10%** of Python3 online submissions for Container With Most Water.\\nMemory Usage: 27.4 MB, less than **58.32%** of Python3 online submissions for Container With Most Water.\\n\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        l, r, area = 0, len(height) - 1, 0\\n        while l < r:\\n            area = max(area, (r - l) * min(height[l], height[r]))\\n            if height[l] < height[r]:\\n\\t\\t\\t\\tl += 1\\n            else:\\n\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\n        return area\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        l, r, area = 0, len(height) - 1, 0\\n        while l < r:\\n            area = max(area, (r - l) * min(height[l], height[r]))\\n            if height[l] < height[r]:\\n\\t\\t\\t\\tl += 1\\n            else:\\n\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6110,
                "title": "very-simple-o-n-solution",
                "content": "The idea is : to compute area, we need to take min(height[i],height[j]) as our height. Thus if `height[i]<height[j]`, then the expression `min(height[i],height[j])` will always lead to at maximum `height[i]` for all other j(i being fixed), hence no point checking them. Similarly when `height[i]>height[j]` then all the other i's can be ignored for that particular j.\\n\\n    class Solution {\\n    public:\\n        int maxArea(vector<int> &height)\\n        {\\n            int j=height.size()-1,i=0,mx=0;\\n            \\n            while(i<j)\\n            {\\n                mx=max(mx,((j-i)*(min(height[i],height[j]))));\\n                \\n                if(height[i]<height[j])\\n                 i++;\\n                 else if(height[i]>=height[j])\\n                 j--;\\n            }\\n            return mx;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxArea(vector<int> &height)\\n        {\\n            int j=height.size()-1,i=0,mx=0;\\n            \\n            while(i<j)\\n            {\\n                mx=max(mx,((j-i)*(min(height[i],height[j]))));\\n                \\n                if(height[i]<height[j])\\n                 i++;\\n                 else if(height[i]>=height[j])\\n                 j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 6131,
                "title": "o-n-7-line-python-solution-72ms",
                "content": "If `height[L] < height[R]`, move `L`, else move `R`. Say height[0] < height[5], area of (0, 4), (0, 3), (0, 2), (0, 1) will be smaller than (0, 5), so no need to try them.\\n\\n    def maxArea(self, height):\\n        L, R, width, res = 0, len(height) - 1, len(height) - 1, 0\\n        for w in range(width, 0, -1):\\n            if height[L] < height[R]:\\n                res, L = max(res, height[L] * w), L + 1\\n            else:\\n                res, R = max(res, height[R] * w), R - 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "If `height[L] < height[R]`, move `L`, else move `R`. Say height[0] < height[5], area of (0, 4), (0, 3), (0, 2), (0, 1) will be smaller than (0, 5), so no need to try them.\\n\\n    def maxArea(self, height):\\n        L, R, width, res = 0, len(height) - 1, len(height) - 1, 0\\n        for w in range(width, 0, -1):\\n            if height[L] < height[R]:\\n                res, L = max(res, height[L] * w), L + 1\\n            else:\\n                res, R = max(res, height[R] * w), R - 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 6150,
                "title": "for-someone-who-is-not-so-clear-on-this-question",
                "content": "      y ^\\n        |\\n        |     a2\\n        |     |  a3          an\\n        |  a1 |  |     a5    | \\n        |  |  |  |  a4 |     |\\n        |  |  |  |  |  | ..  |\\n        --------------------------->\\n       0   1  2  3  4  5 ..  n     x\\n    \\n\\n 1. For someone who is not clear on this question. It's not like\\n    \"https://leetcode.com/problems/trapping-rain-water/ \" Which is to\\n    get the total water for all the bars problem, It actually is to find\\n    the any 2 bars ai, aj, which hold most water together with x-axis.\\n    This post give a very good detail explanation as well.\\n    https://leetcode.com/discuss/37631/simple-and-clear-proof-explanation\\n\\n------------------------------------------------------------------------",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 975586,
                "title": "javascript-o-n-time-solution-that-s-easy-to-understand",
                "content": "Before we go on, we need to look at the given test cases, and make some facts up to start writing our code:\\n- We can see that the area of the container is limited by the smallest side, so we need to know what the smallest side is every iterations\\n- The area of a container is (right - left) multiplied by the smallestSide. \\n- If the area is greater than our result, we have a new result\\n- When moving the left or right pointer, we want to get rid of the smaller side, so iterate from that side\\n\\nWith this we can do the problem in O(n) time and constant space by having a left and right pointer, and moving these pointers inward. \\n\\n```\\nconst maxArea = (height) => {\\n\\tlet result = 0,\\n\\t\\tleft = 0,\\n\\t\\tright = height.length - 1;\\n\\n\\twhile (left < right) {\\n\\t\\tlet smallestSide = Math.min(height[left], height[right]);\\n\\t\\tlet area = (right - left) * smallestSide;\\n\\n\\t\\tif (area > result) result = area;\\n\\n\\t\\tif (height[left] < height[right]) left++;\\n\\t\\telse right--;\\n\\t}\\n\\n\\treturn result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxArea = (height) => {\\n\\tlet result = 0,\\n\\t\\tleft = 0,\\n\\t\\tright = height.length - 1;\\n\\n\\twhile (left < right) {\\n\\t\\tlet smallestSide = Math.min(height[left], height[right]);\\n\\t\\tlet area = (right - left) * smallestSide;\\n\\n\\t\\tif (area > result) result = area;\\n\\n\\t\\tif (height[left] < height[right]) left++;\\n\\t\\telse right--;\\n\\t}\\n\\n\\treturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6126,
                "title": "c-o-n-solution-with-thought-process-applying-simple-bucket-theory",
                "content": "The brute force solution can definitely lead us to the right answer just by doing too many redundant comparisons. When two pointer approach comes to mind, it is intuitive to set both pointers `i, j` at each end of this array, and move them strategically to the middle of array, update the answer during this process return the answer when we reach the end of array. Suppose now we have the scenarios below:\\n\\n    7, 5, 6, 9\\n    \\n    i        j\\n\\nWhen `i = 1,  j = 4`, \\n\\n    ans = min(7, 9) * (4 - 1) = 21 \\n\\nWhat's next? Should we move `i` or `j`? We notice that to calculate the area, the height is really identified by the `smaller number / shorter end` between the two ends, since it's required that you may not slant the water, so it sounds like Bucket theory: how much water a bucket can contain depends on the shortest plank. So, as to find the next potential maximum area, we disregard the shorter end by moving it to the next position. So in the above case, the next status is to move `i` to the left, \\n\\n    7, 5, 6, 9\\n    \\n       i     j\\n\\nupdate:\\n\\n    area (i, j) = area(2, 4) = min(5, 9) * (4 - 2) = 10\\n    ans = max(21, 10) = 21\\n\\nYou may notice that, if we move `j` instead, you actually get a larger area for length of 2: \\n\\n    area (i, j) = area(1, 3) = min(7, 6) * (3 - 1) = 18\\n\\nDoes that mean this approach will not work? If you look at this way, we move pointer as to get the next potential max, so it doesn't need to be the maximum for all combinations with length `l`. Even though `18` is greater than `10`, it's smaller than `21` right? So don't worry, we can move on to find the next potential maximum result. Now we need to prove, why disregard the shorter end can safely lead us to the right answer by doing a little maths. \\n\\n    Given an array: a1, a2, a3, a4, ai, ......, aj, ......, an\\n                                     i           j\\n\\nAssume the maximum area so far is `ans`, we prove that \\n\\n    \"By moving shorter end pointer further doesn't eliminate the final answer (with two ends at maxi, maxj respectively) in our process\"\\n\\nSuppose we have two ends at (`i, j`) respectively at this moment:\\n\\n(i) If the final answer equals what we have already achieved, it's done! In this scenario, we must have\\n\\n    maxi <= i, maxj >= j \\n\\n(ii) Otherwise, we know as we move any pointer further, the length of the next rectangle decreases, so the height needs to increase as to result in a larger area. So we have \\n\\n    min(height[maxi], height[maxj]) > min(height[i], height[j]) \\nSo the smaller one in height[`i`], height[`j`] won't become any end in the maximum rectangle, so it's safe to move forward without it.\\n\\nTill now, it has been proved that this approach can work in O(n) time since we advance one end towards the middle in each iteration, and update ans takes constant time in each iteration.\\n\\n    class Solution {\\n    public:\\n        int maxArea(vector<int>& height) {\\n            int ans = 0;\\n            int i = 0, j = height.size() - 1;          \\n            while(i < j){\\n                ans = max(ans, (j - i) * min(height[i], height[j]));\\n                height[i] > height[j] ? j-- : i++;  \\n            }\\n            \\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxArea(vector<int>& height) {\\n            int ans = 0;\\n            int i = 0, j = height.size() - 1;          \\n            while(i < j){\\n                ans = max(ans, (j - i) * min(height[i], height[j]));\\n                height[i] > height[j] ? j-- : i++;  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3278302,
                "title": "c-accepted-code-beginner-friendly-two-pointers-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n       int ans = 0, n = height.size();\\n       int i = 0, j = n-1;\\n       while(i<j){\\n           if(height[i]>height[j]){\\n               ans = max(ans, (j-i)*height[j]);\\n               j--;\\n           }\\n           else{\\n               ans = max(ans, (j-i)*height[i]);\\n               i++;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n\\nDo Upvote if it helps.\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n       int ans = 0, n = height.size();\\n       int i = 0, j = n-1;\\n       while(i<j){\\n           if(height[i]>height[j]){\\n               ans = max(ans, (j-i)*height[j]);\\n               j--;\\n           }\\n           else{\\n               ans = max(ans, (j-i)*height[i]);\\n               i++;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n\\nDo Upvote if it helps.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915231,
                "title": "2-approaches-brute-force-and-two-pointers-with-image-explanation",
                "content": "[Leetcode](https://leetcode.com/) [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/).\\n\\nHere shows **2** Approaches to slove this problem: **Brute Force** and **Two Pointers**.\\n\\n# Intuition\\n\\n![Problem 11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nSuppose two pointers $i$, $j$, the heights of the vertical lines are $h[i]$, $h[j]$, and the area in this state is $S(i, j)$. \\n\\nAs we all known, the container is determined by the short line, the area formula can be easily obtained:\\n\\n$$\\nS(i, j)= min(h[i], h[j]) \\\\times (j - i)\\n$$\\n\\n# Brute Froce\\n\\nIt\\'s easy to use the brute force approach, the total states is $C(n, 2)= n \\\\times (n - 1) / 2$, we have to **enumerate all these states** to get the max area.\\n\\nThe time complexity is $O(n^2)$, exceed the time limit.\\n\\n```java\\n    // BF time: O(n^2) space: O(1)\\n    // TimeOut\\n    public static int maxArea_bf(int[] height) {\\n        int len = height.length;\\n        int max = 0;\\n        for (int i = 0; i < len - 1; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                int area = Math.min(height[i], height[j]) * (j - i);\\n                max = Math.max(max, area);\\n            }\\n        }\\n\\n        return max;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$\\n- **Space Complexity**: $O(1)$\\n\\n# Two Pointers\\n\\nIn each state $S(i, j)$, no matter whether the left line or right line moves to the middle, it will cause less wide to $width - 1$:\\n\\n- Move the short line, the short line $min(h[i], h[j])$ of the container may hold more water,  the area may increase.\\n- Move the long line, the short line $min(h[i], h[j])$ of the container will **remain the same or less**, so the area will definitely become less.\\n\\nTherefore, we can use two pointers to the left and right line of the container. We move the short line in each round, update the max area until the two pointers met each other as the below pictures show.\\n\\n![Problem 11 1](https://assets.leetcode.com/users/images/1bbdebff-40e8-43b6-b975-050eced682e6_1649125223.181647.png)\\n\\n![Problem 11 2](https://assets.leetcode.com/users/images/e7d55353-7491-44b2-af67-51e4aeee414f_1649125223.358524.png)\\n\\n![Problem 11 3](https://assets.leetcode.com/users/images/395bbe7e-1218-4750-a744-21c590c5981c_1649125223.3798895.png)\\n\\n## Proof\\n\\nAssuming that $h[i] \\\\lt h[j]$ under the state $S(i, j)$, move the short line to $S(i + 1, j)$, which means that we eliminate $S(i, j - 1), S(i, j - 2), ... , S(i, i + 1)$ states. The area of all eliminated states must be smaller than the current area:\\n\\n1. Short line height: same or less than $S(i, j)$ ($\\\\le h[i]$);\\n2. Width: less than $S(i, j)$.\\n\\nTherefore, each round moves the short line, and all the eliminated states will not cause the loss of the maximum area.\\n\\n```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static int maxArea_tp(int[] height) {\\n        int len = height.length;\\n        int left = 0;\\n        int right = len - 1;\\n        int max = Math.min(height[left], height[right]) * (right - left);\\n        while (left < right) {\\n            // Move the shorter lines each time\\n            if (height[left] <= height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n\\n            // update the max area\\n            max = Math.max(max, Math.min(height[left], height[right]) * (right - left));\\n        }\\n\\n        return max;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```java\\n    // BF time: O(n^2) space: O(1)\\n    // TimeOut\\n    public static int maxArea_bf(int[] height) {\\n        int len = height.length;\\n        int max = 0;\\n        for (int i = 0; i < len - 1; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                int area = Math.min(height[i], height[j]) * (j - i);\\n                max = Math.max(max, area);\\n            }\\n        }\\n\\n        return max;\\n    }\\n```\n```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static int maxArea_tp(int[] height) {\\n        int len = height.length;\\n        int left = 0;\\n        int right = len - 1;\\n        int max = Math.min(height[left], height[right]) * (right - left);\\n        while (left < right) {\\n            // Move the shorter lines each time\\n            if (height[left] <= height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n\\n            // update the max area\\n            max = Math.max(max, Math.min(height[left], height[right]) * (right - left));\\n        }\\n\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6245,
                "title": "o-n-java-solution-two-pointers",
                "content": "       public int maxArea(int[] height) {\\n    \\t\\tint maxWater=0, left=0, right=height.length-1;\\n    \\t\\twhile(left<right) {\\n    \\t\\t\\tmaxWater = Math.max(maxWater,(right-left)*Math.min(height[left], height[right]));\\n    \\t\\t\\tif(height[left]<height[right]) left++;\\n    \\t\\t\\telse right--;\\n    \\t\\t}\\n    \\t\\treturn maxWater;\\n    \\t}\\n\\n 1. Start with pointer left=0 and pointer right=length-1\\n 2. The max water is limited by the pointer with smaller height\\n 3. When moving a pointer, the width of the area decrease\\n 4. If we move the pointer with higher height, we will never get a\\n    greater area, the max height will be at most the one of the pointer with smaller height.\\n 5. So we need to move the pointer with smaller height to have a chance to get higher height at the next step.",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "       public int maxArea(int[] height) {\\n    \\t\\tint maxWater=0, left=0, right=height.length-1;\\n    \\t\\twhile(left<right) {\\n    \\t\\t\\tmaxWater = Math.max(maxWater,(right-left)*Math.min(height[left], height[right]));\\n    \\t\\t\\tif(height[left]<height[right]) left++;\\n    \\t\\t\\telse right--;\\n    \\t\\t}\\n    \\t\\treturn maxWater;\\n    \\t}\\n\\n 1. Start with pointer left=0 and pointer right=length-1\\n 2. The max water is limited by the pointer with smaller height\\n 3. When moving a pointer, the width of the area decrease\\n 4. If we move the pointer with higher height, we will never get a\\n    greater area, the max height will be at most the one of the pointer with smaller height.\\n 5. So we need to move the pointer with smaller height to have a chance to get higher height at the next step.",
                "codeTag": "Unknown"
            },
            {
                "id": 3375849,
                "title": "two-pointer-logic-python3",
                "content": "\\n\\n# Two Pointer Logic : TC----->O(N)\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        left,right,answer=0,len(height)-1,0\\n        while left<=right:\\n            area=min(height[right],height[left])*(right-left)\\n            answer=max(answer,area)\\n            if height[right]>height[left]:\\n                left+=1\\n            else:\\n                right-=1\\n        return answer\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        left,right,answer=0,len(height)-1,0\\n        while left<=right:\\n            area=min(height[right],height[left])*(right-left)\\n            answer=max(answer,area)\\n            if height[right]>height[left]:\\n                left+=1\\n            else:\\n                right-=1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277192,
                "title": "accepted-o-n-simple-and-fast-java-c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\n  Code in JAVA and C :-\\n```\\n# JAVA :-\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | **3** *ms* | *Beats* **92%**\\n**Memory** | **50** *MB* | *Beats* **89%**\\n```\\nclass Solution {\\n    public int maxArea(int[] arr) {\\n        final int N = arr.length;\\n        int max = 0 , test, i=0, j=N-1;\\n        while(j>i){\\n            test = arr[i] < arr[j] ? arr[i] : arr[j];\\n            test = (j - i) * test;\\n            if(max < test) max = test;\\n            if(arr[i] < arr[j]) i++ ;\\n            else j--;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n---\\n\\n# C :-\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | 88ms | Beats **97%**\\n**Memory** | 12MB | Beats **65%**\\n```\\nint maxArea(int* arr, int N){\\n    int max = 0,test,i=0,j=N-1;\\n    while(j>i){\\n        test = arr[i];\\n        if(test>arr[j]) test = arr[j];\\n        test = (j - i) * test;\\n        if(max < test) max = test;\\n        if(arr[i] < arr[j]) i++ ;\\n        else j--;\\n    }\\n    return max;\\n}\\n```\\n\\n## Tom need a UPVOTE : |\\n![waiting-tom-and-jerry.gif](https://assets.leetcode.com/users/images/4f0cc754-71e1-4cfc-816b-36a94c20b17f_1678366238.9546802.gif)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n  Code in JAVA and C :-\\n```\n```\\nclass Solution {\\n    public int maxArea(int[] arr) {\\n        final int N = arr.length;\\n        int max = 0 , test, i=0, j=N-1;\\n        while(j>i){\\n            test = arr[i] < arr[j] ? arr[i] : arr[j];\\n            test = (j - i) * test;\\n            if(max < test) max = test;\\n            if(arr[i] < arr[j]) i++ ;\\n            else j--;\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nint maxArea(int* arr, int N){\\n    int max = 0,test,i=0,j=N-1;\\n    while(j>i){\\n        test = arr[i];\\n        if(test>arr[j]) test = arr[j];\\n        test = (j - i) * test;\\n        if(max < test) max = test;\\n        if(arr[i] < arr[j]) i++ ;\\n        else j--;\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069698,
                "title": "python-js-go-c-o-n-by-two-pointers-w-comment",
                "content": "O(n) by two-pointers \\n\\n[\\u4E2D\\u6587\\u8A73\\u89E3\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/650aeea5fd897800013a926b)\\n\\n---\\n\\n**Implementation** by two-pointers in Python:\\n\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        \\n        # length of input array\\n        size = len(height)\\n        \\n        # two pointers, left init as 0, right init as size-1\\n        left, right = 0, size-1\\n        \\n        # maximal width between leftmost stick and rightmost stick\\n        max_width = size - 1\\n        \\n        # area also known as the amount of water\\n        area = 0\\n        \\n\\t\\t# trade-off between width and height\\n        # scan each possible width and compute maximal area\\n        for width in range(max_width, 0, -1):\\n            \\n            if height[left] < height[right]:\\n                # the height of lefthand side is shorter\\n                area = max(area, width * height[left] )\\n                \\n                # update left index to righthand side\\n                left += 1\\n                \\n            else:\\n                # the height of righthand side is shorter\\n                area = max(area, width * height[right] )\\n                \\n                # update right index to lefthand side\\n                right -= 1\\n                \\n        return area\\n                \\n```\\n\\n---\\n\\n**Implementation** by two-pointers in Javscript:\\n\\n```\\nvar maxArea = function(height) {\\n    \\n    // length of input array\\n    const size = height.length;\\n    \\n    // two pointers, leftinit as 0, right init as size-1\\n    let [left, right] = [0, size-1];\\n    \\n    let maxWidth = size-1;\\n    \\n    let area = 0;\\n    \\n    // trade-off between width and height\\n    // scan each possible width and compute maximal area\\n    for( let width = maxWidth ; width > 0 ; width-- ){\\n        \\n        if( height[left] < height[right] ){    \\n            area = Math.max(area, width * height[left] );\\n            \\n            // move left index to righthand side\\n            left += 1;\\n        }else{\\n            area = Math.max(area, width * height[right] );\\n            \\n            // move right index to lefthand side\\n            right -= 1;\\n        }\\n        \\n    }\\n    return area;\\n};\\n```\\n\\n---\\n\\n**Implementation** by two-pointers in Golang:\\n\\n```\\nfunc Max(x, y int)int{\\n    if x >= y {\\n        return x\\n    }\\n    \\n    return y\\n}\\n\\nfunc maxArea(height []int) int {\\n    \\n    // length of input array\\n    size := len(height)\\n    \\n    // tow pointers, left init as 0, right init as size-1\\n    left, right := 0, size-1\\n    \\n    // maximal width between leftmost stick and rightmost stick\\n    maxWidth := size-1\\n    \\n    // area also known as the amount of water\\n    area := 0\\n    \\n    // trade-off between width and height\\n    // scan each possible width and compute maximal area\\n    for width := maxWidth ; width > 0 ; width-- {\\n        \\n        if height[left] < height[right]{\\n            \\n            // the height of lefthand side is shorter\\n            area = Max(area, width * height[left])\\n            \\n            // update left index to righthand side\\n            left += 1\\n            \\n        }else{\\n            \\n            // the height of righthand side is shorter\\n            area = Max(area, width * height[right])\\n            \\n            // update left index to righthand side\\n            right -= 1\\n        }\\n        \\n    }\\n    return area\\n}\\n```\\n\\n---\\n\\n**Implementation** by two-pointers in C++\\n\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        \\n        int size = height.size();\\n        \\n        \\n        // two pointers, left init as 0, right init as size-1\\n        int left = 0, right = size-1;\\n        \\n        // maximal width between leftmost stick and rightmost stick\\n        int maxWidth = size-1;\\n            \\n        // area also known as the amount of water\\n        int area = 0;\\n        \\n        \\n        // trade-off between width and height\\n        // scan each possible width and compute mximal area\\n        for( int width = maxWidth ; width > 0 ; width-=1 ){\\n            \\n            if( height[left] < height[right] ){\\n                \\n                // the height of lefthand side is shorter\\n                area = max(area, width * height[left] );\\n                              \\n                // update left index to righthand side\\n                left += 1;\\n                \\n            }\\n            else{\\n                \\n                // the height of righthand side is shorter\\n                area = max(area, width * height[right] );\\n                \\n                // update right index to lefthand side\\n                right -= 1;\\n                \\n            }\\n        }\\n        \\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        \\n        # length of input array\\n        size = len(height)\\n        \\n        # two pointers, left init as 0, right init as size-1\\n        left, right = 0, size-1\\n        \\n        # maximal width between leftmost stick and rightmost stick\\n        max_width = size - 1\\n        \\n        # area also known as the amount of water\\n        area = 0\\n        \\n\\t\\t# trade-off between width and height\\n        # scan each possible width and compute maximal area\\n        for width in range(max_width, 0, -1):\\n            \\n            if height[left] < height[right]:\\n                # the height of lefthand side is shorter\\n                area = max(area, width * height[left] )\\n                \\n                # update left index to righthand side\\n                left += 1\\n                \\n            else:\\n                # the height of righthand side is shorter\\n                area = max(area, width * height[right] )\\n                \\n                # update right index to lefthand side\\n                right -= 1\\n                \\n        return area\\n                \\n```\n```\\nvar maxArea = function(height) {\\n    \\n    // length of input array\\n    const size = height.length;\\n    \\n    // two pointers, leftinit as 0, right init as size-1\\n    let [left, right] = [0, size-1];\\n    \\n    let maxWidth = size-1;\\n    \\n    let area = 0;\\n    \\n    // trade-off between width and height\\n    // scan each possible width and compute maximal area\\n    for( let width = maxWidth ; width > 0 ; width-- ){\\n        \\n        if( height[left] < height[right] ){    \\n            area = Math.max(area, width * height[left] );\\n            \\n            // move left index to righthand side\\n            left += 1;\\n        }else{\\n            area = Math.max(area, width * height[right] );\\n            \\n            // move right index to lefthand side\\n            right -= 1;\\n        }\\n        \\n    }\\n    return area;\\n};\\n```\n```\\nfunc Max(x, y int)int{\\n    if x >= y {\\n        return x\\n    }\\n    \\n    return y\\n}\\n\\nfunc maxArea(height []int) int {\\n    \\n    // length of input array\\n    size := len(height)\\n    \\n    // tow pointers, left init as 0, right init as size-1\\n    left, right := 0, size-1\\n    \\n    // maximal width between leftmost stick and rightmost stick\\n    maxWidth := size-1\\n    \\n    // area also known as the amount of water\\n    area := 0\\n    \\n    // trade-off between width and height\\n    // scan each possible width and compute maximal area\\n    for width := maxWidth ; width > 0 ; width-- {\\n        \\n        if height[left] < height[right]{\\n            \\n            // the height of lefthand side is shorter\\n            area = Max(area, width * height[left])\\n            \\n            // update left index to righthand side\\n            left += 1\\n            \\n        }else{\\n            \\n            // the height of righthand side is shorter\\n            area = Max(area, width * height[right])\\n            \\n            // update left index to righthand side\\n            right -= 1\\n        }\\n        \\n    }\\n    return area\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        \\n        int size = height.size();\\n        \\n        \\n        // two pointers, left init as 0, right init as size-1\\n        int left = 0, right = size-1;\\n        \\n        // maximal width between leftmost stick and rightmost stick\\n        int maxWidth = size-1;\\n            \\n        // area also known as the amount of water\\n        int area = 0;\\n        \\n        \\n        // trade-off between width and height\\n        // scan each possible width and compute mximal area\\n        for( int width = maxWidth ; width > 0 ; width-=1 ){\\n            \\n            if( height[left] < height[right] ){\\n                \\n                // the height of lefthand side is shorter\\n                area = max(area, width * height[left] );\\n                              \\n                // update left index to righthand side\\n                left += 1;\\n                \\n            }\\n            else{\\n                \\n                // the height of righthand side is shorter\\n                area = max(area, width * height[right] );\\n                \\n                // update right index to lefthand side\\n                right -= 1;\\n                \\n            }\\n        }\\n        \\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144091,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func maxArea(_ h: [Int]) -> Int {\\n        guard h.count > 2 else { return min(h[0], h[1]) }\\n        var val = 0, lhs = 0, rhs = h.count - 1\\n        while lhs < rhs {\\n            val = max(val, min(h[lhs], h[rhs]) * (rhs - lhs))\\n            h[lhs] < h[rhs] ? (lhs += 1) : (rhs -= 1)\\n        }\\n        return val\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].\\n    // In this case, the max area of water (blue section) the container can contain is 49.\\n    func test0() {\\n        let value = solution.maxArea([1,8,6,2,5,4,8,3,7])\\n        XCTAssertEqual(value, 49)\\n    }\\n    \\n    func test1() {\\n        let value = solution.maxArea([1,1])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxArea(_ h: [Int]) -> Int {\\n        guard h.count > 2 else { return min(h[0], h[1]) }\\n        var val = 0, lhs = 0, rhs = h.count - 1\\n        while lhs < rhs {\\n            val = max(val, min(h[lhs], h[rhs]) * (rhs - lhs))\\n            h[lhs] < h[rhs] ? (lhs += 1) : (rhs -= 1)\\n        }\\n        return val\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].\\n    // In this case, the max area of water (blue section) the container can contain is 49.\\n    func test0() {\\n        let value = solution.maxArea([1,8,6,2,5,4,8,3,7])\\n        XCTAssertEqual(value, 49)\\n    }\\n    \\n    func test1() {\\n        let value = solution.maxArea([1,1])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6101,
                "title": "from-dp-to-greedy-o-n-with-explanation-easy-way-to-see-this-problem",
                "content": "We could see this problem in a DP view and with some tricks we could do it in a greedy way which is O(n) time complexity.\\nLet's define **S(i...j) to be the max volume from index i to j and v(i, j) be the volume of the container with boundary i and j** . So we just need to figure out S(0...n) (0 and n are the leftmost and rightmost index of the array).\\nIt is easy to derive that **S(0..n) = max{v(0, n), S(1...n), S(0...n-1)}**, and the time complexity is O(n^2). But we can optimize it. WLOG(without loss of generality), we assume height(0) > height(n), then we can simplify S(0..n) as **S(0...n) = max{v(0, n), S(0...n-1)}** and the complexity is O(n). Below is the proof :\\n1, if v(0, n) is the largest volume, sicne we have figured out the result, the simplifier is all right.\\n2, if not, we could find out that n can't be the boundry of the container. If n is the right boundry, becaues of height(0) > height(n) , the max volumn must be height(n) * (n - 0) = v(0, n), which arrives at a contradiction. So S(1...n) can be simplified as S(1...n-1) which is included in S(0...n-1).\\nThe code is from the forum and mainly from https://discuss.leetcode.com/topic/16754/simple-and-fast-c-c-with-explanation/5\\nThe relationship can be represented as :\\n```\\n           / max{v(i, j), S(i...j-1)};  height(i) >= height(j)\\nS(i..j) = |\\n           \\\\ max{v(i, j), S(i+1...j)};  height(i) < height(j)\\n\\npublic class Solution {\\n    public int maxArea(int[] height) {\\n        int lo = 0;\\n        int hi = height.length - 1;\\n        int max = 0;\\n        while(lo < hi) {\\n            int min = Math.min(height[lo], height[hi]);\\n            max = Math.max(max, min * (hi - lo));\\n            while(lo <= hi && height[lo] <= min) lo++;\\n            while(lo <= hi && height[hi] <= min) hi--;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxArea(int[] height) {\\n        int lo = 0;\\n        int hi = height.length - 1;\\n        int max = 0;\\n        while(lo < hi) {\\n            int min = Math.min(height[lo], height[hi]);\\n            max = Math.max(max, min * (hi - lo));\\n            while(lo <= hi && height[lo] <= min) lo++;\\n            while(lo <= hi && height[hi] <= min) hi--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1069818,
                "title": "c-two-pointers-greedy-o-n-0ms-beats-100-explanation",
                "content": "**EXPLANATION**\\n- Make two pointers one (```l```) pointing to the start of the ```height``` vector and the other (```r```) pointing to the end of the ```height``` vector.\\n\\t```\\n\\tint l=0,r=height.size()-1;\\n\\t```\\n- Iterate the ```height``` vector until `l<r` and at each iteration, find the total water between ```l``` and ```r``` by the below method:\\n\\t- For any given ```l``` and ```r```, the **height** of the contained water depends upon the **minimum ( left height, right height)**.\\n\\t- If left height is **(```lh = height[l]```)** and right height is **(```rh = height[r]```)**, then the **height** of the contained water is **```min(lh, rh)```**.\\n\\t- Also the **width** of the contained water is equal to the difference between right and left index, that is **```r-l```**.\\n\\t- So the **total area of water** contained is **width `*` height**, that is  **```(r - l) * min(lh, rh)```**.\\n\\t```\\n\\tint lh=height[l];\\n\\tint rh=height[r];\\n\\tmax_area=max(max_area,(r-l)*min(lh,rh));\\n\\t```\\n- The **maximum area of water** that can be contained in each iteration is the **answer**.\\n\\t```\\n\\tmax_area=max(max_area,(r-l)*min(lh,rh));\\n\\t```\\n- Also, after finding the area of water for a given ```l``` and ```r```, increase *l* or decrease *r* according to whole height is smaller `lh` or `rh`.\\n\\t```\\n\\tif(lh<rh) ++l\\n\\telse --r\\n\\t```\\n\\n\\n**COMPLETE CODE**\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int l=0,r=height.size()-1;\\n        int max_area=0;\\n        \\n        while(l<r){\\n            int lh=height[l];\\n            int rh=height[r];\\n            \\n            max_area=max(max_area,(r-l)*min(lh,rh));\\n            \\n            if(lh<rh) ++l;\\n            else --r;\\n        }\\n\\t\\t\\n        return max_area;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```l```\n```height```\n```r```\n```height```\n```\\n\\tint l=0,r=height.size()-1;\\n\\t```\n```height```\n```l```\n```r```\n```l```\n```r```\n```lh = height[l]```\n```rh = height[r]```\n```min(lh, rh)```\n```r-l```\n```(r - l) * min(lh, rh)```\n```\\n\\tint lh=height[l];\\n\\tint rh=height[r];\\n\\tmax_area=max(max_area,(r-l)*min(lh,rh));\\n\\t```\n```\\n\\tmax_area=max(max_area,(r-l)*min(lh,rh));\\n\\t```\n```l```\n```r```\n```\\n\\tif(lh<rh) ++l\\n\\telse --r\\n\\t```\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int l=0,r=height.size()-1;\\n        int max_area=0;\\n        \\n        while(l<r){\\n            int lh=height[l];\\n            int rh=height[r];\\n            \\n            max_area=max(max_area,(r-l)*min(lh,rh));\\n            \\n            if(lh<rh) ++l;\\n            else --r;\\n        }\\n\\t\\t\\n        return max_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6089,
                "title": "anyone-who-has-a-o-n-algorithm",
                "content": "anyone who has a O(N) algorithm ?\\n\\nI am using the following code but the time exceeds the limit for the extreme case (ascending sequece) , so I added some special code to handle the extreme case to get a pass.  Anyone who has better solution?\\n\\n\\n    \\tpublic  int maxArea1(int[] height){\\n\\t\\tif ( (height == null) || (height.length <= 1) )\\n\\t\\t\\treturn 0 ;\\n\\t\\tint result = 0 ;\\n\\t\\tArrayList<Integer> seq = new ArrayList<Integer>();\\n\\t\\tseq.add(new Integer(0));\\n\\t\\tfor (int i = 1 ; i < height.length; i++){\\n\\t\\t\\tfor ( Integer idx : seq ){\\n\\t\\t\\t\\tint ht = height[i] > height[idx.intValue()] ? height[idx.intValue()] : height[i] ;\\n\\t\\t\\t\\tint area = (i - idx.intValue()) * ht ;\\n\\t\\t\\t\\tif ( area > result ) result = area ;\\n\\t\\t\\t}\\n\\t\\t\\tint lastIdx = seq.get(seq.size() - 1).intValue();\\n\\t\\t\\tif ( height[i] > height[lastIdx]){\\n\\t\\t\\t\\tseq.add(new Integer(i)) ;\\n\\t\\t\\t}\\n\\t\\t}\\t\\t\\n\\t\\treturn result ;\\n\\t\\t\\n\\t}",
                "solutionTags": [],
                "code": "anyone who has a O(N) algorithm ?\\n\\nI am using the following code but the time exceeds the limit for the extreme case (ascending sequece) , so I added some special code to handle the extreme case to get a pass.  Anyone who has better solution?\\n\\n\\n    \\tpublic  int maxArea1(int[] height){\\n\\t\\tif ( (height == null) || (height.length <= 1) )\\n\\t\\t\\treturn 0 ;\\n\\t\\tint result = 0 ;\\n\\t\\tArrayList<Integer> seq = new ArrayList<Integer>();\\n\\t\\tseq.add(new Integer(0));\\n\\t\\tfor (int i = 1 ; i < height.length; i++){\\n\\t\\t\\tfor ( Integer idx : seq ){\\n\\t\\t\\t\\tint ht = height[i] > height[idx.intValue()] ? height[idx.intValue()] : height[i] ;\\n\\t\\t\\t\\tint area = (i - idx.intValue()) * ht ;\\n\\t\\t\\t\\tif ( area > result ) result = area ;\\n\\t\\t\\t}\\n\\t\\t\\tint lastIdx = seq.get(seq.size() - 1).intValue();\\n\\t\\t\\tif ( height[i] > height[lastIdx]){\\n\\t\\t\\t\\tseq.add(new Integer(i)) ;\\n\\t\\t\\t}\\n\\t\\t}\\t\\t\\n\\t\\treturn result ;\\n\\t\\t\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1915620,
                "title": "c-short-easy-explanation",
                "content": "***Explanation :***\\n\\n**Intuition : Volume/Area depends upon the bar having minimum height**\\n* Now suppose, height[i] < height[j], in this case we can only store water with area height[i]*(j-i), now there is chance there is a greater value of i present in array so increment i\\n* Vice-vera height[i]>height[j], here area would be height[j]*(j-i), in this case there\\'s chance a greater value of j is present in array so decrement j\\n\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        \\n        int i=0;\\n        int j=height.size()-1;\\n        int mx=-1;\\n        \\n        while(i<j) {\\n            mx=max(mx,min(height[j],height[i])*(j-i));  //formula to calculate area -> min(height[j],height[i])*(j-i)\\n            if(height[i]<height[j])\\n                i++;\\n            else\\n                j--;\\n        }\\n        return mx;\\n    }\\n};\\n\\nif (isHelpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        \\n        int i=0;\\n        int j=height.size()-1;\\n        int mx=-1;\\n        \\n        while(i<j) {\\n            mx=max(mx,min(height[j],height[i])*(j-i));  //formula to calculate area -> min(height[j],height[i])*(j-i)\\n            if(height[i]<height[j])\\n                i++;\\n            else\\n                j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3696055,
                "title": "c-solution-python-java-easy-understanding-two-pointer-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor maximinzing the area , breadth should be maximum , so thats why we start our \"j\" pointer from the last and \"i\" pointer to the start .\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& v) {\\n\\n        int i = 0;\\n        int n = v.size();\\n        int j = n - 1;\\n        int area = 0;\\n\\n        while(j > i){\\n            area = max(area, min(v[i],v[j]) * abs(i - j));\\n            if(v[i] < v[j]) i++;\\n            else j--;\\n        }\\n\\n        return area;\\n        \\n    }\\n};\\n```\\n\\n# Python \\n```\\nclass Solution:\\n    def maxArea(self, v):\\n        i = 0\\n        n = len(v)\\n        j = n - 1\\n        area = 0\\n        while j > i:\\n            area = max(area, min(v[i], v[j]) * abs(i - j))\\n            if v[i] < v[j]:\\n                i += 1\\n            else:\\n                j -= 1\\n        return area\\n\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public int maxArea(int[] arr) {\\n        final int N = arr.length;\\n        int max = 0 , area, i=0, j=N-1;\\n        while(j>i){\\n            area = arr[i] < arr[j] ? arr[i] : arr[j];\\n            area = (j - i) * area;\\n            if(max < area) max = area;\\n            if(arr[i] < arr[j]) i++ ;\\n            else j--;\\n        }\\n        return max;\\n    }\\n}\\n\\n```\\n# Tom need a UPVOTE : |\\n\\n![Upvote.gif](https://assets.leetcode.com/users/images/7a6f0d2b-4e40-4db2-89bd-34277876b5d3_1688030952.7603087.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& v) {\\n\\n        int i = 0;\\n        int n = v.size();\\n        int j = n - 1;\\n        int area = 0;\\n\\n        while(j > i){\\n            area = max(area, min(v[i],v[j]) * abs(i - j));\\n            if(v[i] < v[j]) i++;\\n            else j--;\\n        }\\n\\n        return area;\\n        \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxArea(self, v):\\n        i = 0\\n        n = len(v)\\n        j = n - 1\\n        area = 0\\n        while j > i:\\n            area = max(area, min(v[i], v[j]) * abs(i - j))\\n            if v[i] < v[j]:\\n                i += 1\\n            else:\\n                j -= 1\\n        return area\\n\\n```\n```\\nclass Solution {\\n    public int maxArea(int[] arr) {\\n        final int N = arr.length;\\n        int max = 0 , area, i=0, j=N-1;\\n        while(j>i){\\n            area = arr[i] < arr[j] ? arr[i] : arr[j];\\n            area = (j - i) * area;\\n            if(max < area) max = area;\\n            if(arr[i] < arr[j]) i++ ;\\n            else j--;\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413203,
                "title": "5-lines-solution-specially-for-beginners-coders-easy-understandable-approach-explained",
                "content": "make a maxArea variable and it a value (-infinity or INT_MIN) because we have to find the max.\\ntake two pointers one points to the first element and other to the last element and make a currArea variable whose height is the min height from the both given heights and multiply it with the distance between pillars or height(difference in the index of both the heights)\\ntraverse the whole array by the comparison according to the height.\\nassign maxArea the max of both the maxArea and the currArea.\\n\\n\\n int maxArea(vector<int>& height) {\\n            \\n           \\n            int maxArea=INT_MIN,i=0,j=height.size()-1;\\n            while(i<j){\\n                     int currArea=min(height[i],height[j])*(j-i);\\n                    if(height[i]<height[j]) i++;\\n                            \\n                    else  j--;\\n                     maxArea=max(maxArea,currArea);\\n            }\\n            return maxArea;\\n        \\n    }\\n\\t\\n\\t//Guys plz plz plz upvote my solution if you really like and understand it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "make a maxArea variable and it a value (-infinity or INT_MIN) because we have to find the max.\\ntake two pointers one points to the first element and other to the last element and make a currArea variable whose height is the min height from the both given heights and multiply it with the distance between pillars or height(difference in the index of both the heights)\\ntraverse the whole array by the comparison according to the height.\\nassign maxArea the max of both the maxArea and the currArea.\\n\\n\\n int maxArea(vector<int>& height) {\\n            \\n           \\n            int maxArea=INT_MIN,i=0,j=height.size()-1;\\n            while(i<j){\\n                     int currArea=min(height[i],height[j])*(j-i);\\n                    if(height[i]<height[j]) i++;\\n                            \\n                    else  j--;\\n                     maxArea=max(maxArea,currArea);\\n            }\\n            return maxArea;\\n        \\n    }\\n\\t\\n\\t//Guys plz plz plz upvote my solution if you really like and understand it.",
                "codeTag": "Unknown"
            },
            {
                "id": 493400,
                "title": "simple-python3-o-n-solution-with-explanation-beats-96",
                "content": "\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        p1 = 0  # first (left) pointer\\n        p2 = len(height) - 1  # second (right) pointer\\n        max_area = 0\\n        while p1 != p2:\\n            if height[p1] > height[p2]:\\n                area = height[p2] * (p2 - p1)  # height of smaller edge multiplies on length\\n                p2 -= 1  # changing smaller edge\\n            else:\\n                area = height[p1] * (p2 - p1)\\n                p1 += 1\\n            if area > max_area: max_area = area  # increasing max area if possible\\n        return max_area\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        p1 = 0  # first (left) pointer\\n        p2 = len(height) - 1  # second (right) pointer\\n        max_area = 0\\n        while p1 != p2:\\n            if height[p1] > height[p2]:\\n                area = height[p2] * (p2 - p1)  # height of smaller edge multiplies on length\\n                p2 -= 1  # changing smaller edge\\n            else:\\n                area = height[p1] * (p2 - p1)\\n                p1 += 1\\n            if area > max_area: max_area = area  # increasing max area if possible\\n        return max_area\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 6213,
                "title": "my-short-and-easy-c-code-in-o-n",
                "content": "    class Solution {\\n    public:\\n        int maxArea(vector<int>& height) {\\n            int i=0,j=height.size()-1,ans = 0;\\n            while(j>i)\\n            {\\n                ans = max(min(height[i],height[j])*(j-i),ans);\\n                if(height[i]>height[j]) j--;\\n                else i++;\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxArea(vector<int>& height) {\\n            int i=0,j=height.size()-1,ans = 0;\\n            while(j>i)\\n            {\\n                ans = max(min(height[i],height[j])*(j-i),ans);\\n                if(height[i]>height[j]) j--;\\n                else i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3329256,
                "title": "98-59-javascript-simply-as-possible-with-readable-variables",
                "content": "Heights that are as far apart as possible will most likely be able to give the maximum amount of stored water. So we start with them.\\n\\nIn order to find the amount of stored water, we need to multiply the width between the heights by the smaller height.\\n\\nNext, we will shift the smaller height index to find out the possible amount of stored water with another height.\\n\\n**Please upvote if it was helpful!**\\n\\n``` JavaScript []\\nvar maxArea = function (height) {\\n    var leftIndex = 0;\\n    var rightIndex = height.length - 1;\\n    var maxStoredWater = 0;\\n\\n    while (leftIndex < rightIndex) {\\n        const leftHeight = height[leftIndex];\\n        const rightHeight = height[rightIndex];\\n        const width = rightIndex - leftIndex;\\n        const smallerHeight = leftHeight < rightHeight ? leftHeight : rightHeight;\\n        const storedWater = width * smallerHeight;\\n\\n        maxStoredWater = storedWater > maxStoredWater ? storedWater : maxStoredWater;\\n        smallerHeight == leftHeight ? leftIndex++ : rightIndex--;\\n    }\\n\\n    return maxStoredWater;\\n};\\n```\\n\\n``` Dart []\\nclass Solution {\\n  int maxArea(List<int> height) {\\n    int leftIndex = 0;\\n    int rightIndex = height.length - 1;\\n    int maxStoredWater = 0;\\n\\n    while (leftIndex < rightIndex) {\\n      final leftHeight = height[leftIndex];\\n      final rightHeight = height[rightIndex];\\n      final width = rightIndex - leftIndex;\\n      final smallerHeight = leftHeight < rightHeight ? leftHeight : rightHeight;\\n      final storedWater = width * smallerHeight;\\n\\n      maxStoredWater = storedWater > maxStoredWater ? storedWater : maxStoredWater;\\n      smallerHeight == leftHeight ? leftIndex++ : rightIndex--;\\n    }\\n\\n    return maxStoredWater;\\n  }\\n}\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/920200213/)",
                "solutionTags": [
                    "JavaScript",
                    "Dart"
                ],
                "code": "``` JavaScript []\\nvar maxArea = function (height) {\\n    var leftIndex = 0;\\n    var rightIndex = height.length - 1;\\n    var maxStoredWater = 0;\\n\\n    while (leftIndex < rightIndex) {\\n        const leftHeight = height[leftIndex];\\n        const rightHeight = height[rightIndex];\\n        const width = rightIndex - leftIndex;\\n        const smallerHeight = leftHeight < rightHeight ? leftHeight : rightHeight;\\n        const storedWater = width * smallerHeight;\\n\\n        maxStoredWater = storedWater > maxStoredWater ? storedWater : maxStoredWater;\\n        smallerHeight == leftHeight ? leftIndex++ : rightIndex--;\\n    }\\n\\n    return maxStoredWater;\\n};\\n```\n``` Dart []\\nclass Solution {\\n  int maxArea(List<int> height) {\\n    int leftIndex = 0;\\n    int rightIndex = height.length - 1;\\n    int maxStoredWater = 0;\\n\\n    while (leftIndex < rightIndex) {\\n      final leftHeight = height[leftIndex];\\n      final rightHeight = height[rightIndex];\\n      final width = rightIndex - leftIndex;\\n      final smallerHeight = leftHeight < rightHeight ? leftHeight : rightHeight;\\n      final storedWater = width * smallerHeight;\\n\\n      maxStoredWater = storedWater > maxStoredWater ? storedWater : maxStoredWater;\\n      smallerHeight == leftHeight ? leftIndex++ : rightIndex--;\\n    }\\n\\n    return maxStoredWater;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142747,
                "title": "python-two-pointer-solution",
                "content": "```\\ndef maxArea(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height) - 1\\n        \\n        area = 0\\n        \\n        while left != right:\\n            l = right - left\\n            h = min(height[right], height[left])\\n            area = max(l*h, area)\\n            \\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef maxArea(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height) - 1\\n        \\n        area = 0\\n        \\n        while left != right:\\n            l = right - left\\n            h = min(height[right], height[left])\\n            area = max(l*h, area)\\n            \\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return area\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3440965,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n       int ans = 0, n = height.size();\\n       int i = 0, j = n-1;\\n       while(i<j){\\n           if(height[i]>height[j]){\\n               ans = max(ans, (j-i)*height[j]);\\n               j--;\\n           }\\n           else{\\n               ans = max(ans, (j-i)*height[i]);\\n               i++;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n       int ans = 0, n = height.size();\\n       int i = 0, j = n-1;\\n       while(i<j){\\n           if(height[i]>height[j]){\\n               ans = max(ans, (j-i)*height[j]);\\n               j--;\\n           }\\n           else{\\n               ans = max(ans, (j-i)*height[i]);\\n               i++;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803384,
                "title": "python-easy-solution",
                "content": "\\n# Code\\u2705\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        maxx = 0 \\n        i = 0\\n        j = len(height)-1\\n        while i < j:\\n            width = abs(i-j)\\n            area = width * min(height[i],height[j])\\n            maxx = max(area,maxx)\\n            if height[i] > height[j]:\\n                j -=1\\n            else:\\n                i +=1\\n        return maxx \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        maxx = 0 \\n        i = 0\\n        j = len(height)-1\\n        while i < j:\\n            width = abs(i-j)\\n            area = width * min(height[i],height[j])\\n            maxx = max(area,maxx)\\n            if height[i] > height[j]:\\n                j -=1\\n            else:\\n                i +=1\\n        return maxx \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230548,
                "title": "two-pointer-approach-c-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int i = 0;\\n        int j = height.size()-1;\\n        int water = 0;\\n        int min_element = INT_MAX;\\n        while(i<j)\\n        {\\n            min_element = min(height[i] , height[j]);\\n            water = max(water , min_element*(j-i));\\n\\t\\t\\t// Move the pointer whose height is less\\n            if(height[i] < height[j])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int i = 0;\\n        int j = height.size()-1;\\n        int water = 0;\\n        int min_element = INT_MAX;\\n        while(i<j)\\n        {\\n            min_element = min(height[i] , height[j]);\\n            water = max(water , min_element*(j-i));\\n\\t\\t\\t// Move the pointer whose height is less\\n            if(height[i] < height[j])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540087,
                "title": "easy-c-solution-with-few-lines-of-code",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n## Code:\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n=height.size();\\n        int ans=0, i=0, j=n-1, area;\\n        while(i<j){\\n            area= (j-i)*min(height[i],height[j]);\\n            ans=max(ans,area);\\n            if(height[i]>height[j])\\n                j--;\\n            else\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n***Please upvote if you find this helpful! Thank you!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n=height.size();\\n        int ans=0, i=0, j=n-1, area;\\n        while(i<j){\\n            area= (j-i)*min(height[i],height[j]);\\n            ans=max(ans,area);\\n            if(height[i]>height[j])\\n                j--;\\n            else\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069570,
                "title": "python-2-pointers-solution-explained",
                "content": "We take two pointers, one at the beginning and one at the end of the array constituting the length of the lines.\\n\\nFuther, we maintain a variable `max_area` to store the maximum area obtained till now.  At every step, we find out the area formed between them, update `max_area` and move the pointer pointing to the shorter line towards the other end by one step. We can visualize eliminating logic in the following way: imagine, that we have matrix of `O(n^2)` possible options, and each time we make a step we eliminate either row or column, that is why it is enough to make `O(n)` steps. \\n\\n**Complexity**: Time complexity is `O(n)`, space is `O(1)`.\\n\\nImagine example, given in problem statement `[1, 8, 6, 2, 5, 4, 8, 3, 7]`. Let us denote by `X` point we already fully considered, that is such point, that for any other point we already checked all `n-1` possible containers. At the first step we choose smallest, between `1` and `7` and mark `1` as fully visited:\\n\\n`[X, 8, 6, 2, 5, 4, 8, 3, 7]`\\n\\nWhy we can do it: because among all containers which have `1` as one of endpoints, the biggest one is the longest one: heights of these containers can be `1` or less and length can be `7` or less.\\n\\nNext step, we choose smallest between `8` and `7` and mark it by `X` as well, so we have:\\n\\n`[X, 8, 6, 2, 5, 4, 8, 3, X]`\\n\\nWhy again we can mark last element by `X`? Because we have pairs of indexes: `[0, 7], [1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]`. First one no need to consider, we already did it, for the other pairs we can say that its heights is no more than `7` and length is no more than `6`. \\n\\nLet us know consider general case:\\n\\n`[X, X, X, ..., X, beg, . . . . . . . , end, X, X, X, X, ... X]`\\n\\nWe have the following **invariant** (property which kept on each step) here: all points, marked as `X` already fully finished. Imagine now, that `beg < end`. Then we can mark `beg` as fully visited, if we check container `[beg, end]`. Why? There are `3` types of containers we can create, where one endpoint is equal to `beg`, the other endpoint can be:\\n\\n1. Point from the first group of `X`, but in this case we can say it is already checked, because one of its ends marked with `X`.\\n2. Point from the last group of `X`, but it is exaclty the same logic here.\\n3. Point in between `beg` and `end`. But in this case, length of this container will always be less or equal to `end - beg` and height of this container will be always less or equal to `height[beg]`. So, checking container `[beg, end]` we have the biggest possible option for containers, where one endpoint is `beg` and another is betweeen `beg` and `end`.\\n\\nWe have absolutely the same logic if `beg > end`. Also, if we have `beg = end`, then we can move **any** of them, we still will keep our invariant.\\n\\n```\\nclass Solution:\\n    def maxArea(self, height):\\n        max_area, beg, end = 0, 0, len(height) - 1\\n        while beg < end:\\n            max_area = max(max_area, min(height[beg], height[end]) * (end - beg))\\n            if height[beg] < height[end]:\\n                beg += 1\\n            else:\\n                end -= 1\\n        return max_area\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**\\n\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height):\\n        max_area, beg, end = 0, 0, len(height) - 1\\n        while beg < end:\\n            max_area = max(max_area, min(height[beg], height[end]) * (end - beg))\\n            if height[beg] < height[end]:\\n                beg += 1\\n            else:\\n                end -= 1\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6217,
                "title": "simple-and-easy-understanding-java-solution",
                "content": "    public int maxArea(int[] height) {\\n        int maxA = 0;\\n        \\n        int i = 0, j = height.length-1;\\n        \\n        while(i < j) {\\n            int H = Math.min(height[i], height[j]);\\n            int W = j - i;\\n            maxA = Math.max(maxA, H*W);\\n            \\n            while(i < j && height[i] <= H) {\\n                ++i;\\n            }\\n            while(i < j && height[j] <= H) {\\n                --j;\\n            }\\n        }\\n        return maxA;\\n    }",
                "solutionTags": [],
                "code": "    public int maxArea(int[] height) {\\n        int maxA = 0;\\n        \\n        int i = 0, j = height.length-1;\\n        \\n        while(i < j) {\\n            int H = Math.min(height[i], height[j]);\\n            int W = j - i;\\n            maxA = Math.max(maxA, H*W);\\n            \\n            while(i < j && height[i] <= H) {\\n                ++i;\\n            }\\n            while(i < j && height[j] <= H) {\\n                --j;\\n            }\\n        }\\n        return maxA;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3493276,
                "title": "c-java-python-javascript-optimized-code-easy-to-understand-100-solution-explained",
                "content": "# Intuition:\\nThe problem requires us to find the maximum area between two lines on the x-axis given the height of the lines as an array. Since the area of a rectangle is determined by the minimum of the heights of the two lines and the distance between them, we can use a two-pointer approach to optimize the solution. We can initialize the left and right pointers to the beginning and end of the array, respectively, and then move the pointer with the smaller height towards the center while updating the maximum area.\\n\\n# Approach:\\n\\n1. Initialize the left and right pointers to the beginning and end of the array, respectively.\\n2. Initialize the max_area variable to 0.\\nWhile left < right:\\na. Calculate the area between the lines at height[left] and height[right] using min(height[left], height[right]) * (right - left).\\nb. Update the max_area variable with the maximum of max_area and area.\\nc. If height[left] < height[right], increment the left pointer.\\n3. Otherwise, decrement the right pointer.\\n4. Return the max_area variable.\\n# Complexity:\\n- Time Complexity: O(n)\\nThe two-pointer approach iterates through the array once, giving us a time complexity of O(n).\\n\\n- Space Complexity: O(1)\\nThe solution uses a constant amount of extra space, giving us a space complexity of O(1).\\n\\n# Similar Question:\\n [https://leetcode.com/problems/trapping-rain-water/solutions/3387829/cjavapythonjavascript-brute-force-optimized-code-easy-to-understand-for-begineers/](https://leetcode.com/problems/trapping-rain-water/solutions/3387829/cjavapythonjavascript-brute-force-optimized-code-easy-to-understand-for-begineers/)\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n - 1;\\n        int max_area = 0;\\n        while (left < right) {\\n            int area = min(height[left], height[right]) * (right - left);\\n            max_area = max(max_area, area);\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return max_area;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int n = height.length;\\n        int left = 0, right = n - 1;\\n        int max_area = 0;\\n        while (left < right) {\\n            int area = Math.min(height[left], height[right]) * (right - left);\\n            max_area = Math.max(max_area, area);\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return max_area;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        n = len(height)\\n        left, right = 0, n - 1\\n        max_area = 0\\n        while left < right:\\n            area = min(height[left], height[right]) * (right - left)\\n            max_area = max(max_area, area)\\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n        return max_area\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar maxArea = function(height) {\\n    let n = height.length;\\n    let left = 0, right = n - 1;\\n    let max_area = 0;\\n    while (left < right) {\\n        let area = Math.min(height[left], height[right]) * (right - left);\\n        max_area = Math.max(max_area, area);\\n        if (height[left] < height[right]) {\\n            left++;\\n        } else {\\n            right--;\\n        }\\n    }\\n    return max_area;\\n}\\n\\n```\\n\\n---\\n\\n# Similar Question:\\n [https://leetcode.com/problems/trapping-rain-water/solutions/3387829/cjavapythonjavascript-brute-force-optimized-code-easy-to-understand-for-begineers/](https://leetcode.com/problems/trapping-rain-water/solutions/3387829/cjavapythonjavascript-brute-force-optimized-code-easy-to-understand-for-begineers/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n - 1;\\n        int max_area = 0;\\n        while (left < right) {\\n            int area = min(height[left], height[right]) * (right - left);\\n            max_area = max(max_area, area);\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return max_area;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int n = height.length;\\n        int left = 0, right = n - 1;\\n        int max_area = 0;\\n        while (left < right) {\\n            int area = Math.min(height[left], height[right]) * (right - left);\\n            max_area = Math.max(max_area, area);\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return max_area;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        n = len(height)\\n        left, right = 0, n - 1\\n        max_area = 0\\n        while left < right:\\n            area = min(height[left], height[right]) * (right - left)\\n            max_area = max(max_area, area)\\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n        return max_area\\n\\n```\n```\\nvar maxArea = function(height) {\\n    let n = height.length;\\n    let left = 0, right = n - 1;\\n    let max_area = 0;\\n    while (left < right) {\\n        let area = Math.min(height[left], height[right]) * (right - left);\\n        max_area = Math.max(max_area, area);\\n        if (height[left] < height[right]) {\\n            left++;\\n        } else {\\n            right--;\\n        }\\n    }\\n    return max_area;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109027,
                "title": "java-simple-solution-with-detailed-explanation",
                "content": "\\nstart with brute force :\\n1. check for every possible subarrays  (Time :O(N^2) ) \\n   eg : height = [1,8,6,2,5,4,8,3,7]\\n   \\n(0,1)         (1,2)      (2,3) .....\\n(0,2)         (1,3)       \\n(0,3)         (1,4)\\n(0,4)         (1,5)\\n(0,5)         (1,6)\\n(0,6)         (1,7)\\n(0,7)         (1,8)\\n(0,8)\\n\\narea = (j-i)*Math.min(height[i],height[j]);\\n\\nj-i : width\\nMath.min(height[i],height[j]) : height\\n\\n\\nbut we can approch greedly \\nlet say (0,8) height[0] is less than height[8] \\n\\nso no need to check for (0,1) ... (0,7)\\nbecause (j-i :**width is going to decrease**)\\n\\nand **height part will either remain constant or decrease**\\nMath.**min**(height[i],height[j]) : height\\n  i know that height[0]<height[8] and\\nheight[1]...height[7] can be either \\n1. greater than height[0]  (new height will be height[0] i.e as of previous height (0,8))\\n2. less than height[0]     (new height will be less than height[0] i.e less than previous height (0,8))\\n3. equal to height[0]    (same as of earlier)\\n\\nso width is decreasing and height is also decreasing/constant . no need to check for (0,1)...(0,7) discard them and increase pointer from 0 to 1.(increase the pointer from  where the height is less).\\n\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int i=0;\\n        int j=height.length-1;\\n        \\n        int ans=0;\\n        while(i!=j){\\n            \\n            int area=(j-i)*Math.min(height[i],height[j]);\\n            \\n            if(area>ans){\\n                ans=area;\\n            }\\n            \\n            if(height[i]>height[j]){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if you find it helpful :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int i=0;\\n        int j=height.length-1;\\n        \\n        int ans=0;\\n        while(i!=j){\\n            \\n            int area=(j-i)*Math.min(height[i],height[j]);\\n            \\n            if(area>ans){\\n                ans=area;\\n            }\\n            \\n            if(height[i]>height[j]){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920507,
                "title": "python",
                "content": "```\\nfunction maxArea(height: number[]): number {\\n    let result = 0;\\n    \\n    for (let i = 0; i < height.length; i++) {\\n        for (let j = (height.length - 1); j >= i; j--) {\\n            const wi = j - i;\\n            const he = Math.min(height[i], height[j]);\\n            const area = wi * he;\\n            result = Math.max(result, area);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction maxArea(height: number[]): number {\\n    let result = 0;\\n    \\n    for (let i = 0; i < height.length; i++) {\\n        for (let j = (height.length - 1); j >= i; j--) {\\n            const wi = j - i;\\n            const he = Math.min(height[i], height[j]);\\n            const area = wi * he;\\n            result = Math.max(result, area);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1069553,
                "title": "c-simple-and-short-o-n-solution-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0, right = height.size()-1, h, max_area = 0;\\n        while (left < right) {\\n            int h = min(height[left], height[right]);\\n            max_area = max(max_area, h * (right - left));\\n            if (height[left] <= h) left++;\\n            if (height[right] <= h) right--;\\n        }\\n        return max_area;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0, right = height.size()-1, h, max_area = 0;\\n        while (left < right) {\\n            int h = min(height[left], height[right]);\\n            max_area = max(max_area, h * (right - left));\\n            if (height[left] <= h) left++;\\n            if (height[right] <= h) right--;\\n        }\\n        return max_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038263,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        l = 0\\n        r = len(height)-1\\n        res = 0\\n        while l < r:\\n            area = (r - l) * min(height[l], height[r])\\n            res = max(area,res)\\n            if height[l]<height[r]:\\n                l = l+1\\n            else:\\n                r = r-1\\n        return res\\n```\\n\\n\\nIn this question, we have to find the Area between two points: *Length x breadth*\\nLength will be the minimum element between the two pointers, and breadth will be the distance between the two pointers.\\n\\nSo, let us approach the question now.\\nAs left pointer is at Element 1, and its index is 0, Right Pointer is at element 7, and its index is the total length of the Array; we calculate the \\nArea = *(Right - Left) x  min(height[left],height[right]*\\n\\nWhy We take the Minimum? Because if we dont, then water will fall from the container.\\nAnd then, we update the result with the Area calculated, while moving forward our left pointer; if the element on the left is less than element on the right; else moving the right pointer backwards if the element on the right is less than element on the left.\\n\\nWe do this till left is less than right.\\n\\n**Runtime: 164 ms, faster than 83.87% of Python3 online submissions for Container With Most Water.\\nMemory Usage: 16.4 MB, less than 74.94% of Python3 online submissions for Container With Most Water.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        l = 0\\n        r = len(height)-1\\n        res = 0\\n        while l < r:\\n            area = (r - l) * min(height[l], height[r])\\n            res = max(area,res)\\n            if height[l]<height[r]:\\n                l = l+1\\n            else:\\n                r = r-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6194,
                "title": "beating-95-python-using-two-pointers",
                "content": "Since we know `area = length * min (height_a, height_b)`, to maximize the area we want to maximize both height and length.\\n\\n- Width: We set two pointers, which are initialized as `0` and `len(height) - 1` to get the max width.\\n- Height: We move the left pointer and right pointer respectively to search for the next higher height.\\n\\n<br>\\n\\n    def maxArea(self, height):\\n        max_area = area = 0\\n        left, right = 0, len(height) - 1\\n        while left < right:\\n            l, r = height[left], height[right]\\n            if l < r:\\n                area = (right - left) * l\\n                while height[left] <= l:\\n                    left += 1\\n            else:\\n                area = (right - left) * r\\n                while height[right] <= r and right:\\n                    right -= 1\\n            if area > max_area:\\n                max_area = area\\n        return max_area",
                "solutionTags": [
                    "Python"
                ],
                "code": "Since we know `area = length * min (height_a, height_b)`, to maximize the area we want to maximize both height and length.\\n\\n- Width: We set two pointers, which are initialized as `0` and `len(height) - 1` to get the max width.\\n- Height: We move the left pointer and right pointer respectively to search for the next higher height.\\n\\n<br>\\n\\n    def maxArea(self, height):\\n        max_area = area = 0\\n        left, right = 0, len(height) - 1\\n        while left < right:\\n            l, r = height[left], height[right]\\n            if l < r:\\n                area = (right - left) * l\\n                while height[left] <= l:\\n                    left += 1\\n            else:\\n                area = (right - left) * r\\n                while height[right] <= r and right:\\n                    right -= 1\\n            if area > max_area:\\n                max_area = area\\n        return max_area",
                "codeTag": "Python3"
            },
            {
                "id": 1672919,
                "title": "easy-solution-with-full-explanations-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- ***This will give Time Limit Exceeded, I put this for basic understanding.***\\n- We have to find the max area.\\n- Here we are fixing one point and counting all the possible answers & storing the max one.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- ***Here we\\u2019ll solve using the 2pointer approach.***\\n- We took 2 pointers ***start & end***.\\n- Calculate the area with the minimum height multiplied by distance.\\n- Store the maximum to ***ans***.\\n- Move the shorter height among 2 pointers to the next position.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n= height.size();\\n        int ans= INT_MIN;\\n        \\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                int a= min(height[i], height[j])*(j-i);\\n                ans = max(ans,a);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n= height.size();\\n        int ans= INT_MIN;\\n        int start=0, end=n-1;\\n        \\n        while(start<end){\\n            int area= min(height[start], height[end]) * (end-start);\\n            ans = max(ans, area);\\n            \\n            if(height[start] > height[end])\\n                end--;\\n            else\\n                start++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n= height.size();\\n        int ans= INT_MIN;\\n        \\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                int a= min(height[i], height[j])*(j-i);\\n                ans = max(ans,a);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n= height.size();\\n        int ans= INT_MIN;\\n        int start=0, end=n-1;\\n        \\n        while(start<end){\\n            int area= min(height[start], height[end]) * (end-start);\\n            ans = max(ans, area);\\n            \\n            if(height[start] > height[end])\\n                end--;\\n            else\\n                start++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818281,
                "title": "python-solution-o-n-beats-99",
                "content": "```\\ndef maxArea(self, height: List[int]) -> int:\\n            begin, end = 0, len(height) - 1\\n            area = 0\\n            while begin != end:\\n                if height[begin] < height[end]:\\n                    t = height[begin]*(end - begin)\\n                    area = max(area,t)\\n                    begin += 1\\n                else:\\n                    t = (height[end]*(end - begin))\\n                    area = max(area,t)\\n                    end -= 1\\n\\n            return area\\n```\\nFaster Solution\\n\\n- instead of using max to find the area, it was faster to use comparators.\\n- instead of using min to find the higher/lower height, we can just use the height after comparison. it was faster to use\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef maxArea(self, height: List[int]) -> int:\\n            begin, end = 0, len(height) - 1\\n            area = 0\\n            while begin != end:\\n                if height[begin] < height[end]:\\n                    t = height[begin]*(end - begin)\\n                    area = max(area,t)\\n                    begin += 1\\n                else:\\n                    t = (height[end]*(end - begin))\\n                    area = max(area,t)\\n                    end -= 1\\n\\n            return area\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3441091,
                "title": "best-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe two pointers are initialized to the first and last indices of the array respectively. \\n\\nIn each iteration of the while loop, the area between the two vertical lines is calculated by multiplying the minimum height between the two lines with the distance between them. The minimum height is chosen because the area of the container is limited by the shorter of the two lines. \\n\\nThe maximum area is then updated by comparing it with the area calculated in the current iteration. \\n\\nThe pointers are then moved towards each other by incrementing the lower pointer if the height at that index is less than the height at the higher pointer, or by decrementing the higher pointer if the opposite is true. This is because we can only increase the area by moving the pointer with the shorter height towards the center, as moving the pointer with the larger height would only decrease the distance between the two lines and result in a smaller area.\\n\\n![water.gif](https://assets.leetcode.com/users/images/baffae7b-583b-47e0-ba71-886cfff9924a_1682165219.3091524.gif)\\n\\n\\n# Complexity\\nThis approach has a *time complexity* of $$O(n)$$, where $$n$$ is the length of the input array.\\n\\nThe *space complexity* of this solution is $$O(1)$$ as it only uses a constant amount of extra space for the variables `maxArea`, `low`, and `high`.\\n\\n# Code\\n```swift\\nclass Solution {\\n    func maxArea(_ height: [Int]) -> Int {\\n        var maxArea = Int.min\\n        var low = 0\\n        var hight = height.count - 1\\n\\n        while low < hight {\\n            let area = min(height[low], height[hight]) * (hight - low)\\n\\n            maxArea = max(area, maxArea)\\n\\n            if height[low] < height[hight] {\\n                low += 1\\n            } else {\\n                hight -= 1\\n            }\\n        }\\n\\n        return maxArea\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/13b3f5a0-67a2-4680-8930-353448b50447_1682083067.5022871.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxArea(_ height: [Int]) -> Int {\\n        var maxArea = Int.min\\n        var low = 0\\n        var hight = height.count - 1\\n\\n        while low < hight {\\n            let area = min(height[low], height[hight]) * (hight - low)\\n\\n            maxArea = max(area, maxArea)\\n\\n            if height[low] < height[hight] {\\n                low += 1\\n            } else {\\n                hight -= 1\\n            }\\n        }\\n\\n        return maxArea\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383649,
                "title": "fastest-solution-explained-0ms-100-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n* *** Java ***\\n\\nThe first thing we should realize is that the amount of water contained is always going to be a rectangle whose area is defined as length * width. The width of any container will be the difference between the index of the two lines (i and j), and the height will be whichever of the two sides is the lowest (min(H[i], H[j])).\\n\\nThe brute force approach would be to compare every single pair of indexes in H, but that would be far too slow. Instead, we can observe that if we start with the lines on the opposite ends and move inward, the only possible time the area could be larger is when the height increases, since the width will continuously get smaller.\\n\\n```\\n\\nclass Solution {\\n    public int maxArea(int[] H) {\\n        int ans = 0, i = 0, j = H.length-1, res = 0;\\n        while (i < j) {\\n            if (H[i] <= H[j]) {\\n                res = H[i] * (j - i);\\n                i++;\\n            } else {\\n                res = H[j] * (j - i);\\n                j--;\\n            }\\n            if (res > ans) ans = res;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 10MB*** (beats 100.00% / 95.49%).\\n* *** Python ***\\n\\n```\\n\\nclass Solution:\\n    def maxArea(self, H: List[int]) -> int:\\n        ans, i, j = 0, 0, len(H)-1\\n        while (i < j):\\n            if H[i] <= H[j]:\\n                res = H[i] * (j - i)\\n                i += 1\\n            else:\\n                res = H[j] * (j - i)\\n                j -= 1\\n            if res > ans: ans = res\\n        return ans\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 23.7MB*** (beats 59.24% / 60.42%).\\n* *** C++ ***\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& H) {\\n        int ans = 0, i = 0, j = H.size()-1, res = 0;\\n        while (i < j) {\\n            if (H[i] <= H[j]) {\\n                res = H[i] * (j - i);\\n                i++;\\n            } else {\\n                res = H[j] * (j - i);\\n                j--;\\n            }\\n            if (res > ans) ans = res;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 78MB*** (beats 100.00% / 100.00%).\\n* *** JavaScript ***\\n\\n\\n```\\n\\nvar maxArea = function(H) {\\n    let ans = 0, i = 0, j = H.length-1\\n    while (i < j) {\\n        ans = Math.max(ans, Math.min(H[i], H[j]) * (j - i))\\n        H[i] <= H[j] ? i++ : j--\\n    }\\n    return ans\\n};\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 15.23MB*** (beats 89.94% / 90.99%).\\n* *** Python3 ***\\n\\nFirst, we check the widest possible container starting from the first line to the last one. Next, we ask ourselves, how is it possible to form an even bigger container? Every time we narrow the container, the width becomes smaller so the only way to get a bigger area is to find higher lines. So why not just greedily shrink the container on the side that has a shorter line? Every time we shrink the container, we calculate the area and save the maximum.\\n\\nTime: **O(n)**\\nSpace: **O(1)**\\n\\nRuntime: 819 ms, faster than 75.10% of Python3 online submissions for Container With Most Water.\\nMemory Usage: 27.4 MB, less than 58.32% of Python3 online submissions for Container With Most Water.\\n\\n```\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        l, r, area = 0, len(height) - 1, 0\\n        while l < r:\\n            area = max(area, (r - l) * min(height[l], height[r]))\\n            if height[l] < height[r]:\\n\\t\\t\\t\\tl += 1\\n            else:\\n\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\n        return area\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 33.33MB*** (beats 99.00% / 60.12%).\\n* *** Kotlin ***\\n\\n\\n```\\n\\n/**\\n * author: Leon\\n * https://leetcode.com/problems/container-with-most-water/\\n * \\n * Time Complexity:     O(N)\\n * Space Complexity:    O(1)\\n * \\n * References:\\n *  https://leetcode.com/problems/container-with-most-water/discuss/6091/Easy-Concise-Java-O(N)-Solution-with-Proof-and-Explanation\\n */\\n class Solution {\\n    fun maxArea(heights: IntArray): Int {\\n        // sanity check\\n        if(heights.isEmpty()) return 0\\n        \\n        val size = heights.size\\n        var lo = 0\\n        var hi = size -1 \\n        var maxArea = 0\\n        \\n        while(lo < hi){\\n            val area = minOf(heights[lo], heights[hi]) * (hi - lo)\\n            maxArea = maxOf(maxArea, area)\\n            \\n            if(heights[lo] < heights[hi])\\n                ++lo\\n            else --hi\\n        }\\n        \\n        return maxArea\\n    }\\n}\\n\\n```\\n\\n```\\nfun maxArea(height: IntArray): Int {\\n    tailrec fun calc(startIdx: Int, endIdx: Int, max: Int): Int =\\n        if (startIdx >= endIdx)\\n            max\\n        else\\n            if (height[startIdx] <= height[endIdx])\\n                calc(\\n                    startIdx = startIdx + 1,\\n                    endIdx = endIdx,\\n                    max = max(max, height[startIdx] * (endIdx - startIdx))\\n                )\\n            else\\n                calc(\\n                    startIdx = startIdx,\\n                    endIdx = endIdx - 1,\\n                    max = max(max, height[endIdx] * (endIdx - startIdx))\\n                )\\n\\n    return calc(startIdx = 0, endIdx = height.size - 1, max = 0)\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 13.17MB*** (beats 79.34% / 99.92%).\\n* *** Swift ***\\n\\n\\n```\\n\\nclass Solution {\\n    func maxArea(_ h: [Int]) -> Int {\\n        guard h.count > 2 else { return min(h[0], h[1]) }\\n        var val = 0, lhs = 0, rhs = h.count - 1\\n        while lhs < rhs {\\n            val = max(val, min(h[lhs], h[rhs]) * (rhs - lhs))\\n            h[lhs] < h[rhs] ? (lhs += 1) : (rhs -= 1)\\n        }\\n        return val\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 62.07MB*** (beats 99.99% / 99.99%).\\n* *** PHP ***\\n\\n\\n```\\n\\nclass Solution {\\n    function maxArea($height) {\\n        \\n        $count = count($height);\\n        $r = 0;\\n        $i = 0;\\n        $j = $count - 1;\\n        \\n        while ($i < $count - 1)\\n        {    \\n            if ($height[$i] <= $height[$j])\\n            {\\n                $t = $height[$i] * ($j - $i);\\n                $i++;\\n            }\\n            else\\n            {\\n                $t = $height[$j] * ($j - $i);\\n                $j--;\\n            }\\n\\n            if ($t > $r) \\n            {\\n                $r = $t;\\n            }\\n        }\\n        \\n        return $r;\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 1.17MB*** (beats 99.64% / 99.92%).\\n* *** C ***\\n\\n\\n```\\n\\nint maxArea(int* heights, int n) {\\n    int water = 0, *i = heights, *j = i + n - 1;\\n    while (i < j) {\\n        int h = *i < *j ? *i : *j;\\n        int w = (j - i) * h;\\n        if (w > water) water = w;\\n        while (*i <= h && i < j) i++;\\n        while (*j <= h && i < j) j--;\\n    }\\n    return water;\\n}\\n\\n```\\n\\n```\\nint maxArea(int* height, int heightSize){\\n    /* Given an integer array height of\\n     * length n. There are n vertical lines\\n     * drawn such that the two endpoints of the\\n     * ith line are (i, 0) and (i, height[i]).\\n     * Finds two lines that together with the\\n     * x-axis form a container, such that the\\n     * container contains the most water and\\n     * returns the maximum amount of water a\\n     * container can store. */\\n    int minIdx = 0, maxIdx = (heightSize - 1);\\n    int minHeight, area;\\n    int res = 0;\\n    while(minIdx < maxIdx){\\n        minHeight = (height[minIdx] < height[maxIdx]) ? height[minIdx] : height[maxIdx];\\n        area = minHeight * (maxIdx - minIdx);\\n        if(area > res){res = area;}\\n        if(height[minIdx] <= height[maxIdx]){minIdx++;}\\n        else{maxIdx--;}\\n    }\\n    return res;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    public int maxArea(int[] H) {\\n        int ans = 0, i = 0, j = H.length-1, res = 0;\\n        while (i < j) {\\n            if (H[i] <= H[j]) {\\n                res = H[i] * (j - i);\\n                i++;\\n            } else {\\n                res = H[j] * (j - i);\\n                j--;\\n            }\\n            if (res > ans) ans = res;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution:\\n    def maxArea(self, H: List[int]) -> int:\\n        ans, i, j = 0, 0, len(H)-1\\n        while (i < j):\\n            if H[i] <= H[j]:\\n                res = H[i] * (j - i)\\n                i += 1\\n            else:\\n                res = H[j] * (j - i)\\n                j -= 1\\n            if res > ans: ans = res\\n        return ans\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& H) {\\n        int ans = 0, i = 0, j = H.size()-1, res = 0;\\n        while (i < j) {\\n            if (H[i] <= H[j]) {\\n                res = H[i] * (j - i);\\n                i++;\\n            } else {\\n                res = H[j] * (j - i);\\n                j--;\\n            }\\n            if (res > ans) ans = res;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nvar maxArea = function(H) {\\n    let ans = 0, i = 0, j = H.length-1\\n    while (i < j) {\\n        ans = Math.max(ans, Math.min(H[i], H[j]) * (j - i))\\n        H[i] <= H[j] ? i++ : j--\\n    }\\n    return ans\\n};\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        l, r, area = 0, len(height) - 1, 0\\n        while l < r:\\n            area = max(area, (r - l) * min(height[l], height[r]))\\n            if height[l] < height[r]:\\n\\t\\t\\t\\tl += 1\\n            else:\\n\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\n        return area\\n\\n```\n```\\n```\n```\\n```\n```\\n\\n/**\\n * author: Leon\\n * https://leetcode.com/problems/container-with-most-water/\\n * \\n * Time Complexity:     O(N)\\n * Space Complexity:    O(1)\\n * \\n * References:\\n *  https://leetcode.com/problems/container-with-most-water/discuss/6091/Easy-Concise-Java-O(N)-Solution-with-Proof-and-Explanation\\n */\\n class Solution {\\n    fun maxArea(heights: IntArray): Int {\\n        // sanity check\\n        if(heights.isEmpty()) return 0\\n        \\n        val size = heights.size\\n        var lo = 0\\n        var hi = size -1 \\n        var maxArea = 0\\n        \\n        while(lo < hi){\\n            val area = minOf(heights[lo], heights[hi]) * (hi - lo)\\n            maxArea = maxOf(maxArea, area)\\n            \\n            if(heights[lo] < heights[hi])\\n                ++lo\\n            else --hi\\n        }\\n        \\n        return maxArea\\n    }\\n}\\n\\n```\n```\\nfun maxArea(height: IntArray): Int {\\n    tailrec fun calc(startIdx: Int, endIdx: Int, max: Int): Int =\\n        if (startIdx >= endIdx)\\n            max\\n        else\\n            if (height[startIdx] <= height[endIdx])\\n                calc(\\n                    startIdx = startIdx + 1,\\n                    endIdx = endIdx,\\n                    max = max(max, height[startIdx] * (endIdx - startIdx))\\n                )\\n            else\\n                calc(\\n                    startIdx = startIdx,\\n                    endIdx = endIdx - 1,\\n                    max = max(max, height[endIdx] * (endIdx - startIdx))\\n                )\\n\\n    return calc(startIdx = 0, endIdx = height.size - 1, max = 0)\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\n    func maxArea(_ h: [Int]) -> Int {\\n        guard h.count > 2 else { return min(h[0], h[1]) }\\n        var val = 0, lhs = 0, rhs = h.count - 1\\n        while lhs < rhs {\\n            val = max(val, min(h[lhs], h[rhs]) * (rhs - lhs))\\n            h[lhs] < h[rhs] ? (lhs += 1) : (rhs -= 1)\\n        }\\n        return val\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\n    function maxArea($height) {\\n        \\n        $count = count($height);\\n        $r = 0;\\n        $i = 0;\\n        $j = $count - 1;\\n        \\n        while ($i < $count - 1)\\n        {    \\n            if ($height[$i] <= $height[$j])\\n            {\\n                $t = $height[$i] * ($j - $i);\\n                $i++;\\n            }\\n            else\\n            {\\n                $t = $height[$j] * ($j - $i);\\n                $j--;\\n            }\\n\\n            if ($t > $r) \\n            {\\n                $r = $t;\\n            }\\n        }\\n        \\n        return $r;\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nint maxArea(int* heights, int n) {\\n    int water = 0, *i = heights, *j = i + n - 1;\\n    while (i < j) {\\n        int h = *i < *j ? *i : *j;\\n        int w = (j - i) * h;\\n        if (w > water) water = w;\\n        while (*i <= h && i < j) i++;\\n        while (*j <= h && i < j) j--;\\n    }\\n    return water;\\n}\\n\\n```\n```\\nint maxArea(int* height, int heightSize){\\n    /* Given an integer array height of\\n     * length n. There are n vertical lines\\n     * drawn such that the two endpoints of the\\n     * ith line are (i, 0) and (i, height[i]).\\n     * Finds two lines that together with the\\n     * x-axis form a container, such that the\\n     * container contains the most water and\\n     * returns the maximum amount of water a\\n     * container can store. */\\n    int minIdx = 0, maxIdx = (heightSize - 1);\\n    int minHeight, area;\\n    int res = 0;\\n    while(minIdx < maxIdx){\\n        minHeight = (height[minIdx] < height[maxIdx]) ? height[minIdx] : height[maxIdx];\\n        area = minHeight * (maxIdx - minIdx);\\n        if(area > res){res = area;}\\n        if(height[minIdx] <= height[maxIdx]){minIdx++;}\\n        else{maxIdx--;}\\n    }\\n    return res;\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471973,
                "title": "easy-c-impl",
                "content": "```\\npublic class Solution\\n{\\n    public int MaxArea(int[] height)\\n    {\\n        int left = 0;\\n        int right = height.Length - 1;\\n\\n        int res = 0;\\n\\n        while (left < right)\\n        {\\n            int minHeight = Math.Min(height[left], height[right]);\\n            res = Math.Max(res, minHeight * (right - left));\\n\\n            if (height[left] <= height[right])\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MaxArea(int[] height)\\n    {\\n        int left = 0;\\n        int right = height.Length - 1;\\n\\n        int res = 0;\\n\\n        while (left < right)\\n        {\\n            int minHeight = Math.Min(height[left], height[right]);\\n            res = Math.Max(res, minHeight * (right - left));\\n\\n            if (height[left] <= height[right])\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6203,
                "title": "java-easy-to-understand-beat-88-21",
                "content": "    public class Solution {\\n        public int maxArea(int[] height) {\\n            int left = 0;\\n\\t\\tint right = height.length-1;\\n\\t\\tint max = 0,temp = 0;\\n\\t\\twhile(left<right) {\\n\\t\\t\\tif(height[left] > height[right]){\\n\\t\\t\\t\\ttemp = (right-left) * height[right];\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\ttemp = (right-left) * height[left];\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n\\t\\t\\tmax = max > temp ? max :temp;\\n\\t\\t}\\n\\t\\treturn max;\\n         }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maxArea(int[] height) {\\n            int left = 0;\\n\\t\\tint right = height.length-1;\\n\\t\\tint max = 0,temp = 0;\\n\\t\\twhile(left<right) {\\n\\t\\t\\tif(height[left] > height[right]){\\n\\t\\t\\t\\ttemp = (right-left) * height[right];\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4033236,
                "title": "worst-method-python3-beginner-un-friendly-abysmal-unreadable-one-liner-beats-26",
                "content": "# Intuition\\nAn esoteric solution to a reasonable interview question!\\n\\n# Approach\\nSolve normally using two pointer approach. Purposefully obfuscate to one line.\\n\\nUses the exec() function from Python to encode a solution into a one-line string with escape codes.\\n\\n\\\\- Please, do not do this in an interview.\\n\\n# Complexity\\n- Time complexity:\\nO(n) maybe? Underlying function is still two pointer.\\n\\n- Space complexity:\\nexec() statement makes this abhorrent.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxArea(self, h: List[int]) -> int:\\n        global w, g; w, g = 0, h; exec(\\'l, r, w = 0, len(g)-1, 0\\\\nwhile l < r:\\\\n\\\\tw = max(w, min(g[l], g[r]) * (r-l))\\\\n\\\\tif g[l] >= g[r]: r -=1\\\\n\\\\telse: l +=1\\', globals()); return w\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, h: List[int]) -> int:\\n        global w, g; w, g = 0, h; exec(\\'l, r, w = 0, len(g)-1, 0\\\\nwhile l < r:\\\\n\\\\tw = max(w, min(g[l], g[r]) * (r-l))\\\\n\\\\tif g[l] >= g[r]: r -=1\\\\n\\\\telse: l +=1\\', globals()); return w\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564388,
                "title": "trapping-rainwater-lc42-vs-container-with-most-water-lc11-image-explanation",
                "content": "Before Trying to solve this, first clear the difference between the two questions. I edited the image given for the question 11. This must probably solve all the confusion. The Green Water is also trapped by the container when it rains. This is the key difference to be noted. \\n\\nThe confusion clears when you look at the meaning of array given. In question 11, the meaning of height[i] is a coordinate (i, height[i]) ie  height[i] is height of a bar with width 0 at position i. Where as for question 42, height[i] is height of a bar with width 1 at position i.\\n\\n![image](https://assets.leetcode.com/users/images/91a719be-84cd-4c94-8d4b-d24af216393d_1636277742.4002173.png)\\n\\n# 42. Trapping Rain Water\\n![image](https://assets.leetcode.com/users/images/d12c8675-4386-412b-a2e0-d3853a7de2a5_1636278407.0996118.png)\\n\\n```\\nint trap(vector<int> &height) \\n{\\n      int maxleft = height[0], maxright = height[height.size() - 1];\\n      int left = 1, right = height.size() - 2;\\n      int result = 0;\\n      while (left <= right)\\n      {\\n          maxleft = max(maxleft, height[left]);\\n          maxright = max(maxright, height[right]);\\n          if (maxright >= maxleft)\\n          {\\n\\t\\t\\t\\tresult += maxleft - height[left++];\\n          }\\n          else\\n          {\\n\\t\\t\\t\\tresult += maxright - height[right--];\\n          }\\n      }\\n      return result;\\n}\\n```\\n\\n# 11. Container With Most Water\\n![image](https://assets.leetcode.com/users/images/c341755c-841f-4654-8c89-4ea406ada82c_1636278454.603099.png)\\n\\n```\\nint maxArea(vector<int>& height) \\n    {\\n        int leftMax = 0, rightMax = 0, left =0,  i = 0, right = 0, j = height.size()-1;\\n        int ans = 0, maxi=0;\\n        while(i<j)\\n        {\\n            if(height[i]>leftMax) leftMax=height[i], left = i;\\n            if(height[j]>rightMax) rightMax=height[j], right = j;\\n            maxi = max(maxi, min(leftMax, rightMax)*(right-left));\\n            if(height[i]<height[j]) i++;\\n            else j--;\\n        }\\n        return maxi;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint trap(vector<int> &height) \\n{\\n      int maxleft = height[0], maxright = height[height.size() - 1];\\n      int left = 1, right = height.size() - 2;\\n      int result = 0;\\n      while (left <= right)\\n      {\\n          maxleft = max(maxleft, height[left]);\\n          maxright = max(maxright, height[right]);\\n          if (maxright >= maxleft)\\n          {\\n\\t\\t\\t\\tresult += maxleft - height[left++];\\n          }\\n          else\\n          {\\n\\t\\t\\t\\tresult += maxright - height[right--];\\n          }\\n      }\\n      return result;\\n}\\n```\n```\\nint maxArea(vector<int>& height) \\n    {\\n        int leftMax = 0, rightMax = 0, left =0,  i = 0, right = 0, j = height.size()-1;\\n        int ans = 0, maxi=0;\\n        while(i<j)\\n        {\\n            if(height[i]>leftMax) leftMax=height[i], left = i;\\n            if(height[j]>rightMax) rightMax=height[j], right = j;\\n            maxi = max(maxi, min(leftMax, rightMax)*(right-left));\\n            if(height[i]<height[j]) i++;\\n            else j--;\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309177,
                "title": "c-solution-o-n-with-proper-explaination",
                "content": "**Brute Force approach - O(n^2) :**\\nexplore all the pairs of vertical lines keeping one pointer(i) at index 0 and other at (i) +1 and increment it .\\n\\n**Optimized Approach - O(N)- time complexity** \\n\\n\\nThis is a very classic question of two-pointers. Here i pointer is at 0 and j is at the end i.e. height.size()-1 we are finding the vertical lines which will give us the maximum area. so here two cases will arise:\\n1) what if increment i pointer \\n   a) maybe the height will increase ( than  max water will increase) \\n   b) if height decreases - water will decrease.\\n2) if we decrement in j :\\n   a) height will increase ( water will decrease ) because we always take the minimum of the heights\\n   b) height will decrease (water will decrease ) \\n\\nso what factor will decide if i will be incremented or j will decrement?\\nif the height of i is greater than height of j than we will decrement j  because no longer it can give us a max water\\nif the height of j is greater than height of i vertical lines we will increment i \\nif both the vertical lines are the same i & j than whichever can be moved it doesn\\'t effect.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int i =0; \\n        int j = height.size()-1;\\n        int max_water = 0;// to store the maximum water collected\\n        while(i< j){\\n           int min_height = min(height[i], height[j]); // minimum of the two vertical lines height is responsible for containing the water \\n           int width = j-i; // index of j - index of i\\n            \\n           max_water = max(max_water, min_height *width); // update the max_water \\n            if(height[i] > height[j]){\\n              //whichever has the minimum height will move\\n                j--;\\n            }else{\\n                i++; // if i has minimum height we will increment it or both i and j pointers have same height increment i it dosen\\'t effect even we can decrement j also for the equal heights \\n            }\\n            \\n        }\\n        return max_water;\\n    }\\n};\\n```\\n**please upvote if you got any help and comment below if have any doubts**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int i =0; \\n        int j = height.size()-1;\\n        int max_water = 0;// to store the maximum water collected\\n        while(i< j){\\n           int min_height = min(height[i], height[j]); // minimum of the two vertical lines height is responsible for containing the water \\n           int width = j-i; // index of j - index of i\\n            \\n           max_water = max(max_water, min_height *width); // update the max_water \\n            if(height[i] > height[j]){\\n              //whichever has the minimum height will move\\n                j--;\\n            }else{\\n                i++; // if i has minimum height we will increment it or both i and j pointers have same height increment i it dosen\\'t effect even we can decrement j also for the equal heights \\n            }\\n            \\n        }\\n        return max_water;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6220,
                "title": "a-fast-and-easy-understand-cpp-solution",
                "content": "        int maxArea(vector<int> &height) {\\n            int l(0), r=height.size()-1, result(0);\\n            while(l < r){\\n                if(height[l] < height[r]){\\n                     result =  max(result, height[l] * (r - l));\\n                     int pivot = height[l++];\\n                     while(l < r && height[l] <= pivot) ++l;\\n                }else{\\n                     result = max(result, height[r] * (r - l));\\n                     int pivot = height[r--];\\n                     while(l < r && height[r] <= pivot) --r;\\n                }\\n            }\\n            return result;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        int maxArea(vector<int> &height) {\\n            int l(0), r=height.size()-1, result(0);\\n            while(l < r){\\n                if(height[l] < height[r]){\\n                     result =  max(result, height[l] * (r - l));\\n                     int pivot = height[l++];\\n                     while(l < r && height[l] <= pivot) ++l;\\n                }else{\\n                     result = max(result, height[r] * (r - l));\\n                     int pivot = height[r--];\\n                     while(l < r && height[r] <= pivot) --r;\\n                }\\n            }\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3146312,
                "title": "c-beats-90-easy-to-understand",
                "content": "# Intuition\\nTwo pointer approach to solve this problem\\n\\n# Approach\\n1. use two pointers , keep ***s at start*** and ***e at end***.\\n2. move the pointer with lower height only\\n3. we have to calculate the area and keep the maximum in the ***maxArea*** variable everytime\\n4. return maxArea\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int maxArea = 0;\\n        int s = 0, e = height.size()-1;\\n\\n        while(s < e){\\n            if(height[s] <= height[e]){\\n                maxArea = max(maxArea,(e-s) * height[s]);\\n                s++;\\n            }else{\\n                maxArea = max(maxArea,(e-s) * height[e]);\\n                e--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int maxArea = 0;\\n        int s = 0, e = height.size()-1;\\n\\n        while(s < e){\\n            if(height[s] <= height[e]){\\n                maxArea = max(maxArea,(e-s) * height[s]);\\n                s++;\\n            }else{\\n                maxArea = max(maxArea,(e-s) * height[e]);\\n                e--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052141,
                "title": "python-simple-solution-two-pointers-greedy-explained",
                "content": "# 1. Brute force solution using Two Pointers\\n# Intuition\\n- Try every single possible of pairs that exists inside of the array has greatest area.\\n# Approach\\n1. Initializing the Max container with the value of 0, the max container will always reinitialize when ever has a new container bigger\\n2. Using Two pointers P1 and P2 to represent every possible pairs(container) of the array.\\n3. Calculating each container exists inside of the array, the area of container is equal with height times width. The height is the lesser value betwen the left of container at the index P1 and the right of container at the index P2, heights = min(height[p1],height[p2]). The width is the length from the left to the right, width = p2-p1. \\n4. Comparing the current container of the array that P1 and P2 pointing with the max container to figure out what is the max conatiner in all possible containers.\\n# Code\\n```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        max_container = 0\\n        for p1 in range(len(height)):\\n            for p2 in range(p1+1,len(height)):\\n                heights = min(height[p1],height[p2])\\n                width = p2 - p1\\n                container = heights * width\\n                max_container = max(max_container, container)\\n        return max_container\\n```\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# 2. Optimize solution using Two Pointer\\n# Intuition\\n- Analyzing formular to calculate the area of container to use Two pointers in another way that can reduce repertion.\\n- Container = min(heights[p1],height[p2]) times p2-1  \\n# Approach\\n1. Initializing the Max area with the value of 0, the max area will always reinitialize when ever has a new area bigger than the value of max area.\\n2. Using shifting pointers with P1 is the most left side of the array and P2 is the most right side of the array. \\n3. Starting calculate the area at the max width first.\\n4. Then, changing width by moving the lesser height between left-most container and the right-most container by 1 index to figure out another container maybe has greater area than the previous because just only max width never guarante it is the max container, maybe the max container has normal width but big hight.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        p1 = 0\\n        p2 = len(height) -1\\n        max_container= 0\\n        while p1 < p2:\\n            heights = min(height[p1],height[p2])\\n            weight = p2 - p1 \\n            container = heights*weight\\n            max_container = max(max_container,container)\\n            if height[p1] <= height[p2]:\\n                p1 +=1\\n            else:\\n                p2 -=1\\n        return max_container\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        max_container = 0\\n        for p1 in range(len(height)):\\n            for p2 in range(p1+1,len(height)):\\n                heights = min(height[p1],height[p2])\\n                width = p2 - p1\\n                container = heights * width\\n                max_container = max(max_container, container)\\n        return max_container\\n```\n```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        p1 = 0\\n        p2 = len(height) -1\\n        max_container= 0\\n        while p1 < p2:\\n            heights = min(height[p1],height[p2])\\n            weight = p2 - p1 \\n            container = heights*weight\\n            max_container = max(max_container,container)\\n            if height[p1] <= height[p2]:\\n                p1 +=1\\n            else:\\n                p2 -=1\\n        return max_container\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541325,
                "title": "c-100-solution-two-pointers-approach-shortest-code-easy-to-understand",
                "content": "**Easy to understand and detailed step by step explanation with code for both brute force and optimized solution:**\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height){\\n        int l=0, r=height.size()-1;\\n        int ans=0, curr=0;\\n        while(l<r){\\n            curr = min(height[l], height[r])*(r-l);\\n            ans = max(ans, curr);\\n            if(height[l]>height[r]){\\n                r--;\\n            }\\n            else{\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote if you find the solution useful, means a lot.\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height){\\n        int l=0, r=height.size()-1;\\n        int ans=0, curr=0;\\n        while(l<r){\\n            curr = min(height[l], height[r])*(r-l);\\n            ans = max(ans, curr);\\n            if(height[l]>height[r]){\\n                r--;\\n            }\\n            else{\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote if you find the solution useful, means a lot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915387,
                "title": "easy-to-understand-codes-c-c-java-python",
                "content": "## C++ \\n```\\nint maxArea(vector<int>& height) {\\n    int water = 0;\\n    int i = 0, j = height.size() - 1;\\n    while (i < j) {\\n        int h = min(height[i], height[j]);\\n        water = max(water, (j - i) * h);\\n        while (height[i] <= h && i < j) i++;\\n        while (height[j] <= h && i < j) j--;\\n    }\\n    return water;\\n}\\n```\\n## C\\n```\\nint maxArea(int* heights, int n) {\\n    int water = 0, *i = heights, *j = i + n - 1;\\n    while (i < j) {\\n        int h = *i < *j ? *i : *j;\\n        int w = (j - i) * h;\\n        if (w > water) water = w;\\n        while (*i <= h && i < j) i++;\\n        while (*j <= h && i < j) j--;\\n    }\\n    return water;\\n}\\n```\\n## JAVA\\n```\\nclass Solution:\\n    def maxArea(self, height):\\n        i, j = 0, len(height) - 1\\n        water = 0\\n        while i < j:\\n            water = max(water, (j - i) * min(height[i], height[j]))\\n            if height[i] < height[j]:\\n                i += 1\\n            else:\\n                j -= 1\\n        return water\\n```\\n## PYTHON\\n```\\nclass Solution:\\n    def maxArea(self, height):\\n        i, j = 0, len(height) - 1\\n        water = 0\\n        while i < j:\\n            water = max(water, (j - i) * min(height[i], height[j]))\\n            if height[i] < height[j]:\\n                i += 1\\n            else:\\n                j -= 1\\n        return water\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nint maxArea(vector<int>& height) {\\n    int water = 0;\\n    int i = 0, j = height.size() - 1;\\n    while (i < j) {\\n        int h = min(height[i], height[j]);\\n        water = max(water, (j - i) * h);\\n        while (height[i] <= h && i < j) i++;\\n        while (height[j] <= h && i < j) j--;\\n    }\\n    return water;\\n}\\n```\n```\\nint maxArea(int* heights, int n) {\\n    int water = 0, *i = heights, *j = i + n - 1;\\n    while (i < j) {\\n        int h = *i < *j ? *i : *j;\\n        int w = (j - i) * h;\\n        if (w > water) water = w;\\n        while (*i <= h && i < j) i++;\\n        while (*j <= h && i < j) j--;\\n    }\\n    return water;\\n}\\n```\n```\\nclass Solution:\\n    def maxArea(self, height):\\n        i, j = 0, len(height) - 1\\n        water = 0\\n        while i < j:\\n            water = max(water, (j - i) * min(height[i], height[j]))\\n            if height[i] < height[j]:\\n                i += 1\\n            else:\\n                j -= 1\\n        return water\\n```\n```\\nclass Solution:\\n    def maxArea(self, height):\\n        i, j = 0, len(height) - 1\\n        water = 0\\n        while i < j:\\n            water = max(water, (j - i) * min(height[i], height[j]))\\n            if height[i] < height[j]:\\n                i += 1\\n            else:\\n                j -= 1\\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419256,
                "title": "easy-2-pointer-solution-faster-than-98",
                "content": "**Upvote** if you found the solution easy\\n\\n\\tclass Solution {\\n    public int maxArea(int[] height) {\\n        int max=0,l=0,r=height.length-1,ar;\\n        while(l<r)\\n        {\\n            if(height[r]<height[l])\\n            {\\n                ar=(r-l)*(height[r]);\\n                r--;\\n            }\\n            else\\n            {\\n                ar=(r-l)*(height[l]);\\n                l++;\\n            }\\n            max=Math.max(max,ar);\\n            \\n        }\\n        return max;\\n        \\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int maxArea(int[] height) {\\n        int max=0,l=0,r=height.length-1,ar;\\n        while(l<r)\\n        {\\n            if(height[r]<height[l])\\n            {\\n                ar=(r-l)*(height[r]);\\n                r--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2595565,
                "title": "my-solution",
                "content": "```\\nfunction maxArea(height: number[]): number {\\n    let result = 0;\\n    \\n    for (let i = 0; i < height.length; i++) {\\n        for (let j = (height.length - 1); j >= i; j--) {\\n            const wi = j - i;\\n            const he = Math.min(height[i], height[j]);\\n            const area = wi * he;\\n            result = Math.max(result, area);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction maxArea(height: number[]): number {\\n    let result = 0;\\n    \\n    for (let i = 0; i < height.length; i++) {\\n        for (let j = (height.length - 1); j >= i; j--) {\\n            const wi = j - i;\\n            const he = Math.min(height[i], height[j]);\\n            const area = wi * he;\\n            result = Math.max(result, area);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349952,
                "title": "javascript-two-pointer",
                "content": "\\tvar maxArea = function(height) {\\n\\t\\tlet l = 0, r = height.length-1, result=0;\\n\\n\\t\\twhile(l<r){\\n\\t\\t\\tlet h = Math.min(height[l], height[r]);\\n\\t\\t\\tlet area = h*(r-l)\\n\\t\\t\\tresult = Math.max(area, result)\\n\\t\\t\\tif(height[l]< height[r]){\\n\\t\\t\\t   l++\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tr--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "\\tvar maxArea = function(height) {\\n\\t\\tlet l = 0, r = height.length-1, result=0;\\n\\n\\t\\twhile(l<r){\\n\\t\\t\\tlet h = Math.min(height[l], height[r]);\\n\\t\\t\\tlet area = h*(r-l)\\n\\t\\t\\tresult = Math.max(area, result)\\n\\t\\t\\tif(height[l]< height[r]){\\n\\t\\t\\t   l++\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tr--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1035783,
                "title": "simple-python-solution-using-two-pointers-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        max_area = 0\\n        left = 0\\n        right = len(height) - 1\\n        while left < right:\\n            w = right - left\\n            h = min(height[left], height[right])\\n            a = w * h\\n            max_area = max(max_area, a)\\n            \\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return max_area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        max_area = 0\\n        left = 0\\n        right = len(height) - 1\\n        while left < right:\\n            w = right - left\\n            h = min(height[left], height[right])\\n            a = w * h\\n            max_area = max(max_area, a)\\n            \\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943677,
                "title": "rust-solution-with-doubleendediterator",
                "content": "```\\nimpl Solution {\\n    pub fn max_area(height: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        let mut iter = height.iter().enumerate();\\n        let mut p1 = iter.next();\\n        let mut p2 = iter.next_back();\\n        while let (Some((i, h1)), Some((j, h2))) = (p1, p2) {\\n            result = result.max(h1.min(h2) * (j - i) as i32);\\n            if h1 < h2 {\\n                p1 = iter.next();\\n            }\\n            else {\\n                p2 = iter.next_back();\\n            }\\n        }\\n        result\\n    }\\n}\\n```\\n\\nThis `while let` is a bit ugly. When [eRFC 2497](https://github.com/rust-lang/rust/issues/53667) will be stabilized you can use instead:\\n`while let Some((i, h1)) = p1 && let Some((j, h2)) = p2 {`",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_area(height: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        let mut iter = height.iter().enumerate();\\n        let mut p1 = iter.next();\\n        let mut p2 = iter.next_back();\\n        while let (Some((i, h1)), Some((j, h2))) = (p1, p2) {\\n            result = result.max(h1.min(h2) * (j - i) as i32);\\n            if h1 < h2 {\\n                p1 = iter.next();\\n            }\\n            else {\\n                p2 = iter.next_back();\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6185,
                "title": "a-javascript-solution",
                "content": "```\\nvar maxArea = function(height) {\\n    var maxArea = 0;\\n    var length = height.length;\\n    var head = 0, tail = length-1;\\n    while (tail - head > 0){\\n        var area = Math.min(height[head],height[tail]) * (tail - head);\\n        maxArea = Math.max(maxArea, area);\\n        if (height[head] > height[tail]){\\n            tail--;\\n        }else{\\n            head++;\\n        }\\n        \\n    }\\n    return maxArea;\\n};",
                "solutionTags": [],
                "code": "```\\nvar maxArea = function(height) {\\n    var maxArea = 0;\\n    var length = height.length;\\n    var head = 0, tail = length-1;\\n    while (tail - head > 0){\\n        var area = Math.min(height[head],height[tail]) * (tail - head);\\n        maxArea = Math.max(maxArea, area);\\n        if (height[head] > height[tail]){\\n            tail--;\\n        }else{\\n            head++;\\n        }\\n        \\n    }\\n    return maxArea;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 6254,
                "title": "my-c-code-o-n-time-updated-with-a-concise-version",
                "content": "The basic idea is to use two pointers to scan the vector, and skip the elements that are less than its previous checked element.\\n\\n// updated version\\n\\n    class Solution {\\n    public:\\n        int maxArea(vector<int>& height) {\\n            int right = height.size()-1, left =0;\\n            int res = 0;\\n            \\n            while(left < right)\\n            {\\n                res = max(res, (right-left)*(height[right]<height[left]?height[right--]:height[left++]));    \\n            }\\n            return res;\\n        }\\n    }; \\n\\n//original one \\n\\n   class Solution {\\n    public:\\n        int maxArea(vector<int> &height) {\\n            int bIdx=0, eIdx, lowH;\\n            int res=0;\\n    \\n            eIdx = height.size()-1;\\n            while(bIdx<eIdx)\\n            {\\n                if(height[bIdx] > height[eIdx])\\n                { // if the right node has a smaller height\\n                    lowH = height[eIdx];\\n                    res = max(res, lowH * (eIdx-bIdx) ); // update the max area\\n                    eIdx--; // skip the current element\\n                    while( (eIdx>bIdx) && (height[eIdx]<= lowH) ) eIdx--; // skip all the subsequent elements that have smaller height\\n                }\\n                else\\n                {// if the left node has a smaller height\\n                    lowH = height[bIdx];\\n                    res = max(res, lowH * (eIdx-bIdx) );\\n                    bIdx++; // skip the current node\\n                    while( (eIdx>bIdx) && (height[bIdx]<= lowH) ) bIdx++;  // skip all the subsequent elements that have smaller height\\n                }\\n            }\\n            \\n            return res;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxArea(vector<int>& height) {\\n            int right = height.size()-1, left =0;\\n            int res = 0;\\n            \\n            while(left < right)\\n            {\\n                res = max(res, (right-left)*(height[right]<height[left]?height[right--]:height[left++]));    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3525310,
                "title": "c-java-python3-solution-faster-than-95",
                "content": "**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-11-container-with-most-water-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-11-container-with-most-water-solution-and-explanation-en/)\\u2B50**\\n\\n> If you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).\\nThanks!\\n\\n## **C# - two pointer to convergence**\\n```\\npublic class Solution {\\n    public int MaxArea(int[] height) {\\n     \\n        int i = 0;\\n        int j = height.Length-1;\\n        int maxAmt = 0;\\n        int iH;\\n        int jH;\\n        int cal;\\n        \\n        while(j>i)\\n        {\\n            iH = height[i];\\n            jH = height[j];\\n            \\n            //Convergence back and forth\\n            //which is higher\\uFF0Cthan will convergence from  the other side\\n            if(iH>jH)\\n            {\\n                cal = jH*(j-i);\\n                j--;\\n            }\\n            else\\n            {\\n                cal = iH*(j-i); \\n                i++;\\n            }\\n            \\n            if(cal>maxAmt)\\n                 maxAmt = cal;\\n            \\n        }\\n        return maxAmt;\\n    }\\n}\\n```\\n\\n---\\n\\n## **Java**\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int i = 0;\\n        int j = height.length-1;\\n        int maxAmt = 0;\\n        int iH;\\n        int jH;\\n        int cal;\\n        \\n        while(j>i)\\n        {\\n            iH = height[i];\\n            jH = height[j];\\n            \\n            //Convergence back and forth\\n            //which is higher\\uFF0Cthan will convergence from  the other side\\n            if(iH>jH)\\n            {\\n                cal = jH*(j-i);\\n                j--;\\n            }\\n            else\\n            {\\n                cal = iH*(j-i); \\n                i++;\\n            }\\n            \\n            if(cal>maxAmt)\\n                 maxAmt = cal;\\n            \\n        }\\n        return maxAmt;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n## **Python3**\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        i = 0;\\n        j = len(height)-1;\\n        maxAmt = 0;\\n        \\n        while(j>i):\\n            iH = height[i];\\n            jH = height[j];\\n            \\n            if(iH>jH):\\n                cal = jH*(j-i);\\n                j-=1;\\n            else:\\n                cal = iH*(j-i); \\n                i+=1;\\n            \\n            if(cal>maxAmt):\\n                 maxAmt = cal;\\n \\n        return maxAmt;\\n```\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxArea(int[] height) {\\n     \\n        int i = 0;\\n        int j = height.Length-1;\\n        int maxAmt = 0;\\n        int iH;\\n        int jH;\\n        int cal;\\n        \\n        while(j>i)\\n        {\\n            iH = height[i];\\n            jH = height[j];\\n            \\n            //Convergence back and forth\\n            //which is higher\\uFF0Cthan will convergence from  the other side\\n            if(iH>jH)\\n            {\\n                cal = jH*(j-i);\\n                j--;\\n            }\\n            else\\n            {\\n                cal = iH*(j-i); \\n                i++;\\n            }\\n            \\n            if(cal>maxAmt)\\n                 maxAmt = cal;\\n            \\n        }\\n        return maxAmt;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int i = 0;\\n        int j = height.length-1;\\n        int maxAmt = 0;\\n        int iH;\\n        int jH;\\n        int cal;\\n        \\n        while(j>i)\\n        {\\n            iH = height[i];\\n            jH = height[j];\\n            \\n            //Convergence back and forth\\n            //which is higher\\uFF0Cthan will convergence from  the other side\\n            if(iH>jH)\\n            {\\n                cal = jH*(j-i);\\n                j--;\\n            }\\n            else\\n            {\\n                cal = iH*(j-i); \\n                i++;\\n            }\\n            \\n            if(cal>maxAmt)\\n                 maxAmt = cal;\\n            \\n        }\\n        return maxAmt;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        i = 0;\\n        j = len(height)-1;\\n        maxAmt = 0;\\n        \\n        while(j>i):\\n            iH = height[i];\\n            jH = height[j];\\n            \\n            if(iH>jH):\\n                cal = jH*(j-i);\\n                j-=1;\\n            else:\\n                cal = iH*(j-i); \\n                i+=1;\\n            \\n            if(cal>maxAmt):\\n                 maxAmt = cal;\\n \\n        return maxAmt;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626891,
                "title": "o-n-easy-to-understand",
                "content": "```\\n// Using  Two Pointer Approach\\n//Easy to understand\\n// Relate Through this array [1 8 6 2 5 4 8 3 7]\\npublic int maxArea(int[] height) {\\n        int maxWater = 0; // store max area of water \\n        int i = 0;// extreme Left\\n        int j = height.length - 1;// extreme right\\n        \\n        while(i < j){// until both are equal\\n            int widthOfIndex = j-i; // difference of indexes give you width \\n            int heightOfLines = Math.min(height[i] , height[j]); // find min height beacuse after that  water will be overflow from the container\\n            \\n            maxWater = Math.max(maxWater , widthOfIndex*heightOfLines);// update the maxWater by simply mutiply width * height\\n            \\n            if(height[i] < height[j]){// if i is small, increment it may be we can find max height \\n                i++;\\n            }else{\\n                j--;// else decement j;\\n            }\\n         }\\n        return maxWater ;\\n    }\\n\\t// please upvote it if you find solution is helpful\\n\\t// Thank you\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n// Using  Two Pointer Approach\\n//Easy to understand\\n// Relate Through this array [1 8 6 2 5 4 8 3 7]\\npublic int maxArea(int[] height) {\\n        int maxWater = 0; // store max area of water \\n        int i = 0;// extreme Left\\n        int j = height.length - 1;// extreme right\\n        \\n        while(i < j){// until both are equal\\n            int widthOfIndex = j-i; // difference of indexes give you width \\n            int heightOfLines = Math.min(height[i] , height[j]); // find min height beacuse after that  water will be overflow from the container\\n            \\n            maxWater = Math.max(maxWater , widthOfIndex*heightOfLines);// update the maxWater by simply mutiply width * height\\n            \\n            if(height[i] < height[j]){// if i is small, increment it may be we can find max height \\n                i++;\\n            }else{\\n                j--;// else decement j;\\n            }\\n         }\\n        return maxWater ;\\n    }\\n\\t// please upvote it if you find solution is helpful\\n\\t// Thank you\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203050,
                "title": "fast-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int size = height.length;\\n        if(size == 1){return 0;}\\n        if(size == 2){return Math.min(height[0],height[1]) ;}\\n        \\n        int left = 0;\\n        int right = size-1;\\n        int max_area = 0;\\n        \\n        while(left != right){\\n            if(height[left] < height[right]){\\n                max_area = Math.max(max_area, height[left]*(right-left));\\n                left++;\\n            }\\n             else{\\n                 max_area = Math.max(max_area, height[right]*(right-left));\\n                 right--;\\n             }            \\n        }\\n       return max_area;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int size = height.length;\\n        if(size == 1){return 0;}\\n        if(size == 2){return Math.min(height[0],height[1]) ;}\\n        \\n        int left = 0;\\n        int right = size-1;\\n        int max_area = 0;\\n        \\n        while(left != right){\\n            if(height[left] < height[right]){\\n                max_area = Math.max(max_area, height[left]*(right-left));\\n                left++;\\n            }\\n             else{\\n                 max_area = Math.max(max_area, height[right]*(right-left));\\n                 right--;\\n             }            \\n        }\\n       return max_area;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168099,
                "title": "compact-ruby-o-n",
                "content": "\\nNot that many Ruby solutions so I decided to share my compact solution.\\n```\\ndef max_area(height)\\n    left = 0 \\n    right = height.length - 1\\n    maxArea = 0    \\n    while (left < right)\\n        maxArea = [[height[left], height[right]].min * (right - left), maxArea].max\\n        height[left] > height[right] ? right -= 1 : left += 1\\n    end\\n    maxArea\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef max_area(height)\\n    left = 0 \\n    right = height.length - 1\\n    maxArea = 0    \\n    while (left < right)\\n        maxArea = [[height[left], height[right]].min * (right - left), maxArea].max\\n        height[left] > height[right] ? right -= 1 : left += 1\\n    end\\n    maxArea\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 6260,
                "title": "sharing-my-simple-c-solution",
                "content": "    int maxArea(vector<int> &height) {\\n        int left = 0, right = height.size() - 1;\\n        int maxWater = 0;\\n        while(left < right){\\n            maxWater = max(maxWater, (right - left) * min(height[left], height[right]));\\n            height[left] < height[right] ? left++ : right--;\\n        }\\n        return maxWater;\\n    }\\n\\nThe basic idea is simple: use two pointers to indicate the left edge and right edge of the water container. Every time move the lower edge towards another edge with one step. At last, we can find the max water container.",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "    int maxArea(vector<int> &height) {\\n        int left = 0, right = height.size() - 1;\\n        int maxWater = 0;\\n        while(left < right){\\n            maxWater = max(maxWater, (right - left) * min(height[left], height[right]));\\n            height[left] < height[right] ? left++ : right--;\\n        }\\n        return maxWater;\\n    }\\n\\nThe basic idea is simple: use two pointers to indicate the left edge and right edge of the water container. Every time move the lower edge towards another edge with one step. At last, we can find the max water container.",
                "codeTag": "Unknown"
            },
            {
                "id": 4066897,
                "title": "video-visualization-and-intuitive-proof-of-o-n-solution",
                "content": "https://youtu.be/Kb20p6zy_14\\n\\nThe strategy is to start with the container of the <i>longest</i> width and move the sides inwards one by one to see if we can get a larger area by shortening the width but getting a taller height. But how do we know which side to move?\\n\\nThe key insight here is that moving the <i>longer</i> side inwards is completely unnecessary because the height of the water is bounded by the <i>shorter</i> side. In other words, we will never be able to get a greater area by moving the longer side inwards because the height will either stay the same or get shorter, and the width will keep decreasing.\\n\\nSo we can skip all those calculations and instead move the <i>shorter</i> side inwards.  This way, we <i>might</i> get a taller height and a larger area.  So at each step, we calculate the area then move the shorter side inwards.  When the left and right sides meet, we are done and we can return the largest area calculated so far.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        max_area = 0\\n        l = 0\\n        r = len(height) - 1\\n        while l < r:\\n            area = (r - l) * min(height[r], height[l])\\n            max_area = max(max_area, area)\\n            if height[l] < height[r]:\\n                l += 1\\n            else:\\n                r -= 1\\n        return max_area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        max_area = 0\\n        l = 0\\n        r = len(height) - 1\\n        while l < r:\\n            area = (r - l) * min(height[r], height[l])\\n            max_area = max(max_area, area)\\n            if height[l] < height[r]:\\n                l += 1\\n            else:\\n                r -= 1\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088376,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxArea(int[] height) {\\n        int l=0,\\n            r=height.Length-1,\\n            current_max=0,\\n            max=0;\\n        while(l<r)\\n        {\\n             current_max= (r-l)*Math.Min(height[l],height[r]); \\n             if(current_max>max) \\n                 max= current_max;\\n\\t\\t\\t\\t \\n             if(height[l]<=height[r])\\n                 l++;\\n             else\\n                r--;\\n         }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxArea(int[] height) {\\n        int l=0,\\n            r=height.Length-1,\\n            current_max=0,\\n            max=0;\\n        while(l<r)\\n        {\\n             current_max= (r-l)*Math.Min(height[l],height[r]); \\n             if(current_max>max) \\n                 max= current_max;\\n\\t\\t\\t\\t \\n             if(height[l]<=height[r])\\n                 l++;\\n             else\\n                r--;\\n         }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883105,
                "title": "100-fastest-solution-explained",
                "content": "Easy to understand and detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer.\\n\\n**Kindly upvote if this helps you. Thank You**",
                "solutionTags": [
                    "Go"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 426557,
                "title": "javascript-better-than-86-and-easy-to-understand",
                "content": "```\\nvar maxArea = function(height) {\\n    let maxArea = -1;\\n    \\n    let left = 0;\\n    let right = height.length - 1;\\n    \\n    while (left < right) {\\n        const lVal = height[left];\\n        const rVal = height[right];\\n        \\n        const h = Math.min(lVal, rVal);\\n        const w = right - left;\\n        \\n        maxArea = Math.max((h * w), maxArea);\\n        \\n        if (lVal > rVal) right--;\\n        else left++;\\n    }\\n    \\n    return maxArea\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxArea = function(height) {\\n    let maxArea = -1;\\n    \\n    let left = 0;\\n    let right = height.length - 1;\\n    \\n    while (left < right) {\\n        const lVal = height[left];\\n        const rVal = height[right];\\n        \\n        const h = Math.min(lVal, rVal);\\n        const w = right - left;\\n        \\n        maxArea = Math.max((h * w), maxArea);\\n        \\n        if (lVal > rVal) right--;\\n        else left++;\\n    }\\n    \\n    return maxArea\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163140,
                "title": "two-pointers-thinking-process",
                "content": "It is intuitive to try each two line to calculate the amount of water trapped and get the most water trapped. That takes O(n^2) time for n is the length of `height`.\\n\\nCan we achieve O(n) time? Two Pointers should always be considered if we try reducing time from O(n^2) to O(n) against an array.\\n\\nAssuming two pointers `i`, `j`  where\\n\\n- `i = 0, j = len(height) - 1` at the very beginning, we calculate the water trapped; \\n- Then we should move pointers towards each other. Which pointer shall we move? Since width will reduce by 1 anyway, we should try keeping the higher height, that is, moving the pointer with a lower height.\\n\\n****\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        res = 0\\n        i, j = 0, len(height) - 1\\n        while i < j:\\n            res = max(res, min(height[i], height[j]) * (j - i))\\n            if height[i] < height[j]:\\n                i += 1\\n            else:\\n                j -= 1\\n        return res\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        res = 0\\n        i, j = 0, len(height) - 1\\n        while i < j:\\n            res = max(res, min(height[i], height[j]) * (j - i))\\n            if height[i] < height[j]:\\n                i += 1\\n            else:\\n                j -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6124,
                "title": "swift-solution-two-pointers",
                "content": "```\\nclass Solution {\\n    func maxArea(_ height: [Int]) -> Int {\\n        var left = 0\\n        var right = height.count - 1\\n        var maxArea = 0\\n        \\n        while left < right {\\n            maxArea = max(maxArea, min(height[left], height[right]) * (right - left))\\n            if height[left] < height[right] {\\n                left += 1\\n            } else {\\n                right -= 1\\n            }\\n        }\\n        \\n        return maxArea\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    func maxArea(_ height: [Int]) -> Int {\\n        var left = 0\\n        var right = height.count - 1\\n        var maxArea = 0\\n        \\n        while left < right {\\n            maxArea = max(maxArea, min(height[left], height[right]) * (right - left))\\n            if height[left] < height[right] {\\n                left += 1\\n            } else {\\n                right -= 1\\n            }\\n        }\\n        \\n        return maxArea\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6229,
                "title": "simple-o-n-time-o-1-solution-in-java",
                "content": "The idea is that a container to hold water can only be formed by two two heights with the lowest height as the height of the container. So, if we start from two numbers farthest apart in length (i.e. first and last element) then we have maximum width rectangle. Now, we can move to shorter height only to left or right to maximize the total area. \\n\\n    public class Solution {\\n        public int maxArea(int[] height) {\\n            int len = height.length, low = 0, high = len -1 ;  \\n            int maxArea = 0;  \\n            while (low < high) {  \\n             maxArea = Math.max(maxArea, (high - low) * Math.min(height[low], height[high]));  \\n             if (height[low] < height[high]) {  \\n               low++;  \\n             } else {  \\n               high--;  \\n             }  \\n            }  \\n            return maxArea;  \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxArea(int[] height) {\\n            int len = height.length, low = 0, high = len -1 ;  \\n            int maxArea = 0;  \\n            while (low < high) {  \\n             maxArea = Math.max(maxArea, (high - low) * Math.min(height[low], height[high]));  \\n             if (height[low] < height[high]) {  \\n               low++;  \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3207794,
                "title": "java-2ms-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int ans = 0;\\n        int j = height.length-1, i = 0;\\n        while(i<j)\\n        {\\n                if(height[i] <= height[j])\\n                {\\n                    ans = Math.max(height[i]*(j-i), ans);\\n                    i++;\\n                } \\n                else \\n                {\\n                    ans = Math.max(height[j]*(j-i), ans);\\n                    j--;\\n                }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int ans = 0;\\n        int j = height.length-1, i = 0;\\n        while(i<j)\\n        {\\n                if(height[i] <= height[j])\\n                {\\n                    ans = Math.max(height[i]*(j-i), ans);\\n                    i++;\\n                } \\n                else \\n                {\\n                    ans = Math.max(height[j]*(j-i), ans);\\n                    j--;\\n                }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330505,
                "title": "c-java-python3-javascript-solution-faster-than-95-easy",
                "content": "\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-11-container-with-most-water-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-11-container-with-most-water-solution-and-explanation-en/)\\u2B50**\\n\\n\\u2B07Submission detail \\u2B07\\n![image](https://assets.leetcode.com/users/images/4099080d-f110-42b5-b518-d7bf3ff161a8_1658288554.1325996.png)\\n\\n![image](https://assets.leetcode.com/users/images/d8f890c3-efab-4c47-86ff-baef597873ff_1655560091.774119.png)\\n\\n![image](https://assets.leetcode.com/users/images/952cfc79-0c58-4e4e-9add-7213f5bfa6de_1655560098.340923.png)\\n\\n![image](https://assets.leetcode.com/users/images/bd36a78a-2604-4d09-b8a8-de1523dcc11f_1658733000.9100928.png)\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-11-container-with-most-water-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-11-container-with-most-water-solution-and-explanation-en/)\\u2B50**\\n\\n\\u2B07Submission detail \\u2B07\\n![image](https://assets.leetcode.com/users/images/4099080d-f110-42b5-b518-d7bf3ff161a8_1658288554.1325996.png)\\n\\n![image](https://assets.leetcode.com/users/images/d8f890c3-efab-4c47-86ff-baef597873ff_1655560091.774119.png)\\n\\n![image](https://assets.leetcode.com/users/images/952cfc79-0c58-4e4e-9add-7213f5bfa6de_1655560098.340923.png)\\n\\n![image](https://assets.leetcode.com/users/images/bd36a78a-2604-4d09-b8a8-de1523dcc11f_1658733000.9100928.png)\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 472242,
                "title": "javascript",
                "content": "Runtime: 2036 ms, faster than 5.03% of JavaScript online submissions for Container With Most Water.\\nMemory Usage: 35.8 MB, less than 24.24% of JavaScript online submissions for Container With Most Water.\\n\\n```\\nlet maxArea = 0;\\n  for (i = 0; i < height.length; i++) {\\n    for (j = 0; j < height.length; j++) {\\n      if (height[i] < height[j]) {\\n        continue;\\n      } else {\\n        const area = Math.abs(i - j) * height[j];\\n        if (area > maxArea) {\\n          maxArea = area;\\n        }\\n      }\\n    }\\n  }\\n  return maxArea;\\n```\\n\\noptimization\\n\\n```\\nvar maxArea = function(height) {\\n  let maxArea = 0;\\n  let i = 0;\\n  let j = height.length - 1;\\n  while (i < j) {\\n    maxArea = Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));\\n    if (height[i] < height[j]) {\\n      i++;\\n    } else {\\n      j--;\\n    }\\n  }\\n  return maxArea;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet maxArea = 0;\\n  for (i = 0; i < height.length; i++) {\\n    for (j = 0; j < height.length; j++) {\\n      if (height[i] < height[j]) {\\n        continue;\\n      } else {\\n        const area = Math.abs(i - j) * height[j];\\n        if (area > maxArea) {\\n          maxArea = area;\\n        }\\n      }\\n    }\\n  }\\n  return maxArea;\\n```\n```\\nvar maxArea = function(height) {\\n  let maxArea = 0;\\n  let i = 0;\\n  let j = height.length - 1;\\n  while (i < j) {\\n    maxArea = Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));\\n    if (height[i] < height[j]) {\\n      i++;\\n    } else {\\n      j--;\\n    }\\n  }\\n  return maxArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374941,
                "title": "10-lines-java-beats-94-96",
                "content": "\\tpublic int maxArea(int[] height) {\\n        int left = 0, right = height.length-1;\\n        int res = Math.min(height[left], height[right]) * (right - left);\\n        while (left < right) {\\n            if (height[left] < height[right]) left++;\\n            else right--;\\n            res = Math.max(res, Math.min(height[left], height[right]) * (right - left));\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "\\tpublic int maxArea(int[] height) {\\n        int left = 0, right = height.length-1;\\n        int res = Math.min(height[left], height[right]) * (right - left);\\n        while (left < right) {\\n            if (height[left] < height[right]) left++;\\n            else right--;\\n            res = Math.max(res, Math.min(height[left], height[right]) * (right - left));\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 248817,
                "title": "java-solutions",
                "content": "**Solution 1: Brute-Force Algorithm**\\n\\n- We have to maximize the Area that can be formed between the vertical lines using the shorter line as `length` and the distance between the lines as the `width` of the rectangle forming the area.\\n- In this case, we will consider the area for every possible pair of the lines and find out the maximum area out of those.\\n\\nTime complexity : O(n<sup>2</sup>) - since calculating area for all `n * (n - 1) / 2` height pairs.\\nSpace complexity : `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int maxArea(int[] height)\\n\\t{\\n        int maxArea = 0;\\n\\t\\t\\n        for (int i = 0; i < height.length; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = i + 1; j < height.length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint length = Math.min(height[i], height[j]);\\n\\t\\t\\t\\tint width = j - i;\\n\\t\\t\\t\\tint curArea =  length * width;\\n\\t\\t\\t\\tmaxArea = Math.max(maxArea, curArea);\\n\\t\\t\\t}\\n\\t\\t}\\n        return maxArea;\\n    }\\n}\\n```\\n\\n**Solution 2: Two Pointer Approach**\\n\\n- The intuition behind this approach is that the area formed between the lines will always be limited by the `height` of the shorter line. Also, the farther the lines, the more will be the area obtained.\\n- So here we start by evaluating the widest container, using the first and the last line. All other possible containers are less wide, so to hold more water, they need to be higher in `length` [height]. \\n- Thus, after evaluating that widest container, we skip lines at both ends which are not higher than current `length` [height]. Then evaluate that new container we arrived at. Repeat until there are no more possible containers left.\\n\\nTime complexity : `O(n)`\\nSpace complexity : `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int maxArea(int[] height)\\n\\t{\\n        int maxArea = 0;\\n\\t\\tint start = 0;\\n\\t\\tint end = height.length - 1;\\n        \\n\\t\\twhile(start < end)\\n\\t\\t{\\n            int length = Math.min(height[start], height[end]);\\n\\t\\t\\tint width = end - start;\\n\\t\\t\\tint curArea =  length * width;\\n\\t\\t\\tmaxArea = Math.max(maxArea, curArea);\\n\\t\\t\\t\\n            while(start < end && height[start] <= length) start++;\\n            while(start < end && height[end] <= length)   end--;\\n        }\\n        return maxArea;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int maxArea(int[] height)\\n\\t{\\n        int maxArea = 0;\\n\\t\\t\\n        for (int i = 0; i < height.length; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = i + 1; j < height.length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint length = Math.min(height[i], height[j]);\\n\\t\\t\\t\\tint width = j - i;\\n\\t\\t\\t\\tint curArea =  length * width;\\n\\t\\t\\t\\tmaxArea = Math.max(maxArea, curArea);\\n\\t\\t\\t}\\n\\t\\t}\\n        return maxArea;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int maxArea(int[] height)\\n\\t{\\n        int maxArea = 0;\\n\\t\\tint start = 0;\\n\\t\\tint end = height.length - 1;\\n        \\n\\t\\twhile(start < end)\\n\\t\\t{\\n            int length = Math.min(height[start], height[end]);\\n\\t\\t\\tint width = end - start;\\n\\t\\t\\tint curArea =  length * width;\\n\\t\\t\\tmaxArea = Math.max(maxArea, curArea);\\n\\t\\t\\t\\n            while(start < end && height[start] <= length) start++;\\n            while(start < end && height[end] <= length)   end--;\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201072,
                "title": "python3-super-intuitive-double-pointer-approach-absolutely-fantastic-naughty-naughty",
                "content": "```python\\nclass Solution:\\n    def maxArea(self, height, result = 0, L = 0):\\n        if not height: return 0\\n        R = len(height)-1          \\n        while L != R:\\n            result = max(result, min(height[L], height[R])*(R-L))\\n            if height[L] < height[R]:\\n                L += 1\\n            else:\\n                R -= 1                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxArea(self, height, result = 0, L = 0):\\n        if not height: return 0\\n        R = len(height)-1          \\n        while L != R:\\n            result = max(result, min(height[L], height[R])*(R-L))\\n            if height[L] < height[R]:\\n                L += 1\\n            else:\\n                R -= 1                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6211,
                "title": "very-clean-and-intuitive-solution-accepted-as-best-submission-in-c",
                "content": "\\n    //AC - 8ms;\\n    int maxArea(int* heights, int size)\\n    {\\n        int l=0, r=size-1;\\n        int max = 0;\\n        while(l < r)\\n        {\\n            int area = (r-l)*(heights[l] < heights[r]? heights[l++] : heights[r--]);\\n            max = max > area? max : area;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "\\n    //AC - 8ms;\\n    int maxArea(int* heights, int size)\\n    {\\n        int l=0, r=size-1;\\n        int max = 0;\\n        while(l < r)\\n        {\\n            int area = (r-l)*(heights[l] < heights[r]? heights[l++] : heights[r--]);\\n            max = max > area? max : area;\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 6243,
                "title": "java-two-pointer",
                "content": "    public class Solution {\\n        public int maxArea(int[] height) {\\n        int result = 0;\\n        for(int i=0,j=height.length-1;i<j;){\\n            // get current area\\n            int area = Math.min(height[i],height[j])*(j-i);\\n            result = Math.max(area,result);\\n            //move the pointers\\n            if(height[i]<height[j]){\\n                i++;\\n            }\\n            else {\\n                j--;\\n            }\\n        }\\n        return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maxArea(int[] height) {\\n        int result = 0;\\n        for(int i=0,j=height.length-1;i<j;){\\n            // get current area\\n            int area = Math.min(height[i],height[j])*(j-i);\\n            result = Math.max(area,result);\\n            //move the pointers\\n            if(height[i]<height[j]){\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3929796,
                "title": "easy-basic-2-pointers-beginners-s-solution-with-approach-beats-98",
                "content": "# Intuition\\nThe question is similar to rainwater trapping problem. Just we do not have to slant the container.\\nSo if we think to contain water between two walls of differnt length we say the water is area between two.\\n\\nfor say e.g  4 and 3 length walls.\\nhence area between the two where the water is contained is\\n`area=3*breadth;` (minimum of two) \\nand if we consider the larger one then the water will overflow.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo the basic approach i thought was to see maximal possible size between walls of differnt height and for that for every wall we have to see every possible wall which would give a time complexity of O(N^2) but the constrains are 10^4. So that would give a TLE. \\n\\nHence i got down to greedy 2 pointers approach where i would see the last 2 walls and calculate water contained within it. Now, if first wall is greater than last then we decrase last else first.\\nBeacause the larger wall may give more optimal answer with other walls.\\n`if(height[i] > height[j]) j--;\\nelse i++;`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n = height.size()-1;\\n        int i=0, j=n;\\n        int ans=0;\\n        while(i <= j){\\n            int area=0;\\n            int ht = min(height[i], height[j]);\\n            area = (j-i)*ht;\\n            ans = max(ans, area);\\n            if(height[i] > height[j]) j--;\\n            else i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n = height.size()-1;\\n        int i=0, j=n;\\n        int ans=0;\\n        while(i <= j){\\n            int area=0;\\n            int ht = min(height[i], height[j]);\\n            area = (j-i)*ht;\\n            ans = max(ans, area);\\n            if(height[i] > height[j]) j--;\\n            else i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145741,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// ----- Without math function -----\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int start = 0;\\n        int end = height.length-1;\\n        int area = 0;\\n        while(start<end){\\n            int s = height[start];\\n            int l = height[end];\\n            if(s<=l && area < s*(end-start)){\\n                area = s*(end-start);\\n            }else if(s>=l && area < l*(end-start)){\\n                area = l*(end-start);\\n            }\\n            if(s<=l){\\n                start++;\\n            }else if(s>=l){\\n                end--;\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```\\n\\n```\\n// ----- with math function ----- \\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int start = 0;\\n        int end = height.length-1;\\n        int area = 0;\\n        while(start<end){\\n            int s = height[start];\\n            int l = height[end];\\n            int min_H = Math.min(s,l);\\n            area = Math.max(area, min_H*(end-start));\\n            if(s<l) start++;\\n            else end--;\\n        }\\n        return area;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// ----- Without math function -----\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int start = 0;\\n        int end = height.length-1;\\n        int area = 0;\\n        while(start<end){\\n            int s = height[start];\\n            int l = height[end];\\n            if(s<=l && area < s*(end-start)){\\n                area = s*(end-start);\\n            }else if(s>=l && area < l*(end-start)){\\n                area = l*(end-start);\\n            }\\n            if(s<=l){\\n                start++;\\n            }else if(s>=l){\\n                end--;\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```\n```\\n// ----- with math function ----- \\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int start = 0;\\n        int end = height.length-1;\\n        int area = 0;\\n        while(start<end){\\n            int s = height[start];\\n            int l = height[end];\\n            int min_H = Math.min(s,l);\\n            area = Math.max(area, min_H*(end-start));\\n            if(s<l) start++;\\n            else end--;\\n        }\\n        return area;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145648,
                "title": "3-ms-without-using-math-function-java-easy-to-understand-for-beginners",
                "content": "# Intuition\\n```\\n----------------- ||  Please leave a like  || --------------\\n```\\n# Code\\n```\\nclass Solution {\\n    public int maxArea(int[] h) {\\n        int ans  = 0;\\n        int start = 0 , end = h.length-1;\\n        while(start != end){\\n            if((h[end]*(end-start)) > ans && h[start] >= h[end] ){\\n                ans = h[end]*(end-start);\\n            }\\n            else if((h[start]*(end-start)) > ans && h[start] <= h[end]){\\n                ans = h[start]*(end-start);\\n            }\\n            if(h[start] >= h[end]){\\n                end--;\\n            }\\n            else if(h[start] <= h[end]){\\n                start++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\n----------------- ||  Please leave a like  || --------------\\n```\n```\\nclass Solution {\\n    public int maxArea(int[] h) {\\n        int ans  = 0;\\n        int start = 0 , end = h.length-1;\\n        while(start != end){\\n            if((h[end]*(end-start)) > ans && h[start] >= h[end] ){\\n                ans = h[end]*(end-start);\\n            }\\n            else if((h[start]*(end-start)) > ans && h[start] <= h[end]){\\n                ans = h[start]*(end-start);\\n            }\\n            if(h[start] >= h[end]){\\n                end--;\\n            }\\n            else if(h[start] <= h[end]){\\n                start++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847080,
                "title": "python-mad-easy-100-on-god",
                "content": "o(n)\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height)-1\\n        res = 0\\n\\n        while right > left:\\n            a = (right-left)*min(height[right],height[left])\\n            res = a if a > res else res\\n\\n            if height[left] > height[right]:\\n                right -= 1\\n            else:\\n                left += 1\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height)-1\\n        res = 0\\n\\n        while right > left:\\n            a = (right-left)*min(height[right],height[left])\\n            res = a if a > res else res\\n\\n            if height[left] > height[right]:\\n                right -= 1\\n            else:\\n                left += 1\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667740,
                "title": "c-easy-fast-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int ans = 0, i=0, j=height.size()-1;\\n        \\n        while(i<j)\\n        {\\n            int x = min(height[i], height[j])*(j-i);\\n            ans = max(ans, x);\\n            if(height[i]<height[j])\\n            i++;\\n            else \\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int ans = 0, i=0, j=height.size()-1;\\n        \\n        while(i<j)\\n        {\\n            int x = min(height[i], height[j])*(j-i);\\n            ans = max(ans, x);\\n            if(height[i]<height[j])\\n            i++;\\n            else \\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255262,
                "title": "c-very-easy-to-understand-two-pointers",
                "content": "```\\nint maxArea(vector<int>& height) {\\n        int water=0, i=0, j=height.size()-1;\\n        while(i<j)\\n        {\\n            int h=min(height[i], height[j]);\\n            water=max(water,(j-i)*h);\\n            while(i<j && height[i]<=h)i++;\\n            while(i<j && height[j]<=h)j--;\\n        }\\n        return water;\\n```\\n**Please upvote if it helps :)**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint maxArea(vector<int>& height) {\\n        int water=0, i=0, j=height.size()-1;\\n        while(i<j)\\n        {\\n            int h=min(height[i], height[j]);\\n            water=max(water,(j-i)*h);\\n            while(i<j && height[i]<=h)i++;\\n            while(i<j && height[j]<=h)j--;\\n        }\\n        return water;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762934,
                "title": "c-two-pointer-approach-o-n-time-o-1-space-solution",
                "content": "**upvote if you understand**\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) \\n    {\\n        // take maxarea = 0\\n        int maxA = 0;\\n        // 1st pointer, point to 1st index\\n        int left = 0;\\n        int n = height.size();\\n        // 2nd pointer, point to last index\\n        int right = n-1;\\n        \\n        while(left < right)\\n        {\\n            int distance = right - left;\\n            int high = min(height[left],height[right]);\\n            int area = distance * high;\\n            maxA = max(maxA,area);\\n            \\n            if(height[left] < height[right])\\n                left++;\\n            else right--;\\n        }\\n        return maxA;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) \\n    {\\n        // take maxarea = 0\\n        int maxA = 0;\\n        // 1st pointer, point to 1st index\\n        int left = 0;\\n        int n = height.size();\\n        // 2nd pointer, point to last index\\n        int right = n-1;\\n        \\n        while(left < right)\\n        {\\n            int distance = right - left;\\n            int high = min(height[left],height[right]);\\n            int area = distance * high;\\n            maxA = max(maxA,area);\\n            \\n            if(height[left] < height[right])\\n                left++;\\n            else right--;\\n        }\\n        return maxA;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633791,
                "title": "python-fast-simple-faster-than-92",
                "content": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        max_area, i, j = 0, 0, len(height)-1\\n        while i != j:\\n            if height[j] > height[i]:\\n                area = height[i] * (j - i)\\n                i += 1\\n            else:\\n                area = height[j] * (j - i)\\n                j -= 1\\n            max_area = max(max_area, area)\\n        return max_area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        max_area, i, j = 0, 0, len(height)-1\\n        while i != j:\\n            if height[j] > height[i]:\\n                area = height[i] * (j - i)\\n                i += 1\\n            else:\\n                area = height[j] * (j - i)\\n                j -= 1\\n            max_area = max(max_area, area)\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277540,
                "title": "8-line-code-o-n-upvote-if-you-like-it",
                "content": "I\\'ve just used two pointer approch to calculate the area in one iteration\\nif the value at left pointer is lesser than the value of the right one the we\\'ll go to the right direction and else move the \\nright pointer to left direction.\\n```\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& arr) {\\n        int i=0,j=arr.size()-1,max_area=-1;\\n        while(i<j){\\n            int curr_area=min(arr[i],arr[j])*(j-i);\\n            if (arr[i]< arr[j]) i++;\\n            else j--;\\n            max_area=max(max_area,curr_area);\\n        }\\n        return max_area;\\n    }\\n    \\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& arr) {\\n        int i=0,j=arr.size()-1,max_area=-1;\\n        while(i<j){\\n            int curr_area=min(arr[i],arr[j])*(j-i);\\n            if (arr[i]< arr[j]) i++;\\n            else j--;\\n            max_area=max(max_area,curr_area);\\n        }\\n        return max_area;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175342,
                "title": "mathematical-proof-by-contradiction-for-o-n-solution-along-with-java-solution",
                "content": "# We can break this problem down into several parts:\\nFirst let\\'s mathematically define the max area for a container. For any indexes *i,j*, we know that *Area(i,j) = (j-i) * Min(height[j]-height[i])*\\n\\nFor now, let\\'s assume that the start and end indexes are fixed.\\n**We want to prove that if height[end]>height[start], there is no integer n, where start<n<end, such that Area(start, n) > Area (start, end).**\\n(In colloquial terms, **Assuming start is fixed**.  if  he height at the end index is greater than the height at the start index, the area of the container formed between start and end is larger than any containers in between)\\n\\n# Proof by Contradiction:\\nAssume that *start, end* are integers such that *height(start)<height(end).*\\nAssume that n is an integer such that *start<n<end*\\n*(Note that start, n, and end represent integers of the array!)*\\n\\nAssume that *Area(start, n) > Area (start, end)*\\nTherefore\\n(n-start)\\\\*Min(height(n),height(start)) >  (end-start)\\\\*Min(height(end),height(start)) = (end-start)\\\\* height(start) \\n\\nHowever we assumed that end>n, and Min(height(n),height(start))<=height(start), therefore this contradicts out assumption that *Area(start, n) > Area (start, end)*\\nSo there is no such n.\\nQED\\n\\n# What does this imply for the code/solution?\\nThis means that instead of doing a brute fore solution in O(n^2) time by calculating all possible areas, we can ignore many area pairs by applying the logic proved above and solve in O(n) time.\\n\\nFirst, take two pointers, one at the start of the array, and one at the end of the array and find the minimum height of start and end. We don\\'t need to include the minimum height\\'s pointer in any further calculations since we proved that it\\'s impossible to find a larger area if the minimum height\\'s pointer is fixed. Therefore update the pointer to the next element (start++ or end--).\\n\\nFor each iteration of the loop, calculate the area inbetween your start and end pointers and save the maximum in a variable accordingly. \\n\\nSince you are only iterating through the array n-1 elements, this solution is done in O(n) time!\\n\\nThe solution code:\\n```\\n        int start = 0;\\n        int end = height.length-1;\\n        int max_area = (end * Math.min(height[start],height[end]));\\n        while(start<end){\\n            if(height[start]<height[end]){ \\n                start++;\\n            }else{\\n                end--;\\n            }\\n            max_area = Math.max( (end-start)*Math.min(height[start],height[end]), max_area);\\n        }\\n        return max_area;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        int start = 0;\\n        int end = height.length-1;\\n        int max_area = (end * Math.min(height[start],height[end]));\\n        while(start<end){\\n            if(height[start]<height[end]){ \\n                start++;\\n            }else{\\n                end--;\\n            }\\n            max_area = Math.max( (end-start)*Math.min(height[start],height[end]), max_area);\\n        }\\n        return max_area;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1134940,
                "title": "c-two-pointer-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int res = 0;\\n        int l = 0, r = height.size()-1;\\n        while (l < r) {\\n            res = max(res, (r-l)*min(height[l], height[r]));\\n            if (height[l] < height[r])\\n                l++;\\n            else\\n                r--;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nA detour:\\n\\nThe first intuition is to use dynamic programming to achive O(n) solution. If we treat each line as the right border of the container and find the maximum amount of water we can hold in O(1), then traverse through all the vertical lines would give use the global maximum.  However, it\\'s difficult to determine what to store in our dp array. The highest line to the left of our current line? Not necessarily, because the width of the container also matters. Suppose the heights of the lines are [2,3,5,4], and we are currently at line with index 3 (height = 4). Using the heighest left border (height = 5) would give us volume = 4 * 1 = 4. But the optimal volume is 2 * 3 = 6. In the end, we still need to check each line to the left of our current right border, which leads to an O(n^2) solution.\\n\\nCan we do better?\\n\\nYes! The key idea is to find the bottle neck of our current result. We start with using left most line as our left border of container and right most line as the right border of the container. Let\\'s use the sample [1,8,6,2,5,4,8,3,7], and use l to denote the index of left border, r to denote the index of the right border. So we start with l = 0 and r = 8. Now what\\'s the bottle neck? The answer is the shorter border, which is 1 since 1 < 7. But why? Note that the container now has the largest width (w = r-l = 8). If we use l = 0 as the left border, the volumn can not go beyond height[0] * w = 8, because the height of our container is at most 1 and width is at most 8. Therefore, we should record the current volumn and advance left border by 1, so now l = 1 and r = 8. Now the bottle neck is 7 since 8 > 7. If we use 7 as the right border, the largest volumn we can get is either 7 * (r-l) = 49, or the current maximum volumn, which is done by using ```res = max(res, (r-l)*min(height[l], height[r]));```\\n\\nDid you find the pattern now? Before we advance the pointer whose line is shorter, we can find the maximum volumn it can hold as a left/right border in O(1), which is exatly the thing we want to do using dynamic programming.  As a result, the total time complexity is O(n) because we will adavance pointers n times where n is the length of the input vector.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int res = 0;\\n        int l = 0, r = height.size()-1;\\n        while (l < r) {\\n            res = max(res, (r-l)*min(height[l], height[r]));\\n            if (height[l] < height[r])\\n                l++;\\n            else\\n                r--;\\n        }\\n        return res;\\n    }\\n};\\n```\n```res = max(res, (r-l)*min(height[l], height[r]));```",
                "codeTag": "Java"
            },
            {
                "id": 841510,
                "title": "easy-solution-do-upvote-if-like-the-solution",
                "content": "Increase or decrease pointer of the shorter height because it will lead to change in area. \\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        \\n        int i=0;\\n        int j=int(height.size())-1;\\n        \\n        int maxi=INT_MIN;\\n        \\n        while(i<j)\\n        {\\n            int area=min(height[i],height[j])*(j-i);\\n            if(height[i]<height[j])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n            if(area>maxi)\\n            {\\n                maxi=area;\\n            }\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        \\n        int i=0;\\n        int j=int(height.size())-1;\\n        \\n        int maxi=INT_MIN;\\n        \\n        while(i<j)\\n        {\\n            int area=min(height[i],height[j])*(j-i);\\n            if(height[i]<height[j])\\n            {\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 529207,
                "title": "python-solution-o-n",
                "content": "Learning Python\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        \\n        \\n        \"\"\"\\n        \\n          How to define a container with most water?\\n          \\n          1. Largest Width\\n          2. Largest Height\\n          \\n          \\n          How do we get largest width (two pointer, one on last and one on right)\\n          How do we get the largest height (moving the index with the lower height)\\n        \\n        \"\"\"\\n        \\n        l,r = 0, len(height) - 1\\n        ans = 0\\n        while l < r:\\n          ans = max(ans, min(height[l], height[r]) * (r - l))\\n          \\n          if(height[l] < height[r]):\\n            l += 1\\n          else:\\n            r -= 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        \\n        \\n        \"\"\"\\n        \\n          How to define a container with most water?\\n          \\n          1. Largest Width\\n          2. Largest Height\\n          \\n          \\n          How do we get largest width (two pointer, one on last and one on right)\\n          How do we get the largest height (moving the index with the lower height)\\n        \\n        \"\"\"\\n        \\n        l,r = 0, len(height) - 1\\n        ans = 0\\n        while l < r:\\n          ans = max(ans, min(height[l], height[r]) * (r - l))\\n          \\n          if(height[l] < height[r]):\\n            l += 1\\n          else:\\n            r -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451070,
                "title": "python3-with-explanation-120ms-14-4-mb-98-6-faster",
                "content": "The idea is pretty simple:\\n1. We measure volume between most left and most right borders: width * minHeight\\n2. Then shift indexes of left and right borders inwards the array and compare new volume with max calculates.\\n3. 3 conditions how we move borders:\\n\\t1. If left border is lower than right border, then we move left border to the right until we find taller one.\\n\\t2. Same with right border, if it\\'s lower than left border, then we move it to the left until we find taller one.\\n\\t3. If two borders are the same height, it make sence to move both of then inwards.\\n4. We finish iterating when two borders meet or cross.\\n\\nHere is the code:\\n```python\\n    def maxArea(self, height: List[int]) -> int:\\n        vol = 0\\n        \\n        i, j = 0, len(height) - 1\\n        while i < j:\\n            vol = max(vol, (j - i) * min(height[i], height[j]))\\n            i1, j1 = i, j\\n            if height[i] <= height[j]:\\n                i1 += 1\\n                while i1 < j and height[i1] <= height[i]:\\n                    i1 += 1\\n            if height[i] >= height[j]:\\n                j1 -= 1\\n                while j1 > i1 and height[j1] <= height[j]:\\n                    j1 -= 1\\n            \\n            i, j = i1, j1\\n        \\n        return vol\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n    def maxArea(self, height: List[int]) -> int:\\n        vol = 0\\n        \\n        i, j = 0, len(height) - 1\\n        while i < j:\\n            vol = max(vol, (j - i) * min(height[i], height[j]))\\n            i1, j1 = i, j\\n            if height[i] <= height[j]:\\n                i1 += 1\\n                while i1 < j and height[i1] <= height[i]:\\n                    i1 += 1\\n            if height[i] >= height[j]:\\n                j1 -= 1\\n                while j1 > i1 and height[j1] <= height[j]:\\n                    j1 -= 1\\n            \\n            i, j = i1, j1\\n        \\n        return vol\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 443691,
                "title": "javascript-solution",
                "content": "```\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1, maxArea = 0;\\n    while(left < right){\\n        let width = right - left;\\n        if(height[left] > height[right]){\\n            maxArea = Math.max(maxArea, width * height[right])\\n            right--;\\n        }else{\\n            maxArea = Math.max(maxArea, width * height[left]);\\n            left++;\\n        }\\n    }\\n    return maxArea;\\n};```",
                "solutionTags": [],
                "code": "```\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1, maxArea = 0;\\n    while(left < right){\\n        let width = right - left;\\n        if(height[left] > height[right]){\\n            maxArea = Math.max(maxArea, width * height[right])\\n            right--;\\n        }else{\\n            maxArea = Math.max(maxArea, width * height[left]);\\n            left++;\\n        }\\n    }\\n    return maxArea;\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 409798,
                "title": "java-two-pointers-with-explanation-easy-understand",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/container-with-most-water/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> Given `n` **non-negative** integers `a1, a2, ..., an`, where each represents a point at coordinate `(i, ai)`. `n` vertical lines are drawn such that the two endpoints of line `i` is at `(i, ai)` and `(i, 0)`. Find two lines, which together with x-axis forms a container, such that the container contains the most water.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/xmocy.jpg \"LeetCode\")\\n\\n**Note:** You may not slant the container and `n` is at least 2.\\n\\n**Example:** \\n\\n```java\\nInput: [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n```\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nTry every container.\\n\\n```java\\npublic int maxArea(int[] height) {\\n  int n = height.length;\\n  int max = Integer.MIN_VALUE;\\n  for (int i = 0; i < n - 1; ++i) {\\n    for (int j = i + 1; j < n; ++j) {\\n      max = Math.max(max, (j - i) * Math.min(height[i], height[j]));\\n    }\\n  }\\n  return max;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Two Pointers\\n\\nWe have two pointers `lo` and `hi` that start from two ends. Each time we update the one with smaller height.\\n\\n**Why?**\\n\\nIt is kind of pruning unnecessary cases. If `height[lo] < height[hi]`, we move `lo` because we know that the areas in which `lo` is the left bar (`[lo, lo + 1]`,`[lo, lo + 2]`, ..., `[lo, hi - 1]`) must be **less than** the area in `[lo, hi]` that we just considered. So next time we should not consider `lo` as the left end anymore.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/8khdy.png)\\n\\nFor example, all the areas (`AB`, `AC`, `AD`, ..., `AH`) are less than `AI`.\\n\\n```java\\npublic int maxArea(int[] height) {\\n  // assume n >= 2\\n  int n = height.length;\\n  int lo = 0, hi = n - 1;\\n  int max = Integer.MIN_VALUE;\\n  while (lo < hi) {\\n    int water = (hi - lo) * Math.min(height[lo], height[hi]);\\n    max = Math.max(max, water);\\n    if (height[lo] < height[hi]) ++lo;\\n    else --hi;\\n  }\\n  return max;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\nInput: [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n```\n```java\\npublic int maxArea(int[] height) {\\n  int n = height.length;\\n  int max = Integer.MIN_VALUE;\\n  for (int i = 0; i < n - 1; ++i) {\\n    for (int j = i + 1; j < n; ++j) {\\n      max = Math.max(max, (j - i) * Math.min(height[i], height[j]));\\n    }\\n  }\\n  return max;\\n}\\n```\n```java\\npublic int maxArea(int[] height) {\\n  // assume n >= 2\\n  int n = height.length;\\n  int lo = 0, hi = n - 1;\\n  int max = Integer.MIN_VALUE;\\n  while (lo < hi) {\\n    int water = (hi - lo) * Math.min(height[lo], height[hi]);\\n    max = Math.max(max, water);\\n    if (height[lo] < height[hi]) ++lo;\\n    else --hi;\\n  }\\n  return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208913,
                "title": "test-case-passing-on-run-code-but-fails-on-submit",
                "content": "Ok. I wrote the code below. The problem is when I am testing this, using the RUN CODE button, it passes the test successfully. But when I SUBMIT the code, it fails for the exact same test case. I am new here, so does anyone know why this is happening?![image](https://assets.leetcode.com/users/anubhavujjawal/image_1545671482.png)\\n\\n\\n```\\nint min(int a, int b){\\n    return a>b?b:a;\\n}\\n\\nint max(int a, int b){\\n    return a<b?b:a;\\n}\\n\\nint cache[10000][10000]={0};\\n\\nint maxAreaFn(int *a, int start, int end){\\n    if(end-start == 1) return min(a[start], a[end]);\\n    if(cache[start][end]!=0) return cache[start][end];\\n    int curr = min(a[end], a[start])*(end-start);\\n    \\n    int right = maxAreaFn(a, start+1, end);\\n    int left = maxAreaFn(a, start, end-1);\\n    cache[start][end] = max(max(curr, right), left);\\n    return cache[start][end];\\n}\\n\\nint maxArea(int* height, int heightSize) {\\n    return maxAreaFn(height, 0, heightSize-1);\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint min(int a, int b){\\n    return a>b?b:a;\\n}\\n\\nint max(int a, int b){\\n    return a<b?b:a;\\n}\\n\\nint cache[10000][10000]={0};\\n\\nint maxAreaFn(int *a, int start, int end){\\n    if(end-start == 1) return min(a[start], a[end]);\\n    if(cache[start][end]!=0) return cache[start][end];\\n    int curr = min(a[end], a[start])*(end-start);\\n    \\n    int right = maxAreaFn(a, start+1, end);\\n    int left = maxAreaFn(a, start, end-1);\\n    cache[start][end] = max(max(curr, right), left);\\n    return cache[start][end];\\n}\\n\\nint maxArea(int* height, int heightSize) {\\n    return maxAreaFn(height, 0, heightSize-1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164308,
                "title": "javascript-simple-solution",
                "content": "```\\nvar maxArea = function(height) {\\n    let max = 0;\\n    let i = 0;\\n    let j = height.length - 1;\\n    \\n    while(i < j){\\n        let cur = (j - i) * Math.min(height[i], height[j]);\\n        max = Math.max(cur, max);\\n        height[i] <= height[j] ? i ++ : j --;\\n    }\\n\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxArea = function(height) {\\n    let max = 0;\\n    let i = 0;\\n    let j = height.length - 1;\\n    \\n    while(i < j){\\n        let cur = (j - i) * Math.min(height[i], height[j]);\\n        max = Math.max(cur, max);\\n        height[i] <= height[j] ? i ++ : j --;\\n    }\\n\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6190,
                "title": "4-lines-java-code",
                "content": "    public int maxArea(int[] height) {\\n        int max = 0, i = 0, j = height.length - 1;\\n        while(i < j)\\n            max = Math.max(max, (j - i) * (height[i] < height[j] ? height[i++] : height[j--]));\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "    public int maxArea(int[] height) {\\n        int max = 0, i = 0, j = height.length - 1;\\n        while(i < j)\\n            max = Math.max(max, (j - i) * (height[i] < height[j] ? height[i++] : height[j--]));\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 6206,
                "title": "best-and-simple-in-c",
                "content": "    int maxArea(int* heights, int size)\\n    {\\n        int l=0, r=size-1;\\n        int max = 0;\\n        while(l < r)\\n        {\\n            int area = (r-l)*(heights[l] < heights[r]? heights[l++] : heights[r--]);\\n            max = max > area? max : area;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "    int maxArea(int* heights, int size)\\n    {\\n        int l=0, r=size-1;\\n        int max = 0;\\n        while(l < r)\\n        {\\n            int area = (r-l)*(heights[l] < heights[r]? heights[l++] : heights[r--]);\\n            max = max > area? max : area;\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3614411,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointer Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n-1;\\n        int maxWater = 0;\\n        while (left < right) {\\n            int area = min (height[left], height[right]) * (right - left);\\n            maxWater = max (maxWater, area);\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return maxWater;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n-1;\\n        int maxWater = 0;\\n        while (left < right) {\\n            int area = min (height[left], height[right]) * (right - left);\\n            maxWater = max (maxWater, area);\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return maxWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324540,
                "title": "accepted-o-n-simple-and-fast-java-with-explanations",
                "content": "# Intuition\\nJust think about two pointer approach pointer 1 pointed on left side and pointer 2 pointed on right side\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.point the two pointer left and right on the height\\n2. claculate the maximum area of container .\\n3. width = right - left \\n4. heigth_of_container = min(height[left],height[right])\\n5. take min heigth to avoid overflow of water\\n6. now calculate area = width * heigth_of_container\\n7. the after that check condition if height[left] < height[right] just increment the left pointer left++;\\n8. just like that if height[right] < height[left] decrement the right pointer right--\\n9. bor base case if both the left and rigth hiegth became equal just increment left++ ande decrement right-- \\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int max = 0;\\n        int left = 0;\\n        int right = height.length-1;\\n        while(left < right)\\n        {\\n          int width = right - left;\\n          int height1 = Math.min(height[left],height[right]);\\n          int area = height1 * width;\\n          max = Math.max(max,area);\\n          if(height[left] < height[right]) left++;\\n          else if(height[right] < height[left]) right--;\\n          else{\\n            left++;\\n            right--;\\n          } \\n        }\\n        \\n        \\n        return max;\\n        \\n    }\\n}\\n```\\nPlease Upvote if you underStand this code",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int max = 0;\\n        int left = 0;\\n        int right = height.length-1;\\n        while(left < right)\\n        {\\n          int width = right - left;\\n          int height1 = Math.min(height[left],height[right]);\\n          int area = height1 * width;\\n          max = Math.max(max,area);\\n          if(height[left] < height[right]) left++;\\n          else if(height[right] < height[left]) right--;\\n          else{\\n            left++;\\n            right--;\\n          } \\n        }\\n        \\n        \\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213356,
                "title": "c-simple-logic-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& nums) {\\n        int area = 0;\\n        int j = nums.size()-1;\\n        int i = 0;\\n        while(i < j){\\n            int temp = min(nums[i],nums[j]);\\n            int dist = j-i;\\n            int temp_area = dist*temp;\\n            area = max(area,temp_area);\\n            if(nums[i] < nums[j])\\n                i++;\\n            else\\n                j--;\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& nums) {\\n        int area = 0;\\n        int j = nums.size()-1;\\n        int i = 0;\\n        while(i < j){\\n            int temp = min(nums[i],nums[j]);\\n            int dist = j-i;\\n            int temp_area = dist*temp;\\n            area = max(area,temp_area);\\n            if(nums[i] < nums[j])\\n                i++;\\n            else\\n                j--;\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716014,
                "title": "python-simple-two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        l, r = 0, len(height)-1\\n        res = 0\\n\\n        while l < r:\\n            area = min(height[l], height[r]) * (r-l)\\n            res = max(res, area)\\n            if height[l] >= height[r]:\\n                r -= 1\\n            else:\\n                l += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        l, r = 0, len(height)-1\\n        res = 0\\n\\n        while l < r:\\n            area = min(height[l], height[r]) * (r-l)\\n            res = max(res, area)\\n            if height[l] >= height[r]:\\n                r -= 1\\n            else:\\n                l += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518074,
                "title": "simple-solution-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int Min = INT_MAX;\\n        int answer = INT_MIN;\\n        while(left < right){\\n            Min = min(height[right],height[left]);\\n                                        //width * height\\n            answer = max(answer,(Min * (right - left)) );\\n            if(height[left] < height[right]){\\n                left++;\\n            }else{\\n                right--;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int Min = INT_MAX;\\n        int answer = INT_MIN;\\n        while(left < right){\\n            Min = min(height[right],height[left]);\\n                                        //width * height\\n            answer = max(answer,(Min * (right - left)) );\\n            if(height[left] < height[right]){\\n                left++;\\n            }else{\\n                right--;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285496,
                "title": "very-easy-100-c-java-javascript-c-fullly-explained-line-by-line",
                "content": "# **C++ SOLUTION:**\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        //Initialize beg and end pointers...\\n        int beg = 0;\\n        int end = height.size() - 1;\\n        // Initialize maximum area...\\n        int maxArea = 0;\\n        // Loop until beg and end meet...\\n        while(beg < end){\\n            //Calculate the area between the two bars and compare it with the current maximum...\\n            maxArea = max(maxArea, min(height[beg], height[end])*(end-beg));\\n            //Move the pointers if there exists a bar whose height is greater than the current one...\\n            if(height[beg] < height[end]){\\n                beg ++;\\n            } else {\\n                end --;\\n            }\\n        }\\n        //Return the maximum area at the end...\\n        return maxArea;\\n    }\\n};\\n```\\n\\n# **JAVA SOLUTION:**\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        \\n        // It stores maximum area...\\n        int maxArea = Integer.MIN_VALUE;\\n        //Initialize beg and end pointers...\\n        int beg = 0;\\n        int end = height.length - 1;\\n        \\n        // Loop until beg and end meet...\\n        while (beg < end){\\n            //Calculate the height of the shorter bar \\u2014 one bar is represented by height[beg] and the other bar is represented by height[end]...\\n            int srtrBar = Math.min(height[beg], height[end]);\\n            //Calculate the area between the two bars and compare it with the current maximum...\\n            maxArea = Math.max(maxArea, srtrBar * (end - beg));\\n            \\n            //Move the pointers if there exists a bar whose height is greater than the current one...\\n            if (height[beg] < height[end]) {\\n                beg++;\\n            } else {\\n                end--;\\n            }\\n        }\\n        //Return the maximum area at the end...\\n        return maxArea;\\n    }\\n}\\n```\\n\\n# **C LANGUAGE:**\\n```\\n#define max_h(a,b) ((a<b)?b:a)\\nint maxArea(int* height, int heightSize){\\n//initialize maxArea and beg & end pointers...\\nint maxArea = -1;\\nint beg  = 0;\\nint end = heightSize-1;\\n    // Loop until beg and end meet...\\n    while(beg<end){\\n        //Move the pointers if there exists a bar whose height is greater than the current one...\\n        //And calculate the area between the two bars and compare it with the current maximum...\\n        if(height[beg]<height[end]){\\n            maxArea = max_h(maxArea, height[beg]*(end-beg));\\n            beg++;\\n        }else{\\n            maxArea = max_h(maxArea, height[end]*(end-beg));\\n            end--;\\n        }    \\n    }\\n    //Return the maximum area at the end...\\n    return maxArea;\\n}\\n```\\n\\n# **JAVASCRIPT SOLUTION:**\\n```\\nvar maxArea = function(height) {\\n    // It stores maximum area...\\n    let maxArea = Number.MIN_SAFE_INTEGER;\\n    //Initialize beg and end pointers...\\n    let beg = 0;\\n    let end = height.length - 1;\\n        \\n    // Loop until beg and end meet...\\n    while (beg < end){\\n        //Calculate the height of the shorter bar \\u2014 one bar is represented by height[beg] and the other bar is represented by height[end]...\\n        let srtrBar = Math.min(height[beg], height[end]);\\n        //Calculate the area between the two bars and compare it with the current maximum...\\n        maxArea = Math.max(maxArea, srtrBar * (end - beg));\\n            \\n        //Move the pointers if there exists a bar whose height is greater than the current one...\\n        if (height[beg] < height[end]) {\\n            beg++;\\n        } else {\\n            end--;\\n        }\\n    }\\n    //Return the maximum area at the end...\\n    return maxArea;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        //Initialize beg and end pointers...\\n        int beg = 0;\\n        int end = height.size() - 1;\\n        // Initialize maximum area...\\n        int maxArea = 0;\\n        // Loop until beg and end meet...\\n        while(beg < end){\\n            //Calculate the area between the two bars and compare it with the current maximum...\\n            maxArea = max(maxArea, min(height[beg], height[end])*(end-beg));\\n            //Move the pointers if there exists a bar whose height is greater than the current one...\\n            if(height[beg] < height[end]){\\n                beg ++;\\n            } else {\\n                end --;\\n            }\\n        }\\n        //Return the maximum area at the end...\\n        return maxArea;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        \\n        // It stores maximum area...\\n        int maxArea = Integer.MIN_VALUE;\\n        //Initialize beg and end pointers...\\n        int beg = 0;\\n        int end = height.length - 1;\\n        \\n        // Loop until beg and end meet...\\n        while (beg < end){\\n            //Calculate the height of the shorter bar \\u2014 one bar is represented by height[beg] and the other bar is represented by height[end]...\\n            int srtrBar = Math.min(height[beg], height[end]);\\n            //Calculate the area between the two bars and compare it with the current maximum...\\n            maxArea = Math.max(maxArea, srtrBar * (end - beg));\\n            \\n            //Move the pointers if there exists a bar whose height is greater than the current one...\\n            if (height[beg] < height[end]) {\\n                beg++;\\n            } else {\\n                end--;\\n            }\\n        }\\n        //Return the maximum area at the end...\\n        return maxArea;\\n    }\\n}\\n```\n```\\n#define max_h(a,b) ((a<b)?b:a)\\nint maxArea(int* height, int heightSize){\\n//initialize maxArea and beg & end pointers...\\nint maxArea = -1;\\nint beg  = 0;\\nint end = heightSize-1;\\n    // Loop until beg and end meet...\\n    while(beg<end){\\n        //Move the pointers if there exists a bar whose height is greater than the current one...\\n        //And calculate the area between the two bars and compare it with the current maximum...\\n        if(height[beg]<height[end]){\\n            maxArea = max_h(maxArea, height[beg]*(end-beg));\\n            beg++;\\n        }else{\\n            maxArea = max_h(maxArea, height[end]*(end-beg));\\n            end--;\\n        }    \\n    }\\n    //Return the maximum area at the end...\\n    return maxArea;\\n}\\n```\n```\\nvar maxArea = function(height) {\\n    // It stores maximum area...\\n    let maxArea = Number.MIN_SAFE_INTEGER;\\n    //Initialize beg and end pointers...\\n    let beg = 0;\\n    let end = height.length - 1;\\n        \\n    // Loop until beg and end meet...\\n    while (beg < end){\\n        //Calculate the height of the shorter bar \\u2014 one bar is represented by height[beg] and the other bar is represented by height[end]...\\n        let srtrBar = Math.min(height[beg], height[end]);\\n        //Calculate the area between the two bars and compare it with the current maximum...\\n        maxArea = Math.max(maxArea, srtrBar * (end - beg));\\n            \\n        //Move the pointers if there exists a bar whose height is greater than the current one...\\n        if (height[beg] < height[end]) {\\n            beg++;\\n        } else {\\n            end--;\\n        }\\n    }\\n    //Return the maximum area at the end...\\n    return maxArea;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122218,
                "title": "simple-yet-best-interview-approach-to-this-problem-in-o-n",
                "content": "This problem can be divided into two sub-problems\\n\\n**1) How much water the container will contain at a particular moment?**\\n\\n* Realize that we need to find the area of water contained **(height * width)**\\n\\n* Now assume that at a particular moment you have two edges (edge1, edge2 at some non-zero distance from each other, so their distance will be their **width** = edge2-edge1\\n\\n* what will be the **height of water** that those edges can contain?\\n\\n\\t* it will be the minimum of the heights of the edges that is min(height[edge1], height[edge2]), this is natural.\\n\\n* Therefore, at any time the area is Area = (edge2-edge1) *  min(height[edge1], height[edge2])\\n\\n* But as we will be updating area whenever we have found edges that can contain more area so, the expression for that is, (edges1 and edges2 are moving two pointer, by this time you have realized it)\\n\\t* **Area = max( Area, (edge2-edge1) *  min(height[edge1], height[edge2]) )**\\n\\t\\n**2) How to choose the two edges for container to collect most water?**\\n\\n* Here we need to be greedy while choosing the edge that can give us max area.\\n\\n* So, what do you you think by looking at Area\\'s formula, what should be our first choice for edges?\\n\\n* Yes, we should first choose the first and last edges as our edge1 and edge2, this is because by doing this we are naturally getting the most width if not the most height too. So, just to maximize our width we choose it.\\n\\n* But it is not enough greed, as there can be edges that have heights that can hold more water so, we need to search for those edges.\\n\\n* Now, we have two pointers, pointer 1 that is edge1 standing on the index 0 and second one, edge2 standing on len(height)-1\\n\\t* To move them what greed we must choose?\\n\\t\\n\\t* As our smaller edge is limiting the height so we must update it with a bigger edge if there is any. But smaller edge can be edge1 or edge2 therefore we must check which one is smaller and only move that pointer. (this can be done with a simple if-else statement) (this is a greedy move)\\n\\t\\n\\t```\\n\\tif height[edge1] < height[edge2]:\\n\\t\\t# edge1 moves forward\\n\\t\\tedge1 += 1\\n\\telse:\\n\\t\\t# edge2 moves backwards\\n\\t\\tedge2 -=1\\n\\t```\\n\\t* **Note:** In this process ans will be updating automatically because of our smart expression that we wrote earlier.\\n\\t* Now we just need to pack these two subproblems under one roof (under a while loop).\\n\\t* Termination condition: when pointer edge1 and edge2 becomes equal, so our while loop must only run while edge1 < edge2\\n\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        \\n        if len(height) == 1:\\n            return 0\\n        \\n        edge1 = 0\\n        area = 0\\n        edge2 = len(height)-1\\n        \\n        while edge1 < edge2:\\n        \\n            area = max(area, min(height[edge1], height[edge2]) * (edge2-edge1))\\n            \"\"\"\\n            whichever edge\\'s height edge1 or edge2\\'s is smaller one, \\n\\t\\t\\twe move that pointer only to find a bigger height to replace that edge, \\n\\t\\t\\tour answer only updates when the water that the edges can contain is more than previous max\\n\\t\\t\\t\"\"\"\\n            if height[edge1] < height[edge2]: \\n                edge1 += 1\\n            else:\\n                edge2 -= 1\\n            \\n        return area\\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\n\\tif height[edge1] < height[edge2]:\\n\\t\\t# edge1 moves forward\\n\\t\\tedge1 += 1\\n\\telse:\\n\\t\\t# edge2 moves backwards\\n\\t\\tedge2 -=1\\n\\t```\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        \\n        if len(height) == 1:\\n            return 0\\n        \\n        edge1 = 0\\n        area = 0\\n        edge2 = len(height)-1\\n        \\n        while edge1 < edge2:\\n        \\n            area = max(area, min(height[edge1], height[edge2]) * (edge2-edge1))\\n            \"\"\"\\n            whichever edge\\'s height edge1 or edge2\\'s is smaller one, \\n\\t\\t\\twe move that pointer only to find a bigger height to replace that edge, \\n\\t\\t\\tour answer only updates when the water that the edges can contain is more than previous max\\n\\t\\t\\t\"\"\"\\n            if height[edge1] < height[edge2]: \\n                edge1 += 1\\n            else:\\n                edge2 -= 1\\n            \\n        return area\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980860,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.\\uD83E\\uDD0D***\\n\\n<iframe src=\"https://leetcode.com/playground/k2wheHHs/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "***Hello it would be my pleasure to introduce myself Darian.\\uD83E\\uDD0D***\\n\\n<iframe src=\"https://leetcode.com/playground/k2wheHHs/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "codeTag": "Unknown"
            },
            {
                "id": 1966211,
                "title": "why-this-is-not-a-dynamic-programming-problem-asking-for-feedback",
                "content": "When I first tackled this problem I didn\\'t think of a two pointer approach at all.\\nAll I could think of was some dynamic programming approach because we\\'re looking to *maximise* the output.\\n\\nThinking about it now, I think it doesn\\'t lend itself well to dynamic programming because it doesn\\'t have overlapping subproblems and an optimal substructure.\\n**Overlapping subproblems** are characterized by recomputations and dependencies on previous results (\"I can\\'t take this weight because the knapsack already contains previously chosen weights\").\\n**Optimal substructure** means that the optimal solution can be constructed from optimal solutions of its subproblems. I think our problem doesn\\'t have an optimal substructure because having found the maximum volume for a certain range doesn\\'t help us finding the maximum volume for the entire range.\\n\\nWhat are your thoughts?",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "When I first tackled this problem I didn\\'t think of a two pointer approach at all.\\nAll I could think of was some dynamic programming approach because we\\'re looking to *maximise* the output.\\n\\nThinking about it now, I think it doesn\\'t lend itself well to dynamic programming because it doesn\\'t have overlapping subproblems and an optimal substructure.\\n**Overlapping subproblems** are characterized by recomputations and dependencies on previous results (\"I can\\'t take this weight because the knapsack already contains previously chosen weights\").\\n**Optimal substructure** means that the optimal solution can be constructed from optimal solutions of its subproblems. I think our problem doesn\\'t have an optimal substructure because having found the maximum volume for a certain range doesn\\'t help us finding the maximum volume for the entire range.\\n\\nWhat are your thoughts?",
                "codeTag": "Unknown"
            },
            {
                "id": 1468258,
                "title": "c-solution",
                "content": "My C# solution:\\n\\n```\\npublic class Solution {\\n    public int MaxArea(int[] height) {\\n        int max=0;\\n        int left=0;\\n        int right=height.Length-1;\\n        \\n        while(left<right){\\n            if(height[left]<height[right]){\\n                var area = Math.Min(height[right],height[left]) * (right-left);\\n                max = Math.Max(max,area);\\n                left++;\\n            }else{\\n                var area = Math.Min(height[right],height[left]) * (right-left);\\n                max = Math.Max(max,area);\\n                right--;\\n            }\\n        }\\n        \\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxArea(int[] height) {\\n        int max=0;\\n        int left=0;\\n        int right=height.Length-1;\\n        \\n        while(left<right){\\n            if(height[left]<height[right]){\\n                var area = Math.Min(height[right],height[left]) * (right-left);\\n                max = Math.Max(max,area);\\n                left++;\\n            }else{\\n                var area = Math.Min(height[right],height[left]) * (right-left);\\n                max = Math.Max(max,area);\\n                right--;\\n            }\\n        }\\n        \\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399010,
                "title": "c-brute-force-optimal-solution-time-o-n-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\t    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n\\t    // Time Limit Exceed(TLE) 54/60 test cases passed\\n        int len=height.size(), max=0, area=0;\\n            for(int i=0;i<len;i++){\\n                for(int j=i+1;j<len;j++){\\n                    area=min(height[i],height[j])*(j-i);\\n                    if(area>max)\\n                        max=area;\\n                }\\n            }\\n        return max;\\n    }\\n};\\n```\\n\\n**Optimal Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t\\t// Two Pointer Algorithm\\n        int len=height.size();\\n        int max=0,left=0,right=len-1,area=0;\\n        while(left<right){\\n            if(height[left]<height[right]){\\n                area=height[left]*(right-left);\\n                left++;\\n            }\\n            else{\\n                area=height[right]*(right-left);\\n                right--;\\n            }\\n            if(area>max)\\n                max=area;\\n        }\\n        return max;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\t    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n\\t    // Time Limit Exceed(TLE) 54/60 test cases passed\\n        int len=height.size(), max=0, area=0;\\n            for(int i=0;i<len;i++){\\n                for(int j=i+1;j<len;j++){\\n                    area=min(height[i],height[j])*(j-i);\\n                    if(area>max)\\n                        max=area;\\n                }\\n            }\\n        return max;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t\\t// Two Pointer Algorithm\\n        int len=height.size();\\n        int max=0,left=0,right=len-1,area=0;\\n        while(left<right){\\n            if(height[left]<height[right]){\\n                area=height[left]*(right-left);\\n                left++;\\n            }\\n            else{\\n                area=height[right]*(right-left);\\n                right--;\\n            }\\n            if(area>max)\\n                max=area;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362458,
                "title": "python-o-n-with-thought-process",
                "content": "I started off by finding the brute force solution to this problem. In O(n^2) we can try every possible choice and then just return the max. We do this with two while loops\\n\\nNaive:\\n```\\ndef maxArea(self, height: List[int]) -> int:\\n        \\n        i = 0\\n        n = len(height)\\n        output = float(\\'-inf\\')\\n        \\n        while i < n:\\n            \\n            j = i + 1\\n            \\n            while j < n:\\n                w = j - i\\n                h = min(height[i], height[j])\\n                output = max(output, w * h)\\n                j += 1\\n            i += 1\\n        \\n        return output\\n\\n```\\n\\nThinking about this solution (which will time out), it becomes clear that we are re-doing unnecessary work. \\n\\nIntuitively\\n1. wider is better\\n2. higher is better\\n\\nSo, we can guarentee we check the widest possible solution by starting with pointers at the far right and the far left. \\n\\nThen, we can **greedily** decide if we want to move the left pointer or the right pointer only based on the remaining property that contributes to area: height.\\n\\nAlways keep the taller side. (If they are the same, it does not matter which one we keep because we have the same height in the next step). So, we only look at each element once, and we get an O(n) solution. O(1) space because we\\'re only using pointers.\\n\\nMuch better:\\n```\\ndef maxArea(self, height: List[int]) -> int:\\n        \\n        i, j = 0, len(height) - 1\\n        output = float(\\'-inf\\')\\n            \\n        while i < j:\\n            \\n            l, r = height[i], height[j]   \\n            h = min(l,r)\\n            w = j - i\\n            output = max(output, h * w)\\n            \\n            if l > r:\\n                j -= 1\\n            else:\\n                i += 1\\n                \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxArea(self, height: List[int]) -> int:\\n        \\n        i = 0\\n        n = len(height)\\n        output = float(\\'-inf\\')\\n        \\n        while i < n:\\n            \\n            j = i + 1\\n            \\n            while j < n:\\n                w = j - i\\n                h = min(height[i], height[j])\\n                output = max(output, w * h)\\n                j += 1\\n            i += 1\\n        \\n        return output\\n\\n```\n```\\ndef maxArea(self, height: List[int]) -> int:\\n        \\n        i, j = 0, len(height) - 1\\n        output = float(\\'-inf\\')\\n            \\n        while i < j:\\n            \\n            l, r = height[i], height[j]   \\n            h = min(l,r)\\n            w = j - i\\n            output = max(output, h * w)\\n            \\n            if l > r:\\n                j -= 1\\n            else:\\n                i += 1\\n                \\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1347606,
                "title": "c-easy-using-two-pointer-o-n",
                "content": "# **SOLUTION**\\nThe following code is written using *two pointers* where we find with conditions the maximum area of water.\\nWe then update this value throughout the running loop to get the answer\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int l = 0 , r = height.size() - 1 ;\\n        int temp ;\\n        int ans_max = 0 ;\\n        while(l <= r)\\n        {\\n            if(height[l] <= height[r])\\n            {\\n                temp = height[l]*(r - l) ;\\n                l++ ;\\n            }\\n            else\\n            {\\n                temp = height[r]*(r - l) ;\\n                r-- ;\\n            }\\n            ans_max = max(temp , ans_max) ;\\n        }\\n        return ans_max ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int l = 0 , r = height.size() - 1 ;\\n        int temp ;\\n        int ans_max = 0 ;\\n        while(l <= r)\\n        {\\n            if(height[l] <= height[r])\\n            {\\n                temp = height[l]*(r - l) ;\\n                l++ ;\\n            }\\n            else\\n            {\\n                temp = height[r]*(r - l) ;\\n                r-- ;\\n            }\\n            ans_max = max(temp , ans_max) ;\\n        }\\n        return ans_max ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296853,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        ret = 0\\n        left, right = 0, len(height)-1\\n        \\n        while left < right:\\n            ret = max(ret, (right-left) * min(height[left], height[right]))\\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        ret = 0\\n        left, right = 0, len(height)-1\\n        \\n        while left < right:\\n            ret = max(ret, (right-left) * min(height[left], height[right]))\\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172680,
                "title": "simple-two-pointer-using-c-trapping-rain-water-logic-faster-than-89",
                "content": "//trapping rain water problem\\nclass Solution {\\npublic:\\nint maxArea(vector& height) {\\n//initialising left and right pointer to start and end of the vector height to maximise the base\\n//initialising maxarea by INT_MIN to maximize the area\\nint left=0,right=height.size()-1,maxarea=INT_MIN;\\n// this left<right is there to stop loop when will be getting negative area\\nwhile(left<right)\\n{\\nmaxarea=max(maxarea,min(height[left],height[right])*(right-left));// calculating max area\\nif(height[left]<height[right])// if we are getting smaller left height then we increment it to //maximize the area\\nleft++;\\nelse// if we are getting smaller right height then we decrement it to maximize the area\\nright--;\\n}return maxarea;// returning max area\\n}\\n};\\nplz upvote if you found it useful...that would be very motivating for me...",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\nint maxArea(vector& height) {\\n//initialising left and right pointer to start and end of the vector height to maximise the base\\n//initialising maxarea by INT_MIN to maximize the area\\nint left=0,right=height.size()-1,maxarea=INT_MIN;\\n// this left<right is there to stop loop when will be getting negative area\\nwhile(left<right)\\n{\\nmaxarea=max(maxarea,min(height[left],height[right])*(right-left));// calculating max area\\nif(height[left]<height[right])// if we are getting smaller left height then we increment it to //maximize the area\\nleft++;\\nelse// if we are getting smaller right height then we decrement it to maximize the area\\nright--;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1084058,
                "title": "golang-solution-with-images",
                "content": "**Code On The Bottom, If This Helps Please Up Vote**\\n\\nThis solution uses a Two-Pointer algorithm.\\n\\nIt can be shown using these pictures:\\n\\n![image](https://assets.leetcode.com/users/images/b970068e-0a69-4e14-a171-babf8b5fdb64_1614363805.9227924.png)\\n\\n![image](https://assets.leetcode.com/users/images/bdece6dc-4360-496f-89dc-2e291f31b957_1614363817.5981355.png)\\n\\n![image](https://assets.leetcode.com/users/images/1fcb62b5-3be7-456a-865f-23102a7fb803_1614363825.7764618.png)\\n\\n\\nThis is not the end but my hand is paining from drawing and writing so much, and I think you understand what this code does.\\n\\n```\\nfunc maxArea(height []int) int {\\n    left, right := 0, len(height)-1\\n    max := 0\\n\\n    for left < right {\\n        max = int(math.Max(float64(max), float64((right-left)*\\n            int(math.Min(float64(height[left]), float64(height[right]))))))\\n\\n        if height[left] < height[right] {\\n            left++\\n        } else {\\n            right--\\n        }\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxArea(height []int) int {\\n    left, right := 0, len(height)-1\\n    max := 0\\n\\n    for left < right {\\n        max = int(math.Max(float64(max), float64((right-left)*\\n            int(math.Min(float64(height[left]), float64(height[right]))))))\\n\\n        if height[left] < height[right] {\\n            left++\\n        } else {\\n            right--\\n        }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1069682,
                "title": "easy-to-understand-c-solution",
                "content": "**use two pointer \\ni points to first value\\nj points to last value\\nin every itteration we find the maximum water it can store**\\n\\nnow area = base * height\\n==> we know the base (j-i)\\n==> so we have to find the height\\n==>height is the minimum of both the height pointing by i and j\\n==>increment the i or j which is minimum because the we have to find the maximum in every iteration.\\n==> time complexity == O(n)\\n==>space complexity == O(1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& a) {\\n        int ans = 0;\\n        int i = 0, j = a.size()-1; // creating two pointer i points to first and j points to second\\n        while(i<j) {\\n            if(a[i] >= a[j]) {\\n                ans = max(ans,(j-i)*a[j]); // (j-i) is base and a[j] is height\\n                j--;\\n            }\\n            else {\\n                ans = max(ans,(j-i)*a[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& a) {\\n        int ans = 0;\\n        int i = 0, j = a.size()-1; // creating two pointer i points to first and j points to second\\n        while(i<j) {\\n            if(a[i] >= a[j]) {\\n                ans = max(ans,(j-i)*a[j]); // (j-i) is base and a[j] is height\\n                j--;\\n            }\\n            else {\\n                ans = max(ans,(j-i)*a[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944012,
                "title": "two-pointer-python-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height)- 1\\n        res  = 0\\n        \\n        while left < right:\\n            res = max(min(height[left], height[right]) * (right - left), res)\\n            if height[left] > height[right]:\\n                right -= 1\\n            else:\\n                left += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height)- 1\\n        res  = 0\\n        \\n        while left < right:\\n            res = max(min(height[left], height[right]) * (right - left), res)\\n            if height[left] > height[right]:\\n                right -= 1\\n            else:\\n                left += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642331,
                "title": "better-than-99-java-submissions",
                "content": "Here i have used recursion. Please upvote if you find this useful. It really encourages the one answering.\\n```\\nclass Solution\\n{\\n    public int maxArea(int[] height)\\n    {\\n        return help(height,0,height.length-1,0);\\n    }\\n    private static int help(int arr[],int start,int end,int max)\\n    {\\n        int temp=Math.min(arr[start],arr[end])*(end-start); //current capacity\\n        if(temp>max)\\n            max=temp;\\n        if(end-start==1)            //if adjacent points treated\\n            return max;\\n        boolean changed=false;      //to check if  any element with height greater                                       than current heights.\\n        if(arr[start]>arr[end])\\n        {\\n            for(int i=end-1;i>start;i--)\\n            {\\n                if(arr[i]>arr[end])\\n                {\\n                    changed=true;\\n                    end=i;\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=start+1;i<end;i++)\\n            {\\n                if(arr[i]>arr[start])\\n                {\\n                    changed=true;\\n                    start=i;\\n                    break;\\n                }\\n            }\\n        }\\n        if(changed)\\n        {\\n            return help(arr,start,end,max);\\n        }\\n        return max;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int maxArea(int[] height)\\n    {\\n        return help(height,0,height.length-1,0);\\n    }\\n    private static int help(int arr[],int start,int end,int max)\\n    {\\n        int temp=Math.min(arr[start],arr[end])*(end-start); //current capacity\\n        if(temp>max)\\n            max=temp;\\n        if(end-start==1)            //if adjacent points treated\\n            return max;\\n        boolean changed=false;      //to check if  any element with height greater                                       than current heights.\\n        if(arr[start]>arr[end])\\n        {\\n            for(int i=end-1;i>start;i--)\\n            {\\n                if(arr[i]>arr[end])\\n                {\\n                    changed=true;\\n                    end=i;\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=start+1;i<end;i++)\\n            {\\n                if(arr[i]>arr[start])\\n                {\\n                    changed=true;\\n                    start=i;\\n                    break;\\n                }\\n            }\\n        }\\n        if(changed)\\n        {\\n            return help(arr,start,end,max);\\n        }\\n        return max;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 385029,
                "title": "scala-tail-recursive-two-pointer-solution",
                "content": "```scala\\nimport scala.math.min\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  def maxArea(height: Array[Int]): Int = {\\n\\n    @tailrec\\n    def traverse(i: Int, j: Int, maxArea: Int): Int = {\\n      if(i >= j) {\\n        maxArea\\n      } else {\\n        val area = (j - i) * min(height(i), height(j))\\n        val newMax = if(area > maxArea) area else maxArea\\n        val (newI, newJ) = if(height(i) < height(j)) (i + 1, j) else (i, j - 1)\\n        traverse(newI, newJ, newMax)\\n      }\\n    }\\n\\n    traverse(0, height.length - 1, 0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```scala\\nimport scala.math.min\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  def maxArea(height: Array[Int]): Int = {\\n\\n    @tailrec\\n    def traverse(i: Int, j: Int, maxArea: Int): Int = {\\n      if(i >= j) {\\n        maxArea\\n      } else {\\n        val area = (j - i) * min(height(i), height(j))\\n        val newMax = if(area > maxArea) area else maxArea\\n        val (newI, newJ) = if(height(i) < height(j)) (i + 1, j) else (i, j - 1)\\n        traverse(newI, newJ, newMax)\\n      }\\n    }\\n\\n    traverse(0, height.length - 1, 0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 340098,
                "title": "python3-solution-using-two-pointers-single-pass",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        res=0\\n        l=len(height)\\n        i,j=0,l-1\\n        while i<j:\\n            k=(j-i)*min(height[j],height[i])\\n            if k>res:res=k\\n            if height[j]<height[i]:j-=1\\n            else:i+=1\\n        return (res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        res=0\\n        l=len(height)\\n        i,j=0,l-1\\n        while i<j:\\n            k=(j-i)*min(height[j],height[i])\\n            if k>res:res=k\\n            if height[j]<height[i]:j-=1\\n            else:i+=1\\n        return (res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323483,
                "title": "python3-straightforward-and-concise-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef maxArea(self, height: List[int]) -> int:\\n\\t\\t\\tres=0\\n\\t\\t\\tstart=0\\n\\t\\t\\tend=len(height)-1\\n\\t\\t\\twhile start<end:\\n\\t\\t\\t\\tarea=(end-start)*min(height[end],height[start])\\n\\t\\t\\t\\tres=max(res,area)\\n\\t\\t\\t\\tif height[end]>height[start]:\\n\\t\\t\\t\\t\\tstart+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend-=1\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxArea(self, height: List[int]) -> int:\\n\\t\\t\\tres=0\\n\\t\\t\\tstart=0\\n\\t\\t\\tend=len(height)-1\\n\\t\\t\\twhile start<end:\\n\\t\\t\\t\\tarea=(end-start)*min(height[end],height[start])\\n\\t\\t\\t\\tres=max(res,area)\\n\\t\\t\\t\\tif height[end]>height[start]:\\n\\t\\t\\t\\t\\tstart+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend-=1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 192578,
                "title": "easy-to-understand-python",
                "content": "```\\n\\t\\t\\t\\t c1 = 0\\n        c2 = len(height) - 1\\n        left = height[c1]\\n        right = height[c2]\\n        \\n        max = 0\\n        \\n        while(c1 != c2):\\n            temp = (c2-c1) * min(left, right)\\n            if temp > max:\\n                max = temp\\n            if left <= right:\\n                c1 += 1\\n                left = height[c1]\\n            else:\\n                c2 -= 1\\n                right = height[c2]\\n                \\n        return max",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t c1 = 0\\n        c2 = len(height) - 1\\n        left = height[c1]\\n        right = height[c2]\\n        \\n        max = 0\\n        \\n        while(c1 != c2):\\n            temp = (c2-c1) * min(left, right)\\n            if temp > max:\\n                max = temp\\n            if left <= right:\\n                c1 += 1\\n                left = height[c1]\\n            else:\\n                c2 -= 1\\n                right = height[c2]\\n                \\n        return max",
                "codeTag": "Unknown"
            },
            {
                "id": 6132,
                "title": "2ms-java-beat-99-86",
                "content": "    public class Solution {\\n        public int maxArea(int[] height) {\\n            int left=0;\\n            int right = height.length-1;\\n            int max=0,area;\\n            while(left<right) {\\n                int l = height[left];\\n                int r = height[right]; \\n                if( l > r){\\n                    area = (right-left) * r;\\n                    while (height[--right] <= r);\\n                }else{\\n                    area = (right-left) * l;\\n                    while (height[++left] < l);\\n                }\\n                if (area > max) max = area;\\n            }\\n            return max;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxArea(int[] height) {\\n            int left=0;\\n            int right = height.length-1;\\n            int max=0,area;\\n            while(left<right) {\\n                int l = height[left];\\n                int r = height[right]; \\n                if( l > r){\\n                    area = (right-left) * r;\\n                    while (height[--right] <= r);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 6230,
                "title": "my-python-solution-64-ms",
                "content": "    class Solution(object):\\n        def maxArea(self, height):\\n            \"\"\"\\n            :type height: List[int]\\n            :rtype: int\\n            \"\"\"\\n            maxVal= 0\\n            # Use two pointer: head pointer and tail pointer\\n            i = 0;j = len(height)-1\\n            while i != j:\\n                currVal = j-i\\n                if height[i] < height[j]:\\n                    currVal, i, j = currVal * height[i], i+1, j \\n                else :\\n                    currVal, i, j = currVal * height[j], i, j-1 \\n                maxVal = currVal if currVal > maxVal else maxVal\\n            return maxVal;",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def maxArea(self, height):\\n            \"\"\"\\n            :type height: List[int]\\n            :rtype: int\\n            \"\"\"\\n            maxVal= 0\\n            # Use two pointer: head pointer and tail pointer\\n            i = 0;j = len(height)-1\\n            while i != j:\\n                currVal = j-i\\n                if height[i] < height[j]:\\n                    currVal, i, j = currVal * height[i], i+1, j \\n                else :\\n                    currVal, i, j = currVal * height[j], i, j-1 \\n                maxVal = currVal if currVal > maxVal else maxVal\\n            return maxVal;",
                "codeTag": "Java"
            },
            {
                "id": 6239,
                "title": "links-to-o-n-solution-explanation-and-my-elaboration",
                "content": "For those who read the articles: \\n\\n - https://leetcode.com/discuss/1074/anyone-who-has-a-o-n-algorithm\\n - https://leetcode.com/discuss/11482/yet-another-way-to-see-what-happens-in-the-o-n-algorithm\\n - https://leetcode.com/discuss/14610/very-simple-o-n-solution\\n\\nBut you still didn't quite get it, here are some simple thoughts:\\n\\n 1. We need to at least check all the heights, but do we need to\\n    check all the choose(n, 2) solutions for each pair of left/right\\n    boundaries? \\n 2. If not, when can we be lazy not to check the\\n    combinations?\\n\\n----------\\n\\nBefore start..\\n\\n 1. left, right represents the left and right boundaries respectively.\\n 2. Area is decided by (right-left)***min**(height[left],height[right])\\n\\n----------\\n\\nBecause you are looking for a **maximum** area, \\nyou can search from the maximum width (left = 0, right = n - 1)\\n\\nConsider the case: height is [1,2,3,4]\\nAt the beginning, the area would be (3-0) *min(1,4) = 3\\nAnd you find that you would **need** to check that left = 1, which leads area to be (3-1)*min(2,4) = 4\\nand so on...\\n\\n\\n----------\\n\\n\\nBut consider the opposite case: height is [4, 3, 2, 1]\\nAt the beginning, the area would be (3-0) *min(4,1) = 3\\nAnd you do **NOT** need to move your left bar at all. \\n\\nWhy? Because the height of area would always bounded by the lowest boundaries.\\nFor example, at this time, when left = 1, the area would only be (3-1)*min(3,1) = 2\\n\\n\\n----------\\n\\n\\nHere we can draw some conclusion:\\n\\n - We can check the left and right **alternatively**.  (What [\\\\[2\\\\]][3] is drawing)\\n - If left bar is higher than the right bar, we don't need to move left bar **until right bar is higher than the left bar**, vise versa. (What [\\\\[3\\\\]][4] is describing)\\n - When left bar pass right bar, we've already check all the boundaries.\\n\\nThese ideas could be proved by the contradiction proof in [\\\\[1\\\\]][5]\\n\\nSome sample code in Python:\\n\\n    class Solution:\\n    # @param {integer[]} height\\n    # @return {integer}\\n    def maxArea(self, height):\\n        lh, maxArea = len(height), 0\\n        if lh < 1:\\n            return 0\\n        left, right, maxArea = 0, lh-1, 0\\n        while(left < right):\\n            maxArea = max(maxArea, (right-left)*min(height[left],height[right]))\\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n        return maxArea\\n\\n\\n  [1]: http://postimg.org/image/embkroso1/\\n  [2]: http://postimg.org/image/z299tlc4p/\\n  [3]: https://leetcode.com/discuss/11482/yet-another-way-to-see-what-happens-in-the-o-n-algorithm\\n  [4]: https://leetcode.com/discuss/14610/very-simple-o-n-solution\\n  [5]: https://leetcode.com/discuss/1074/anyone-who-has-a-o-n-algorithm",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3894983,
                "title": "java-100-faster-step-by-step-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/91cb894b-88ae-4867-8365-d80637026c21_1691759174.5441668.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        // Initialize two pointers: l starts at the leftmost element, and r starts at the rightmost element\\n        int l = 0;\\n        int r = height.length - 1;\\n        int ans = 0; // Initialize the variable to store the maximum area\\n\\n        // Use a two-pointer approach to find the container with the maximum area\\n        while (l < r) {\\n            // Calculate the current area based on the smaller of the two heights and the distance between the pointers\\n            int currentArea = (r - l) * Math.min(height[r], height[l]);\\n            \\n            // Update the maximum area if the current area is larger\\n            ans = Math.max(ans, currentArea);\\n\\n            // Move the pointer that points to the smaller height\\n            if (height[r] > height[l]) {\\n                l++; // Move the left pointer towards the right\\n            } else {\\n                r--; // Move the right pointer towards the left\\n            }\\n        }\\n        \\n        return ans; // Return the maximum area found\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        // Initialize two pointers: l starts at the leftmost element, and r starts at the rightmost element\\n        int l = 0;\\n        int r = height.length - 1;\\n        int ans = 0; // Initialize the variable to store the maximum area\\n\\n        // Use a two-pointer approach to find the container with the maximum area\\n        while (l < r) {\\n            // Calculate the current area based on the smaller of the two heights and the distance between the pointers\\n            int currentArea = (r - l) * Math.min(height[r], height[l]);\\n            \\n            // Update the maximum area if the current area is larger\\n            ans = Math.max(ans, currentArea);\\n\\n            // Move the pointer that points to the smaller height\\n            if (height[r] > height[l]) {\\n                l++; // Move the left pointer towards the right\\n            } else {\\n                r--; // Move the right pointer towards the left\\n            }\\n        }\\n        \\n        return ans; // Return the maximum area found\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890070,
                "title": "easy-python-solution-beats-91-96-with-great-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet us take the two edges as the container walls and calculate the water in them.\\n\\nSo now we change the smaller wall.THE reason for NOT Changing the bigger wall is that the amount of water would not increase no matter the size of the bigger wall hence we are considering the size of the smaller wall to calculate the amount of water needed.\\n\\nNOTE: If you can not understand my explanation please read the approach and then try to understand my intuition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n->Take two variables ```(l,r)``` and assign the boundaries of the given list.\\n\\n->Now calculate the amount of water in them.The amount of water present is basically the distance between the walls multiplied by the smaller wall heigth\\n\\n->Now compare the heights of the walls in the positions and move the smaller wall towards the bigger wall.\\n[The reason for this is given in the intuition .I recommend reading it if u have not read it]\\n\\n->continue this process till the left wall crosses the right wall.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n         l,r=0,len(height)-1\\n\\n         water=0\\n         while l<r:\\n            water=max(min(height[l],height[r])*(r-l),water)\\n            if height[l]<height[r]:\\n                 l+=1\\n            else:\\n                 r-=1\\n \\n         return water\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```(l,r)```\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n         l,r=0,len(height)-1\\n\\n         water=0\\n         while l<r:\\n            water=max(min(height[l],height[r])*(r-l),water)\\n            if height[l]<height[r]:\\n                 l+=1\\n            else:\\n                 r-=1\\n \\n         return water\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849056,
                "title": "easy-2-pointer-solution",
                "content": "\\n# Approach\\nInitialize the maxi variable to store the maximum area seen so far, and set it to 0.\\nInitialize two pointers, s and e, one at the beginning of the array (index 0) and the other at the end (index n-1), where n is the size of the input array.\\nWhile s is less than e, repeat the following steps:\\nCalculate the area between the two pointers using the formula min(height[s], height[e]) * (e - s). Here, min(height[s], height[e]) represents the height of the shorter vertical line, and (e - s) represents the width of the container.\\nUpdate the maxi variable by taking the maximum of the current maxi and the calculated area.\\nMove the pointer with the smaller height inward:\\nIf height[s] > height[e], decrement e to try a smaller height.\\nIf height[s] <= height[e], increment s to try a larger height.\\nOnce the loop is completed, return the maxi, which represents the maximum area that can be held by any container.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int maxi=0;\\n        int n = height.size();\\n        int s= 0;\\n        int e= n-1; \\n        while(s<e)\\n        {\\n            int area = min(height[s],height[e]) * (e-s);\\n            maxi = max(maxi,area);\\n            if(height[s]>height[e])\\n            {\\n                e--;    \\n            }\\n            else if(height[s]<=height[e])\\n            {\\n                s++;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int maxi=0;\\n        int n = height.size();\\n        int s= 0;\\n        int e= n-1; \\n        while(s<e)\\n        {\\n            int area = min(height[s],height[e]) * (e-s);\\n            maxi = max(maxi,area);\\n            if(height[s]>height[e])\\n            {\\n                e--;    \\n            }\\n            else if(height[s]<=height[e])\\n            {\\n                s++;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497491,
                "title": "sliding-window-beats-96-36-runtime-and-memory-extremely-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDP via memo but failed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding window.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n# @param {Integer[]} height\\n# @return {Integer}\\ndef max_area(height)\\n\\n    # We need to track our max_area as thats our answer, left and right window index.\\n    max_area = 0\\n    left_window_index = 0\\n    right_window_index = height.size - 1\\n    \\n    # While our two points have not met:\\n    # 1. Calculate the size of area and if area is larger than our current max area, replace max area with area.\\n    # 2. Move our left or right pointer based on which will raise the min_height for the next calculation.\\n    while left_window_index != right_window_index\\n        # Calculate width and left and right line height.\\n        width = (right_window_index - left_window_index) \\n        left_height = height[left_window_index]\\n        right_height = height[right_window_index]\\n\\n        # Determine our mine height and determine the change for our right or left pointer based on raising the min height.\\n        if right_height <  left_height\\n            min_height = right_height\\n            right_window_index = right_window_index - 1\\n        else\\n            min_height = left_height \\n            left_window_index = left_window_index + 1\\n        end\\n\\n        # Calculate the size of area and if area is larger than our current max area, replace max area with area.\\n        area = width * min_height\\n        if area > max_area\\n            max_area = area\\n        end\\n    end\\n\\n    max_area\\nend\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} height\\n# @return {Integer}\\ndef max_area(height)\\n\\n    # We need to track our max_area as thats our answer, left and right window index.\\n    max_area = 0\\n    left_window_index = 0\\n    right_window_index = height.size - 1\\n    \\n    # While our two points have not met:\\n    # 1. Calculate the size of area and if area is larger than our current max area, replace max area with area.\\n    # 2. Move our left or right pointer based on which will raise the min_height for the next calculation.\\n    while left_window_index != right_window_index\\n        # Calculate width and left and right line height.\\n        width = (right_window_index - left_window_index) \\n        left_height = height[left_window_index]\\n        right_height = height[right_window_index]\\n\\n        # Determine our mine height and determine the change for our right or left pointer based on raising the min height.\\n        if right_height <  left_height\\n            min_height = right_height\\n            right_window_index = right_window_index - 1\\n        else\\n            min_height = left_height \\n            left_window_index = left_window_index + 1\\n        end\\n\\n        # Calculate the size of area and if area is larger than our current max area, replace max area with area.\\n        area = width * min_height\\n        if area > max_area\\n            max_area = area\\n        end\\n    end\\n\\n    max_area\\nend\\n\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3340741,
                "title": "easy-c-two-pointers",
                "content": "# Intuition\\nChecking max water that can be store using that particular index with any other index.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWill use two pointers to calculate the max water that can be store in container. We will move that pointer whose value in height array is low towards the bigger element. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& nums) {\\n        int n=nums.size();        \\n        int ans=0;\\n        int i=0, j=n-1;\\n        while(i<=j){\\n            ans=max(ans,min(nums[i],nums[j])*(j-i));\\n            if(nums[i]>=nums[j])j--;\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& nums) {\\n        int n=nums.size();        \\n        int ans=0;\\n        int i=0, j=n-1;\\n        while(i<=j){\\n            ans=max(ans,min(nums[i],nums[j])*(j-i));\\n            if(nums[i]>=nums[j])j--;\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255239,
                "title": "o-n-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int result = 0, left = 0, right = height.size() - 1;\\n        while(left < right) {\\n            long long area = (right - left) * min(height[left], height[right]);\\n            if(area > result) {\\n                result = area;\\n            }\\n            if(height[left] < height[right]) {\\n                left += 1;\\n            } else {\\n                right -= 1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int result = 0, left = 0, right = height.size() - 1;\\n        while(left < right) {\\n            long long area = (right - left) * min(height[left], height[right]);\\n            if(area > result) {\\n                result = area;\\n            }\\n            if(height[left] < height[right]) {\\n                left += 1;\\n            } else {\\n                right -= 1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251572,
                "title": "java-beat-94-two-pointers-fully-explained",
                "content": "\\n\\n# Approach\\n\\n- We have to test each volume case but we have to do it in an optimize way to not have a ***\"Time Exceed\"*** error.\\n\\n- To achieve that we are going to use two pointers one from the beginning of the array **i** and from the end of the array **j**.\\n\\n- To test the volume size we are going to save the current studied volume if its bigger than the previous saved. We can calculate the volume with the following formula : \\n\\n            V = height x length <=> v = height_min x (j-i)\\nTo calculate the volume we have to consider the smaller stick from the two (*otherwise the water would spilled out !*). And the length is corresponding to the distance between **i** and **j**.\\n\\n\\n\\n- Then we will be moving the the pointer corresponding to the smaller height to maximize the volume.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        \\n        int v_max  = 0 ; int i = 0 ; int h_min = 0 ; int j = height.length - 1 ; \\n\\n        while ( j != i ){\\n\\n            if ( height[i] < height[j]){\\n                h_min = height[i] ; \\n            }else{\\n                h_min = height[j] ;\\n            }\\n\\n            if (h_min*(j-i) > v_max){\\n                v_max = h_min*(j-i);\\n            }\\n\\n            if (height[i] < height[j]){\\n                i++ ;\\n            }else{\\n                j-- ;\\n            }\\n        }\\n    return v_max ;\\n    }\\n}\\n```\\nI hope that it helps you !\\n\\n***if (helpsyou){\\nupvote ;\\n}***\\n\\n<3",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        \\n        int v_max  = 0 ; int i = 0 ; int h_min = 0 ; int j = height.length - 1 ; \\n\\n        while ( j != i ){\\n\\n            if ( height[i] < height[j]){\\n                h_min = height[i] ; \\n            }else{\\n                h_min = height[j] ;\\n            }\\n\\n            if (h_min*(j-i) > v_max){\\n                v_max = h_min*(j-i);\\n            }\\n\\n            if (height[i] < height[j]){\\n                i++ ;\\n            }else{\\n                j-- ;\\n            }\\n        }\\n    return v_max ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175919,
                "title": "easy-python-using-two-pointers",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        start=0\\n        end=len(height)-1\\n        mx=0\\n        while start<end:\\n            min_storage=min(height[start],height[end])\\n            storage=min_storage*(end-start)\\n            mx=max(mx,storage)\\n            if height[start]<height[end]:\\n                start+=1\\n            else:\\n                end-=1\\n        return mx\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        start=0\\n        end=len(height)-1\\n        mx=0\\n        while start<end:\\n            min_storage=min(height[start],height[end])\\n            storage=min_storage*(end-start)\\n            mx=max(mx,storage)\\n            if height[start]<height[end]:\\n                start+=1\\n            else:\\n                end-=1\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914775,
                "title": "beat-96-in-time-and-98-in-memory-efficient-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere are the 3 things which came to my mind when read the Question:\\n1. distance between the two pillers (width) should be maximum to get maximum area. \\n2. the minimum height of two pillers will be the height of the container.\\n3. Only beneficial to process the area if we get high value of height as we move on because we need more area, i.e. ultimately more height and more width.\\n\\n***Please Upvote if you find it helpful :)***\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is a two pointer approach with initially one pointer at starting of vector/array and another at the end of the vector/array.\\n\\nhere I have broken the process in some points:\\n1. we have two pointers i = 0 and j = A.size() - 1.\\n2. increase the pointer whose value is small i.e., if A[i]<A[j], i++.\\n3. if the value at new increased pointer is more than the value at the previous pointer, i.e., if A[i]>A[i-1], we will calculate the area by min(A[i],A[j])*(j-i). (here min is taken as min of both will be the height of the container)\\n4. We will then update the value of area by taking the maximum of present calculated area and previous area using max() function.\\n5. similarly if A[j]<=A[i], then j--.\\n6. if A[j]>A[j+1], we\\'ll calculate the area with same formula and update it similarly.\\n7. We\\'ll continue this till i and j becomes equal.\\n8. At last we will get maximum possible value of area.\\n \\n**Go and see the code below for better understanding.**\\n# Complexity\\n- Time complexity: $$O(n)$$ , beats  96%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$ , beats 98%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int i = 0;\\n        int j = height.size() - 1;\\n        int V = min(height[i], height[j]) * (j-i);\\n\\n        while(i!=j){\\n            if(height[i]<height[j]){\\n                i++;\\n                if(height[i]>height[i-1] && i!=j){\\n                    V = max(V , min(height[i], height[j]) * (j-i));\\n                }\\n            }\\n            else{\\n                j--;\\n                if(height[j]>height[j+1] && i!=j){\\n                    V = max(V , min(height[i], height[j]) * (j-i));\\n                }\\n            }\\n        }\\n        return V;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int i = 0;\\n        int j = height.size() - 1;\\n        int V = min(height[i], height[j]) * (j-i);\\n\\n        while(i!=j){\\n            if(height[i]<height[j]){\\n                i++;\\n                if(height[i]>height[i-1] && i!=j){\\n                    V = max(V , min(height[i], height[j]) * (j-i));\\n                }\\n            }\\n            else{\\n                j--;\\n                if(height[j]>height[j+1] && i!=j){\\n                    V = max(V , min(height[i], height[j]) * (j-i));\\n                }\\n            }\\n        }\\n        return V;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908601,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n       int l=0, h=height.size()-1;\\n        int ans=0;\\n        while(l<h)\\n        {\\n            int a=min(height[l], height[h])*(h-l);\\n            ans=max(a, ans);\\n            if(height[l]>height[h])\\n                h--;\\n            else\\n                l++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n       int l=0, h=height.size()-1;\\n        int ans=0;\\n        while(l<h)\\n        {\\n            int a=min(height[l], height[h])*(h-l);\\n            ans=max(a, ans);\\n            if(height[l]>height[h])\\n                h--;\\n            else\\n                l++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848874,
                "title": "a-o-nlogn-solution",
                "content": "A O(nlogn) Solution:\\n1. Sort all the lines from largest to smallest and store their position in a list. \\n2. So we are basically picking the largest two lines, and marking them with left and right depending on their position. \\n3. Then we calculate the area between them. \\n4. After that, we add the third largest line, if this line is further away from left or right, then we adjust the left and right lines. \\n5. Then, calculating the area between the left line and this line, and the area between the right line and this line, and picking the largest one between them. \\n6. So on and so forth. This is because as the newly added line can make an area with any other line that has been irritated(since they are all larger than the current line, therefore the largest area is only the area between the most left line or the most right line that has been irritated(similar to Approach 2)\\n7. If the area is larger than the area between the current line and the entire width, then there\\'s no point continuing, therefore return the area. \\n\\nCode: \\n```py\\nclass Solution:\\n    def maxArea(self, height) -> int:\\n        area = 0\\n        SortedList = sorted(range(len(height)), key=lambda k: height[k], reverse=True)\\n        left = SortedList[0]\\n        right = SortedList[0]\\n        for h in SortedList:\\n            left = min(h, left)\\n            right = max(h, right)\\n            area = max(area, height[h] * max(h - left, right - h))\\n            \\n            if area > len(height) * height[h]:\\n                return area\\n\\n        return area\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def maxArea(self, height) -> int:\\n        area = 0\\n        SortedList = sorted(range(len(height)), key=lambda k: height[k], reverse=True)\\n        left = SortedList[0]\\n        right = SortedList[0]\\n        for h in SortedList:\\n            left = min(h, left)\\n            right = max(h, right)\\n            area = max(area, height[h] * max(h - left, right - h))\\n            \\n            if area > len(height) * height[h]:\\n                return area\\n\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802281,
                "title": "o-n-simple-and-clear-proof-cpp-solution",
                "content": "**Idea / Proof:**\\n\\n* 1. The widest container (using first and last line) is a good candidate, because of its width. Its water level is the height of the smaller one of first and last line.\\n* 2.  All other containers are less wide and thus would need a higher water level in order to hold more water.\\n* 3.  The smaller one of first and last line doesn\\'t support a higher water level and can thus be safely removed from further consideration.\\n\\n**C++ Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int i=0, j= height.size()-1;\\n        int area = 0;\\n        while(i < j){\\n            area = max(area,min(height[i],height[j])*(j-i));\\n            (height[i] > height[j]) ? j-- : i++ ;\\n        }\\n        return area;\\n    }\\n};\\n```\\n\\n### Basic Implementation: \\n\\n* Variables i and j define the container under consideration. We initialize them to first and last line, meaning the widest container. Variable area will keep track of the highest amount of water we managed so far. \\n* We compute j - i, the width of the current container, and min(height[i], height[j]), the water level that this container can support. Multiply them to get how much water this container can hold, and update water accordingly. \\n* Next remove the smaller one of the two lines from consideration, as justified above in \"Idea / Proof\". Continue until there is nothing left to consider, then return the result.\\n\\n`Simple & Clear Explanation - O(N)`\\n\\n**Upvote if you find this usable.**\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int i=0, j= height.size()-1;\\n        int area = 0;\\n        while(i < j){\\n            area = max(area,min(height[i],height[j])*(j-i));\\n            (height[i] > height[j]) ? j-- : i++ ;\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774636,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int ans = 0;\\n        int l = 0, r = height.size()-1;\\n        while(l < r) {\\n            int h = min(height[l], height[r]);\\n            int area = (r - l) * h;\\n            ans = max(ans, area);\\n            if(height[l] <= height[r]) l++;\\n            else r--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int ans = 0;\\n        int l = 0, r = height.size()-1;\\n        while(l < r) {\\n            int h = min(height[l], height[r]);\\n            int area = (r - l) * h;\\n            ans = max(ans, area);\\n            if(height[l] <= height[r]) l++;\\n            else r--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761182,
                "title": "11-container-with-most-water-js",
                "content": "```\\n// Here we can use a naive approach of two nested loops and calculate area for every single element \\n// in the heights array with others but this would be O(n^2) time complexity. instead we can use two \\n// pointers, one starts at the beging and the other at the last height of the array and keep moving them\\n// according to the heights values.\\n\\nRuntime: 74 ms, faster than 97.95% of JavaScript online submissions for Container With Most Water.\\nMemory Usage: 48.9 MB, less than 95.88% of JavaScript online submissions for Container With Most Water.\\n\\nconst maxArea = (height) => {\\n    let left = 0;\\n    let right = height.length - 1;\\n    let maxAreaBetweenTwoHeights = 0;\\n\\n    while(left < right) {\\n        maxAreaBetweenTwoHeights = Math.max(maxAreaBetweenTwoHeights, \\n                                   Math.min(height[right], height [left]) * (right - left) );\\n        if(height[left] < height[right]) {\\n            left++;\\n        } else {\\n            right--;\\n        }\\n    }\\n    return maxAreaBetweenTwoHeights;\\n}",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\n// Here we can use a naive approach of two nested loops and calculate area for every single element \\n// in the heights array with others but this would be O(n^2) time complexity. instead we can use two \\n// pointers, one starts at the beging and the other at the last height of the array and keep moving them\\n// according to the heights values.\\n\\nRuntime: 74 ms, faster than 97.95% of JavaScript online submissions for Container With Most Water.\\nMemory Usage: 48.9 MB, less than 95.88% of JavaScript online submissions for Container With Most Water.\\n\\nconst maxArea = (height) => {\\n    let left = 0;\\n    let right = height.length - 1;\\n    let maxAreaBetweenTwoHeights = 0;\\n\\n    while(left < right) {\\n        maxAreaBetweenTwoHeights = Math.max(maxAreaBetweenTwoHeights, \\n                                   Math.min(height[right], height [left]) * (right - left) );\\n        if(height[left] < height[right]) {\\n            left++;\\n        } else {\\n            right--;\\n        }\\n    }\\n    return maxAreaBetweenTwoHeights;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2677571,
                "title": "0-ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int maximumArea = Integer.MIN_VALUE;\\n        int left = 0;\\n        int right = height.length - 1;\\n        while (left < right) {\\n            int shorterLine = Math.min(height[left], height[right]);\\n            maximumArea = Math.max(maximumArea, shorterLine * (right - left));\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return maximumArea;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int maximumArea = Integer.MIN_VALUE;\\n        int left = 0;\\n        int right = height.length - 1;\\n        while (left < right) {\\n            int shorterLine = Math.min(height[left], height[right]);\\n            maximumArea = Math.max(maximumArea, shorterLine * (right - left));\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return maximumArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648265,
                "title": "java-javascript-easy-to-understand-two-pointer-solutions",
                "content": "Java:\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int maxArea = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        \\n        while (left < right) {\\n            int width = right - left;\\n            maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * width);\\n            \\n            if (height[left] <= height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n}\\n```\\nJavaScript:\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nconst maxArea = function(height) {\\n    let maxArea = 0;\\n    let left = 0;\\n    let right = height.length - 1;\\n\\n    while (left < right) {\\n        let width = right - left;\\n\\n        maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * width);\\n\\n        if (height[left] <= height[right]) {\\n            left++;\\n        } else {\\n            right--;\\n        }\\n    }\\n\\n    return maxArea;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int maxArea = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        \\n        while (left < right) {\\n            int width = right - left;\\n            maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * width);\\n            \\n            if (height[left] <= height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nconst maxArea = function(height) {\\n    let maxArea = 0;\\n    let left = 0;\\n    let right = height.length - 1;\\n\\n    while (left < right) {\\n        let width = right - left;\\n\\n        maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * width);\\n\\n        if (height[left] <= height[right]) {\\n            left++;\\n        } else {\\n            right--;\\n        }\\n    }\\n\\n    return maxArea;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552333,
                "title": "c-easy-solution-clean-code",
                "content": "**Please UpVote if it helps you**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxArea(vector<int>& height) {\\n\\t\\t\\tint ans = 0,n = height.size();\\n\\t\\t\\tint i=0,j=n-1;\\n\\t\\t\\tans = min(height[i],height[j])*(j-i);\\n\\t\\t\\twhile(i<j+1){\\n\\t\\t\\t\\tans = max(ans,min(height[i],height[j])*(j-i));\\n\\t\\t\\t\\tif(height[i]>height[j]){\\n\\t\\t\\t\\t\\tj-=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ti+=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxArea(vector<int>& height) {\\n\\t\\t\\tint ans = 0,n = height.size();\\n\\t\\t\\tint i=0,j=n-1;\\n\\t\\t\\tans = min(height[i],height[j])*(j-i);\\n\\t\\t\\twhile(i<j+1){\\n\\t\\t\\t\\tans = max(ans,min(height[i],height[j])*(j-i));\\n\\t\\t\\t\\tif(height[i]>height[j]){\\n\\t\\t\\t\\t\\tj-=1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2429848,
                "title": "python-c-java-kotline-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q11. Container With Most Water***\\n\\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\\n\\nReturn the maximum amount of water a container can store.\\n\\n**Notice** that you may not slant the container.\\n\\n___________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def maxArea(self, H: List[int]) -> int:\\n        ans, i, j = 0, 0, len(H)-1\\n        while (i < j):\\n            if H[i] <= H[j]:\\n                res = H[i] * (j - i)\\n                i += 1\\n            else:\\n                res = H[j] * (j - i)\\n                j -= 1\\n            if res > ans: ans = res\\n        return ans\\n```\\n**Runtime:**  993 ms\\t\\n**Memory Usage:**  27.4 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int n=height.length;\\n        int l=0,h=n-1;\\n        int max=Integer.MIN_VALUE;\\n        while(l<h)\\n        {\\n            int water=(h-l)*Math.min(height[l],height[h]);\\n            max=Math.max(max,water);\\n            if(height[l]<height[h])++l;\\n            else --h;\\n        }\\n        return max;\\n    }\\n}\\n```\\n**Runtime:**  4 ms\\t\\n**Memory Usage:**  73.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int maxA = 0;\\n        int left = 0;\\n        int n = height.size();\\n        int right = n-1;\\n        \\n        while(left < right)\\n        {\\n            int distance = right - left;\\n            int high = min(height[left],height[right]);\\n            int area = distance * high;\\n            maxA = max(maxA,area);\\n            \\n            if(height[left] < height[right])\\n                left++;\\n            else right--;\\n        }\\n        return maxA;\\n    }\\n};\\n```\\n**Runtime:**  124 ms\\t\\n**Memory Usage:**  59.1 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Kotline  Code** :\\n```\\nclass Solution {\\n    fun maxArea(heights: IntArray): Int {\\n        if(heights.isEmpty()) return 0\\n        \\n        val size = heights.size\\n        var l = 0\\n        var h = size -1 \\n        var max = 0\\n        \\n        while(l < h){\\n            val area = minOf(heights[l], heights[h]) * (h - l)\\n            max = maxOf(max, area)\\n            \\n            if(heights[l] < heights[h])\\n                ++l\\n            else --h\\n        }\\n        \\n        return max\\n    }\\n}}\\n```\\n**Runtime:**  683 ms\\t\\n**Memory Usage:**  83.5 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, H: List[int]) -> int:\\n        ans, i, j = 0, 0, len(H)-1\\n        while (i < j):\\n            if H[i] <= H[j]:\\n                res = H[i] * (j - i)\\n                i += 1\\n            else:\\n                res = H[j] * (j - i)\\n                j -= 1\\n            if res > ans: ans = res\\n        return ans\\n```\n```\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        int n=height.length;\\n        int l=0,h=n-1;\\n        int max=Integer.MIN_VALUE;\\n        while(l<h)\\n        {\\n            int water=(h-l)*Math.min(height[l],height[h]);\\n            max=Math.max(max,water);\\n            if(height[l]<height[h])++l;\\n            else --h;\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int maxA = 0;\\n        int left = 0;\\n        int n = height.size();\\n        int right = n-1;\\n        \\n        while(left < right)\\n        {\\n            int distance = right - left;\\n            int high = min(height[left],height[right]);\\n            int area = distance * high;\\n            maxA = max(maxA,area);\\n            \\n            if(height[left] < height[right])\\n                left++;\\n            else right--;\\n        }\\n        return maxA;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun maxArea(heights: IntArray): Int {\\n        if(heights.isEmpty()) return 0\\n        \\n        val size = heights.size\\n        var l = 0\\n        var h = size -1 \\n        var max = 0\\n        \\n        while(l < h){\\n            val area = minOf(heights[l], heights[h]) * (h - l)\\n            max = maxOf(max, area)\\n            \\n            if(heights[l] < heights[h])\\n                ++l\\n            else --h\\n        }\\n        \\n        return max\\n    }\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411532,
                "title": "python-100-two-pointers-detailed-explantion-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        \\n        # Two pointers solution\\n        max_area = 0     # this variable store the answer\\n        left, right = 0, len(height) - 1        # two pointers at each side\\n        \\n        # find the max Area\\n        while left < right:\\n            \\n            # Area = Width x Height \\n            # (width is obvs the distance between the two)\\n            # (height can only be the min of the 2 heights- else water would splash out)\\n            curArea = (right - left) * min(height[left], height[right])\\n            max_area = max(max_area, curArea)     # check if the new one is bigger\\n            \\n            # if left height is smaller, move it in, else move right in \\n            if height[left] < height[right]:\\n                while(height[left+1] < height[left]):\\n                    left += 1\\n                left += 1\\n            else:\\n                while(height[right-1] < height[right]):\\n                    right -= 1\\n                right -= 1\\n        \\n        #return Answer\\n        return max_area\\n```\\n**Please UPVOTE if you LIKE**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        \\n        # Two pointers solution\\n        max_area = 0     # this variable store the answer\\n        left, right = 0, len(height) - 1        # two pointers at each side\\n        \\n        # find the max Area\\n        while left < right:\\n            \\n            # Area = Width x Height \\n            # (width is obvs the distance between the two)\\n            # (height can only be the min of the 2 heights- else water would splash out)\\n            curArea = (right - left) * min(height[left], height[right])\\n            max_area = max(max_area, curArea)     # check if the new one is bigger\\n            \\n            # if left height is smaller, move it in, else move right in \\n            if height[left] < height[right]:\\n                while(height[left+1] < height[left]):\\n                    left += 1\\n                left += 1\\n            else:\\n                while(height[right-1] < height[right]):\\n                    right -= 1\\n                right -= 1\\n        \\n        #return Answer\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241313,
                "title": "2-pointer-simple-o-n-solution-explanation-with-graphic",
                "content": "Algorithm explanation: The trick is that you have to choose the perfect left wall and perfect right wall for the container that sums up the most water.\\n\\nInside an unlimited time iteration:\\n-> One pointer will points from the beginning of the array.\\n-> The other pointer points the end of the array.\\n-> I will calculate how much water can these two pointer values from the array holds and if this water is maximum than previous water, i will update the water.\\n-> For moving to the next iteration, I will only change any one of the pointers. From the two pointers, which ever one is holding the smaller value, i will update it to go to its next value. If both are equal, i will change any one of them. \\n-> Stop the loop only when any of the two pointers reach an end of array![image](https://assets.leetcode.com/users/images/0a212332-1f43-4742-bbee-e76a087e6370_1657023331.0694628.jpeg)\\n.\\n```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        water = 0\\n        def calcWater(i, j):\\n            nonlocal water\\n            water = max(water, min(height[i], height[j]) * abs(j - i))\\n            \\n        st = True\\n        i, j = 0, len(height)-1\\n        while(st):\\n            calcWater(i, j)\\n            if height[i] < height[j]:\\n                i = i + 1\\n            elif height[i] > height[j]:\\n                j = j - 1\\n            else:\\n                j = j - 1    \\n                \\n            if j == -1 or i == len(height):\\n                st = False\\n            \\n        return water\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n        water = 0\\n        def calcWater(i, j):\\n            nonlocal water\\n            water = max(water, min(height[i], height[j]) * abs(j - i))\\n            \\n        st = True\\n        i, j = 0, len(height)-1\\n        while(st):\\n            calcWater(i, j)\\n            if height[i] < height[j]:\\n                i = i + 1\\n            elif height[i] > height[j]:\\n                j = j - 1\\n            else:\\n                j = j - 1    \\n                \\n            if j == -1 or i == len(height):\\n                st = False\\n            \\n        return water\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565001,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567802,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1564741,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567057,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568582,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566352,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575067,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565277,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567702,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565586,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565001,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567802,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1564741,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567057,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568582,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566352,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575067,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565277,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567702,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565586,
                "content": [
                    {
                        "username": "halleknast",
                        "content": "The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\\n\\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\\n\\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\\n\\n\"[...]. All pairs of the <i>n</i> lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\""
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@Lumiann](/Lumiann) no, it\\'s better"
                    },
                    {
                        "username": "Lumiann",
                        "content": "Your formulation is far more worse."
                    },
                    {
                        "username": "navya2govil",
                        "content": "yeah the water formulation made me thin about how we can also consider diagonal distance between a very small line and a large line "
                    },
                    {
                        "username": "RhythmGarg",
                        "content": "[@boshnyak](/boshnyak) Was it the stack one? (Largest histogram or something)"
                    },
                    {
                        "username": "bsmonteiro99",
                        "content": "Thank you, I would never be able to understand the original text."
                    },
                    {
                        "username": "dealwith",
                        "content": "[@halleknast](/halleknast) you\\'re right here, thanks for the explanation"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "[@boshnyak](/boshnyak) you talking abouyt trapping rain water?? yeahh its pretty easy than this one\\n"
                    },
                    {
                        "username": "boshnyak",
                        "content": "The drawing is also very confusing. I just did a similar problem marked as hard with a much better drawing."
                    },
                    {
                        "username": "jadekler",
                        "content": "This question is exceptionally unclear. Anyone else having that trouble?"
                    },
                    {
                        "username": "mdizhaan21",
                        "content": "yes me.......proper explanation is not given and yes unclear question"
                    },
                    {
                        "username": "musoudeus",
                        "content": "the question truly confuse me,just take it as \"Plz help me finding the largest 2D area that two bars can make\""
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "[@esakkimuthu6842](/esakkimuthu6842) can anyone enlighten me how are you taking the input? \\n"
                    },
                    {
                        "username": "Denis411",
                        "content": "I just looked at tests to understand"
                    },
                    {
                        "username": "esakkimuthu6842",
                        "content": "[@Jean de Klerk](/jadekler)  me too have  same \\ntrouble"
                    },
                    {
                        "username": "IndigoBeast",
                        "content": "This is a formal proof of the O(n) algorithm mentioned in the tutorial.\\n\\nProblem Description:\\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn\\'t mean range [i, j - 1] can\\'t contain it, we just want to prove range [i + 1, j] will contain it).\\n\\nProof:\\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both. \\n\\nLet\\'s assume [i + 1, j] doesn\\'t contain the optimal range, but [i, j - 1] contains it. Then this means two things: \\n1. the optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it. \\n2. The optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]). \\n\\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\\n\\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i."
                    },
                    {
                        "username": "agnivS",
                        "content": "Why is this optimal algorithm not equivalent to the statement that if we have the full area from the leftmost column to the rightmost column, no better solution with larger area can exist with a smaller |i-j|?"
                    },
                    {
                        "username": "PyGeek03",
                        "content": "[@nathanwailes](/nathanwailes) Why would the distance not be constant? Do you mean it would increase?"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between the pillars are not constant?  It seems like your proof would still apply, right?"
                    },
                    {
                        "username": "shiva97",
                        "content": "The proof of why the solution works is important to understand. Following is its summary:\\n* Consider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\\n* Now suppose that `h(i)>h(j)` (we are not loosing generality by this assumption)\\n* We calculate the water capacity for the i, j. It will be `h(j)*(j-i)`.\\n* Now see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\\n\\t* capacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\\n\\t* First about the width. It is easy to see that for all other i\\'s (`i = 1, 2,... ,height.size()-2`) we will have a lesser width.\\n\\t* Second, the height will be the minimum of the column at i and at j, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\\n\\t* So both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where `i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1`\\n\\t* Which basically means that we can simply move j to j-1.\\n\\nThis is how I understood it and I hope this explanation makes it easy to understand."
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "\"Second, the height will be the minimum of the column at `i` and at `j`, i.e. `min(h(i),h(j))`. But this value will be always less than `h(j)`\" doesn\\'t make sense to me.  If the height is the minimum height between columns `i` and `j`, and `h(i) > h(j)`, the minimum is `h(j)`. So how will this value always be less than `h(j)`?"
                    },
                    {
                        "username": "gonzi",
                        "content": "[@user5075zH](/user5075zH) When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "odie5533",
                        "content": "[@bookworm5253](/bookworm5253) I was having trouble with h[i] == h[j] before reading your post. Thank you for the explanation!"
                    },
                    {
                        "username": "bookworm5253",
                        "content": "[@user5075zH](/user5075zH) \\nThis is how i understood it.\\nSuppose h[i] == h[j] for some range [i, j].\\n\\nNow, there can be following cases.\\n1. Max water is contained in [i, j].\\n2. Max water is contained in [i+1, j].\\n3. Max water is contained in [i, j-1].\\n\\nNow, we can show that if max water capacity lies in [i+1, j]; it will not contain [j-1,j].\\nSimilarly if it lies in [i, j-1]; it will not contain [i,i+1].\\nThis can be shown as follows.\\nIf it lies in [i+1, j] and also contains [j-1, j], this means that container lies in [k, j] for some i+1<=k<j.\\nmax_water = min(h[k], h[j])*(j-k)\\nNow, min(h[k], h[j]) can at most be h[j], if h[k]>h[j].\\nHence, we essentially have max_water(k,j) = h[j]*(j-k).\\nBut notice, our original range [i,j] had max_water(i,j) = h[j]*(j-i). //h[i] == h[j].\\n\\nNow, max_water(i,j) > max_water(k,j); since, i<k.\\nHence, max_water cannot contain [j-1,j], since h[j] will constrain the water that can be held.\\nSimilarly, we can show that max_water cannot lie in between, [i, i+1] because h[i] will constrain the amount of water that can be held.\\n\\nIn essence, the cases 2 & 3 can be reduced with the final cases being:\\n1.. Max water is contained in [i, j]. or\\n2. Max water is contained in [i+1, j-1].\\nWe\\'ve shown above that max_water range cannot contain the subranges [i, i+1] & [j-1,j].\\n\\nSo, it doesn\\'t matter which pointer we move in case of h[i] == h[j]. If the max_water is contained in [i+1, j-1], the other pointer will also get reduced further down.\\n\\nEg: {2, 3, 12, 12, 1, 2}.\\nHere i = 0, j = 5.\\nmax_water either lies between h[0,5] or h[1,4]. Notice, it does not lie between h[1, 4] or h[2,5].\\nNow, change any pointer i or j. For this explanation I\\'ll do i++.\\nWhat happens in the next iteration?\\nh[i] = 3, h[j] = 2; hence, j--; You can dry run through this example and look at the above proof to get a clearer picture of what\\'s happening."
                    },
                    {
                        "username": "user5075zH",
                        "content": "I like this a lot. Is there another reasoning to explain away the situation where h(i) == h(j) ? If we have that reasoning on why it doesn\\'t matter which pointer you move, I think that would give a more complete proof. Tbh, that is the harder part for me to understand. "
                    },
                    {
                        "username": "alec_cs",
                        "content": "Some of these proofs are not very clear. I want to expand on [Steven Pochmann\\'s](https://leetcode.com/problems/container-with-most-water/discuss/6100/Simple-and-clear-proofexplanation) idea and hopefully make it clearer.\\n\\n**Explanation**\\n* To start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still *brute forcing* the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\\n* At each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\\n\\t * Outcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\\n\\t * Outcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width *may or may not* be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\\n\\n**So why do we always move the pointer of the smallest pillar?**\\n\\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration."
                    },
                    {
                        "username": "fomachka93",
                        "content": "This explanation helped me solve the problem! Thank you so much! Really clicked for me after reading this."
                    },
                    {
                        "username": "213edu",
                        "content": "Thank you very much for lighting my lightbulb with such a great explanation!"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@nathanwailes](/nathanwailes) The solution mentioned above applies to the case where the distances between pillars are constant. This is because the two-pointer approach is designed to maximize the width (distance) first, and then aim to increase the height (pillar size). \\n\\nIf the distances between pillars are not constant, the solution would become more complex. A brute force approach would still check every possible pair of pillars, but the time complexity would be higher.\\n\\nAlternatively, you might also use a variant of the two-pointer approach, but you would need to adjust your strategy when deciding which pointer to move. Instead of just considering the heights of the pillars, you would also need to take into account the distances between them. \\n\\nFor example, moving the pointer at the shorter pillar might not always be the best choice if the distance to the next pillar is significantly larger. You might get a larger area by moving the pointer at the taller pillar if the distance to the next pillar is small. However, finding an optimal strategy for this variant of the problem could be quite challenging.\\n\\nIn general, problems involving non-uniform distances or weights often require more complex algorithms and may not have efficient solutions. They may involve techniques like dynamic programming, graph algorithms, or other more advanced methods."
                    },
                    {
                        "username": "alvordar",
                        "content": "Nice explanation!"
                    },
                    {
                        "username": "stridemann",
                        "content": "If you throw your post text to ChatGPT it gives you complete code that beat 80% :)\\n(me on C#)"
                    },
                    {
                        "username": "nathanwailes",
                        "content": "What if the distances between pillars are not constant?"
                    },
                    {
                        "username": "TheLoneArchitect",
                        "content": "Brilliant explanation !"
                    },
                    {
                        "username": "jiklein",
                        "content": "It seems like their tester never tests if the heights are equal.\\n\\nFor example if we have 10, 1, ..., 300, 10 it makes a huge difference whether you move the left or right pointer. In this case you need to compare the heights that are one closer to get the optimal solution. Very surprising that leet code never checks for this."
                    },
                    {
                        "username": "user9100sQ",
                        "content": "Hi. incase of Equal heights it makes for even more efficient solution if we simply move both pointers at once (increment Left and decrement Right).\n\nIn case: 10, 1, ..., 300, 10\n1. If we only move Left to 1: we can see that the width is decreased by 1 however the height will also get to min of 1. This is a worse solution than that of prev 10-10.\n\n2. If we only move Right to 300: width is also decreased by one. And since the min is set by Left (10), the 300 will be of no significance as only 10 height of it will be used. This sol will be same as previous 10x10 but with a decreased width.\n\nWith both these cases the resulting is worse than the previous solution so we can just move both pointers.  \n\n3. If we move both: 1,...,300 is a new domain worth exploring for a better solution.\n\n"
                    },
                    {
                        "username": "Flashcode",
                        "content": "It doesn\\'t affect the answer after thinking this out.\\n Consider h1,h2,.....,h3,h4 where h1==h4. From those candidates, the maximum contained water is only possible in [h1,h4]. \\n[h1,h3] or [h2,h4] will contain less water than [h1,h4]. \\nYou can advance the right or left pointer, but the next cases are [h2,h3] and it\\'s subranges and you will reach those if you advance first either of the pointers\\n"
                    },
                    {
                        "username": "Fanoflix",
                        "content": "As far as I tested and tried it out. It wouldn\\'t make a difference. Can you provide a test case where it provided the wrong max area to you?"
                    },
                    {
                        "username": "bvelarde",
                        "content": "Isn\\'t it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?"
                    },
                    {
                        "username": "alexposl89",
                        "content": "It\\'s 8x5 -> 5 is a distance between 8 and 8\\n7x7 is greater than 8x5"
                    },
                    {
                        "username": "hoangneeee",
                        "content": "[@prakhar0101](/prakhar0101) Thank you for clearing my mind"
                    },
                    {
                        "username": "Lumiann",
                        "content": "[@G-and-or-S](/G-and-or-S) Lowest height? Lmao what"
                    },
                    {
                        "username": "prakhar0101",
                        "content": "if you see the x- axis then it doesn\\'t become 8 X 8 , it will become 8 X 6 = 48 which is less than 7 x 7"
                    },
                    {
                        "username": "bayberryy",
                        "content": "[@G-and-or-S](/G-and-or-S) Thank you! This cleared my doubt:)"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "[@G-and-or-S](/G-and-or-S) I made that mistake at first too, the explanation isnt very clear"
                    },
                    {
                        "username": "brightroy",
                        "content": "[@G-and-or-S](/G-and-or-S) Agree,. Area = Length * Breadth. So If we can chose 8 then the next 8 is at a distance of 5 which makes the area 8*5 = 40 which is less than 7 * 7 = 49"
                    },
                    {
                        "username": "G-and-or-S",
                        "content": "length x lowest height, not lowest height x lowest height\n\nit would be 8x5 vs 7x7"
                    },
                    {
                        "username": "gilbertliu42",
                        "content": " WA\\nInput:\\t[1,2,1]\\nOutput:\\t1\\nExpected:\\t2\\n Does this mean to find the total \"area\"? NO\\n\\n WA\\nInput:\\t[1,2,4,3]\\nOutput:\\t6\\nExpected:\\t4\\n This is to find the max area between any of two lines.\\n\\n# You really should refine it a little bit. #"
                    },
                    {
                        "username": "Mohitzen",
                        "content": "[@ChiruKola](/ChiruKola) i guess that is correct and you gotta recheck ur understanding. it\\'s asking the maximum area. So, 7*7 where one of them comes from x-axis distance between indices of the two vertical poles (j-i) where i=1 and j=8 and other \\'7\\' is the pole height common to both of the poles to form a rectangle."
                    },
                    {
                        "username": "ChiruKola",
                        "content": "then in the first test case we have 8 and 8 then we get 64 but the ans is 49,why?"
                    },
                    {
                        "username": "gajanand_010",
                        "content": "1 2 1 so 1st and 3rd position area is 2 and height 1 but diffrence is 2 so area is 2"
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Detailed step by step explanation with code for both brute force and optimized solution:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer :)"
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Thank you "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/container-with-most-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1571033,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1570872,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1566734,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1567582,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1567487,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1568247,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1835772,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1575622,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1567430,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1877488,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "Whoever designed this problem has no ability whatsoever to speak in plain English."
                    },
                    {
                        "username": "Chris1337",
                        "content": "I was furious reading this problem. It took me a solid 12 minutes to decipher what the first two sentences meant. Not the first time a problem was so unclear, I have even made posts on leetcode\\'s github suggesting clearer problem descriptions but to no avail."
                    },
                    {
                        "username": "labrador_peninsula",
                        "content": "**Algorithm:**\\n* Designate two pointers `ptr_lo = 0` and `ptr_hi = length(height) - 1` i.e. set the two pointers at the two ends.\\n* If `height[ptr_lo] <= height[ptr_hi]` then increment `ptr_lo`.\\n* If `height[ptr_lo] > height[ptr_hi]` then decrement `ptr_hi` (i.e. iteratively move the smaller of the two edges closer to the other).\\n* Calculate the area after each change and keep track of the maximum area.\\n* End when the two pointers are equal to each other.\\n\\n**Why the algorithm works**\\nLet `i, j` be the left and right edges of the container with most water (`0 <= i < j < length(height)`). If there are multiple such containers, then `i, j` can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when `ptr_lo == i` and `ptr_hi == j` i.e. the maximum area is always considered.\\n\\n![image](https://assets.leetcode.com/users/images/511aae4e-7436-4cee-87f4-b6592219c54a_1652078458.8835633.png)\\n![image](https://assets.leetcode.com/users/images/817b6573-f2a3-4969-b78c-b94eac189e36_1652078458.9361658.png)\\n\\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\\n\\n**Scenario 1:** `ptr_lo == i` and `ptr_hi == j` at the same time\\nThis means we proved our hypothesis.\\n\\n**Scenario 2:** `ptr_lo` reaches the left edge first\\nHere, we have `ptr_lo == i` and `j < ptr_hi < length(height)`. We can now have two sub-scenarios:\\n\\n***Sub-scenario 1*** If `height[ptr_hi] >= height[ptr_lo]` i.e. the right edge `>=` left edge\\n ![image](https://assets.leetcode.com/users/images/c3af9451-9074-42a0-8f7e-f0b60e80b030_1652078857.1577551.png)\\n\\nIn this situation, we see that by letting  `height[ptr_hi] >= height[ptr_lo]`, we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\\n\\n***Sub-scenario 2*** If `height[ptr_lo] > height[ptr_hi]` i.e. the left edge `>` right edge\\n![image](https://assets.leetcode.com/users/images/76fb8c39-b700-481d-9d76-22a293741810_1652078995.2830222.png)\\n\\nUsing the algorithm, we will just keep decrementing `ptr_hi`. In fact, because sub-scenario 1 is impossible, once `ptr_lo == i`, then for all `j < ptr_hi < length(height)` we have `height[ptr_lo] > height[ptr_hi]`.\\n\\nTherefore, once `ptr_lo` reaches `i`, it will stays there until `ptr_hi` reaches `j`. We proved our hypothesis\\n\\n**Scenario 3:** `ptr_hi` reaches the right edge first\\nThis is the same as scenario 2, only reversed.\\n\\nHope this helps."
                    },
                    {
                        "username": "mew-the-cat",
                        "content": "Thank you! It\\'s the best explanation out there"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "thank u so much"
                    },
                    {
                        "username": "najwer23",
                        "content": "thanks! it was helpful"
                    },
                    {
                        "username": "nomad",
                        "content": "Hi,\\n\\nI am not able to understand the non-trivial nature of the question. \\nCan we not not always obtain largest area by choosing the first and the last as the two lines? I am sure this might not be the case as it would be too trivial. Help me with some counter argument.\\n\\nThanks in advance\\nNomad_Coder"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@santanusen](/santanusen) 10*1 == 10, not 100...\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Take the following array as example [1, 10, 10, 1].\\nThe area you get by taking the first and the last as the two lines is h x d = min(1, 1) * (3 - 0) = 3.\\nBut, if you choose the two lines in the middle, the area is min(10, 10) * (2 - 1) = 100."
                    },
                    {
                        "username": "thesilentpsycho",
                        "content": "inf , inf -> inf\\ninf , x -> x\\nx, x -> x\\nx, 0 -> 0\\n\\nIf we move from the smaller side, there is a chance that we might increase the area.\\nIf we move from the bigger side, there is no chance in all possible cases:\\n1. we find smaller wall next\\n2. we find bigger wall next (still height will remain the smaller of left and right, breadth will decrease by 1)\\n3. we find equal wall next"
                    },
                    {
                        "username": "cryptsign",
                        "content": "If you had solved \"Area under histogram\" before, you have to read the problem carefully. In \"Area under Histogram\", the horizontal line cut across multiple vertical lines (histograms). Here the horizontal line can only connect two vertical lines. At least that affected my solution to this problem."
                    },
                    {
                        "username": "cq_vincent",
                        "content": "One subtlety about the greedy approach is how to make sure it doesn\\'t miss out the global optimal value. For example, if we finally arrive at `left=20, right=21` but the actual optimal pair is `left=5, right=10` , it would mean our answer is strictly sub-optimal. From a mathematical point of view, it isn\\'t totally clear how the two-pointer increment-decrement approach can actually avoid the possibility of strict sub-optimality.\\n\\nTherefore I sketched a mathematical proof that rigorously rules out strict sub-optimality. However, the proof contains rendered TeX contents from another website so I cannot do a stratight copy and paste to LeetCode. So I\\'ll paste the link here: https://zhuanlan.zhihu.com/p/93461322."
                    },
                    {
                        "username": "Zauhd",
                        "content": "Can these problems have better example cases instead of just the base case plus one? It just seems lazy"
                    },
                    {
                        "username": "bparanj",
                        "content": "It\\'s your job to create the test cases during the interview and also during practice."
                    },
                    {
                        "username": "yogeshnikam671",
                        "content": "How is the answer of \\nheight = [1,2,1] is 2 ??? \\nAm I missing something in the question ?\\n"
                    },
                    {
                        "username": "Anandyadav45",
                        "content": "length between height[0]  and height[2] is 2 unit so that volume=length*height means 1multiply by 2=2  that it"
                    },
                    {
                        "username": "aqin",
                        "content": "the O(n) algorithm is to use two pointers to point the start and end position respectively and only move the pointer which points a shorter line inwards one step and update the answer after each movement.\\nWhy does this algorithm works? We change a way to think about it. If the optimal solution choose the index i and j as the left and right side, will we miss the case by using the algorithm above? The answer is no. I will prove it.\\nSince  i and j are the optimal pointer.So lines on the left of i and lines  on the right of j must be shorter than i and j. Or we can get a large area by using that line with i or j.(if we have k < i and len(k) > len(i) or len(j), the area between k and j is larger than i and j, it gets a contradiction).So when we run our algorithm, if left pointer arrives at i firstly, then we will always move right pointer until it reach j, since lines on the right of j is all shorter than i.Or if right pointer arrive at j firstly, then we will always move the left pointer until it reach i. So we won\\'t miss the combination of i and j, then we won\\'t miss  the optimal answer"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two-pointer approach with an intuitive proof:\n\nhttps://youtube.com/watch?v=Kb20p6zy_14"
                    }
                ]
            },
            {
                "id": 1567164,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1568677,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1568607,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1575425,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1570360,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1570182,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1570115,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1568830,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1565935,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1997016,
                "content": [
                    {
                        "username": "lijiyao111",
                        "content": "For case of [1,2,1], the solution is 2. It means the container is bounded by location 0 and 2. This means the middle highest block is leaking water.\\n\\nI think for this case the largest container can only contain 1 amount of water, and the container could be either [1,2] or [2,1], assuming no leaking."
                    },
                    {
                        "username": "kim-tom",
                        "content": "I posted a mathematical proof [here](https://www.mathwills.com/posts/245)."
                    },
                    {
                        "username": "kuldeepsan09",
                        "content": "Basically:\\nThe one with smaller height(hi) in two pointer case will always contain min(hi,hj)*(|j-i|) where j is from 1 to n. So min(hi,hj)<=hi. For the two pointer method the other pointer will have height>hi so min(hi,height of other pointer) = hi which is the maximum possible of min(hi,hj). Also since the two pointers are the farthest |j-i| is also maximum. So it remains the optimal way."
                    },
                    {
                        "username": "chombik",
                        "content": "Input: [2,3,4,5,18,17,6]\\nOutput: 16\\nExpected: 17\\n\\nHow can be 17???"
                    },
                    {
                        "username": "OliKaushal",
                        "content": "Between 18 and 17 a container will be formed which stores 17 units water. "
                    },
                    {
                        "username": "wubo1994",
                        "content": "Assume initially the two pointers are at 0 and len(height) - 1:\\n\\nleft, right = 0, len(height) - 1\\n\\nWe move the pointers based on this rule: if we height[left] <= height[right], then we move the left pointer, otherwise we move the right pointer.\\n\\nThe reason we are moving in this way is because, assume if you move the higher bar (the pointer which points to the higher height of the two), then you will end up having two situation: 1. the next bar is still higher than or equal to the shorter bar of the two, in that case the area you get will be less because the area is dictated by the shorter of the two bars, and in this case width is getting smaller, and the shorter bar of the two remains the same; 2. the next bar is shorter than the original shorter bar of the two, in this case since the width is getting smaller, plus the shorter bar of the two also getting smaller, so the area obviously also decreasing.\\n\\nBut until here one problem arises: how do I know this two pointer approach won\\'t miss the most optimal solution? Since two pointer does not iterate through all the possible combinations of picking 2 out of N, we need to prove that our approach is garenteed to give us the largest area:\\n\\nProof:\\n\\n1. The two pointers, together, will garentee to iterate through all the bars in the input once; \\n2. Let\\'s assume the optimal solution with largest area is at index L and index R;\\n3. Using proof by contradiction, assume our two pointer solution can give us the NON-OPTIMAL solution, and according to hypothesis 1, we know at least one of the two pointers will go through L or R, so let\\'s assume left pointer came to index L, then since we assumed that our approach does not give the best solution, that means the left pointer will move to the next index before right pointer ever reaches to R, in our algorithm this can only happen when right pointer encounters a bar that is higher than height[L], let use Ra to denote it, but if this happens, then the area formed between L and Ra: (height[L] * (Ra - L)) would actually be the better solution than between L and R because the height of area between L and Ra is height[L], while the height of area between L and R is min(height[L],height[R]), and the width between L and R is surely smaller than between L and Ra, so until here, we have a contradiction with our initial assumption of that L and R form the best solution, in other words, right pointer will always come to R.\\n\\nProof done."
                    },
                    {
                        "username": "cmy690731",
                        "content": "Here is a proof of correctness of the two pointer approach.\\n\\nSuppose the maximum area is formed by lines `i*` and `j*` with `0 < i* < j* < n`, where `n` is the total number of lines. I.e. the maximum area `A* = (j* - i* + 1) * min(nums[i*], nums[j*])`. \\n\\nWe start with ` i = 0` and `j = n-1`. By incrementing `i` and decrementing `j`, either `i` reaches `i*` first or `j` reaches `j*` first. Without loss of generality assume `i` reaches `i*` first, and `i = i*` and `j* < j` at this moment. Now if we can show `nums[j\\'] < min(nums[i], nums[j*])` for all `j* < j\\' <= j`, then the algorithm would guarantee `j` reaches `j*` before `i` increments and therefore `A*` will be recorded. And to show above, suppose there is `j* < j\\' <= j` such `nums[j\\'] > nums[i]` or `nums[j\\'] > nums[j*]`, in both cases the area formed by lines `i` and `j\\'` will be greater than `A*`. \\n\\n\\n\\n"
                    },
                    {
                        "username": "joyreturn0",
                        "content": "I think many friends have been already familiar with this solution, but some may be wondering why it doesn\\u2019t miss the best case. Since it eliminates many pairs(i, j). Let me try to explain it in a simple way. it might seem long, but it\\'s very easy to follow.\\n\\n![image](https://assets.leetcode.com/users/images/c99703c1-cc7a-4b77-bf0f-e1a1d6090a3f_1597343413.3305771.png)\\n\\n1. This graph pictures the initialization stage: i < j. From the perspective of i=1, its best choice is j=n among all integers from j=2 to j=n. Why? Because the height of the container that i make up is at most i\\'s length: if i=1 meets a longer one, the height will still be limited by i\\u2019s length; if i meets a shorter one, the height will be even worse. So, among all integers, i\\u2019s best strategy is to find the furthest integer, which is n.\\n\\n2. If you understand the above, you understand 3 general properties for any pair(i, j), :\\n\\t* The shorter one doesn\\u2019t have to form containers with any other integers between i and j, since j beats all of them. \\n\\t* The shorter one may not be the longer one\\u2019s best choice.\\n\\t* The longer one still have the chance to form larger container with lines in between i and j. So the longer one still need to search.\\n\\n3. If you understand the above, you are 90% to understand the solution.\\n\\t* In the solution, the pair(i, j) starts from (1, n). Let\\u2019s assume line i=1 is shorter. Then, we abandon i=1 and move the pointer i to the next integer in between i and j, which is i=2, since i=1 has already found its best choice but j=n hasn\\u2019t.\\n\\t* In the next pair (2, n), assume line j=n is shorter, we abandon j=n and move the pointer j to the next integer in between i and j, which is j=n-1, since j=n has found its best choice but i=2 hasn\\u2019t.\\n\\t* We repeat above steps until two pointers meet. In this way, every integer has found its best choice.\\n\\n4. Why T(n)=O(n)?\\n\\t* It\\'s because in pair (1, n), we eliminate n-2 unnecessary comparisons for the shorter one.\\n\\t* In the second iteration (2, n) or (1, n-1), we eliminate n-3 unnecessary comparisons for the shorter one.\\n\\t* ......\\n\\t* In the second last iteration, we elimiate 1 unnecessary comparisions for the shorter one.\\n\\t* In the last iteration, we elimiate 0 unnecessary comparisions for the shorter one.\\n\\t* In sum, we eliminate m=(n-2)+(n-3)+...+2+1 unnecessary comparisons from C(n, 2)=n*(n-1)/2. The actual comparisons that we implemented are C(n, 2)-m which is n-1.\\n\\n5. Another way to interpret this T(n)=n-1 is that, we have implemented n-1 iterations. That means, we have calculated the area of n-1 containers. Why? Think about an easy scenario when n is the longest line among all. Then the iterations goes from (1, n) to (n-1, n) because j=n never change it\\'s place. In this scenario, we move i from 1 to n-1 so there are n-1 iterations in total.\\n\\nHope this explanation helps!\\n\\nReference: [Lei Mao\\'s Log Book \\u2013 Simple Proof to the Container With Most Water Problem](http://)\\n\\n"
                    },
                    {
                        "username": "fasthall",
                        "content": "I know this problem can be easily solved with two pointers with better performance.\\nBut I guess it can be solved with DP too. However, I can't formulate the general equation of DP.\\nCan anyone give me a hint here?"
                    },
                    {
                        "username": "lichenran",
                        "content": "The other answers with explanations all prove that, starting from the edge, with the moving strategy ( i.e. move the pointer of the smaller value to the inner side ), the amount of water will increase sometime in the future.\\n\\nHowever, can the maximum value be reached? That's the key problem.\\n\\nHere is my proof of why the maximum value can be reached definitely.\\n\\nGiven ***a1, a2, ..., an.***\\n\\nFirst of all, let's assume that the optimal choice of the container with the most water is ***( ai, aj ) ( i < j )***. Then I just need to prove that there will definitely exist one situation where the left pointer is at ***ai*** while the right pointer is at ***aj***.\\n\\nThen I will prove that ***a1, a2, ...and ai-1*** are all smaller than ***aj***. This proof is simple, because if ***ak*** >= ***aj*** and ***1 <= k <= i-1***, then the optimal choice would be ***( ak, aj )***, not ***( ai, aj )***.\\n\\nSymmetrically, ***aj+1, aj+2, ...and an*** are all smaller than ***ai***.\\n\\nFinally, during the movement of the pointers, either ***ai*** or ***aj*** will be reached at first, so let's assume ***ai*** is reached before ***aj***. Then because ***aj+1, aj+2, ...and an*** are all smaller than ***ai***, so the right pointer will continue moving ( because the value it points to is smaller ) until it reaches ***aj***. Now the left pointer is at ***ai*** and the right pointer is at ***aj***.\\n\\nAnd if ***aj*** is reached before ***ai***, the proof is also obvious."
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "In case if you are wondering why 8 * 8  = 64 , is not the answer for the first case.\\n\\nWe have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    }
                ]
            },
            {
                "id": 1568828,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1568829,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1568827,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1980111,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1936689,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1734477,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1624060,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1576783,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1576061,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1575972,
                "content": [
                    {
                        "username": "labs",
                        "content": "I imagined this to output 2 for [2,1,2] but it returns 4. So it means that it is not like https://github.com/adnanaziz/epicode/blob/master/java/src/main/java/com/epi/TrappingRainWater.java. Could someone please explain why it won't be 2? I could imagine 1*1 + 1*1 = 2."
                    },
                    {
                        "username": "niconico",
                        "content": "Let C(1, n) denote the problem of finding the largest container given a1, a2, ..., an. Without loss of generality, let's assume a1 < an. Then there are only two possibilities: The largest container has (1, a1) as the left side, or it does not. For the first possibility, the right side of the largest container must be (n, an), which has been explained. For the second possibility, it is the problem C(2, n). To solve C(2, n), we increment the left pointer by 1.Then, to solve C(1, n), we only need to compare the results of both possibilities. In the case that a1 >= an, the argument remains similar. This is exactly what the solution does.\\n\\nWe are still using recursion in this problem, but the nuance is that we cannot break the problem into a subproblem in a particular direction as in most cases, say, breaking C(1, n) into C(1, n-1). We have to make a decision to break C(1, n) into C(1, n-1) or C(2, n), depending on the input."
                    },
                    {
                        "username": "srikar349",
                        "content": "Can anyone explain me what happens when height[left] == height[right]"
                    },
                    {
                        "username": "brunofurtado",
                        "content": "Really badly formulated problem, the bars in between don\\'t interfer with how much water it can hold, it just wants you to return the area"
                    },
                    {
                        "username": "jt88",
                        "content": "my program passes all test cases, but when i hit submit i get \"time limit exceeded\" on one the test cases it already passed..."
                    },
                    {
                        "username": "joshkim81",
                        "content": "> There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\n\\nI can\\'t believe how far they went out of their way to write like this."
                    },
                    {
                        "username": "pbanavara",
                        "content": "I have revisited this problem thrice or perhaps more. Every other time, I was stuck with a solution that didn\\'t really sit in my head. So now it has. What changed. The basic inution.\\n\\nLet\\'s look at this from a geometry perspective. A container can either be a rectangle or a square,  and in either of them you need the length to be maximum for the area to be maximum. With the same length you will perhaps get more area in a rectangle provided height > length that\\'s about it.\\n\\nOnce this intuition sets in, rest is easy. \\n\\nSince I need the maximum area, my best starting point is the max length  so ` lp = 0, rp = len(array) - 1`\\nHeight I don\\'t have much control I have to take the min of arr[lp], arr[rp] since the water has to hold.  So `height = min(array[lp], arra[rp])`\\narea = length * height but since you need max area ` area = max(area, length * height ) `\\n\\nNow all you need is to figure out which pointer to move, left or right that\\'s again fairly simple\\n`if lp < rp : lp += 1\\nelse rp -= 1 `\\n\\nThat\\'s it\\n\\nPython code:\\n\\n```python\\ndef maxArea(self, height: List[int]) -> int:\\n        lp, rp = 0, len(height) - 1\\n        area = 0\\n        while lp <= rp:\\n            length = abs(rp - lp)\\n            width = min(height[lp], height[rp])\\n            area = max(area, length * width)\\n            if height[lp] < height[rp]:\\n                lp += 1\\n            else:\\n                rp -= 1\\n        return area\\n```"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript, Java, Python, and C++.\\nIf you have any doubts, let me know in the comments section\\nhttps://coderfact.com/data-structures/container-with-most-water-leetcode-11-fastest-solution/\\nIf it helps you please upvote."
                    },
                    {
                        "username": "kinianlo",
                        "content": "Consider a list of heights {a_1, ..., a_n}. Denote the area formed by the i-th stick and the j-th stick by A(i, j). \\nWithout loss of generality, assume a_1 <= a_n. \\n\\nOne thing to note is:\\nIf we restrict ourself to use a_1 as the left stick, then the maximum area possible is A(1, n).\\nProof.\\nconsider 2 =< p <= n-1, either a_p <= a_1 or a_p > a_1.\\nCase 1 (a_p <= a_1), A(1, p) = a_p * (p-1) <= a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nCase 2 (a_p > a_1), A(1, p) = a_1 * (p-1) < a_1 * (n-1) = A(1, n)\\nThus A(1, p) < A(1, n) \\nSo in anycase, A(1, p) < A(1, n)\\n\\nIn other words, for a_1, we just need to consider A(1, n). After we have consider A(1, n). We can forget about a_1, as if it does not exist. So we remove that a_1 from the list of heights. Now we have reduced the length of the list of heights by 1. Repeat until there is only one stick left."
                    },
                    {
                        "username": "harish1234567",
                        "content": "#Intilasize i and j as low and high of indexes of height, to make most water heights is important\\nas well as gap between indexs( I.e X coordinates) . increment i when height[i ] is less than height[j] vice versa\\n\\n\\n![image](https://assets.leetcode.com/users/images/cd303ecf-a41b-4fe6-b038-97a9443f0099_1637037812.7804585.png)\\n"
                    }
                ]
            },
            {
                "id": 1575128,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1574424,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1572998,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1572751,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1572436,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1572233,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1571034,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1566812,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1567295,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1570701,
                "content": [
                    {
                        "username": "showera",
                        "content": "The main idea of this approach is that we take the container with the most left and the most right bar as the start point, and keep on moving the shorter one a step forward towards the other one.\\n\\nThe proof has three parts:\\n1. We may encounter a larger container if moving the shorter one.\\n2. We will not get a larger container if moving the longer one.\\n3. If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.\\nCombining the three parts, we can conclude that we will not miss the largest container if we only move the shorter one.\\n\\ns = length of short end\\nl = length of long end\\nd = distance between two ends\\narea_0 = d * s\\n\\nsn = length of the bar next to the short end\\nln = length of the bar next to the long end\\n\\n\\n**- Part 1: We may encounter a larger container if moving the short one.**\\nIf sn and l are large enough, we could have a bigger container. \\nFor instance, if \\nsn = (s * d) / (d - 1) +1 ,  l = 3s,\\nthen \\n\\tarea_after = sn * (d - 1) = area_0 + 1 > area_0\\nSo we find a larger container.\\n\\n**- Part 2: We will never get a larger container if moving the long one.**\\nif ln <= s, then\\n\\tarea_after = ln * (d -1) < s * d = area_0\\nif ln > s, then\\n\\tarea_after = s * (d -1) < s * d = area_0\\nSo no matter how much steps we moved, we could not have a container larger that area_0.\\n\\n**- Part 3: If the two bars are of the same length, keep moving any one until we reach situation 1 and 2.**\\n"
                    },
                    {
                        "username": "GopalSir",
                        "content": "First we set out two pointer on the two extremes of height array and calculate the area contained in this box . Which will be given by  **min(height[start],height[end])*(end-start)**\\n\\nNow , this area can already be maxxx area , but we need to check other possibilites ( in optimal way ) , where each step is guaranteed to take us near required solution quickly . \\n\\nlet the current minimum height among two extreme pointers be \"h\"\\n\\nAt a certain position of \"start\" and \"end\" pointer , we have only three possibilites to check new area \\n1. Close in \"start\"  , start++\\n2. Close in \"end\"  , end --\\n3. Close in \"both of them\" start++, end--\\n\\nNow , the only way closing in will gurantee greater area ( remember , our width is decreasing ) is when both extreme pointers have a height greater than \"h\" , calculated earlier  . So , keep closing in both pointers till height of both of them becomes greater than \"h\". Calculate new area and repeat closing in again ."
                    },
                    {
                        "username": "peterhieuvu",
                        "content": "We will do a proof by contradiction.\\n\\nConsider, for contradiction, that there is a set of inputs `s` with an optimal solution that is skipped over by the algorithm. The way that the algorithm works, we know that every height will be reached by one of the two pointers at least once. As a result, there is a height in the optimal pair in `s` that is reached first. Let\\'s call this height `h_1` and the other height `h_2`. Since the optimal solution is skipped over in `s`, that must mean that the pointer, `p_1`, on `h_1` moves off of `h_1` before the other pointer, `p_2`, can get to `h_2`. That means that `p_2` must have landed on a height `h_c > h_1` before reaching `h_2`. \\n\\nBut, since the algorithm moves inwards from the outer two edges, that means that the area between `h_1` and `h_c` is greater than the area between `h_1` and `h_2`. Therefore, `h_1` and `h_2` are not the optimal pair and we have a contradiction. Since our only assumption was that the optimal pair was skipped by the algorithm, we have proved that the algorithm will not skip over the optimal pair.\\n\\nQ.E.D."
                    },
                    {
                        "username": "user8037",
                        "content": "Starting from (a0, aN), we assume a0 < aN, then the largest area that contains a0 is exactly a0 * N, because for any K where 0 < K < N, the best possible case is aK >= a0 and the area is then a0 * K, which is less than a0 * N. So by remembering a0 * N as the current max, we have covered all possible cases containing a0. Based on this, the search space halves into (a1 .. aN). Hence the movement of point of the smaller element."
                    },
                    {
                        "username": "fmurphy1",
                        "content": "I am assuming we ignore the lines in between.  In the example illustration, the area that holds water is 49 because min(8,7) is 7 and the distance between the 8-height line and the 7-height line is 7, hence 7 x 7 = 49.   At first glance it appears that the 8-height line two lines left of the right edge would act as a dam and prevent the area between the 8 and 7 lines from filling up completely."
                    },
                    {
                        "username": "bananapancake",
                        "content": "Since the algorithm does not visit every possible interval, some might have doubts if this algorithm really finds the biggest area even though it doesn't visit every interval. Here's a proof that the solution it produces is truly maximum.\nPick an arbitrary interval [i, j] where i < j. Suppose area(i, j) < max area, and during the two-pointer sweep, [i, j] is not visited. But we know i and j must have been visited once separately. So there must be an interval [k, j], where k < i, that is visited.\nIf height[k] >= height[i], then area(k, j) > area(i, j), since j - k > j - i. Since we know area(k, j) <= max area per the algorithm. area(i, j) < max area.\nElse, height[k] < height[i]. Here's an observation: since [i, j] was not visited during the algorithm, but[k, j] is, this means after visiting[k, j], the pointer at j moved left first. So height[k] >= height[j]. Since height[k] < height[i], height[j] < height[i] too. So j is the bottleneck for both [i, j] and [k, j]. So area(i, j) < area(k, j) <= max area.\n\nDrawing a picture of k, i, j would make this proof clear."
                    },
                    {
                        "username": "guolei329",
                        "content": "I think it is intuition that we should compute the volume rather than area. But why do you all compute the area, and you never asked this weird issue?"
                    },
                    {
                        "username": "ravi007",
                        "content": "Atleast give some testcases, so that problem can be understood easily. :("
                    },
                    {
                        "username": "abbasim1",
                        "content": "This problem can be seen as a 2d linear programming problem.\\n\\nA simple example of a 2d linear programming would be to maximize (or minimize for that matter) the following function z = 2x - 5y over the following constraints:\\nx>=0, y>=0, 2x+10y<=10, 7x-5y<=14, -x+3y<=15.\\n\\nThe constraints form a convex hull, on tip of which the optimum soltution is searched.\\n\\nThe following picture belongs to some another problem, the red quadrilateral is the \"hull\" and the four points are the candidates to be the optimum point. (src: http://www.ifp.illinois.edu/~angelia/ge330fall09_lp_model3.pdf )\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/abbasim1/image_1521848593.png)\\n\\n\\nSo looking at the picture above, what you can do is start from point B, by having the maximum y and minimum x, and you go to the other end (point D) where x is at the maximum and y is at the minimum.\\n\\n\\nNow, the solution provided is exactly the same. You have two variables: height and width, and the target function is the area of the container. You start from maximum width and shall make sure you won\\'t reduce width without increasing the height. Of course you can start the other way, start the \"two pointers\" from the two highest bars, and move the bucket limits outwards, At each step move the limit bar from which the next highest bar is reachable. So, let\\'s say bars are numbered in terms of their height in the following order: 2--1--3. After calculating the area formed by bar #1 (the highest) and #2 (the second highest), you must move bar #1 because #3 (the third highest) is reachable by #1. Of course this method has a drawback. The bars need to be sorted. But, if you do it the other way around as in the solution, you don\\'t have to sort anything; x values are already sorted.\\n\\nTherefore, the solution makes sense and it is intutive because it mapps to 2d linear/integer programming problem."
                    },
                    {
                        "username": "ashwinshirva",
                        "content": "Fast and simple solution with step by step explanation:\\n\\nhttps://www.code-recipe.com/post/container-with-most-water"
                    }
                ]
            },
            {
                "id": 1568023,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 1568831,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 1575960,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 2073872,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 2060570,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 2060416,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 2046657,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 2046195,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 2041633,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 2038141,
                "content": [
                    {
                        "username": "maomao9003",
                        "content": "\\nAssume that the max area consists with line-1 and line-2, their height is h<sub>1</sub> and h<sub>2</sub>, their x-coordinate is x<sub>1</sub> and x<sub>2</sub>. ( x<sub>1</sub> < x<sub>2</sub>)\\n\\nLet  x<sub>i</sub> <  x<sub>1</sub> and  x<sub>j</sub> >  x<sub>2</sub>, we can know h<sub>i</sub>,h<sub>j</sub> < min(h<sub>1</sub>, h<sub>2</sub>). If not, there will be a  area bigger than the area consists with line-1 and line-2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/maomao9003/image_1526888670.png)\\n\\nThe \\u201CTwo Pointer Approach\\u201D use two pointer(p<sub>i</sub> and  p<sub>j</sub>, p<sub>i</sub> pointing head, p<sub>j</sub> pointing end). Each time, move the pointer pointing to the shorter line towards the other end by one step.\\nWhen moving, there must be a time, p<sub>i</sub> pointing x<sub>1</sub> and p<sub>j</sub> pointing x<sub>2</sub>. Proof:\\n>>> If  p<sub>i</sub> first points to x<sub>1</sub>, p<sub>j</sub> shall be keep moving to x<sub>2</sub>, because all lines on line-2 right shorter than line-2.\\n>>> Similarly if  p<sub>j</sub> first points to x<sub>2</sub>, p<sub>i</sub> shall be keep moving to x<sub>1</sub>."
                    },
                    {
                        "username": "yg2",
                        "content": "Another proof: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\nIf Am<An,F(m,n)=(n-m)*Min(Am,An), then F(m,i) <= F(m,n) for all m<=i<=n. Done\\n\\nOr algebracally F(m,i) = (i-m)*Min(Am,Ai) <= (i-m)*Am <= (n-m)*Am = F(m,n)\\n\\nSo all the skipped pairs are covered.\\n\\n\\n\\n\\nAaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "2699amruthap",
                        "content": "Hey guys,\\nI hope you all are happy and safe !\\n\\nCan someone please tell me the difference between this question and largest rectangle. \\n\\nhttps://leetcode.com/problems/container-with-most-water\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nboth looks pretty similar to me..\\n\\nThank you :)"
                    },
                    {
                        "username": "Arrghtv",
                        "content": "I actually hate this problem"
                    },
                    {
                        "username": "sourav_maz",
                        "content": "Can this be solved using stacks?"
                    },
                    {
                        "username": "Aakash_86553",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int left = 0;\\n        int right = height.size() - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = min(height[left], height[right]) * (right - left);\\n            maxArea = max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n};"
                    },
                    {
                        "username": "Sachi-nandan",
                        "content": "just disgusting test cases"
                    },
                    {
                        "username": "gauthamarunachalam1998",
                        "content": "I think the problem needs to be reworded. The question does not clearly state that we should create a container by using just he min height of the lines"
                    },
                    {
                        "username": "sapercq",
                        "content": "Task itself is very easy,but time complex must be o(n).That the hard part."
                    },
                    {
                        "username": "dhyeys08",
                        "content": "Algorithm: \\n1) Take an array list.\\n2) Compare all the numbers in a list itself for the two greatest number.\\n3) Once we found both the numbers, we will do the square of the 2nd greatest number.\\n4) Print the square. Maximum that much water they can store in the container."
                    }
                ]
            },
            {
                "id": 2037993,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2036256,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2035756,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2032975,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2025262,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2021638,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2016393,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2014890,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2013501,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2009490,
                "content": [
                    {
                        "username": "be4ko",
                        "content": "Can someone Explain this problem a bit more ,, I have no Idea What should I return or calculate ! "
                    },
                    {
                        "username": "kamranbadirov",
                        "content": "Basically think of it as two pointer approaching towards each other. You want to move the pointer that points to the smaller container since we are looking for the biggest volume. \n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height)-1\n        curr = 0\n        while i < j:\n            vol = (j - i) * min(height[i], height[j])\n            curr = max(curr, vol)\n            if height[i] <= height[j]:\n                i += 1\n            else:\n                j -= 1\n        return curr\n"
                    },
                    {
                        "username": "115ankitdasuni",
                        "content": "time complexity - O(n^2);\\n   int maxArea(vector<int>& height) {\\n       int ma,s;\\n       ma=0;\\n       s=height.size();\\n       for (int i =0 ; i<s;i++)\\n       {\\n           for (int j =i+1;j<s;j++)\\n           {\\n               int a;\\n               if (height[j]<height[i]){\\n                    a=height[j]*(j-i);\\n\\n                    if(ma<a)\\n                    {\\n                        ma = a;\\n                    }\\n               }\\n               else{\\n                   a = height[i]*(j-i);\\n                   if (ma<a)\\n                   {\\n                       ma=a;\\n                   }\\n               }\\n           }\\n       }\\n       return ma;\\n\\n    }"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "EASIEST SOLUTION IN PYTHON YOU WILL EVER FIND by David Grace \\n\\n\\n `class Solution:\\n    def maxArea(self, height: List[int]) -> int:\\n\\n        left,right=0,len(height)-1\\n\\n        max_area=0\\n\\n\\n        while(left<right):\\n\\n            min_height=min(height[right],height[left])\\n            width=right-left\\n\\n            max_area=max(max_area,min_height*width)\\n\\n\\n            if height[left]<height[right]:\\n                left+=1\\n            else:\\n                right-=1\\n        return max_area\\n`\\n\\nthe code is pretty self explainatory"
                    },
                    {
                        "username": "KhadarAfghan",
                        "content": "Input\\nheight =\\n[1,2,1]\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n2\\ncan anyone plz explain this? how we expect 2 "
                    },
                    {
                        "username": "codesupernova",
                        "content": "I solved it but I don\\'t know why and I can\\'t believe my answer solves every odds."
                    },
                    {
                        "username": "kopal41",
                        "content": "Its a good question.\\nMy approach to solve this question is:\\n1.Set i at 0th position and j at n-1th position then check for the minimum height and calculate the area of rectangle which will the capacity as:\\ncapacity=min(height[i],height[j])*(j-1)\\n2.Do increment in i if height[i] is less than height[j] and decrement in j if height[j] is smaller than height[i]\\n3.Follow the loop till you get an i which is greater than j and so comapariosns for the calculated capacity and return the max capacity."
                    },
                    {
                        "username": "thrillobit",
                        "content": "Was this question marked as \"hard\" before?"
                    },
                    {
                        "username": "Yuvarajesh",
                        "content": "in the given test case [1,8,6,2,5,4,8,3,7], 8*8 = 64 can be a maximum why the answer is 49"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nLet me know if you need a detailed explanation."
                    },
                    {
                        "username": "adesh3002",
                        "content": "The whole point of this question, is finding the area inside the rectangle from i  to j. \\n\\nFirst you need an two pointer i initialize with 0 and j to len(height) - 1. \\n\\nAlways increase the i and decrease the j based on some conditions. \\n\\nIs water capacity of this i and j is greater than previous water capacity. \\n\\nCondition for increment and decrement of i and j. \\n\\ni ->  if element at i is less than element at j  \\nj -> if element at i is greater than element at j \\n\\nBased on that you can find maximum capacity water range in array of given height."
                    }
                ]
            },
            {
                "id": 2008439,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 2005095,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 2004044,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 1996943,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 1993510,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 1992171,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 1989692,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 1988431,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 1983890,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 1981375,
                "content": [
                    {
                        "username": "anivaries",
                        "content": "Finally a test which I managed to do without googling \\uD83D\\uDE2D"
                    },
                    {
                        "username": "I_am_Spike",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int start = 0;\\n        int end = height.size()-1;\\n        int area = 0;\\n        while(start<=end){\\n            if(height[start] <= height[end]){\\n             area = max(area,height[start]*(end-start));\\n            start++;\\n           \\n            }\\n            else if(height[start] > height[end]){\\n            area = max(area,height[end]*(end-start));\\n            end--;    \\n            }\\n         }\\n         return area;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "I multiplied the minimum of height[i] and height[j] with absolute value of (i-j), Lastly I pushed the final value each time into an another vector and printed the greatest value present that vector. This approach works but exceeds the time limit. Is there any way to optimize this approach which will be good enough for Leetcode ? \\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "Instead of storing all the values in the vector and then finding the maximum value, you can use  an extra variable.\n\narea = 0\nmaxarea = INT_MIN\n\narea = ans                                          // ans:  the value that you were pushing in the vector.\nmaxarea = max(maxarea, area )\n.\n.\nreturn maxarea\n\nHope this helps )"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "For same height scenario, I used the following approach:\\n\\nI am comparing the heights of bars left to the current left_pointer and right to the current right_pointer.\\nIf the bar next to the left_pointer is larger than the bar next to the right_pointer then move the left_pointer otherwise move the right_pointer. "
                    },
                    {
                        "username": "tt_nk",
                        "content": "Can someone clear this, why the area 8*8 is not the highest?"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We have to find the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the two pillars represents the width.\\n\\nExample: [1,8,6,2,5,4,8,3,7]\\n\\nHere, first 8 is at index 1 and the next 8 is at index 6, giving us area of 40 units (8 * 5),\\n(8 * 5 = min(first, next) = min(8,8) = 8 and next index - first index = 6 -1 = 5)\\n, but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units (7 *7).\\nsince 49 > 40, the req. pillars are 8 and 7.\\n\\nI hope this helps ;"
                    },
                    {
                        "username": "saisupriyavaru",
                        "content": "I have used two pointers approach here. One pointer starts from beginning of array and the other starts from end of the array. Firstly, I am finding the area of container if we consider extreme points and then comparing it by moving the pointers who height is smaller than other. We save the max area obtained for all different combinations and return it when p1>=p2."
                    },
                    {
                        "username": "sabresage",
                        "content": "can anybody explain the question in clarified way as I am unable to understand it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The following is the intuition to the two pointer approach people have followed in the solution section:\\n\\nThe problem basically requires us to find the maximum rectangle area that can be formed using the lines as one of the side of the rectangle.\\n\\nInitially if we keep 2 pointers x1 and x2 where x1 = 0 and x2 = height.size()-1\\nThen, \\n\\nThe area of rectangle  = length * breadth, here initially length = x2-x1; \\nand breadth = min(height[x1],height[x2])\\n\\nnow since we want to move the pointers and dont know which pointer to move, \\nwe will think of the following:\\n\\nthe initial length is x2-x1 and we are shrinking this length, so we will try to increase the breadth somehow,\\nhow can we do that? by moving the pointer which is having smaller height in hopes that we would find a bigger height somewhere else which would make min(height[x1],height[x2]) bigger.\\n\\nSo, if(height[x2]<height[x1]) x2--\\nelse x1++\\n"
                    },
                    {
                        "username": "HG2407",
                        "content": "How the hell is this a test case ? Is LC joking with us ?\\n[8361,5302,8672,2400,5150,3527,9216,6713,2902,310,555,9176,311,9968,5705,3983,7992,8553,6953,9541,5828,1750,6731,3552,5274,7303,3724,5387,9504,1900,937,1146,7266,7943,7911,9055,8046,7180,6516,7810,686,5210,1956,4540,7540,2083,1579,4260,2450,2527,6524,5723,6766,777,5694,6018,2880,3653,6011,8172,5943,2862,6594,2902,9887,5878,3065,8197,9195,4560,3428,2209,475,852,9488,3368,4319,6230,1975,5829,9474,4490,2067,6048,9136,5344,6022,1787,5553,140,5130,524,3450,4008,721,6154,5598,8219,4614,3404,8232,9023,4552,7711,6057,5324,8578,3595,4663,4,3703,1429,7921,3085,3694,1461,8932,2632,7046,801,6043,617,7565,3469,1627,1464,3050,7982,6702,5467,8604,5515,9155,3260,5040,313,8885,929,4103,7947,1139,702,1047,2889,1439,3945,4738,2462,8491,7699,376,4639,1329,3644,7408,3665,7417,1388,861,7510,7908,4568,2618,4565,7222,2003,......\\nI can\\'t even paste the whole test case here\\n"
                    },
                    {
                        "username": "DKotov29",
                        "content": "why not 8*8 in example so we will have 64 and not 49"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "simply because you have to choose minimum height otherwise container will overflow\\n"
                    },
                    {
                        "username": "Onkar_Wagh",
                        "content": "We are finding the area of the largest rectangle, while doing so, the pillars represent the height of the rectangle and the distance between the  two pillars represents the width. \n\n\nExample:  [1,8,6,2,5,4,8,3,7]\nHere, first 8 is at index 1 and the next 8 is at index 6, giving as area of 40 units (8 * 5), but if you consider 8 (index 1) and 7 (index 8), we get an area of 49units  (7 *7).\nsince 49 > 40, the req. pillars are 8 and 7.\n\nLet me know if you need a detailed explanation."
                    }
                ]
            },
            {
                "id": 1981037,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1980965,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1978760,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1973709,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1973135,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1968136,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1960037,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1953898,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1951888,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1947687,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Why cant we use largest area in a histogram approach ?? Pls Help"
                    },
                    {
                        "username": "spookie886",
                        "content": "why is this question included in the hard collection of leetcode\\'s top intervew questions?"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Iterate the array with two pointers from start and end moving inwards. The maximum area is the product of the minimum height of the two bars and the distance between them."
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How for this [0,1,1] answer is 2? isn\\'t it 1?\\n"
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "I\\'m still digesting the fact that we will move the smaller pointer to get larger area. "
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "FOR ME LITERALLY TLE 47/61 TESTCASES PASSED I DID BRUTE FORCE METHOD USING TWO POINTERS AND O(N^2) "
                    },
                    {
                        "username": "njdgaf",
                        "content": "Ideally two taller vertical lines between two shorter vertical lines should have water at a higher height. It is not taken into consideration here."
                    },
                    {
                        "username": "user4796V",
                        "content": "bro, i looked up the optimal time and space complexity (O(n) and O(1))\\nwrote the algorithm and knew that it will work, it indeed worked fine and i have no idea why "
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "\\n\\nmy code was obsoletely correct bt still giving me error ...leetcode look into this \\n sort(v.begin(), v.end(), greater<int>()); this is not acting properly in your server\\n"
                    },
                    {
                        "username": "H4CE",
                        "content": "the third parameter should be greater \\<int\\>() "
                    },
                    {
                        "username": "relentless026",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n        int start =0;\\n        int end= height.size()-1;\\n        int area=INT_MIN;\\n\\n        while(start<end)\\n        {\\n          int area1= (end-start)*min(height[start],height[end]);\\n          area = max(area,area1);\\n          if(height[start]<height[end]) start++;\\n         if(height[start]>height[end]) end--;\\n         if(height[start]==height[end]){\\n           start++;\\n           end--;\\n         }\\n          \\n        }\\n        return area;\\n        \\n    }\\n};\\n\\nCan anyone tell what\\'s the problem with this code its not giving the correct output\\n"
                    }
                ]
            },
            {
                "id": 1947621,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1945334,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1943730,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1942652,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1936802,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1936160,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1932696,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1932426,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1931039,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1930592,
                "content": [
                    {
                        "username": "abhisekhbarman688",
                        "content": "  class Solution {\\npublic:\\n          int maxArea(vector<int>& height) {\\n        int left=0;\\n        int right = height.size()-1;\\n        int maxarea=0;\\n        while(left < right){\\n            int area = min(height[left],height[right]) *(right-left);\\n maxarea= max(area,maxarea);\\n            if(height[left] < height[right])\\n                left++;\\n            else\\n                right--;  \\n         }\\n         return maxarea;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Jayendra06",
                        "content": "The problem's solution will become simpler if you think it in this way.\nFirstly, Ignore the water logic here since as in example 1 you can see that height[6] pillar isn't blocking the water. So in this question basically we have to find the max area of rectangle formed. \nNow, assume there are two pointers at each end of array, `i=0` and `j=size of heights - 1`\nSo, the area of the formed rectangle will be made up of 2 factors  `height = minimun of height[i] and height[j]` and `width = j-i`.  \nNow comes the interesting part on how to move the 2 poiners `i` and `j`.\nYou can clearly observe that area is `directly proportional` to height and width, since, `area = height * width`.\nAnd if you move i towards right by incrementing it or j towards right by decrementing it. The `width will always decrease` thus we can ignore width and continue thinking.\n\nNow, we just have to maximize height in order to maximize area.\nSo clearly we will move that pointer among i and j which is having lesser height in search for a greater height.\n\nHence, you just have to check which pointer value is lesser among i and j and move it while constantly updating area with a greater value, if found."
                    },
                    {
                        "username": "lowerkinded",
                        "content": "A note for the solution: It only makes sense to move the lowest pointer because the lowest pointer will be the limiting factor in the area calculation no matter what else you do. You have to be increasing that `min(l, r)`."
                    },
                    {
                        "username": "sarmittal",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left =0;\\n        int right = height.length-1;\\n        int max = 0;\\n        while(left<right){\\n            int w = right-left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = w*h;\\n            max = Math.min(area,max);\\n            if(height[left]>height[right]){\\n                right--;\\n            }else if(height[left]<height[right]){\\n                left--;\\n            }else{\\n                right--;\\n                left--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nWhere i am making mistake ????"
                    },
                    {
                        "username": "jt88",
                        "content": "why doesn\\'t leet code tell us it is mandatory to use pointers in this specific problem?\\n\\nwas scoring correct on all test cases and submit was marking wrong(yet showing correct output) due to my 2 for loops to scan the largest area\\n\\nfor i in range(1,n):\\n            for j in range(0, i):\\n\\n\\nyou want us to use pointers? then let us know in the description."
                    },
                    {
                        "username": "shreyasudaya",
                        "content": "What is the complexity required?"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "My solution is almost correct 53 out of 61 can anyone recode my code  `your inline code...your inline code...`\\nclass Solution(object):\\n    def maxArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hl = 0\\n        ma = max(height)\\n        me = 0\\n        ind = 0\\n        for i in range(len(height)-1, 0, -1):\\n            if height[i] > me:\\n                me = height[i]\\n                ms = 0\\n                for j in range(ind, len(height)):\\n                    if height[j] > ms:\\n                        ms = height[j]\\n                        hl = max(hl, (i-j) * min(ms, me))\\n                    if ms < me:\\n                        ind = j\\n            if me == ma:\\n                break\\n\\n        return hl "
                    },
                    {
                        "username": "jxuycy",
                        "content": "Ever since leetcode update , it always give me those runtime error, keey giving me You might be using global/static variables or C/C++. The system executes all testcases using the same program instance. Global/static variables affect the program state from one test case to another. someone plz fixed it ?"
                    },
                    {
                        "username": "adwong1218",
                        "content": "[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\n\\nwhy does it keep saying this?"
                    },
                    {
                        "username": "im-naime",
                        "content": "First, try to come up with the brute force logic which is trivial. It will help to come up with the two-pointer solution. This problem isn\\'t as hard as you think :)"
                    }
                ]
            },
            {
                "id": 1925334,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1925238,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1923031,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1913363,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1913038,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1912497,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1910964,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1896363,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1889077,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1888316,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "What if in an iteration of the while loop, we encounter bars of the same length, what happens then? Do we increment one pointer or decrement the other one?"
                    },
                    {
                        "username": "gonzi",
                        "content": "When both heights are equal it doesn\\'t matter what pointer you are moving because you will always get a worst water capacity. This is true because you are keeping the height constraint but reducing the width. So if it is a better answer it must be in both ranges [i + 1, j] and [i, j -1]. If it is in both ranges it is in the intersecion so it is in [i + 1, j - 1] which leads to the fact that, when you have equal heights, you can move both pointers at the same."
                    },
                    {
                        "username": "dilmohankumar",
                        "content": "its a simple sol. we are taking min height of left and right=n-1 which is with width multiplay min height with width  and store in area know we will take max in ech lop it will check which is grater amng thos area after that setting condion for moving pointer to satify all possible cointer we take we move left if left hrght is small we decrement right if right hight is mall and return  max\\n"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "By any chance are we not allowed to use max() function in this question???"
                    },
                    {
                        "username": "dactung93",
                        "content": "It use 2 pointer, i starting from left and j starting from right.\n\nUse a while loop until i>=j\n\nCalculate the Area first then compare the height of both left and right column.\nIn which is lower, then move the pointer toward the center.\nCompare until it reaches the point when left and right meet.\n\nBut be aware about the case when both left and right height are equal. Then you can move either left or right to the next position.\n\nTime Complexity beats 91%"
                    },
                    {
                        "username": "Gowravsai26",
                        "content": "i didnt understand the question itself.\\npls explain!!"
                    },
                    {
                        "username": "LostSibling",
                        "content": "What a confusing question. I know I solved it if it was based on the amount of water it can be maximally be stored, instead it\\'s just the largest area. "
                    },
                    {
                        "username": "sufyan_ashraf",
                        "content": "for this array = [1,8,6,2,5,4,8,3,7] the answer is 19 but the question shows an answer of 49. That\\'s not correct."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "thats correct because the water stored is basically the area of the largest rectangle that we can form. So in this case the answer is 7*7=49.\\n"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "How is [1, 2, 1] \\'s output is 2?"
                    },
                    {
                        "username": "aryehakierman",
                        "content": "found this explanation on stack overflow\\n\\n\\nWhen you have a pair (leftPointer, rightPointer), then the least of height[leftPointer] and height[rightPointer] determines the volume that the corresponding container has.\\n\\nLet\\'s assume that height[leftPointer] is the lesser one (or at least not greater).\\n\\nThen we know that for any i in the range [leftPointer+1, ..., highPointer] the volume between leftPointer and i cannot be greater than what we already have. Even if there would be a very high height[i] it wouldn\\'t matter as then height[leftPointer] is the lesser and determining height. And because the distance between leftPointer and i is less than the distance between leftPointer and rightPointer, the volume can never exceed what we already have.\\n\\nSo we don\\'t need to visit those leftPointer, i pairs. That\\'s were we avoid making all combinations.\\n\\nOn the other hand, we cannot exclude that there is an i where the i, highPointer pair would represent a greater volume container. That is why leftPointer++ is the correct action to take, and then the same reasoning can be applied to the new pair."
                    },
                    {
                        "username": "bit_weiser",
                        "content": "think about the situation when no example were given to understand the problem.\\n\\nand also think abt the situation when only example were given to solve the problem"
                    }
                ]
            },
            {
                "id": 1887858,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1878269,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1875941,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1866768,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1863145,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1857533,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1850128,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1847107,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1834231,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1831002,
                "content": [
                    {
                        "username": "DrSaAI",
                        "content": "I was able to solve the problem in 5 minutes with the hint, but I do not understand the logic. "
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "  int n=height.size();\\n        // int ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         int k=min(height[i],height[j]);\\n        //         if(k*(j-i)>ans){\\n        //             ans=k*(j-i);\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\nthis code is running for initial cases but giving time limit exceeded error can anyone expain this why;\\n"
                    },
                    {
                        "username": "vjgajjela",
                        "content": "Even I got same timeout.\\nI think with the test case which has long data there is minumum time expectation, hence the error. I got this error when I tried with my brute force approach, but later it was not coming for my final submission "
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "learned something but still not convinced how..."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "use two pointer it will easily solved."
                    },
                    {
                        "username": "MahiBhatK",
                        "content": "List<Integer> areas = new ArrayList<>();\\n\\n        for(int i=0; i<height.length-1; i++){\\n            for(int j=i+1; j<height.length; j++){\\n                if(height[i]<height[j]){\\n                    areas.add(height[i]*(j-i));\\n                }else {\\n                    areas.add(height[j]*(j-i));\\n                }\\n                   \\n            }\\n        }\\n       int a = areas.stream().mapToInt(area->area).max().getAsInt();\\n       return a;\\n\\nCurrently time complexity is O(n2), I want it to be O(n).\\nHelp me"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it should be one among the easier medium questions "
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "Guys I keep getting Compile Error while doing on leetcode. I am using Rust. My code run perfectly on the local machine, and I also tried to just copy and paste the answers in the Solution, just in case, but I get the same Compile Error - with 0/0 testcases passed. \\n```bash\\nUnknown preprocess compile error\\n```\\n"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while(left < right){\\n            int Area = \\n             Math.min(height[left], height[right]) * (right - left);\\n\\n            maxArea = Math.max(Area, maxArea);\\n\\n            if(height[left] < height[right])\\n                left++;\\n            else \\n                right++;\\n            \\n        }\\n\\n        return maxArea;\\n        \\n    }\\n}\\n\\n\\nI am getting a runtime error and I am unable to understand what\\'s wrong. \\n\\nThis is what the error says\\n\\njava.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length 9\\n  at line 8, Solution.maxArea\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "manifold1985",
                        "content": "you put \"right++\", while it should be \"right--\"."
                    },
                    {
                        "username": "b210396",
                        "content": "it is giving the answer of previous test case and i have no idea what to do !!!\\nthe code is running correctly in vs code.\\nit is very frustating \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "galymzhvnov",
                        "content": "JS\\nvar maxArea = function(height) {\\n    let left = 0, right = height.length - 1;\\n    let maxArea = 0;\\n    while(left < right) {\\n        const columnHeight = Math.min(height[right], height[left]);\\n        const Square = (right - left) * columnHeight \\n        maxArea = Math.max(Square, maxArea)\\n        if(height[left] < height[right]){\\n            left++;\\n        }else {\\n            right--;\\n        }\\n    }\\n    return maxArea;\\n};"
                    }
                ]
            },
            {
                "id": 1819044,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1811752,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809512,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1808550,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1803768,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1792403,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1783540,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1782179,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1781835,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1780983,
                "content": [
                    {
                        "username": "vjgajjela",
                        "content": "Either the problem definition is not descriptive or few of the test cases are wrong."
                    },
                    {
                        "username": "cagils",
                        "content": "Two pointers approach O(n)\\nWe first maximize width\\nThis guarantees we have the max area for the shortest one of the current pointers\\nSo we can move that shortest pointer inwards safely\\nIf both are equal we can move both inwards at the same time\\nAn optimization is we can store the historical max for each pointer and only calculate if it is bigger"
                    },
                    {
                        "username": "aryaman123_",
                        "content": "Guys i stuck in the question like should i have to add the another variable to storing the answers"
                    },
                    {
                        "username": "shehtabmasud10",
                        "content": "why for the testcase number 22 the output 2? and not 1?\\nheight = [1, 2, 1]\\nThe most water can contain should be 1 right? for height[0] and height[1]?"
                    },
                    {
                        "username": "mujaeim",
                        "content": "Can anyone help me why I am getting time Limit Exceeded for testcase 54/61? This test case basically contains more than 100 integers. `public static int maxArea(int[] height) {\\n        int area, width;\\n        int maximumArea = 0;\\n        int count = 0;\\n\\n        for (int i = count; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                width = (height[i] > height[j]) ? height[j] : height[i];\\n                area = width * (j - i);\\n\\n                if (area > maximumArea) {\\n                    maximumArea = area;\\n                }\\n            }\\n            count++;\\n        }\\n        return maximumArea;\\n    }`"
                    },
                    {
                        "username": "Numresunw",
                        "content": "two nested for-loops are way too slow for large sized arrays try using a sliding window aproach which is basically the same but a lot faster since you dont duplicate iterations"
                    },
                    {
                        "username": "mike_nossal",
                        "content": "I think the answer is wrong on test case 51 -- which says the expected output is 24 -- I believe the correct answer is 20 (which is what my code produces)."
                    },
                    {
                        "username": "purvashah98",
                        "content": "For the sample testcase\\nInput: height = [1,8,6,2,5,4,8,3,7]\\nOutput: 49\\n\\nWhy is the output 49 and not 64? the water stored btw 1st and 6th index would be maxium and not 1st and 8th index.\\nThis is so confusing!"
                    },
                    {
                        "username": "rohithgundu11949",
                        "content": "for 1st and 6th position it will be 40(height=8 & width=5)"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Javascript solution \\nvar maxArea = function(height) {\\nlet Maxar=0;\\nlet pointer2 =height.length-1;\\nlet  pointer1= 0;\\n\\nwhile(pointer1 < pointer2){\\n   \\n       let width= pointer2 - pointer1;\\n        let heights= Math.min(height[pointer1], height[pointer2]);\\n       let area= heights* width;\\n        Maxar= Math.max(area,Maxar);\\n      \\n    if(height[pointer1] <= height[pointer2]){\\n        pointer1++;\\n    }else{\\n        pointer2--;\\n    }\\n\\n   \\n}\\n\\n return Maxar;\\n    \\n};"
                    },
                    {
                        "username": "deeksha310",
                        "content": "We can solve it by two methods :-\\n1. Brute force-   Simply keep 2 loops  and calculate the area at every step\\nTo  calculate area-  area=min(height[i],height[j]) * (j-i);\\nstore the current area in variable and at every step check if area is greater than max area. \\nTime complexity - O(n2)  \\nsome test cases will fail bcoz of high time complexity\\nHope you get an idea\\n\\n//optimised\\n2. Two Pointer approach\\nput one pointer at start and other at end\\nthe one whose value is less will move and will be used to calculate area.\\nWhen you dry-run it you will get an idea that we may assume that the one whose value is less might not be a good solution so we calculate and move it.\\nsuppose pointer j value is less\\nthen area will be\\n area=arr[j] * (j-i);\\n\\ntime complexity- O(n)\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int lp=0,rp=height.size()-1,maxy=0;\\n        while(lp<rp){\\n            int hlp=height[lp],hrp=height[rp];\\n            maxy=max(maxy,min(hlp,hrp)*(rp-lp));\\n            if(hlp<hrp){\\n                lp++;\\n            }\\n            else{\\n                rp--;\\n            }\\n        }\\n        return maxy;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1779729,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1776541,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1776288,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1774056,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1755484,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1754626,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1752866,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1752581,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1748106,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1745863,
                "content": [
                    {
                        "username": "jlee474",
                        "content": "Using Javascript -->  .findLastIndex() method of an array is not a function? Wth."
                    },
                    {
                        "username": "NikSS212",
                        "content": "WTF???  TestCase 52 (Time Limit Exceeded) "
                    },
                    {
                        "username": "ankush920",
                        "content": "very simple two pointer approach with O(n)  t.c. :-\\n\\nclass Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n\\n// simple two point approach question very easy     \\n        int n =height.size(); \\n\\n        if( n==2)\\n        {\\n             return min(height[0], height[1]); \\n        }\\n\\nint ans = -1,  i=0 , j=n-1;\\n\\nwhile( i<j)\\n{\\n  int val = min(height[i] ,height[j])*(j-i);\\n    ans =max(ans, val);\\n\\n    if( height[i]>height[j])\\n    {\\n         j--;\\n         continue;\\n    }\\n\\n    \\n    if( height[i]<height[j])\\n    {\\n        i++;\\n        continue;\\n         \\n    }\\n     \\n     i++;\\n      j--;\\n}\\n\\n       \\n return ans;    \\n    }\\n};"
                    },
                    {
                        "username": "aravind_ravva",
                        "content": "This question always hits my imagination \\n\\n[leetcode](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\n\\nhow can the water get stored if 8 is there in between 2 7\\'s \\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "good question."
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: Run Time - 759 ms\\n\\nclass Solution:\\n    def maxArea(self, height: List[int]) -> int:       \\n        minHeight = 0\\n        res = 0\\n        maxVal = 0\\n        lenHeight = len(height)        \\n        j = lenHeight - 1 \\n        k = j  \\n        l = 0        \\n        for i in range(lenHeight):                           \\n                if height[l] > height[j]:\\n                    minHeight = height[j]\\n                else:\\n                    minHeight = height[l]\\n                res = minHeight * k                \\n                maxVal = max(maxVal,res)   \\n                if height[j] < height[l]:            \\n                    j -= 1                   \\n                else:\\n                    l += 1             \\n                k -= 1                \\n        return maxVal"
                    },
                    {
                        "username": "luna4tech",
                        "content": "<b>Why the two pointer approach works(in simple words):</b>\\nWe take two pointers i and j starting at the extremes of the array and keep moving i to right and j to the left.\\n\\nif `height[i] < height[j]`\\n- In brute force we would have calculated `(i,j-1), (i,j-2).. `\\n- Since `height[i]` is lesser, even though the values of `height[j-1], height[j-2]..` are more, we are limited by `height[i] `\\n- But width keeps decreasing as we move j to the left fixing i, so area also keeps decreasing\\n\\nSame applies for other case `height[i] > height[j]`"
                    },
                    {
                        "username": "Isshh",
                        "content": "Can someone provide any suggestion? \\nI am able to pass 55/61 cases\\nclass Solution {\\n    public int maxArea(int[] height) {\\n        if(height.length==2)\\n        {\\n            return (Math.min(height[0], height[1]));\\n        }\\n        int r=0;\\n        int h=0;\\n        int w=0;\\n        int j=height.length-1;\\n        int c=1;\\n        while(j>=0){\\n        int h1=height[j];\\n            for(int i=0;i<j;i++)\\n            {   if(h<height[i] && h<height[j]){\\n                int h2=height[i];\\n                c=Math.min(h1, h2)*(j-i);                             \\n                if(c>r){\\n                    r=c;\\n                  w=j-i;\\n                  h=Math.min(h1, h2); }\\n                }//if\\n            }//for\\n            j--;\\n        }//while\\n        return r;\\n    }\\n}"
                    },
                    {
                        "username": "donnadiee666",
                        "content": "This happens to me too 55/61 cases"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sra22",
                        "content": "Can someone explain problem statement to find out solution, \\nThanks."
                    },
                    {
                        "username": "user3882os",
                        "content": "approach other than O(n^2) are not clicking to me. what i need to do to improve my critical thinking and more efficient solution?"
                    }
                ]
            },
            {
                "id": 1745430,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            },
            {
                "id": 1745425,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            },
            {
                "id": 1739989,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            },
            {
                "id": 1731536,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            },
            {
                "id": 1730491,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            },
            {
                "id": 1727547,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            },
            {
                "id": 1726302,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            },
            {
                "id": 1724469,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            },
            {
                "id": 1723528,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            },
            {
                "id": 1721749,
                "content": [
                    {
                        "username": "srihar9397",
                        "content": "O(N) beats 97.71 in time. Simple python solution\n\n \n    `class Solution:\n        def maxArea(self, height: List[int]) -> int:\n            left = 0\n            right = len(height) - 1\n            water = 0\n\n            while True:\n                # the least number is the multiplier\n                multipler = height[left] if height[left] < height[right] else height[right]\n\n                #calculate the water contained and update \n                tmp_water = (right-left) * multipler\n                if tmp_water > water: water = tmp_water\n\n                if(height[left] < height[right]): left += 1\n                else: right -= 1\n\n                if(left >= right): break\n        \n        return water\n`"
                    },
                    {
                        "username": "hussienabdallah14",
                        "content": "at first, I didn\\'t understand the problem cause (the two endpoints of the Ith line are (i, 0)\\n and (i, height[i]) this part has a mistake. it should be (i.0) and (i, height[i-1])"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "Time limit exceeded even if I use an ArrayList... going from array to al validated ~8 more tests, I\\'m assuming that the last ones will be even heavier so it has no chance of working. Not used to dealing with collections of this size, any advice or link to a tuto would be appreciated."
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "which companies have asked this?"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "55/60 Test Cases running by bruteforce method\\nPlease improve by your side\\nlet max = 0\\n    for (let i = 0; i < height.length-1; i++) {\\n        for (let j = i+1; j < height.length; j++) {\\n            let min = Math.min( height[i], height[j])\\n            let x = min * (j-i)\\n            if(max < x){\\n                max = x\\n            }\\n        }\\n    }\\n    return(max)"
                    },
                    {
                        "username": "agnivS",
                        "content": "My approach was iterating through all the possible columns height[i] throughout the array, and for each one iterating through the indices of the array once from 0 to i and again from i+1 to height.length - 1 to get the index of the 2nd column j. \\n I only considered the pairs (i,j) such that h[i] <= h[j] without loss of generality. \\nThese two iterations were used in order to ensure we start at the farthest possible column in the respective direction of the concerned column i and iterate towards i, breaking out of the loop whenever h[j] >= h[i] since the \"area of a container\" in this case is simply min{h[i],h[j]} * |j-i| = h[i] * |j-i|. Hence a larger absolute difference between j and i where h[j] >= h[i] produces a maximum container area for such a value of h[i].\\nDespite the fact that two for loops for the iteration inside the outside index counter loop were used and the overall time complexity may seem like a brute force O(N^2) on surface level,\\n(1) What would be the true time complexity of this solution and why? \\n"
                    },
                    {
                        "username": "sankarshbb",
                        "content": "After I submitted my code, it showed that for the input [1,2,4,3] the expected output was 4 but the correct output should be 9. Did anyone find this wrong output??"
                    },
                    {
                        "username": "sabonett",
                        "content": "[@LeetCode](/LeetCode) official solution leads to \"Time Limit Exceeded\" in Java. "
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is actually an interesting problem, which can be easily solved in `O(n)` time using `O(1)` space. \n\nThe key idea is to use two pointers.\nWe initialize `left = 0` and `right = n-1` (n=the number of elements in the array).\nNow arises the following three cases:\n`1) height[left] > height[right]`\n`2) height[right] > height[left]`\n`3) height[left] == height[right]`\n\n`CASE 1 :`\nDecrement `right` by 1.\nThe reason behind is that the maximum water that the container starting at left and ending at right can hold, is `min(height[left] , height[right])*(right-left)`. If we increment `left`, then it is guaranteed that the minimum of both the heights will not go above `height[right]` , however the difference `(right-left)` will get reduced. As a result the maximum water holding capacity will either remain constant or decrease.\nHere we will not increment left and decrement right simultaneously as we may miss a better solution.\n\n`CASE 2 :`\nIncrement `left` by 1.\nThe reason is similar to the previous one, as decrementing `right` pointer either decreases the result or keeps it constant.\n\n`CASE 3 :`\nSimultaneously increment `left` and decrement `right`.\nHere if we either increment `left` or decrement `right`, then again the minimum of the two heights does not increases. It either decreases or remains the same. The only option remaining is to do both simultaneously.\n\nNOTE : After every iteration do not forget to update the answer as in\n `ans = max(ans , min(height[left] , height[right]) * (right-left))`"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "It's not a medium problem at all. It's too easy"
                    }
                ]
            }
        ]
    }
]