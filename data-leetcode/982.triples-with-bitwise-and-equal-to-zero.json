[
    {
        "title": "Unique Paths III",
        "question_content": "You are given an m x n integer array grid where grid[i][j] could be:\n\n\t1 representing the starting square. There is exactly one starting square.\n\t2 representing the ending square. There is exactly one ending square.\n\t0 representing empty squares we can walk over.\n\t-1 representing obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\nExample 2:\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\nExample 3:\n\nInput: grid = [[0,1],[2,0]]\nOutput: 0\nExplanation: There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 20\n\t1 <= m * n <= 20\n\t-1 <= grid[i][j] <= 2\n\tThere is exactly one starting cell and one ending cell.",
        "solutions": [
            {
                "id": 221946,
                "title": "java-python-brute-force-backtracking",
                "content": "# Explanation\\nFirst find out where the start and the end is.\\nAlso We need to know the number of empty cells.\\n\\nWe we try to explore a cell,\\nit will change 0 to -2 and do a dfs in 4 direction.\\n\\nIf we hit the target and pass all empty cells, increment the result.\\n<br>\\n\\n# Complexity\\nTime complexity is as good as dp,\\nbut it take less space and easier to implement.\\n<br>\\n\\n**Java:**\\n```java\\n    int res = 0, empty = 1, sx, sy, ex, ey;\\n    public int uniquePathsIII(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) empty++;\\n                else if (grid[i][j] == 1) {\\n                    sx = i;\\n                    sy = j;\\n                }\\n            }\\n        }\\n        dfs(grid, sx, sy);\\n        return res;\\n    }\\n\\n    public void dfs(int[][] grid, int x, int y) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] < 0)\\n            return;\\n        if (grid[x][y] == 2) {\\n            if (empty == 0) res++;\\n            return;\\n        }\\n        grid[x][y] = -2;\\n        empty--;\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x - 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x, y - 1);\\n        grid[x][y] = 0;\\n        empty++;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def uniquePathsIII(self, A):\\n        self.res = 0\\n        m, n, empty = len(A), len(A[0]), 1\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    x, y = (i, j)\\n                elif A[i][j] == 0:\\n                    empty += 1\\n\\n        def dfs(x, y, empty):\\n            if not (0 <= x < m and 0 <= y < n and A[x][y] >= 0): return\\n            if A[x][y] == 2:\\n                self.res += empty == 0\\n                return\\n            A[x][y] = -2\\n            dfs(x + 1, y, empty - 1)\\n            dfs(x - 1, y, empty - 1)\\n            dfs(x, y + 1, empty - 1)\\n            dfs(x, y - 1, empty - 1)\\n            A[x][y] = 0\\n        dfs(x, y, empty)\\n        return self.res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    int res = 0, empty = 1, sx, sy, ex, ey;\\n    public int uniquePathsIII(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) empty++;\\n                else if (grid[i][j] == 1) {\\n                    sx = i;\\n                    sy = j;\\n                }\\n            }\\n        }\\n        dfs(grid, sx, sy);\\n        return res;\\n    }\\n\\n    public void dfs(int[][] grid, int x, int y) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] < 0)\\n            return;\\n        if (grid[x][y] == 2) {\\n            if (empty == 0) res++;\\n            return;\\n        }\\n        grid[x][y] = -2;\\n        empty--;\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x - 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x, y - 1);\\n        grid[x][y] = 0;\\n        empty++;\\n    }\\n```\n```py\\n    def uniquePathsIII(self, A):\\n        self.res = 0\\n        m, n, empty = len(A), len(A[0]), 1\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    x, y = (i, j)\\n                elif A[i][j] == 0:\\n                    empty += 1\\n\\n        def dfs(x, y, empty):\\n            if not (0 <= x < m and 0 <= y < n and A[x][y] >= 0): return\\n            if A[x][y] == 2:\\n                self.res += empty == 0\\n                return\\n            A[x][y] = -2\\n            dfs(x + 1, y, empty - 1)\\n            dfs(x - 1, y, empty - 1)\\n            dfs(x, y + 1, empty - 1)\\n            dfs(x, y - 1, empty - 1)\\n            A[x][y] = 0\\n        dfs(x, y, empty)\\n        return self.res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1553805,
                "title": "c-simple-and-clean-dfs-solution-explained-0ms-faster-than-100",
                "content": "**Explanation:**\\nFirst step, we need to know where the starting point is. We also want to know the number of empty cells.\\nSo we iterate through the grid, count empty cells and save the starting point - `start_x` and `start_y`.\\nNow, we do classic DFS, marking the visited cells with -1 and counting the cells we passed.\\nIf we reached the ending point and we passed `empty` number of cells - this means we passed by every non-obstacle cell.\\n```\\nclass Solution {\\npublic:\\n    int res = 0, empty = 1;\\n    void dfs(vector<vector<int>>& grid, int x, int y, int count) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1) return;\\n        \\n        if (grid[x][y] == 2) {\\n            if(empty == count) res++; \\n            return;\\n        }\\n        \\n        grid[x][y] = -1;\\n        \\n        dfs(grid, x+1, y, count+1);\\n        dfs(grid, x-1, y, count+1);\\n        dfs(grid, x, y+1, count+1);\\n        dfs(grid, x, y-1, count+1);\\n        \\n        grid[x][y] = 0;\\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int start_x, start_y;\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1) start_x = i, start_y = j;\\n                else if (grid[i][j] == 0) empty++;\\n            }\\n        }\\n        \\n        dfs(grid, start_x, start_y, 0);\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0, empty = 1;\\n    void dfs(vector<vector<int>>& grid, int x, int y, int count) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1) return;\\n        \\n        if (grid[x][y] == 2) {\\n            if(empty == count) res++; \\n            return;\\n        }\\n        \\n        grid[x][y] = -1;\\n        \\n        dfs(grid, x+1, y, count+1);\\n        dfs(grid, x-1, y, count+1);\\n        dfs(grid, x, y+1, count+1);\\n        dfs(grid, x, y-1, count+1);\\n        \\n        grid[x][y] = 0;\\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int start_x, start_y;\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1) start_x = i, start_y = j;\\n                else if (grid[i][j] == 0) empty++;\\n            }\\n        }\\n        \\n        dfs(grid, start_x, start_y, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221941,
                "title": "c-brute-force-dfs",
                "content": "First, we find our startig point (```i1, j1```) and count the number of empty cells. We then do DFS, marking visited elements and tracking number of steps (```s```). If we reach the target, and number of steps matches the number of empty cells (``` s == t_s```) - we found a path.\\n```\\nint dfs(vector<vector<int>>& g, int i, int j, int s, int t_s) {\\n  if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1) return 0;\\n  if (g[i][j] == 2) return s == t_s ? 1 : 0;\\n  g[i][j] = -1;\\n  int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n  g[i][j] = 0;\\n  return paths;\\n}\\nint uniquePathsIII(vector<vector<int>>& g) {\\n  auto i1 = 0, j1 = 0, t_steps = 0;\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[0].size(); ++j) {\\n      if (g[i][j] == 1) i1 = i, j1 = j;\\n      if (g[i][j] != -1) ++t_steps;\\n    }\\n  return dfs(g, i1, j1, 1, t_steps);\\n}\\n```\\n## Complexity Analysis\\nRuntime: O(3 ^ n), where n is the total number of cells without obstacles.\\nMemory: O(n) for the DFS stack.",
                "solutionTags": [],
                "code": "```i1, j1```\n```s```\n``` s == t_s```\n```\\nint dfs(vector<vector<int>>& g, int i, int j, int s, int t_s) {\\n  if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1) return 0;\\n  if (g[i][j] == 2) return s == t_s ? 1 : 0;\\n  g[i][j] = -1;\\n  int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n  g[i][j] = 0;\\n  return paths;\\n}\\nint uniquePathsIII(vector<vector<int>>& g) {\\n  auto i1 = 0, j1 = 0, t_steps = 0;\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[0].size(); ++j) {\\n      if (g[i][j] == 1) i1 = i, j1 = j;\\n      if (g[i][j] != -1) ++t_steps;\\n    }\\n  return dfs(g, i1, j1, 1, t_steps);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1535158,
                "title": "python-backtracking-easy-to-understand-with-explanation",
                "content": "### Introduction\\n\\nThe goal is to travel through the ```grid``` from the starting point (```grid[x][y] == 1```) to the ending point (```grid[x][y] == 2```) while visiting every non-obstacle coordinate (```grid[x][y] == 0```). We can split the problem up into 3 parts:\\n\\n1. How do we know where to start and where to end?\\n2. How do we know if we\\'ve visited every non-obstacle coordinate?\\n3. At each coordinate ```(x, y)```, how do we tell where we can move to next?\\n\\n---\\n\\n### Part 1: Finding our starting and ending points\\n\\nYes, admittedly this is very trivial, but its the first thing I want to settle before we move on to tackle the more difficult logic. The reason this part is even needed in the first place is because the starting and ending points can be anywhere in the given grid, unlike most other grid-traversing problems where the starting and ending positions are fixed.\\n\\nThe simplest of implementations to find the starting and ending points would be:\\n\\n```python\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\tstart = end = None\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\tstart = (i, j)\\n\\t\\t\\telif grid[i][j] == 2:\\n\\t\\t\\t\\tend = (i, j)\\n\\tpass  # main logic here\\n```\\n\\nThis is the most brute-force solution with O(mn) time complexity, but it does the job. We could optimise it further of course:\\n\\n- Break after ```start``` and ```end``` are found (i.e. not ```None```)\\n- Flattening the ```grid``` and using basic math to determine the positions of ```start``` and ```end```\\n\\nFor now, let\\'s leave it as it is. (We\\'ll come back to it in Part 2)\\n\\n---\\n\\n### Part 2: Keeping track of the success condition\\n\\nWhen we finally reach the ending point, we need to know if the path we took was valid. Given the criteria that determine the validity of a path, we have the following implications:\\n\\n1. **We need to know the positions of all non-obstacle coordinates before we traverse the grid.**\\n\\nOtherwise, we won\\'t be able to tell if we\\'ve visited all of them. This also implies that we cannot determine the positions dynamically; if we try to check for all adjacent non-obstacle coordinates at every ```(x, y)```, we will end up having to check ```grid``` again once we reach the end to determine path validity.\\n\\nThis means we need some kind of data structure to store the non-obstacle coordinates. Then, at each coordinate ```(x, y)```, we can check if the adjacent coordinates are non-obstacles, and update the data structure accordingly. This helps us when we get to the ending point, since we can check for some property of the data structure (size, most likely) to immediately determine if the path is valid.\\n\\n2. **We need to keep track of the \\'visited status\\' of each non-obstacle coordinate at all times.**\\n\\nOtherwise, we may end up crossing our paths, or miss one non-obstacle coordinate out in our traversion. Since each non-obstacle coordinate only needs to be visited once, the data structure storing these non-obstacle coordinates double up as an array of \\'flags\\': their presence in the data structure can serve to indicate whether or not they have been visited (depending on implementation).\\n\\nIn consideration of these 2 implications, my implementation is to use a set as the data structure. Before traversion, we can store all non-obstacle coordinates into the set. Then, during traversion, we can check if a coordinate is non-obstacle by checking if it is present in the set, and remove each coordinate when we visit it.\\n\\nThe advantage of this implementation is twofold:\\n\\n- **The functions we need from the set data structure can all be done in O(1) average time complexity**. You can read more about the time complexities [here](https://wiki.python.org/moin/TimeComplexity). The operations we are particularly interested in are ```x in s```, insertion, and deletion (from dict). Hence, apart from the O(mn) auxiliary space, there is no considerable overhead to take into consideration.\\n- **We can find all non-obstacle coordinates while finding the starting and ending points simultaneously**. In comparison with potentially faster methods like flattening ```grid```, the brute-force algorithm that we used earlier (see Part 1) is much better for finding multiple coordinates, since we have no idea how many non-obstacle coordinates there are or where to look for them.\\n\\n```python\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\tstart = end = None\\n\\tvisit = set()  # non-obstacle coordinates to visit for path to be valid\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\tstart = (i, j)\\n\\t\\t\\telif grid[i][j] == 2:\\n\\t\\t\\t\\tend = (i, j)\\n\\t\\t\\t\\tvisit.add(end)  # of course, we need to visit the end coordinate too!\\n\\t\\t\\telif grid[i][j] == 0:\\n\\t\\t\\t\\tvisit.add((i, j))  # non-obstacle coordinate; add to visit\\n\\tpass  # main logic here\\n```\\n\\n**EDIT:** I missed this myself, but there is a way to utilise O(1) auxiliary space after all. Simply 1) having a counter to keep track of how many non-obstacle coordinates we have left to visit while 2) modifying `grid` in-place once we visit these coordinates to denote \\'visited\\' status is good enough. Credit to [@pedro](https://leetcode.com/pedro/) for spotting this improvement. You can view the edited implementation below.\\n\\n---\\n\\n### Part 3: Moving through the grid\\n\\nObviously, we don\\'t actually know if a particular adjacent non-obstacle coordinate will be good or not (i.e. part of the valid path, if any) until we actually try to traverse through the coordinate. This is where backtracking comes in: We can just move to any adjacent non-obstacle coordinate, and if it (eventually) leads to a dead end or an invalid path, we can \\'return\\' (backtrack) to the current coordinate and try again with a different non-obstacle coordinate.\\n\\nThere are a few considerations:\\n\\n- A given coordinate can be the diverging point for multiple valid paths. In other words, for a given coordinate ```(x, y)```, any combination of the adjacent coordinates ```(x-1, y)```, ```(x+1, y)```, ```(x, y-1)```, ```(x, y+1)``` can lead to valid paths (if those coordinates are non-obstacles). This means that **even if we do find a valid path, we still need to \\'return\\' back to the current coordinate and try again for all possible adjacent coordinates**.\\n- Upon \\'returning\\' to a given coordinate, we need to likewise \\'un-visit\\' the coordinate we came from. This means that **we need to add the coordinate back into the set before we try a different path**.\\n- The success condition in all of this backtracking is when we reach the ending point with no more coordinates to visit (i.e. the set is empty). We then need to **relay this information back to previous coordinates to consolidate all possible paths, all the way until we backtrack back to the starting point**.\\n\\n---\\n\\n### Implementation\\n\\nOriginal Answer (using set):\\n\\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\t\\t# first, prepare the starting and ending points\\n\\t\\t# simultaneously, record all the non-obstacle coordinates\\n        start = end = None\\n        visit = set()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 1:\\n                    start = (i, j)\\n                elif grid[i][j] == 2:\\n                    end = (i, j)\\n                    visit.add((i, j))\\n        \\n        def backtrack(x, y, visit):\\n            if (x, y) == end:\\n\\t\\t\\t\\t# implement success condition: valid only if there are no more coordinates to visit\\n                return len(visit) == 0\\n            result = 0  # assume no valid paths by default\\n\\t\\t\\t\\n\\t\\t\\t# we need to try every possible path from this coordinate\\n            if (x-1, y) in visit:\\n\\t\\t\\t\\t# the coordinate directly above this one is non-obstacle, try that path\\n                visit.remove((x-1, y))  # first, note down the \\'visited status\\' of the coordinate\\n                result += backtrack(x-1, y, visit)  # then, DFS to find all valid paths from that coordinate\\n                visit.add((x-1, y))  # last, reset the \\'visited status\\' of the coordinate\\n            if (x+1, y) in visit:\\n\\t\\t\\t\\t# the coordinate directly below this one is non-obstacle, try that path\\n                visit.remove((x+1, y))\\n                result += backtrack(x+1, y, visit)\\n                visit.add((x+1, y))\\n            if (x, y-1) in visit:\\n\\t\\t\\t\\t# the coordinate directly to the left of this one is non-obstacle, try that path\\n                visit.remove((x, y-1))\\n                result += backtrack(x, y-1, visit)\\n                visit.add((x, y-1))\\n            if (x, y+1) in visit:\\n\\t\\t\\t\\t# the coordinate directly to the right of this one is non-obstacle, try that path\\n                visit.remove((x, y+1))\\n                result += backtrack(x, y+1, visit)\\n                visit.add((x, y+1))\\n            return result\\n        \\n        return backtrack(start[0], start[1], visit)  # we start from the starting point, backtrack all the way back, and consolidate the result\\n```\\n\\n**EDIT:** Optimised answer (based on comments):\\n\\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # iterate through the grid to get relevant info\\n        start = None  # to store starting point\\n        count = 0  # to count number of squares to walk over\\n        for i in range(m):\\n            for j in range(n):\\n                count += grid[i][j] == 0\\n                if not start and grid[i][j] == 1:\\n                    start = (i, j)\\n        \\n        def backtrack(i: int, j: int) -> int:\\n            \"\"\"\\n            Backtracking algo to find all valid paths from (i, j).\\n            :param i: Index of row (where top = 0) of coordinate.\\n            :param j: Index of column (where left = 0) of coordinate.\\n            :returns: Total number of valid paths from (i, j).\\n            \"\"\"\\n            nonlocal count\\n            result = 0\\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                # border check\\n                if 0 <= x < m and 0 <= y < n:\\n                    if grid[x][y] == 0:\\n                        # traverse down this path\\n                        grid[x][y] = -1\\n                        count -= 1\\n                        result += backtrack(x, y)\\n                        # backtrack and reset\\n                        grid[x][y] = 0\\n                        count += 1\\n                    elif grid[x][y] == 2:\\n                        # check if all squares have been walked over\\n                        result += count == 0\\n            return result\\n        \\n        # perform DFS + backtracking to find valid paths\\n        return backtrack(start[0], start[1])\\n```\\n\\nBased on my submission results, there seems to be a slight improvement in both runtime and memory usage.\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/140c97c4-599e-407a-be5d-b6dc90620dc6_1634923959.5940614.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```grid```\n```grid[x][y] == 1```\n```grid[x][y] == 2```\n```grid[x][y] == 0```\n```(x, y)```\n```python\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\tstart = end = None\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\tstart = (i, j)\\n\\t\\t\\telif grid[i][j] == 2:\\n\\t\\t\\t\\tend = (i, j)\\n\\tpass  # main logic here\\n```\n```start```\n```end```\n```None```\n```grid```\n```start```\n```end```\n```(x, y)```\n```grid```\n```(x, y)```\n```x in s```\n```grid```\n```python\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\tstart = end = None\\n\\tvisit = set()  # non-obstacle coordinates to visit for path to be valid\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\tstart = (i, j)\\n\\t\\t\\telif grid[i][j] == 2:\\n\\t\\t\\t\\tend = (i, j)\\n\\t\\t\\t\\tvisit.add(end)  # of course, we need to visit the end coordinate too!\\n\\t\\t\\telif grid[i][j] == 0:\\n\\t\\t\\t\\tvisit.add((i, j))  # non-obstacle coordinate; add to visit\\n\\tpass  # main logic here\\n```\n```(x, y)```\n```(x-1, y)```\n```(x+1, y)```\n```(x, y-1)```\n```(x, y+1)```\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\t\\t# first, prepare the starting and ending points\\n\\t\\t# simultaneously, record all the non-obstacle coordinates\\n        start = end = None\\n        visit = set()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 1:\\n                    start = (i, j)\\n                elif grid[i][j] == 2:\\n                    end = (i, j)\\n                    visit.add((i, j))\\n        \\n        def backtrack(x, y, visit):\\n            if (x, y) == end:\\n\\t\\t\\t\\t# implement success condition: valid only if there are no more coordinates to visit\\n                return len(visit) == 0\\n            result = 0  # assume no valid paths by default\\n\\t\\t\\t\\n\\t\\t\\t# we need to try every possible path from this coordinate\\n            if (x-1, y) in visit:\\n\\t\\t\\t\\t# the coordinate directly above this one is non-obstacle, try that path\\n                visit.remove((x-1, y))  # first, note down the \\'visited status\\' of the coordinate\\n                result += backtrack(x-1, y, visit)  # then, DFS to find all valid paths from that coordinate\\n                visit.add((x-1, y))  # last, reset the \\'visited status\\' of the coordinate\\n            if (x+1, y) in visit:\\n\\t\\t\\t\\t# the coordinate directly below this one is non-obstacle, try that path\\n                visit.remove((x+1, y))\\n                result += backtrack(x+1, y, visit)\\n                visit.add((x+1, y))\\n            if (x, y-1) in visit:\\n\\t\\t\\t\\t# the coordinate directly to the left of this one is non-obstacle, try that path\\n                visit.remove((x, y-1))\\n                result += backtrack(x, y-1, visit)\\n                visit.add((x, y-1))\\n            if (x, y+1) in visit:\\n\\t\\t\\t\\t# the coordinate directly to the right of this one is non-obstacle, try that path\\n                visit.remove((x, y+1))\\n                result += backtrack(x, y+1, visit)\\n                visit.add((x, y+1))\\n            return result\\n        \\n        return backtrack(start[0], start[1], visit)  # we start from the starting point, backtrack all the way back, and consolidate the result\\n```\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # iterate through the grid to get relevant info\\n        start = None  # to store starting point\\n        count = 0  # to count number of squares to walk over\\n        for i in range(m):\\n            for j in range(n):\\n                count += grid[i][j] == 0\\n                if not start and grid[i][j] == 1:\\n                    start = (i, j)\\n        \\n        def backtrack(i: int, j: int) -> int:\\n            \"\"\"\\n            Backtracking algo to find all valid paths from (i, j).\\n            :param i: Index of row (where top = 0) of coordinate.\\n            :param j: Index of column (where left = 0) of coordinate.\\n            :returns: Total number of valid paths from (i, j).\\n            \"\"\"\\n            nonlocal count\\n            result = 0\\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                # border check\\n                if 0 <= x < m and 0 <= y < n:\\n                    if grid[x][y] == 0:\\n                        # traverse down this path\\n                        grid[x][y] = -1\\n                        count -= 1\\n                        result += backtrack(x, y)\\n                        # backtrack and reset\\n                        grid[x][y] = 0\\n                        count += 1\\n                    elif grid[x][y] == 2:\\n                        # check if all squares have been walked over\\n                        result += count == 0\\n            return result\\n        \\n        # perform DFS + backtracking to find valid paths\\n        return backtrack(start[0], start[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973622,
                "title": "java-code-with-dfs-and-backtracking-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0 , a = 0, b = 0 ;\\n        for(int r = 0; r < grid.length ; r++){\\n            for(int c = 0; c < grid[0].length; c++){\\n                if(grid[r][c] == 0)   zero++;\\n                   else if(grid[r][c] == 1){\\n                    a = r;\\n                    b = c;\\n                }\\n            }\\n        }\\n        return path(grid, a, b, zero);\\n    }\\n    private int path(int[][] grid, int x, int y, int zero){\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == -1)\\n           return 0;\\n        if(grid[x][y] == 2)\\n           return zero == -1 ? 1 : 0;\\n        grid[x][y] = -1;\\n        zero--;\\n        int totalCount = path(grid, x + 1, y, zero) + path(grid, x, y + 1, zero) +\\n                         path(grid, x - 1, y, zero) + path(grid, x, y - 1, zero);\\n        grid[x][y] = 0;\\n        zero++;\\n\\n        return totalCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0 , a = 0, b = 0 ;\\n        for(int r = 0; r < grid.length ; r++){\\n            for(int c = 0; c < grid[0].length; c++){\\n                if(grid[r][c] == 0)   zero++;\\n                   else if(grid[r][c] == 1){\\n                    a = r;\\n                    b = c;\\n                }\\n            }\\n        }\\n        return path(grid, a, b, zero);\\n    }\\n    private int path(int[][] grid, int x, int y, int zero){\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == -1)\\n           return 0;\\n        if(grid[x][y] == 2)\\n           return zero == -1 ? 1 : 0;\\n        grid[x][y] = -1;\\n        zero--;\\n        int totalCount = path(grid, x + 1, y, zero) + path(grid, x, y + 1, zero) +\\n                         path(grid, x - 1, y, zero) + path(grid, x, y - 1, zero);\\n        grid[x][y] = 0;\\n        zero++;\\n\\n        return totalCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554054,
                "title": "c-dfs-backtracking-bit-manipulation-short-simple-w-explanation-beats-100",
                "content": "\\nWe are given a `m x n` grid in which we need to find the number of distinct paths visiting every cell exactly once (except obstacle cells with value -1) starting from cell with value 1 and ending at cell with value 2.\\n\\n\\n<details open>\\n<summary><b>Try Solving using Hint</b></summary>\\n\\n1. Observe that we need to explore all adjacent cells from current cell since we dont which cell might be valid. Try brute-force\\n2. Recursively explore from each cell. Discard invalid paths (reached obstacle, visited multiple times, etc)\\n</details>\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Backtracking + DFS)***\\n\\n\\nThere isn\\'t a specific strategy that we can apply to choose our paths since we dont initially know what a cell value might be and so we must **explore the whole grid exhaustively**, visiting one cell after another, starting from `G[i][j] = 1`. If at any point we -\\n* reach an obstacle or,\\n* visit an empty cell twice or,\\n* reach end cell without visiting each empty cells,\\n\\nthen we know that we have **reached an invalid path**. We will discard this path or in other words, we will **backtrack** from the current point and explore other options.  We also need to mark a cell so that we know that this cell is visited. We do this by changing a visited cell value to `3` (if input modification isn\\'t allowed - see below). We change it back to `0` if we backtrack.\\n\\nWe continue the above process till we reach the end cell and have visited all empty cells once. At this point, we have found a valid path and we increment the resultant count.\\n\\nWe don\\'t know the starting cell of the grid nor do we know the number of empty cells. So, we iterate over the grid once to find the start cell and number of cells to visit. Then we call our **backtracking DFS function from start cell** and follow the process described above.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& G) {\\n        int startRow, startCol, cellsToVisit = 0;\\n        for(int i = 0; i < size(G); i++)\\n            for(int j = 0; j < size(G[0]); j++) \\n                if(G[i][j] == 1) startRow = i, startCol = j;\\n                else if(G[i][j] != -1) cellsToVisit++;\\n\\t\\t\\t\\t\\n        dfs(G, startRow, startCol, cellsToVisit);\\n        return ans;\\n    }\\nprivate:\\n    int ans = 0, dir[5] {0, 1, 0, -1, 0};  // <- a common way to make 4-way exploration in dfs concise\\n\\t\\n\\t// checks if cell is valid. If none of 3 points mentioned in post is satisfied, it is a valid cell\\n    bool isValidCell(vector<vector<int>>& G, int i, int j) {\\n        return i >= 0 && j >= 0 && i < size(G) && j < size(G[0]) && G[i][j] != -1 && G[i][j] != 3;\\n    }\\n\\t\\n    void dfs(vector<vector<int>>& G, int i, int j, int cellsToVisit) {\\n        if(not isValidCell(G, i, j)) return;   // return if cell is invalid\\n        if(G[i][j] == 2) {                     // reached end cell\\n            if(cellsToVisit == 0) ans++;       // if all cells are visited, increment valid path count\\n            return;                            // no further exploration possible after reaching end cell\\n        }\\n        G[i][j] = 3;                           // mark cell as visited\\n        for(int k = 0; k < 4; k++)             // explore path futher 4-directionally\\n            dfs(G, i + dir[k], j + dir[k+1], cellsToVisit - 1);    \\n        G[i][j] = 0;                           // backtrack\\n    }        \\n};\\n```\\n\\n***Time Complexity :*** **<code>O(3<sup>m * n</sup>)</code>**. At every cell (except the start cell), we can continue the path exploration in 3 direction (after excuding previous visited cell) and there can be `O(m*n)` cells in total to be visited. In reality, the number of recursions required is much less due to dead-ends.\\n***Space Complexity :*** **`O(m*n)`** required for implicit recursive stack in `dfs`.\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Backtracking + DFS + Bit Manipulation)***\\n\\nIn the above solution, we were marking a visited cell by changing the grid\\'s cell value. If the input grid cannot be modified, we can use auxillary boolean matrix or make a copy of grid. However, an elegant solution is to use bitmask. This works because the grid is small enough to fit within integer bits (`m * n <= 20`).\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& G) {\\n        int startRow, startCol, mask = 0;\\n        m = size(G), n = size(G[0]);\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++) {\\n                if(G[i][j] == 1) startRow = i, startCol = j;\\n                if(G[i][j] != -1) mask |= 1 << i*n+j;       // set bits of cells that need to be visited\\n            }\\n\\n        dfs(G, startRow, startCol, mask);\\n        return ans;\\n    }\\nprivate:\\n    int m, n, ans = 0, dir[5] {0, 1, 0, -1, 0}; \\n    bool isValidCell(vector<vector<int>>& G, int i, int j, int mask) {\\n        return i >= 0 && j >= 0 && i < size(G) && j < size(G[0]) && G[i][j] != -1 && mask & 1 << i*n+j;\\n    }\\n\\t\\n    void dfs(vector<vector<int>>& G, int i, int j, int mask) {\\n        if(not isValidCell(G, i, j, mask)) return;\\n        mask ^= 1 << i*n+j;                                  // mark as visited by unsetting bit\\n        if(G[i][j] == 2) {       \\n            if(!mask) ans++;                                 // valid path if all required cells are visited\\n            return;              \\n        }\\n        for(int k = 0; k < 4; k++)\\n            dfs(G, i + dir[k], j + dir[k+1], mask);\\n    }        \\n};\\n```\\n\\n***Time Complexity :*** **<code>O(3<sup>m * n</sup>)</code>**\\n***Space Complexity :*** **`O(m*n)`** \\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& G) {\\n        int startRow, startCol, cellsToVisit = 0;\\n        for(int i = 0; i < size(G); i++)\\n            for(int j = 0; j < size(G[0]); j++) \\n                if(G[i][j] == 1) startRow = i, startCol = j;\\n                else if(G[i][j] != -1) cellsToVisit++;\\n\\t\\t\\t\\t\\n        dfs(G, startRow, startCol, cellsToVisit);\\n        return ans;\\n    }\\nprivate:\\n    int ans = 0, dir[5] {0, 1, 0, -1, 0};  // <- a common way to make 4-way exploration in dfs concise\\n\\t\\n\\t// checks if cell is valid. If none of 3 points mentioned in post is satisfied, it is a valid cell\\n    bool isValidCell(vector<vector<int>>& G, int i, int j) {\\n        return i >= 0 && j >= 0 && i < size(G) && j < size(G[0]) && G[i][j] != -1 && G[i][j] != 3;\\n    }\\n\\t\\n    void dfs(vector<vector<int>>& G, int i, int j, int cellsToVisit) {\\n        if(not isValidCell(G, i, j)) return;   // return if cell is invalid\\n        if(G[i][j] == 2) {                     // reached end cell\\n            if(cellsToVisit == 0) ans++;       // if all cells are visited, increment valid path count\\n            return;                            // no further exploration possible after reaching end cell\\n        }\\n        G[i][j] = 3;                           // mark cell as visited\\n        for(int k = 0; k < 4; k++)             // explore path futher 4-directionally\\n            dfs(G, i + dir[k], j + dir[k+1], cellsToVisit - 1);    \\n        G[i][j] = 0;                           // backtrack\\n    }        \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& G) {\\n        int startRow, startCol, mask = 0;\\n        m = size(G), n = size(G[0]);\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++) {\\n                if(G[i][j] == 1) startRow = i, startCol = j;\\n                if(G[i][j] != -1) mask |= 1 << i*n+j;       // set bits of cells that need to be visited\\n            }\\n\\n        dfs(G, startRow, startCol, mask);\\n        return ans;\\n    }\\nprivate:\\n    int m, n, ans = 0, dir[5] {0, 1, 0, -1, 0}; \\n    bool isValidCell(vector<vector<int>>& G, int i, int j, int mask) {\\n        return i >= 0 && j >= 0 && i < size(G) && j < size(G[0]) && G[i][j] != -1 && mask & 1 << i*n+j;\\n    }\\n\\t\\n    void dfs(vector<vector<int>>& G, int i, int j, int mask) {\\n        if(not isValidCell(G, i, j, mask)) return;\\n        mask ^= 1 << i*n+j;                                  // mark as visited by unsetting bit\\n        if(G[i][j] == 2) {       \\n            if(!mask) ans++;                                 // valid path if all required cells are visited\\n            return;              \\n        }\\n        for(int k = 0; k < 4; k++)\\n            dfs(G, i + dir[k], j + dir[k+1], mask);\\n    }        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553873,
                "title": "java-easy-solution-dfs-backtracking-explanation-simplified",
                "content": "Hey Programmers,\\nI solve this problem using DFS + Backtracking approach\\n\\n* First find out where the start and the end is.\\n* Also We need to know the number of empty cells.\\n* We try to explore a cell,\\n* Let\\'s understand it using an example :- \\n\\n![image](https://assets.leetcode.com/users/images/cab2469b-d1b5-4b6a-9b26-31c641fe9608_1635817324.7521498.png)\\n\\n* it will change 0 to -1 and do a dfs in 4 direction.\\n\\n* If we hit the target and pass all empty cells, increment the result.\\n\\n![image](https://assets.leetcode.com/users/images/83e606a6-26fd-4ef4-9ce0-45625d353d4b_1635817420.0894692.png)\\n\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0; // Count the 0\\'s\\n        int sx = 0; // starting x index\\n        int sy = 0; // starting y index\\n        \\n        for(int r = 0; r < grid.length; r++){ // r = row\\n            for(int c = 0; c < grid[0].length; c++){ // c = column\\n                if(grid[r][c] == 0) zero++; // if current cell is 0, count it.\\n                else if(grid[r][c] == 1){\\n                    sx = r; // starting x co-ordinate\\n                    sy = c; // starting y co-ordinate\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n    public int dfs(int grid[][], int x, int y, int zero){\\n        // Base Condition\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == -1){\\n            return 0;\\n        }\\n        if(grid[x][y] == 2){\\n            return zero == -1 ? 1 : 0; // Why zero = -1, because in above example we have 9 zero\\'s. So, when we reach the final cell we are covering one cell extra then the zero count. \\n            // If that\\'s the case we find the path and return \\'1\\' otherwise return \\'0\\';\\n        }\\n        grid[x][y] = -1; // mark the visited cells as -1;\\n        zero--; // and reduce the zero by 1\\n        \\n        int totalPaths = dfs(grid, x + 1, y, zero) + // calculating all the paths available in 4 directions\\n            dfs(grid, x - 1, y, zero) + \\n            dfs(grid, x, y + 1, zero) + \\n            dfs(grid, x, y - 1, zero);\\n        \\n        // Let\\'s say if we are not able to count all the paths. Now we use Backtracking over here\\n        grid[x][y] = 0;\\n        zero++;\\n        \\n        return totalPaths; // if we get all the paths, simply return it.\\n    }\\n}\\n```\\n\\nI hope this will help you to understand. Thanks (:",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0; // Count the 0\\'s\\n        int sx = 0; // starting x index\\n        int sy = 0; // starting y index\\n        \\n        for(int r = 0; r < grid.length; r++){ // r = row\\n            for(int c = 0; c < grid[0].length; c++){ // c = column\\n                if(grid[r][c] == 0) zero++; // if current cell is 0, count it.\\n                else if(grid[r][c] == 1){\\n                    sx = r; // starting x co-ordinate\\n                    sy = c; // starting y co-ordinate\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n    public int dfs(int grid[][], int x, int y, int zero){\\n        // Base Condition\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == -1){\\n            return 0;\\n        }\\n        if(grid[x][y] == 2){\\n            return zero == -1 ? 1 : 0; // Why zero = -1, because in above example we have 9 zero\\'s. So, when we reach the final cell we are covering one cell extra then the zero count. \\n            // If that\\'s the case we find the path and return \\'1\\' otherwise return \\'0\\';\\n        }\\n        grid[x][y] = -1; // mark the visited cells as -1;\\n        zero--; // and reduce the zero by 1\\n        \\n        int totalPaths = dfs(grid, x + 1, y, zero) + // calculating all the paths available in 4 directions\\n            dfs(grid, x - 1, y, zero) + \\n            dfs(grid, x, y + 1, zero) + \\n            dfs(grid, x, y - 1, zero);\\n        \\n        // Let\\'s say if we are not able to count all the paths. Now we use Backtracking over here\\n        grid[x][y] = 0;\\n        zero++;\\n        \\n        return totalPaths; // if we get all the paths, simply return it.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855647,
                "title": "python-simple-dfs-backtracking-explained",
                "content": "If you look carefully at your problem constraints: `m*n <= 20`, where `m` and `n` your grid sizes, we can guess, that we need to use dfs in this problem: that is try to check all possible options. So, we need to do several steps:\\n\\n1. Find our starting point: traverse all grid and find cell with value `1`. Also count number of cells we need to visit, I denoted them `empty`.\\n2. Now, use recursive `dfs(x,y, rest)` function, where `x` and `y` are current coordinates in our cell and `rest` is how many empty cells we need to traverse.\\n2.1 First we check if we can move to the current cell: if it is outside our grid and it is already visited or have obstacle, we return\\n2.2 If current cell is end cell and we already visited all cells, we add `1` to `self.ans`.\\n2.3 Define list of neighbours and for each of them run our `dfs`: mark visited cell with `-2` and then mark it back when we go outside recursion. It is important to do this, because in python `grid` is global variable and we need to change it back.\\n3. FInally, we just run `dfs(sx, sy, empty - 1)`, where `(sx, sy)` is coordinates of starting cell and return `self.ans`.\\n\\n**Complexity**: Space complexity is `O(mn)`, this is the possible biggest length of our recursion stack. Time complexity is `O(3^(mn))`, because on each step (except first) we have no more than `3` options to go: all directions except direction we came from. In practice however it will work much faster than this estimate because of big number of dead-ends\\n\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid):\\n        self.ans, empty = 0, 0\\n        m, n = len(grid[0]), len(grid)\\n        def dfs(x, y, rest):\\n            if x < 0 or x >= n or y < 0 or y >= m or  grid[x][y] < 0: return\\n            if grid[x][y] == 2 and rest == 0:\\n                self.ans += 1\\n            \\n            neibs = [[0,1],[0,-1],[1,0],[-1,0]]\\n            for dx, dy in neibs:\\n                save = grid[x][y]\\n                grid[x][y] = -2\\n                dfs(x+dx, y+dy, rest - 1)\\n                grid[x][y] = save\\n            \\n        for i,j in product(range(n), range(m)):\\n            if grid[i][j] == 1: (sx, sy) = (i,j)\\n            empty += (grid[i][j] != -1)\\n\\n        dfs(sx, sy, empty-1)\\n        return self.ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid):\\n        self.ans, empty = 0, 0\\n        m, n = len(grid[0]), len(grid)\\n        def dfs(x, y, rest):\\n            if x < 0 or x >= n or y < 0 or y >= m or  grid[x][y] < 0: return\\n            if grid[x][y] == 2 and rest == 0:\\n                self.ans += 1\\n            \\n            neibs = [[0,1],[0,-1],[1,0],[-1,0]]\\n            for dx, dy in neibs:\\n                save = grid[x][y]\\n                grid[x][y] = -2\\n                dfs(x+dx, y+dy, rest - 1)\\n                grid[x][y] = save\\n            \\n        for i,j in product(range(n), range(m)):\\n            if grid[i][j] == 1: (sx, sy) = (i,j)\\n            empty += (grid[i][j] != -1)\\n\\n        dfs(sx, sy, empty-1)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974068,
                "title": "c-dfs-backtracking-with-intuition-approach-and-comments",
                "content": "# Intuition\\nAs constraints are very less, we will try to implement it by exploring all possibilities from the each cell.\\n\\n# Approach\\nWe will keep count of empty cell `grid[i][j] == 0` in the variable `empty` and will have the start and end destination stored in the pair of integers `src` and `dest`.\\n\\nWe start the call from `{src.first, src.second, empty}`. Now for all `grid[i][j]` we have 4 possible directions. We will try all that and will see that anyone of that is yielding the desired solution or not. \\n\\n### State = `dfs(i, j, left)`\\n\\nAt this state, we are currently on the cell {i, j} and have the emplty cells as `left`. \\n\\nFirst of all let\\'s mark this cell as visited by assigning it the value of an obstacle. (for backtracking)\\n\\nNow initialize the `ans as 0` and iterate over all possible direction from the current cell. if the direction is valid and is not an obstacle then we will add the ans of that direction our current ans. Remember we have taken this cell in the path so the empty cell would now be equal to `left - 1`.\\n\\nIn short, `ans += dfs(x, y, left - 1);`\\n\\nAfter enumerating all the direction, we have to mark current cell as empty cell for the process of `backtracking`.\\n\\n### Base Case = `dfs(i, j, left)`\\nIf we have used all the empty cell i.e., `left == -1` and are at the destination, then we found the correct 4-directional walks. So return 1 for this state.\\n\\n# Code\\n```\\nclass Solution {\\n    // Dimensions \\n    int m, n;\\n\\n    // Direction Vectors\\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, -1, 1};\\n\\npublic:\\n    // function to check for the validity of CELLij\\n    bool isvalid(int i, int j)\\n    {\\n        return i >= 0 and j >= 0 and i < m and j < n;\\n    }\\n\\n    int dfs(int i, int j, int left, pair<int, int> dest, vector<vector<int>> &grid)\\n    {\\n        // Base case\\n        if (left == -1 and pair<int, int>(i, j) == dest)\\n            return 1;\\n\\n        // Mark visited\\n        grid[i][j] = -1;\\n\\n        int ans = 0;\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n\\n            // Add up all possibilities to answer\\n            if (isvalid(x, y) and grid[x][y] != -1)\\n                ans += dfs(x, y, left - 1, dest, grid);\\n        }\\n\\n        // Backtrack\\n        grid[i][j] = 0;\\n\\n        return ans;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>> &grid)\\n    {\\n        m = grid.size(), n = grid[0].size();\\n\\n        pair<int, int> src, dest;\\n        int empty = 0;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0)\\n                    empty++;\\n                if (grid[i][j] == 1)\\n                    src = {i, j};\\n                if (grid[i][j] == 2)\\n                    dest = {i, j};\\n            }\\n        }\\n\\n        return dfs(src.first, src.second, empty, dest, grid);\\n    }\\n};\\n```\\n\\nIf you like it, Please Upvote !!. Also check my [repo](https://github.com/jatin1510/Templates) for amazing templates of CP and DSA.",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    // Dimensions \\n    int m, n;\\n\\n    // Direction Vectors\\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, -1, 1};\\n\\npublic:\\n    // function to check for the validity of CELLij\\n    bool isvalid(int i, int j)\\n    {\\n        return i >= 0 and j >= 0 and i < m and j < n;\\n    }\\n\\n    int dfs(int i, int j, int left, pair<int, int> dest, vector<vector<int>> &grid)\\n    {\\n        // Base case\\n        if (left == -1 and pair<int, int>(i, j) == dest)\\n            return 1;\\n\\n        // Mark visited\\n        grid[i][j] = -1;\\n\\n        int ans = 0;\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n\\n            // Add up all possibilities to answer\\n            if (isvalid(x, y) and grid[x][y] != -1)\\n                ans += dfs(x, y, left - 1, dest, grid);\\n        }\\n\\n        // Backtrack\\n        grid[i][j] = 0;\\n\\n        return ans;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>> &grid)\\n    {\\n        m = grid.size(), n = grid[0].size();\\n\\n        pair<int, int> src, dest;\\n        int empty = 0;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0)\\n                    empty++;\\n                if (grid[i][j] == 1)\\n                    src = {i, j};\\n                if (grid[i][j] == 2)\\n                    dest = {i, j};\\n            }\\n        }\\n\\n        return dfs(src.first, src.second, empty, dest, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289954,
                "title": "java-solution-dfs-with-backtracking",
                "content": "**Idea**\\nSince the requirement is to touch every empty cell exactly once, we need `dfs` and maintain a step count `count` for the recursive path and when we reach destination, we compare how many empty cells we covered.\\nTo avoid cycles in the path, we mark the cells in the current dfs path as blockers and remove them while coming back.\\n\\n```\\npublic int uniquePathsIII(int[][] g) {\\n        int x = 0, y = 0, empty = 0;\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    ++empty;\\n                else if(g[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n\\n        return dfs(g, x, y, -1, empty);\\n    }\\n    private int dfs(int[][] g, int i, int j, int count, int need){\\n        if(i < 0 || i == g.length || j < 0 || j == g[0].length || g[i][j] == -1) return 0;\\n        if(g[i][j] == 2){\\n            if(count == need)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        g[i][j] = -1;\\n        int total = dfs(g, i-1, j, count+1, need);\\n        total += dfs(g, i, j+1, count+1, need);\\n        total += dfs(g, i+1, j, count+1, need);\\n        total += dfs(g, i, j-1, count+1, need);\\n        g[i][j] = 0;\\n        return total;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int uniquePathsIII(int[][] g) {\\n        int x = 0, y = 0, empty = 0;\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    ++empty;\\n                else if(g[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n\\n        return dfs(g, x, y, -1, empty);\\n    }\\n    private int dfs(int[][] g, int i, int j, int count, int need){\\n        if(i < 0 || i == g.length || j < 0 || j == g[0].length || g[i][j] == -1) return 0;\\n        if(g[i][j] == 2){\\n            if(count == need)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        g[i][j] = -1;\\n        int total = dfs(g, i-1, j, count+1, need);\\n        total += dfs(g, i, j+1, count+1, need);\\n        total += dfs(g, i+1, j, count+1, need);\\n        total += dfs(g, i, j-1, count+1, need);\\n        g[i][j] = 0;\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554601,
                "title": "java-simple-and-readable-solution-dfs-backtracking",
                "content": "**Problem statement at a glance:** So, a m x n matrix is given with a \\'1\\', \\'2\\' ,\\'-1\\' and \\'0\\'s. We need to find all valid paths and for a path from 1 -> 2, and we must cover all 0\\'s exactly once.\\n**Approach:**\\n1. First calculate total number of zeros we need to cover and starting cell indices.\\n2. Make a DFS Call. It is used to traverse four directions for every cell.\\n3. Once you find a valid cell, make that cell as invalid and perform dfs for four directions and after that make it as valid (Backtrack), because that cell may be counted in other paths.\\n**Dry run/Pictorial representation of an example:**\\n![image](https://assets.leetcode.com/users/images/a99199e9-cfe4-42c0-95c4-f46b2cd29818_1635841909.3198805.png)\\n![image](https://assets.leetcode.com/users/images/3ceb86c4-34ae-46bd-98dc-79e73da16548_1635841988.6123862.png)\\n\\nCross ticks shows they are invalid. Sorry for the bad drawing\\uD83D\\uDE05\\n\\n**Time Complexity:** If we observe the dry run, atleast 1 cell will be invalid (It may repeat again...visited again). So the number of cells may be as follows:\\n   3 ~ 3^1\\n   3 3 3 ~ 3^2\\n   3 3 3 3 3 3 3 3 3 ~ 3^3\\n   .\\n   .\\n   .\\n   upto 3^n , here n is M * N\\n   So time complexity is O(3^(N * M )) \\n   **Space Complexity:**  O(M* N) - Total number of cells in grid. And it is due to recursive calls.\\n   \\n   **Code:**\\n   ```\\nclass Solution { \\n    // DFS function\\n    public int DFS(int [][]obstacleGrid,int i,int j,int totalZeros,int currentZeros)\\n    {\\n        // Checking whether current position is valid or not\\n        if(i<0 || i>=obstacleGrid.length || j<0 || j>=obstacleGrid[0].length)\\n            return 0;\\n        // If current cell is an obstacle ,then we cant proceed further, hence no path exists\\n        if(obstacleGrid[i][j]==-1)\\n            return 0;\\n        // If we found ending square then we got a path. But also take care of number of zeros traversed.\\n        if(obstacleGrid[i][j]==2 && totalZeros==currentZeros-1)\\n            return 1;\\n        else if(obstacleGrid[i][j]==2)\\n            return 0;\\n        // If all the above conditions were false, it means our cell is having 0 and we can move further, so first make that cell to be invalid.\\n        obstacleGrid[i][j]=-1;\\n        // Now, perform for the four directions of current cell\\n        int totalPaths=DFS(obstacleGrid,i+1,j,totalZeros,currentZeros+1)+\\n                       DFS(obstacleGrid,i-1,j,totalZeros,currentZeros+1)+\\n                       DFS(obstacleGrid,i,j+1,totalZeros,currentZeros+1)+ \\n                       DFS(obstacleGrid,i,j-1,totalZeros,currentZeros+1);\\n        // Backtrack=>Make that cell as valid so that we can use this cell for other paths.\\n        obstacleGrid[i][j]=0;\\n        // Finally return total number of valid paths.\\n        return totalPaths;\\n    }\\n   \\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int totalZeros=0,startX=0,startY=0;\\n        // Find total number of zeros, we should move exactly once and also find starting cell indices.\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    totalZeros++;\\n                if(grid[i][j]==1)\\n                {\\n                    startX=i;\\n                    startY=j;\\n                }\\n            }\\n        }\\n        // Calling DFS Function.\\n        return DFS(grid,startX,startY,totalZeros,0);\\n    }\\n}\\n```\\nThanks for reading! Please upvote and comment if you got a clear idea:)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution { \\n    // DFS function\\n    public int DFS(int [][]obstacleGrid,int i,int j,int totalZeros,int currentZeros)\\n    {\\n        // Checking whether current position is valid or not\\n        if(i<0 || i>=obstacleGrid.length || j<0 || j>=obstacleGrid[0].length)\\n            return 0;\\n        // If current cell is an obstacle ,then we cant proceed further, hence no path exists\\n        if(obstacleGrid[i][j]==-1)\\n            return 0;\\n        // If we found ending square then we got a path. But also take care of number of zeros traversed.\\n        if(obstacleGrid[i][j]==2 && totalZeros==currentZeros-1)\\n            return 1;\\n        else if(obstacleGrid[i][j]==2)\\n            return 0;\\n        // If all the above conditions were false, it means our cell is having 0 and we can move further, so first make that cell to be invalid.\\n        obstacleGrid[i][j]=-1;\\n        // Now, perform for the four directions of current cell\\n        int totalPaths=DFS(obstacleGrid,i+1,j,totalZeros,currentZeros+1)+\\n                       DFS(obstacleGrid,i-1,j,totalZeros,currentZeros+1)+\\n                       DFS(obstacleGrid,i,j+1,totalZeros,currentZeros+1)+ \\n                       DFS(obstacleGrid,i,j-1,totalZeros,currentZeros+1);\\n        // Backtrack=>Make that cell as valid so that we can use this cell for other paths.\\n        obstacleGrid[i][j]=0;\\n        // Finally return total number of valid paths.\\n        return totalPaths;\\n    }\\n   \\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int totalZeros=0,startX=0,startY=0;\\n        // Find total number of zeros, we should move exactly once and also find starting cell indices.\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    totalZeros++;\\n                if(grid[i][j]==1)\\n                {\\n                    startX=i;\\n                    startY=j;\\n                }\\n            }\\n        }\\n        // Calling DFS Function.\\n        return DFS(grid,startX,startY,totalZeros,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221965,
                "title": "java-dfs-with-memo",
                "content": "Some notes:\\n1. `dfs()`: returns the number of valid paths from current status to the destination.\\n2. `cur`: the number of visited squares.\\n3. `total`: the number of squares need to be visited in the grid.\\n\\nTime: N^2 * 2^N, where N is grid.length * grid[0].length\\nSpace: N * 2^N\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int x = -1, y = -1, m = grid.length, n = grid[0].length, total = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n                if (grid[i][j] == 0) {\\n                    total++;\\n                }\\n            }\\n        }\\n        return dfs(grid, x, y, 0, total + 1, new HashMap<>());\\n    }\\n    private int dfs(int[][] grid, int x, int y, int cur, int total, Map<String, Integer> memo) {\\n        int m = grid.length, n = grid[0].length;\\n        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == -1) {\\n            return 0;\\n        }\\n        if (grid[x][y] == 2) {\\n            if (total == cur) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        grid[x][y] = -1;\\n        String key = getKey(grid) + \" \" + x + \" \" + y;\\n        if (!memo.containsKey(key)) {\\n            int[][] dirs = new int[][]{{1, 0}, {0, 1}, {0, -1}, {-1, 0}};\\n            int result = 0;\\n            for (int[] dir : dirs) {\\n                result += dfs(grid, x + dir[0], y + dir[1], cur + 1, total, memo);\\n            }\\n            memo.put(key, result);\\n        }\\n        grid[x][y] = 0;\\n        return memo.get(key);\\n    }\\n    private int getKey(int[][] grid) {\\n        int result = 0;\\n        for (int[] row : grid) {\\n            for (int a : row) {\\n                result <<= 1;\\n                if (a != 0) {\\n                    result ^= 1;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int x = -1, y = -1, m = grid.length, n = grid[0].length, total = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n                if (grid[i][j] == 0) {\\n                    total++;\\n                }\\n            }\\n        }\\n        return dfs(grid, x, y, 0, total + 1, new HashMap<>());\\n    }\\n    private int dfs(int[][] grid, int x, int y, int cur, int total, Map<String, Integer> memo) {\\n        int m = grid.length, n = grid[0].length;\\n        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == -1) {\\n            return 0;\\n        }\\n        if (grid[x][y] == 2) {\\n            if (total == cur) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        grid[x][y] = -1;\\n        String key = getKey(grid) + \" \" + x + \" \" + y;\\n        if (!memo.containsKey(key)) {\\n            int[][] dirs = new int[][]{{1, 0}, {0, 1}, {0, -1}, {-1, 0}};\\n            int result = 0;\\n            for (int[] dir : dirs) {\\n                result += dfs(grid, x + dir[0], y + dir[1], cur + 1, total, memo);\\n            }\\n            memo.put(key, result);\\n        }\\n        grid[x][y] = 0;\\n        return memo.get(key);\\n    }\\n    private int getKey(int[][] grid) {\\n        int result = 0;\\n        for (int[] row : grid) {\\n            for (int a : row) {\\n                result <<= 1;\\n                if (a != 0) {\\n                    result ^= 1;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973375,
                "title": "python-3-15-lines-dfs-w-comments-t-m-98-94",
                "content": "```\\nclass Solution:\\n     def uniquePathsIII(self, grid: list[list[int]]) -> int:\\n\\n        M, N = range(len(grid)), range(len(grid[0]))\\n\\n        zeros = sum(row.count(0) for row in grid)       # count the zeros to ensure all cells visited\\n        start = tuple((r,c) for r in M for c in N       # find start in grid\\n                           if grid[r][c] == 1)[0]\\n        self.ans = 0\\n\\n        def dfs(row, col, zeros):\\n            grid[row][col] = 3                          # change 0 to 3 to avoid returning\\n\\n            for dr, dc in ((-1,0),(0,-1),(1,0),(0,1)):  # explore the grid recursively\\n                R, C = row+dr, col+dc\\n                if R in M and C in N:\\n                    if grid[R][C] == 0: dfs(R, C, zeros-1)\\n                    if grid[R][C] == 2 and zeros == 0: self.ans += 1\\n\\n            grid[row][col] = 0                          # change back\\n            return\\n\\n        dfs(*start, zeros)\\n        return self.ans\\n\\n```\\n[https://leetcode.com/problems/unique-paths-iii/submissions/868318437/](http://)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n     def uniquePathsIII(self, grid: list[list[int]]) -> int:\\n\\n        M, N = range(len(grid)), range(len(grid[0]))\\n\\n        zeros = sum(row.count(0) for row in grid)       # count the zeros to ensure all cells visited\\n        start = tuple((r,c) for r in M for c in N       # find start in grid\\n                           if grid[r][c] == 1)[0]\\n        self.ans = 0\\n\\n        def dfs(row, col, zeros):\\n            grid[row][col] = 3                          # change 0 to 3 to avoid returning\\n\\n            for dr, dc in ((-1,0),(0,-1),(1,0),(0,1)):  # explore the grid recursively\\n                R, C = row+dr, col+dc\\n                if R in M and C in N:\\n                    if grid[R][C] == 0: dfs(R, C, zeros-1)\\n                    if grid[R][C] == 2 and zeros == 0: self.ans += 1\\n\\n            grid[row][col] = 0                          # change back\\n            return\\n\\n        dfs(*start, zeros)\\n        return self.ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513906,
                "title": "java-tc-o-3-rc-sc-o-rc-simple-dfs-solution-w-backtracking",
                "content": "```java\\n/**\\n * DFS solution with Backtracking\\n *\\n * Here we are using grid array to keep track of visited squares and reset them\\n * back while backtracking.\\n *\\n * Time Complexity:\\n * -> O(R*C) ==> To find the start, end, & number of non-obstacle squares.\\n * -> O(4 * 3^(N-2)) ==> DFS Helper will explore all possible paths. At each square\\n * (except start & end) we will explore at most 3 directions. At start we will\\n * explore 4 directions and at end we will stop the further exploration of that\\n * path. Here N is bounded by R*C.\\n *\\n * Total time complexity: O(R*C + 4 * 3^(N-2)) = O(3^(R*C))\\n *\\n * Space Complexity: O(N) --> For recursion stack. Here N is bounded by R*C.\\n *\\n * R = Number of rows. C = Number of columns. N = Number of non-obstacle\\n * squares.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return 0;\\n        }\\n        int[] start = null;\\n        int[] end = null;\\n        int nonObstacleSquares = 0;\\n\\n        // Finding the coordinates of Start and End cell.\\n        // Also, finding the number of Non-Obstacle Squares.\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                switch (grid[i][j]) {\\n                    case 1:\\n\\t\\t\\t\\t\\t\\t// If the input grid has two cells marked as start, then return 0\\n                        if (start != null) {\\n                            return 0;\\n                        }\\n                        start = new int[] { i, j };\\n                        nonObstacleSquares++;\\n                        break;\\n                    case 2:\\n\\t\\t\\t\\t\\t\\t// If the input grid has two cells marked as end, then return 0\\n                        if (end != null) {\\n                            return 0;\\n                        }\\n                        end = new int[] { i, j };\\n                        nonObstacleSquares++;\\n                        break;\\n                    case 0:\\n                        nonObstacleSquares++;\\n                        break;\\n                }\\n            }\\n        }\\n        if (start == null || end == null) {\\n            return 0;\\n        }\\n\\n        return dfsHelper(grid, start[0], start[1], nonObstacleSquares);\\n    }\\n\\n    private int dfsHelper(int[][] grid, int row, int col, int nonObstacleSquares) {\\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == -1\\n                || grid[row][col] == 3) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Found the end square. If number of cells to be visited is 1, then count this path.\\n        if (grid[row][col] == 2) {\\n            return nonObstacleSquares == 1 ? 1 : 0;\\n        }\\n\\n        int preVal = grid[row][col];\\n        grid[row][col] = 3;\\n        int pathCount = 0;\\n        for (int[] d : DIRS) {\\n            pathCount += dfsHelper(grid, row + d[0], col + d[1], nonObstacleSquares - 1);\\n        }\\n        grid[row][col] = preVal;\\n        return pathCount;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Unique Path question on LeetCode:\\n- [62. Unique Paths](https://leetcode.com/problems/unique-paths/discuss/1513886/Java-or-TC:-O(M*N)-or-SC:-O(min(MN))-or-Space-optimized-Dynamic-Programming-solution)\\n- [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/discuss/1513891/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/discuss/1513899/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java\\n/**\\n * DFS solution with Backtracking\\n *\\n * Here we are using grid array to keep track of visited squares and reset them\\n * back while backtracking.\\n *\\n * Time Complexity:\\n * -> O(R*C) ==> To find the start, end, & number of non-obstacle squares.\\n * -> O(4 * 3^(N-2)) ==> DFS Helper will explore all possible paths. At each square\\n * (except start & end) we will explore at most 3 directions. At start we will\\n * explore 4 directions and at end we will stop the further exploration of that\\n * path. Here N is bounded by R*C.\\n *\\n * Total time complexity: O(R*C + 4 * 3^(N-2)) = O(3^(R*C))\\n *\\n * Space Complexity: O(N) --> For recursion stack. Here N is bounded by R*C.\\n *\\n * R = Number of rows. C = Number of columns. N = Number of non-obstacle\\n * squares.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return 0;\\n        }\\n        int[] start = null;\\n        int[] end = null;\\n        int nonObstacleSquares = 0;\\n\\n        // Finding the coordinates of Start and End cell.\\n        // Also, finding the number of Non-Obstacle Squares.\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                switch (grid[i][j]) {\\n                    case 1:\\n\\t\\t\\t\\t\\t\\t// If the input grid has two cells marked as start, then return 0\\n                        if (start != null) {\\n                            return 0;\\n                        }\\n                        start = new int[] { i, j };\\n                        nonObstacleSquares++;\\n                        break;\\n                    case 2:\\n\\t\\t\\t\\t\\t\\t// If the input grid has two cells marked as end, then return 0\\n                        if (end != null) {\\n                            return 0;\\n                        }\\n                        end = new int[] { i, j };\\n                        nonObstacleSquares++;\\n                        break;\\n                    case 0:\\n                        nonObstacleSquares++;\\n                        break;\\n                }\\n            }\\n        }\\n        if (start == null || end == null) {\\n            return 0;\\n        }\\n\\n        return dfsHelper(grid, start[0], start[1], nonObstacleSquares);\\n    }\\n\\n    private int dfsHelper(int[][] grid, int row, int col, int nonObstacleSquares) {\\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == -1\\n                || grid[row][col] == 3) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Found the end square. If number of cells to be visited is 1, then count this path.\\n        if (grid[row][col] == 2) {\\n            return nonObstacleSquares == 1 ? 1 : 0;\\n        }\\n\\n        int preVal = grid[row][col];\\n        grid[row][col] = 3;\\n        int pathCount = 0;\\n        for (int[] d : DIRS) {\\n            pathCount += dfsHelper(grid, row + d[0], col + d[1], nonObstacleSquares - 1);\\n        }\\n        grid[row][col] = preVal;\\n        return pathCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856162,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n  int uniquePathsIII(vector<vector<int>>& grid) {        \\n    int sx = -1, sy = -1;\\n    int n = 1; // track the total count of empty square need to be visited\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if (grid[i][j] == 0) ++n;\\n        else if (grid[i][j] == 1) { sx = j; sy = i; } // starting square    \\n    return dfs(grid, sx, sy, n);\\n  }\\n    \\nprivate:\\n  int dfs(vector<vector<int>>& grid, int x, int y, int n) {\\n    if (x < 0 || x == grid[0].size() || y < 0 || y == grid.size() || grid[y][x] == -1) return 0;\\n    if (grid[y][x] == 2) return n == 0;//n=0 means all empty squares are visited=>one path found\\n    grid[y][x] = -1;\\n    int paths = dfs(grid, x + 1, y, n - 1) + dfs(grid, x - 1, y, n - 1) + dfs(grid, x, y + 1, n - 1) + dfs(grid, x, y - 1, n - 1);\\n    grid[y][x] = 0;\\n    return paths;        \\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int uniquePathsIII(vector<vector<int>>& grid) {        \\n    int sx = -1, sy = -1;\\n    int n = 1; // track the total count of empty square need to be visited\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if (grid[i][j] == 0) ++n;\\n        else if (grid[i][j] == 1) { sx = j; sy = i; } // starting square    \\n    return dfs(grid, sx, sy, n);\\n  }\\n    \\nprivate:\\n  int dfs(vector<vector<int>>& grid, int x, int y, int n) {\\n    if (x < 0 || x == grid[0].size() || y < 0 || y == grid.size() || grid[y][x] == -1) return 0;\\n    if (grid[y][x] == 2) return n == 0;//n=0 means all empty squares are visited=>one path found\\n    grid[y][x] = -1;\\n    int paths = dfs(grid, x + 1, y, n - 1) + dfs(grid, x - 1, y, n - 1) + dfs(grid, x, y + 1, n - 1) + dfs(grid, x, y - 1, n - 1);\\n    grid[y][x] = 0;\\n    return paths;        \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855922,
                "title": "c-simple-dfs-solution-explained-100-time-50-space",
                "content": "I have to admit I \"wasted\" some time over-optimising (or trying to), since I read that the maximum breadth and width of the map might both be `20`, so I was more concerned about performance than a mere map with max 20 overall elements.\\n\\nLesson learnt: take more time to review the specs carefully.\\n\\nBut I digress; going back to business, I knew I had to move with a dfs approach and plenty of backtracking, which is what I did, first of all creating a few class variables (in order to have less memory wasted passing data to my recursive calls:\\n* `x` and `y` will keep track of the initial starting point for the calls (I somehow ended up still passing them in the recursive calls, but in the end at least they still store the starting point);\\n* `xLen` and `yLen` will store the map size and thus also the upper limit (excluded) for our `x` and `y` value;\\n* `countZeros` will keep track of how many \"walkable\" cells we have already visited, while `totalZeros` will keep track of the overall amount of them on the map;\\n* `res` will keep the count of the viable paths found going over all the cells;\\n* `cell` is just a temporary variable to store the value of the currently visited map slot - I might have avoided it with little pain, but still felt it made things a bit more readable; or maybe not - you tell me.\\n\\nIn our main function we first of all proceed to give the right value to most of those class variables at once, starting with the upper limits, and then using nested loops to go at once both finding the starting point (the only `1` on the map) and the total of all the walkable cells (marked with `0`).\\n\\nRemember that in matrixes your first index is the `y`, since they are organised as arrays of rows.\\n\\nNow, a tricky part: you might be tempted (or at least I was) to go and call your `dfs` routine directly on the starting point, but that is a bit of a pain in the ass, since you would need some extra logic in order NOT to backtrack on it (and turn it into a `0`); in order to avoid that, I just called my `dfs` on all the 4 adjacent squares and never looked back - much simpler and moore convenient.\\n\\nBut what does this `dfs` helper function?\\n\\nWell, for starters it checks if we are out of bonds with either `x` or `y` and if so, it just `return`s.\\n\\nIf we are in a valid slot, it gives its value to `cell`, then it checks if it is not a `0` (with `!cell`) and if so it increases `res` IFF the current `cell`  is `2` and if we have actually touched all the available slots (`cell == 2` and `countZeros == totalZeros`, respectively) and in any other case it `return`s out of the recursive calls as well, as in the previous example.\\n\\nIf instead we are still on a valid path, then we flag our current cell a visited with `-1`, increase `countZeros` by `1` (since we have walked another unwalked valid cell) and then proceeds to call itself recurisively to all the adjacent cells.\\n\\nFinally, it backtracks restoring the previous values of `grid[y][x]` and `countZeros`.\\n\\nAfter all the `dfs` calls are done, we go back to the main function and just return `res`  :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int x, y, xLen, yLen, countZeros = 0, totalZeros = 0, res = 0, cell;\\n    void dfs(vector<vector<int>>& grid, int x, int y) {\\n        // exit condition: out of bonds\\n        if (x < 0 || y < 0 || x == xLen || y == yLen) return;\\n        cell = grid[y][x];\\n        if (cell) {\\n            // increasing res if we reached the goal and touched all available cell\\n            res += cell == 2 && countZeros == totalZeros;\\n            return;\\n        }\\n        // marking cell as visited\\n        grid[y][x] = -1;\\n        countZeros++;\\n        // exploring north, east, south, west\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        // backtracking cell as visitable\\n        grid[y][x] = 0;\\n        countZeros--;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // setting class variables right\\n        yLen = grid.size();\\n        xLen = grid[0].size();\\n        for (int _y = 0; _y < yLen; _y++) {\\n            for (int _x = 0; _x < xLen; _x++) {\\n                cell = grid[_y][_x];\\n                // finding the starting point\\n                if (cell == 1) {\\n                    x = _x;\\n                    y = _y;\\n                }\\n                // increasing countZeros for each cell == 0\\n                totalZeros += !cell;\\n            }\\n        }\\n        // exploring north, east, south, west of the starting point\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        return res;\\n    }\\n};\\n```\\nOh, it just occurred to me I did not really need `countZeros`; well, alternative, slightly more efficient version of it, as food for thought:\\n```cpp\\nclass Solution {\\npublic:\\n    int x, y, xLen, yLen, totalZeros = 0, res = 0, cell;\\n    void dfs(vector<vector<int>>& grid, int x, int y) {\\n        // exit condition: out of bonds\\n        if (x < 0 || y < 0 || x == xLen || y == yLen) return;\\n        cell = grid[y][x];\\n        if (cell) {\\n            // increasing res if we reached the goal and touched all available cell\\n            res += cell == 2 && !totalZeros;\\n            return;\\n        }\\n        // marking cell as visited\\n        grid[y][x] = -1;\\n        totalZeros--;\\n        // exploring north, east, south, west\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        // backtracking cell as visitable\\n        grid[y][x] = 0;\\n        totalZeros++;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // setting class variable right\\n        yLen = grid.size();\\n        xLen = grid[0].size();\\n        for (int _y = 0; _y < yLen; _y++) {\\n            for (int _x = 0; _x < xLen; _x++) {\\n                cell = grid[_y][_x];\\n                // finding the starting point\\n                if (cell == 1) {\\n                    x = _x;\\n                    y = _y;\\n                }\\n                // increasing countZeros for each cell == 0\\n                totalZeros += !cell;\\n            }\\n        }\\n        // exploring north, east, south, west of the starting point\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int x, y, xLen, yLen, countZeros = 0, totalZeros = 0, res = 0, cell;\\n    void dfs(vector<vector<int>>& grid, int x, int y) {\\n        // exit condition: out of bonds\\n        if (x < 0 || y < 0 || x == xLen || y == yLen) return;\\n        cell = grid[y][x];\\n        if (cell) {\\n            // increasing res if we reached the goal and touched all available cell\\n            res += cell == 2 && countZeros == totalZeros;\\n            return;\\n        }\\n        // marking cell as visited\\n        grid[y][x] = -1;\\n        countZeros++;\\n        // exploring north, east, south, west\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        // backtracking cell as visitable\\n        grid[y][x] = 0;\\n        countZeros--;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // setting class variables right\\n        yLen = grid.size();\\n        xLen = grid[0].size();\\n        for (int _y = 0; _y < yLen; _y++) {\\n            for (int _x = 0; _x < xLen; _x++) {\\n                cell = grid[_y][_x];\\n                // finding the starting point\\n                if (cell == 1) {\\n                    x = _x;\\n                    y = _y;\\n                }\\n                // increasing countZeros for each cell == 0\\n                totalZeros += !cell;\\n            }\\n        }\\n        // exploring north, east, south, west of the starting point\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int x, y, xLen, yLen, totalZeros = 0, res = 0, cell;\\n    void dfs(vector<vector<int>>& grid, int x, int y) {\\n        // exit condition: out of bonds\\n        if (x < 0 || y < 0 || x == xLen || y == yLen) return;\\n        cell = grid[y][x];\\n        if (cell) {\\n            // increasing res if we reached the goal and touched all available cell\\n            res += cell == 2 && !totalZeros;\\n            return;\\n        }\\n        // marking cell as visited\\n        grid[y][x] = -1;\\n        totalZeros--;\\n        // exploring north, east, south, west\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        // backtracking cell as visitable\\n        grid[y][x] = 0;\\n        totalZeros++;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // setting class variable right\\n        yLen = grid.size();\\n        xLen = grid[0].size();\\n        for (int _y = 0; _y < yLen; _y++) {\\n            for (int _x = 0; _x < xLen; _x++) {\\n                cell = grid[_y][_x];\\n                // finding the starting point\\n                if (cell == 1) {\\n                    x = _x;\\n                    y = _y;\\n                }\\n                // increasing countZeros for each cell == 0\\n                totalZeros += !cell;\\n            }\\n        }\\n        // exploring north, east, south, west of the starting point\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553847,
                "title": "c-clean-recursive-backtracking-solution-explained",
                "content": "The idea is to do the following:\\n- Find the starting cell (find the 1 in the grid)\\n- Count the number of cells to visit (count the 0s in the grid)\\n- Traverse the grid up/down/left/right recursively from the starting cell. On each step:\\n\\t- if the cell is a 0: flag the current cell as visited (=1), traverse the grid (decreasing the count of cells to visit by 1), and backtrack by removing the cell flag (=0)\\n\\t- if the cell is the ending square (2), check the remaining count of cells to visit. If 0, then increment the number of paths, otherwise, stop traversing.\\n\\t- otherwise (cell is a -1=obstacle or a 1=visited), stop traversing\\n\\t\\n\\n```\\nclass Solution {\\npublic:    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        initVariables( grid );\\n        traverse( grid, xStart, yStart, toVisit );\\n        return nValidPath;\\n    }\\n    \\nprivate:\\n    /*\\n    Get the starting positon in the grid && the number of zeros (cells to visit)\\n    xStart,yStart = start position\\n    toVisit = number of cells to visit\\n    */\\n    void initVariables( vector<vector<int>>& grid )\\n    {\\n        for ( int i = 0; i < grid.size(); ++i )\\n        {\\n            for ( int j = 0; j < grid[0].size(); ++j )\\n            {\\n                int n = grid[i][j];\\n                if ( n == 1 ) \\n                {\\n                    xStart = i; \\n                    yStart = j;\\n                }\\n                else if ( n == 0 ) \\n                    ++toVisit;\\n            }\\n        }\\n    }\\n    \\n    /*\\n    Visit a cell\\n    */\\n    void move( vector<vector<int>>& grid, int x, int y, int toVisit )\\n    {\\n        // Move only if the position is valid \\n        if ( x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() )\\n        {\\n            // If the cell we are moving to is the ending square and toVisit == 0:\\n            // the path is valid\\n            if ( grid[x][y] == 2 )\\n            {\\n                if ( toVisit == 0 )\\n                    ++nValidPath;\\n            }\\n            // Otherwise, if the cell we are moving to is 0 (<=> not -1 or 1, meaning obstacle or visited),\\n            // flag the cell as visited, traverse the grid again, and backtrack\\n            else if ( grid[x][y] == 0 )\\n            {\\n                grid[x][y] = 1;\\n                traverse( grid, x, y, toVisit - 1 );\\n                grid[x][y] = 0;\\n            }\\n        }\\n    }\\n    \\n    /*\\n    Traverse the grid from a cell (go in 4 directions)\\n    */\\n    void traverse( vector<vector<int>>& grid, int x, int y, int toVisit )\\n    {\\n        // go up\\n        move( grid, x - 1, y, toVisit );\\n        // go down \\n        move( grid, x + 1, y, toVisit );\\n        // go left \\n        move( grid, x, y - 1, toVisit );\\n        // go right \\n        move( grid, x, y + 1, toVisit );\\n    }\\n    \\n    /*\\n    Members\\n    */\\n    int xStart = 0, yStart = 0, toVisit = 0, nValidPath = 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        initVariables( grid );\\n        traverse( grid, xStart, yStart, toVisit );\\n        return nValidPath;\\n    }\\n    \\nprivate:\\n    /*\\n    Get the starting positon in the grid && the number of zeros (cells to visit)\\n    xStart,yStart = start position\\n    toVisit = number of cells to visit\\n    */\\n    void initVariables( vector<vector<int>>& grid )\\n    {\\n        for ( int i = 0; i < grid.size(); ++i )\\n        {\\n            for ( int j = 0; j < grid[0].size(); ++j )\\n            {\\n                int n = grid[i][j];\\n                if ( n == 1 ) \\n                {\\n                    xStart = i; \\n                    yStart = j;\\n                }\\n                else if ( n == 0 ) \\n                    ++toVisit;\\n            }\\n        }\\n    }\\n    \\n    /*\\n    Visit a cell\\n    */\\n    void move( vector<vector<int>>& grid, int x, int y, int toVisit )\\n    {\\n        // Move only if the position is valid \\n        if ( x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() )\\n        {\\n            // If the cell we are moving to is the ending square and toVisit == 0:\\n            // the path is valid\\n            if ( grid[x][y] == 2 )\\n            {\\n                if ( toVisit == 0 )\\n                    ++nValidPath;\\n            }\\n            // Otherwise, if the cell we are moving to is 0 (<=> not -1 or 1, meaning obstacle or visited),\\n            // flag the cell as visited, traverse the grid again, and backtrack\\n            else if ( grid[x][y] == 0 )\\n            {\\n                grid[x][y] = 1;\\n                traverse( grid, x, y, toVisit - 1 );\\n                grid[x][y] = 0;\\n            }\\n        }\\n    }\\n    \\n    /*\\n    Traverse the grid from a cell (go in 4 directions)\\n    */\\n    void traverse( vector<vector<int>>& grid, int x, int y, int toVisit )\\n    {\\n        // go up\\n        move( grid, x - 1, y, toVisit );\\n        // go down \\n        move( grid, x + 1, y, toVisit );\\n        // go left \\n        move( grid, x, y - 1, toVisit );\\n        // go right \\n        move( grid, x, y + 1, toVisit );\\n    }\\n    \\n    /*\\n    Members\\n    */\\n    int xStart = 0, yStart = 0, toVisit = 0, nValidPath = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108997,
                "title": "backtracking-solution-in-c-with-time-complexity-analysis",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- First, we\\u2019re finding the number of zeros & the starting point, then we\\u2019ll call our recursive function.\\n- There will be 2 base cases:\\n    - `if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1)` return 0.\\n    - `if(grid[x][y] == 2)` return 1 if zero=-1 (means we\\u2019ve visited all the zeros present there), else return 0.\\n- Else we\\u2019ll make current 0 to -1(not using visited array to save space) & decrease zero then call the recursive function for next 4 stages (down, right, up, left).\\n- Now after coming back from the recursive call we\\u2019ll backtrack, make current 0 & increase zero.\\n- **Time complexity:** O(4^n) //4calls for every cell.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zero = 0, x = 0, y = 0;\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 0) zero++;\\n                if(grid[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        return solve(grid, zero, x, y);\\n    }\\n    \\n    int solve(vector<vector<int>>& grid, int zero, int x, int y){\\n        if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1)\\n            return 0;\\n        \\n        if(grid[x][y] == 2){\\n            if(zero == -1) return 1;\\n            else return 0;\\n        }\\n        \\n        grid[x][y] = -1;\\n        zero--;\\n        \\n        int ans = solve(grid, zero, x+1, y) + solve(grid, zero, x, y+1) + solve(grid, zero, x-1, y) + solve(grid, zero, x, y-1);\\n        \\n        grid[x][y] = 0;\\n        zero++;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zero = 0, x = 0, y = 0;\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 0) zero++;\\n                if(grid[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        return solve(grid, zero, x, y);\\n    }\\n    \\n    int solve(vector<vector<int>>& grid, int zero, int x, int y){\\n        if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1)\\n            return 0;\\n        \\n        if(grid[x][y] == 2){\\n            if(zero == -1) return 1;\\n            else return 0;\\n        }\\n        \\n        grid[x][y] = -1;\\n        zero--;\\n        \\n        int ans = solve(grid, zero, x+1, y) + solve(grid, zero, x, y+1) + solve(grid, zero, x-1, y) + solve(grid, zero, x, y-1);\\n        \\n        grid[x][y] = 0;\\n        zero++;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834105,
                "title": "easy-to-understand-c-dfs-4ms",
                "content": "Here is my code for the problem. It contains comments for better understanding. Open to suggestions and new ideas of solving it. \\n**Please upvote if found helpful**\\n\\n```\\nclass Solution {\\n    int dfs(vector<vector<int>>& grid, int i, int j, int s, int c) {\\n        // invalid indexes or position\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == -1)\\n            return 0;\\n        \\n        // we reached target, now compare if the number of steps matches the number of empty cells\\n        if(grid[i][j] == 2)\\n            return s == c ? 1 : 0;\\n        \\n        // mark as processed\\n        grid[i][j] = -1;\\n        \\n        // explore all the directions\\n        int path = dfs(grid, i + 1, j, s + 1, c) \\n                 + dfs(grid, i - 1, j, s + 1, c) \\n                 + dfs(grid, i, j + 1, s + 1, c) \\n                 + dfs(grid, i, j - 1, s + 1, c);\\n        \\n        // backtrack and mark as available\\n        grid[i][j] = 0;\\n        \\n        return path;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // starti & startj hold the position of starting square\\n        // count holds the number of empty cells\\n        int starti = 0, startj = 0, count = 0;\\n        \\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == 1) {\\n                    starti = i;\\n                    startj = j;\\n                }\\n                \\n                if(grid[i][j] != -1)\\n                    count++;\\n            }\\n        }\\n        \\n        return dfs(grid, starti, startj, 1, count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(vector<vector<int>>& grid, int i, int j, int s, int c) {\\n        // invalid indexes or position\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == -1)\\n            return 0;\\n        \\n        // we reached target, now compare if the number of steps matches the number of empty cells\\n        if(grid[i][j] == 2)\\n            return s == c ? 1 : 0;\\n        \\n        // mark as processed\\n        grid[i][j] = -1;\\n        \\n        // explore all the directions\\n        int path = dfs(grid, i + 1, j, s + 1, c) \\n                 + dfs(grid, i - 1, j, s + 1, c) \\n                 + dfs(grid, i, j + 1, s + 1, c) \\n                 + dfs(grid, i, j - 1, s + 1, c);\\n        \\n        // backtrack and mark as available\\n        grid[i][j] = 0;\\n        \\n        return path;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // starti & startj hold the position of starting square\\n        // count holds the number of empty cells\\n        int starti = 0, startj = 0, count = 0;\\n        \\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == 1) {\\n                    starti = i;\\n                    startj = j;\\n                }\\n                \\n                if(grid[i][j] != -1)\\n                    count++;\\n            }\\n        }\\n        \\n        return dfs(grid, starti, startj, 1, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222492,
                "title": "backtracking-thinking-process-java",
                "content": ">We are asked to figure out number of paths such that each path starts at 1,  ends at 2, and passes all 0s.\\n\\n> That\\'s natural to backtracking, i.e., exhaustive searching with earlier pruning.\\n\\n> Base case (leaf nodes in backtracking tree): we are at `(endX, endY)` and we have visited `numEmpty + 2` squares.\\n\\n\\n> Recursive cases: we try 4-directional walks to see if it leads to a valid path - which will return 1 finally.\\n\\n****\\n```\\n    private int m, n, numEmpty;\\n    private static final int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n    private int countPaths(int x, int y, Set<Integer> visited, int endX, int endY, int[][] grid) {\\n        if (x == endX && y == endY && visited.size() - 2 == numEmpty) return 1;\\n        \\n        int count = 0;\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx < 0 || ny < 0 || nx >= m | ny >= n || grid[nx][ny] == -1) continue;\\n            int norder = serial(nx, ny);\\n            if (!visited.contains(norder)) {\\n                visited.add(norder);\\n                count += countPaths(nx, ny, visited, endX, endY, grid);\\n                visited.remove(norder);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int startX = 0, startY = 0, endX = 0, endY = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    startX = i;\\n                    startY = j;\\n                } else if (grid[i][j] == 2) {\\n                    endX = i;\\n                    endY = j;\\n                } else if (grid[i][j] == 0) {\\n                    numEmpty++;\\n                }\\n            }\\n        }\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(serial(startX, startY));\\n        \\n        return countPaths(startX, startY, visited, endX, endY, grid);\\n    }\\n\\n    private int serial(int x, int y) {\\n        return x * n + y;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    private int m, n, numEmpty;\\n    private static final int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n    private int countPaths(int x, int y, Set<Integer> visited, int endX, int endY, int[][] grid) {\\n        if (x == endX && y == endY && visited.size() - 2 == numEmpty) return 1;\\n        \\n        int count = 0;\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx < 0 || ny < 0 || nx >= m | ny >= n || grid[nx][ny] == -1) continue;\\n            int norder = serial(nx, ny);\\n            if (!visited.contains(norder)) {\\n                visited.add(norder);\\n                count += countPaths(nx, ny, visited, endX, endY, grid);\\n                visited.remove(norder);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int startX = 0, startY = 0, endX = 0, endY = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    startX = i;\\n                    startY = j;\\n                } else if (grid[i][j] == 2) {\\n                    endX = i;\\n                    endY = j;\\n                } else if (grid[i][j] == 0) {\\n                    numEmpty++;\\n                }\\n            }\\n        }\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(serial(startX, startY));\\n        \\n        return countPaths(startX, startY, visited, endX, endY, grid);\\n    }\\n\\n    private int serial(int x, int y) {\\n        return x * n + y;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974294,
                "title": "c-dfs-backtrack-comments-added-easy-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int path(int i,int j,int n,int m,int &c,int cnt,vector<vector<int>> &grid)\\n    {\\n        if(i<0 or j<0 or i>=n or j>=m or grid[i][j]==-1 or grid[i][j]==3)\\n            return 0;\\n        \\n        // ending square\\n        if(grid[i][j]==2)\\n        {\\n            //if all empty cells visited then returning 1 else 0\\n            if(cnt-1 == c) return 1;\\n            return 0;\\n        }\\n        \\n        grid[i][j]=3;                                          // mark as visited\\n        \\n        // all possible paths\\n        int up = path(i-1,j,n,m,c,cnt+1,grid);\\n        int down = path(i+1,j,n,m,c,cnt+1,grid);\\n        int left = path(i,j-1,n,m,c,cnt+1,grid);\\n        int right = path(i,j+1,n,m,c,cnt+1,grid);\\n    \\n        grid[i][j]=0;                                          // mark as unvisited\\n        \\n        return up+down+left+right;                             // total count of reaching ending square\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int st,en;\\n        int c=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                // if it is starting square\\n                if(grid[i][j]==1)\\n                {\\n                    st=i;\\n                    en=j;\\n                }\\n                \\n                // count of empty cells\\n                if(grid[i][j]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return path(st,en,n,m,c,0,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int path(int i,int j,int n,int m,int &c,int cnt,vector<vector<int>> &grid)\\n    {\\n        if(i<0 or j<0 or i>=n or j>=m or grid[i][j]==-1 or grid[i][j]==3)\\n            return 0;\\n        \\n        // ending square\\n        if(grid[i][j]==2)\\n        {\\n            //if all empty cells visited then returning 1 else 0\\n            if(cnt-1 == c) return 1;\\n            return 0;\\n        }\\n        \\n        grid[i][j]=3;                                          // mark as visited\\n        \\n        // all possible paths\\n        int up = path(i-1,j,n,m,c,cnt+1,grid);\\n        int down = path(i+1,j,n,m,c,cnt+1,grid);\\n        int left = path(i,j-1,n,m,c,cnt+1,grid);\\n        int right = path(i,j+1,n,m,c,cnt+1,grid);\\n    \\n        grid[i][j]=0;                                          // mark as unvisited\\n        \\n        return up+down+left+right;                             // total count of reaching ending square\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int st,en;\\n        int c=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                // if it is starting square\\n                if(grid[i][j]==1)\\n                {\\n                    st=i;\\n                    en=j;\\n                }\\n                \\n                // count of empty cells\\n                if(grid[i][j]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return path(st,en,n,m,c,0,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222212,
                "title": "c-backtracking",
                "content": "The idea is as follows: let\\'s call a \"complete path\" a path where all 0\\'s are used. The number of complete paths at index (x, y) is equal to the sum of complete paths moving up, down, left and right. We increment the number of zeros encountered each time we go deeper in the recursion tree. If we ever reach the destination cell with the required amont of zeros, then we have encountered a complete path and return 1. \\n\\nThe c++ code below implements the above idea.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zeros = 1;\\n        int x_start, y_start, x_end, y_end;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[i].size(); j++) {\\n                if(grid[i][j] == 0) zeros++;\\n                else if(grid[i][j] == 1) {\\n                    x_start = i;\\n                    y_start = j;\\n                }\\n                else if(grid[i][j] == 2) {\\n                    x_end = i;\\n                    y_end = j;\\n                }\\n            }\\n        }\\n        \\n        return paths(grid, x_start, y_start, x_end, y_end, 0, zeros);\\n    }\\n    \\n    int paths(vector<vector<int>> &grid, \\n              int x, int y, int x_end, int y_end, int covered, int required) {\\n        if(x == x_end && y == y_end && covered == required) {\\n            return 1;\\n        }\\n                \\n        grid[x][y] = -1;\\n        int res = 0;\\n        vector<vector<int>> dirs = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        for(auto &dir : dirs) {\\n            int new_x = x + dir[0];\\n            int new_y = y + dir[1];\\n            if(valid_index(new_x, new_y, grid.size(), grid[x].size())\\n              && (grid[new_x][new_y] == 0 || grid[new_x][new_y] == 2)) {\\n                res += paths(grid, new_x, new_y, x_end, y_end, covered + 1, required);\\n            }\\n        }\\n        grid[x][y] = 0;\\n        \\n        return res;\\n    }\\n    \\n    int valid_index(int i, int j, int n, int m) {\\n        return i >= 0 && j >= 0 && i < n && j < m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zeros = 1;\\n        int x_start, y_start, x_end, y_end;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[i].size(); j++) {\\n                if(grid[i][j] == 0) zeros++;\\n                else if(grid[i][j] == 1) {\\n                    x_start = i;\\n                    y_start = j;\\n                }\\n                else if(grid[i][j] == 2) {\\n                    x_end = i;\\n                    y_end = j;\\n                }\\n            }\\n        }\\n        \\n        return paths(grid, x_start, y_start, x_end, y_end, 0, zeros);\\n    }\\n    \\n    int paths(vector<vector<int>> &grid, \\n              int x, int y, int x_end, int y_end, int covered, int required) {\\n        if(x == x_end && y == y_end && covered == required) {\\n            return 1;\\n        }\\n                \\n        grid[x][y] = -1;\\n        int res = 0;\\n        vector<vector<int>> dirs = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        for(auto &dir : dirs) {\\n            int new_x = x + dir[0];\\n            int new_y = y + dir[1];\\n            if(valid_index(new_x, new_y, grid.size(), grid[x].size())\\n              && (grid[new_x][new_y] == 0 || grid[new_x][new_y] == 2)) {\\n                res += paths(grid, new_x, new_y, x_end, y_end, covered + 1, required);\\n            }\\n        }\\n        grid[x][y] = 0;\\n        \\n        return res;\\n    }\\n    \\n    int valid_index(int i, int j, int n, int m) {\\n        return i >= 0 && j >= 0 && i < n && j < m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184821,
                "title": "python3-backtracking-bitmask-dp",
                "content": "**Approach 1 -- backtracking**\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0]) # dimensions \\n        empty = 0 \\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 1: start = (i, j)\\n                elif grid[i][j] == 0: empty += 1 # empty squares \\n        \\n        def fn(i, j, empty): \\n            \"\"\"Count paths via backtracking.\"\"\"\\n            nonlocal ans \\n            if grid[i][j] == 2: \\n                if empty == -1: ans += 1\\n                return \\n            grid[i][j] = -1 # mark as visited \\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != -1: \\n                    fn(ii, jj, empty-1)\\n            grid[i][j] = 0 # backtracking\\n        \\n        ans = 0 \\n        fn(*start, empty)\\n        return ans\\n```\\n\\n**Approach 2 -- bitmask dp**\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mask = 0\\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 1: start = (i, j)\\n                if grid[i][j] in (-1, 1): mask ^= 1 << i*n+j\\n        \\n        @cache\\n        def fn(i, j, mask): \\n            \"\"\"Return unique paths from (i, j) to end\"\"\"\\n            if grid[i][j] == 2 and mask == (1<<m*n) - 1: return 1\\n            ans = 0\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    kk = ii*n + jj \\n                    if not mask & 1<<kk: ans += fn(ii, jj, mask ^ 1<<kk)\\n            return ans \\n                \\n        return fn(*start, mask)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0]) # dimensions \\n        empty = 0 \\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 1: start = (i, j)\\n                elif grid[i][j] == 0: empty += 1 # empty squares \\n        \\n        def fn(i, j, empty): \\n            \"\"\"Count paths via backtracking.\"\"\"\\n            nonlocal ans \\n            if grid[i][j] == 2: \\n                if empty == -1: ans += 1\\n                return \\n            grid[i][j] = -1 # mark as visited \\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != -1: \\n                    fn(ii, jj, empty-1)\\n            grid[i][j] = 0 # backtracking\\n        \\n        ans = 0 \\n        fn(*start, empty)\\n        return ans\\n```\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mask = 0\\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 1: start = (i, j)\\n                if grid[i][j] in (-1, 1): mask ^= 1 << i*n+j\\n        \\n        @cache\\n        def fn(i, j, mask): \\n            \"\"\"Return unique paths from (i, j) to end\"\"\"\\n            if grid[i][j] == 2 and mask == (1<<m*n) - 1: return 1\\n            ans = 0\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    kk = ii*n + jj \\n                    if not mask & 1<<kk: ans += fn(ii, jj, mask ^ 1<<kk)\\n            return ans \\n                \\n        return fn(*start, mask)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974009,
                "title": "simple-backtracking-solution-c",
                "content": "# Intuition\\nDo whats given . You need to walk over every zero and need to reach the 2 from 1 , So keep track of all the zeros and the zeros you have walked and using backtracking because if we go on a path that is not correct we could backtrack to the path that is actually correct containg all the zeros.\\n\\n# Approach\\nClassical Backtracking Approch\\n1. Keep track of total zeros and the zeros you walked\\n2. When on a zero you increment walked zero and then change it to visited path\\n3. And after moving on those path you set them back to zero as they could help in other path building.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i , int j , int n , int m , vector<vector<int>>& grid , int totalWalk , int doneWalk \\n            , vector<vector<int>>& dir , int& ans){\\n        if(grid[i][j] == -1){\\n            return ;\\n        }\\n        if(grid[i][j] == 2 && doneWalk == totalWalk){\\n            ans++;\\n        }\\n        else{\\n            int val = grid[i][j];\\n            if(val == 0){\\n                doneWalk++;\\n            }\\n            grid[i][j] = -1;\\n            for(auto it : dir){\\n                int x = i + it[0];\\n                int y = j + it[1];\\n                if(x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == -1){\\n                    continue;\\n                }\\n                else{\\n                    dfs(x , y , n , m , grid , totalWalk , doneWalk , dir , ans);\\n                }\\n            }\\n            if(val == 0){\\n                doneWalk--;\\n            }\\n            grid[i][j] = val;\\n        }\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ii = 0 , jj = 0 , totalWalk = 0 , doneWalk = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(grid[i][j] == 0){\\n                    totalWalk++;\\n                }\\n                if(grid[i][j] == 1){\\n                    ii = i;\\n                    jj = j;\\n                }\\n            }\\n        }\\n        vector<vector<int>> dir = {{0 , -1} , {0 , 1} , {1 , 0} , {-1 , 0}};\\n        int ans = 0;\\n        dfs(ii , jj , n , m , grid , totalWalk , doneWalk , dir , ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i , int j , int n , int m , vector<vector<int>>& grid , int totalWalk , int doneWalk \\n            , vector<vector<int>>& dir , int& ans){\\n        if(grid[i][j] == -1){\\n            return ;\\n        }\\n        if(grid[i][j] == 2 && doneWalk == totalWalk){\\n            ans++;\\n        }\\n        else{\\n            int val = grid[i][j];\\n            if(val == 0){\\n                doneWalk++;\\n            }\\n            grid[i][j] = -1;\\n            for(auto it : dir){\\n                int x = i + it[0];\\n                int y = j + it[1];\\n                if(x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == -1){\\n                    continue;\\n                }\\n                else{\\n                    dfs(x , y , n , m , grid , totalWalk , doneWalk , dir , ans);\\n                }\\n            }\\n            if(val == 0){\\n                doneWalk--;\\n            }\\n            grid[i][j] = val;\\n        }\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ii = 0 , jj = 0 , totalWalk = 0 , doneWalk = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(grid[i][j] == 0){\\n                    totalWalk++;\\n                }\\n                if(grid[i][j] == 1){\\n                    ii = i;\\n                    jj = j;\\n                }\\n            }\\n        }\\n        vector<vector<int>> dir = {{0 , -1} , {0 , 1} , {1 , 0} , {-1 , 0}};\\n        int ans = 0;\\n        dfs(ii , jj , n , m , grid , totalWalk , doneWalk , dir , ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973771,
                "title": "c-7ms-o-n-2-n-dfs-dynamic-programming-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo generate a valid path from a given square to the goal, we\\'re going to need to make one move first, and then generate the rest of the path. However, when we do this, we want to take into account that we\\'ve already visited a square that we came from, so that we don\\'t visit it again. This gives the idea of doing a graph search, where we go down paths using a DFS and counting each time we reach the end on a path of length $$n$$, where $$n$$ is the number of squares in the grid. However, going through all the possible paths might take a while -- although $$n = 20$$ means an exponential time solution is probably OK still. This graph search approach will form the foundation of our solution.\\n\\nOne other thing we can notice is that we might encounter a \"subproblem\" multiple times. In this case, we define a subproblem as finding the number of paths from a given square to the end, for a given set of vertices that we have already visited. There are $$2^n$$ such sets and only $$n$$ squares in the grid, so this will allow us to reuse some work when counting the total number of paths.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by initializing the grid for a recursive DFS/DP solution. Afterward, we use a memoized solve function, which takes in an x-coordinate and a y-coordinate representing our current location as well as an integer representing which locations we\\'ve already visited. This integer will have 1s at each bit corresponding to a visited square and 0s corresponding to unvisited squares. In this way, we can efficiently check if we\\'ve visited a square using bitwise operations. Additionally, this requires us to number the squares of the grid from 0 to $$n - 1$$, which can be done using the usual row-by-row, column-by-column ordering.\\n\\nIn a given call to the function, we first check if we either are in a base case or a case we\\'ve already solved before. If either of these holds, we just return that result. If not, we add the current square to the visited set and try paths where the next move is up, down, left, and right. Taking the sum of these 4 numbers gives the answer for this case, which we then memoize. Then calling our recursive, memoized solve function for our first square starting with an empty visited set will give us the desired answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIf we let the number of squares in the grid be $$n$$, the original branching search/DFS solution which does not memoize any states has a time complexity of $$O(3^n)$$, since we are trying paths of length up to $$n$$ and each one consists of moves in one of three directions since you can\\'t double back. However, the DP solution reduces this to $$O(n \\\\cdot 2^n)$$ since we only need to evaluate $$n \\\\cdot 2^n$$ states -- there are $$n$$ squares we can currently be on and $$2^n$$ possible sets of squares we have already visited. Each state is evaluated in constant time, since it is just taking the sum of four other states or looking up a memoized solution.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nBy memoizing, we are trading memory usage for an improved runtime. The memory used by this program could potentially end up having to store one integer for every DP state that we check, giving a space complexity of $$O(n \\\\cdot 2^n)$$ as well.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // variables to use in our solution\\n    vector<vector<int>> grid;\\n    int m, n, c;\\n    // memo table - dp[state] = # of paths to end from that state\\n    // C++ doesn\\'t like hashing pairs, so square s with visited set k is represented by (s << 20) + k\\n    // since the maximum size of the visited set is 20.\\n    unordered_map<int, int> dp;\\n    int solve(int x, int y, int visited) {\\n        int a = n * x + y; // find the number of this square\\n        int id = ((n * x + y) << 20) + visited; // generate memo table id\\n        // if we have already solved this state, return value\\n        if(dp.count(id) > 0) return dp[id];\\n        // base case - if we\\'re at the end, check if we have visited enough grid squares before\\n        if(grid[x][y] == 2) return (__builtin_popcount(visited) == c ? 1 : 0);\\n        // output variable\\n        int res = 0;\\n        // new visited set\\n        int nvis = visited | (1 << a);\\n        // try going up\\n        if(x > 0 && grid[x - 1][y] != -1 && (visited & (1 << (a - n))) == 0) {\\n            res += solve(x - 1, y, nvis);\\n        }\\n        // try going down\\n        if(x + 1 < m && grid[x + 1][y] != -1 && (visited & (1 << (a + n))) == 0) {\\n            res += solve(x + 1, y, nvis);\\n        }\\n        // try going left\\n        if(y > 0 && grid[x][y - 1] != -1 && (visited & (1 << (a - 1))) == 0) {\\n            res += solve(x, y - 1, nvis);\\n        }\\n        // try going right\\n        if(y + 1 < n && grid[x][y + 1] != -1 && (visited & (1 << (a + 1))) == 0) {\\n            res += solve(x, y + 1, nvis);\\n        }\\n        // memoize result before we return so that we can reuse it\\n        dp[id] = res;\\n        return res;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& g) {\\n        // initialize some variables for the search\\n        grid = g;\\n        m = grid.size();\\n        n = grid[0].size();\\n        // find starting square\\n        int x, y;\\n        // count number of non-obstacle, non-end squares\\n        c = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid[i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n                if(grid[i][j] == 1 || grid[i][j] == 0) ++c;\\n            }\\n        }\\n        // call DP solution\\n        return solve(x, y, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // variables to use in our solution\\n    vector<vector<int>> grid;\\n    int m, n, c;\\n    // memo table - dp[state] = # of paths to end from that state\\n    // C++ doesn\\'t like hashing pairs, so square s with visited set k is represented by (s << 20) + k\\n    // since the maximum size of the visited set is 20.\\n    unordered_map<int, int> dp;\\n    int solve(int x, int y, int visited) {\\n        int a = n * x + y; // find the number of this square\\n        int id = ((n * x + y) << 20) + visited; // generate memo table id\\n        // if we have already solved this state, return value\\n        if(dp.count(id) > 0) return dp[id];\\n        // base case - if we\\'re at the end, check if we have visited enough grid squares before\\n        if(grid[x][y] == 2) return (__builtin_popcount(visited) == c ? 1 : 0);\\n        // output variable\\n        int res = 0;\\n        // new visited set\\n        int nvis = visited | (1 << a);\\n        // try going up\\n        if(x > 0 && grid[x - 1][y] != -1 && (visited & (1 << (a - n))) == 0) {\\n            res += solve(x - 1, y, nvis);\\n        }\\n        // try going down\\n        if(x + 1 < m && grid[x + 1][y] != -1 && (visited & (1 << (a + n))) == 0) {\\n            res += solve(x + 1, y, nvis);\\n        }\\n        // try going left\\n        if(y > 0 && grid[x][y - 1] != -1 && (visited & (1 << (a - 1))) == 0) {\\n            res += solve(x, y - 1, nvis);\\n        }\\n        // try going right\\n        if(y + 1 < n && grid[x][y + 1] != -1 && (visited & (1 << (a + 1))) == 0) {\\n            res += solve(x, y + 1, nvis);\\n        }\\n        // memoize result before we return so that we can reuse it\\n        dp[id] = res;\\n        return res;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& g) {\\n        // initialize some variables for the search\\n        grid = g;\\n        m = grid.size();\\n        n = grid[0].size();\\n        // find starting square\\n        int x, y;\\n        // count number of non-obstacle, non-end squares\\n        c = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid[i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n                if(grid[i][j] == 1 || grid[i][j] == 0) ++c;\\n            }\\n        }\\n        // call DP solution\\n        return solve(x, y, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390360,
                "title": "python-well-explained-and-simple",
                "content": "# Idea is : Since we need to cover all empty spaces and reach destination, so we increment our pathcount only when we have \\n#   1. reached destination and \\n#   2. emptycell count == 0. \\n# So lets count all empty spaces, start point (i,j) and destination before we start dfs. After that it regular DFS. \\n# NOTE: DFS works best because it goes in depth and finds path until not hit by boundry condition or obstacle. \\n\\n```\\n\\nclass Solution(object):\\n    def uniquePathsIII(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.totalPaths = 0\\n        empty = 1\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                \\n                if grid[i][j] == 1: \\n                    x,y = (i, j)        # start point\\n                elif grid[i][j] == 2: \\n                    self.end = (i, j)   # end point\\n                elif grid[i][j] == 0: \\n                    empty += 1          # count no. of empty spaces\\n                    \\n        self.dfs(grid, x, y, empty)\\n        return self.totalPaths\\n    \\n    def dfs(self, grid, x, y, empty):\\n\\n        if not (0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] >= 0): \\n            return\\n\\n        if (x, y) == self.end:\\n            if empty == 0:              # Problem says -> path that walk over every non-obstacle square exactly once.\\n                self.totalPaths += 1\\n            return\\n\\n        grid[x][y] = -2\\n        self.dfs(grid, x + 1, y, empty - 1)\\n        self.dfs(grid, x - 1, y, empty - 1)\\n        self.dfs(grid, x, y + 1, empty - 1)\\n        self.dfs(grid, x, y - 1, empty - 1)\\n        grid[x][y] = 0\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def uniquePathsIII(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.totalPaths = 0\\n        empty = 1\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                \\n                if grid[i][j] == 1: \\n                    x,y = (i, j)        # start point\\n                elif grid[i][j] == 2: \\n                    self.end = (i, j)   # end point\\n                elif grid[i][j] == 0: \\n                    empty += 1          # count no. of empty spaces\\n                    \\n        self.dfs(grid, x, y, empty)\\n        return self.totalPaths\\n    \\n    def dfs(self, grid, x, y, empty):\\n\\n        if not (0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] >= 0): \\n            return\\n\\n        if (x, y) == self.end:\\n            if empty == 0:              # Problem says -> path that walk over every non-obstacle square exactly once.\\n                self.totalPaths += 1\\n            return\\n\\n        grid[x][y] = -2\\n        self.dfs(grid, x + 1, y, empty - 1)\\n        self.dfs(grid, x - 1, y, empty - 1)\\n        self.dfs(grid, x, y + 1, empty - 1)\\n        self.dfs(grid, x, y - 1, empty - 1)\\n        grid[x][y] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386273,
                "title": "dfs-solution-with-detailed-explanation-and-comments-python",
                "content": "The idea is to recusively explore all possible paths from the starting cell \\'1\\', stopping exploration as soon as paths are found to be invalid. The trick to ensure each cell is traversed only once is to change its value from \\'0\\' to \\'-1\\' right after its visited, so it is considered a wall. However, after checking valid movements in all 4 directions, **be careful to revert grid values to 0** in order to consider previously unexplored paths (if not, grid will only be traversed once).\\n\\n* First, we loop through all elements of grid to (1) **count all traversable cells** (i.e. 1, 2 and 0s) and (2) **find the starting point** (i.e. cell \\'1\\' coordinates). This information is stored in `to_visit` and `start_r, start_c` respectively.\\n\\n* Next, we implement the `dfs` function, which will **construct the graph of all possible paths**, backtracking whenever we either (1) find a wall or a previously visited cell or (2) reach the ending cell \\'2\\' without having visited all the grid\\'s 0s.\\n\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        self.R, self.C = len(grid), len(grid[0])\\n        self.directions = (0, 1), (0, -1), (1, 0), (-1, 0)\\n        to_visit = 0\\n        for r in range(self.R):\\n            for c in range(self.C):\\n                # count all 0s, 1 and 2 cells to be visited\\n\\t\\t\\t\\tif grid[r][c] != -1: to_visit += 1\\n                # find starting point i.e. cell 1\\n                if grid[r][c] == 1: start_r, start_c = r, c\\n\\n        return self.dfs(grid, start_r, start_c, to_visit)\\n        \\n    def dfs(self, grid, r, c, to_visit):\\n        # check if out of range or wall found\\n        if not (0 <= r < self.R and 0 <= c < self.C) or grid[r][c] == -1: return 0\\n        \\n        # found end cell, valid path if all 0s visited\\n        if grid[r][c] == 2: return to_visit == 1\\n        \\n        # valid movement, keep going\\n        elif grid[r][c] in [0, 1]:\\n            res = 0\\n            # mark as visited\\n            grid[r][c] = -1\\n            # check movements in all 4 directions\\n            for dr, dc in self.directions:\\n                res += self.dfs(grid, r + dr, c + dc, to_visit - 1)\\n            # mark prev explored cell as unvisited\\n            grid[r][c] = 0\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        self.R, self.C = len(grid), len(grid[0])\\n        self.directions = (0, 1), (0, -1), (1, 0), (-1, 0)\\n        to_visit = 0\\n        for r in range(self.R):\\n            for c in range(self.C):\\n                # count all 0s, 1 and 2 cells to be visited\\n\\t\\t\\t\\tif grid[r][c] != -1: to_visit += 1\\n                # find starting point i.e. cell 1\\n                if grid[r][c] == 1: start_r, start_c = r, c\\n\\n        return self.dfs(grid, start_r, start_c, to_visit)\\n        \\n    def dfs(self, grid, r, c, to_visit):\\n        # check if out of range or wall found\\n        if not (0 <= r < self.R and 0 <= c < self.C) or grid[r][c] == -1: return 0\\n        \\n        # found end cell, valid path if all 0s visited\\n        if grid[r][c] == 2: return to_visit == 1\\n        \\n        # valid movement, keep going\\n        elif grid[r][c] in [0, 1]:\\n            res = 0\\n            # mark as visited\\n            grid[r][c] = -1\\n            # check movements in all 4 directions\\n            for dr, dc in self.directions:\\n                res += self.dfs(grid, r + dr, c + dc, to_visit - 1)\\n            # mark prev explored cell as unvisited\\n            grid[r][c] = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222109,
                "title": "screencast-of-weekly-contest-120",
                "content": "https://www.youtube.com/watch?v=EXrh9ZIyuec&t=7s",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=EXrh9ZIyuec&t=7s",
                "codeTag": "Unknown"
            },
            {
                "id": 221913,
                "title": "python-solution-using-bit-with-extra-detailed-chinese-explanation",
                "content": "__update:2019.01.23__\\nyou can get Chinese explanation in \\nhttps://buptwc.com/2019/01/22/Leetcode-980-Unique-Paths-III/\\n\\n`1 <= grid.length * grid[0].length <= 20` just tell us to use bit!\\nI use bit represent the position we need to visit\\nfor grid[i][j], I use `1<<(i*m+j)` represent position(i,j)\\'s status\\n\\nfor instance, grid = [[0,1], [0,2]]\\nthe `start` status should be `0010`, position should be `0,1`(grid[i][j] = 1)\\nthe `final` status should be `1111`, position should be `1,1`(grid[i][j] = 2)\\n\\nnow we use recursion, start from `final` status, the process will be:\\n`1111, 1, 1` -> `0111, 1, 0` -> `0011, 0, 0` -> `0010, 0, 1`(start status)\\nso we find one path!\\n\\n```python\\n# I use sys modue to avoid stack overflow.\\n# but I haven\\'t tried to see if there\\'s a real stack overflow without adding it.\\nimport sys  \\nsys.setrecursionlimit(1000000)\\nclass Solution:\\n    def uniquePathsIII(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        start = 0\\n        final = 0\\n        fi = fj = 0\\n        # record the start status and final status\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != -1:\\n                    final += 1 << (i*m+j)\\n                if grid[i][j] == 1:\\n                    start += 1 << (i*m+j)\\n                    si, sj = i, j\\n                if grid[i][j] == 2:\\n                    fi, fj = i, j\\n\\n        cache = {(start,si,sj): 1}\\n        def solve(status, i, j):\\n            if (status,i,j) in cache: return cache[status,i,j]\\n            res = 0\\n            now_status = 1 << (i*m + j)\\n            for x,y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                if 0<=x<n and 0<=y<m and grid[x][y] != -1:\\n                    mask = 1 << (x*m+y)\\n                    if status & mask:\\n                        res += solve(status ^ now_status, x, y)\\n            cache[status,i,j] = res\\n            return res\\n        return solve(final, fi, fj)\\n```",
                "solutionTags": [],
                "code": "```python\\n# I use sys modue to avoid stack overflow.\\n# but I haven\\'t tried to see if there\\'s a real stack overflow without adding it.\\nimport sys  \\nsys.setrecursionlimit(1000000)\\nclass Solution:\\n    def uniquePathsIII(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        start = 0\\n        final = 0\\n        fi = fj = 0\\n        # record the start status and final status\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != -1:\\n                    final += 1 << (i*m+j)\\n                if grid[i][j] == 1:\\n                    start += 1 << (i*m+j)\\n                    si, sj = i, j\\n                if grid[i][j] == 2:\\n                    fi, fj = i, j\\n\\n        cache = {(start,si,sj): 1}\\n        def solve(status, i, j):\\n            if (status,i,j) in cache: return cache[status,i,j]\\n            res = 0\\n            now_status = 1 << (i*m + j)\\n            for x,y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                if 0<=x<n and 0<=y<m and grid[x][y] != -1:\\n                    mask = 1 << (x*m+y)\\n                    if status & mask:\\n                        res += solve(status ^ now_status, x, y)\\n            cache[status,i,j] = res\\n            return res\\n        return solve(final, fi, fj)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463043,
                "title": "c-java-python-easy-to-understand-4-directional-walk-w-backtracking",
                "content": "I think the comments are explicit enough to explain the **DFS-based 4-directional walk with backtracking** approach that is used here. We just need to find the starting square and then we do this walk until we reach the ending square and there will only be a valid path if we visited all the empty squares exactly once. \\n\\nWhen we visit an empty square, we mark it as an obstacle and going back (while backtracking) we unmark them.\\n\\n```\\nTime complexity: O(4 ^ (no. of elements in grid))\\nSpace complexity: O(no. of elements in grid)\\n```\\n\\n\\u2714 C++: \\n\\n```\\nclass Solution {\\nprivate:\\n    int dfs(vector<vector<int>> &grid, int x, int y, int emptyCell) {\\n        // base cases -\\n        // 1. out of bounds and obstacles\\n        if(x == -1 or x == grid.size() or y == -1 or y == grid[0].size() or grid[x][y] == -1) \\n            return 0;\\n        // 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if(grid[x][y] == 2)\\n            return emptyCell == 0;\\n        // since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1;\\n        // do the 4-directional dfs walk from here\\n        int walks = \\n              dfs(grid, x + 1, y, emptyCell - 1)   // visit SOUTH\\n            + dfs(grid, x - 1, y, emptyCell - 1)   // visit NORTH\\n            + dfs(grid, x, y + 1, emptyCell - 1)   // visit EAST\\n            + dfs(grid, x, y - 1, emptyCell - 1);  // visit WEST\\n        // coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0;\\n        return walks;\\n    }\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int emptyCell = 1, xIdx, yIdx;\\n        // counting the no. of empty cells and getting the position of starting square\\n        // x and y coordinate of starting square are xIdx and yIdx respectively\\n        for(int i = 0; i < grid.size(); ++i) {\\n            for(int j = 0; j < grid[0].size(); ++j) {\\n                if(grid[i][j] == 1) \\n                    xIdx = i, yIdx = j;\\n                else if(grid[i][j] == 0)\\n                    ++emptyCell;\\n            }\\n        }\\n        return dfs(grid, xIdx, yIdx, emptyCell);\\n    }\\n};\\n```\\n\\n\\u2714 Java:\\n\\n```\\nclass Solution {\\n    private int dfs(int[][] grid, int x, int y, int emptyCell) {\\n        // base cases -\\n        // 1. out of bounds and obstacles\\n        if(x == -1 || x == grid.length || y == -1 || y == grid[0].length || grid[x][y] == -1)\\n            return 0;\\n        // 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if(grid[x][y] == 2)\\n            return emptyCell == 0 ? 1 : 0;\\n        // since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1;\\n        // do the 4-directional dfs walk from here\\n        int walks = \\n              dfs(grid, x + 1, y, emptyCell - 1)   // visit SOUTH\\n            + dfs(grid, x - 1, y, emptyCell - 1)   // visit NORTH\\n            + dfs(grid, x, y + 1, emptyCell - 1)   // visit EAST\\n            + dfs(grid, x, y - 1, emptyCell - 1);  // visit WEST\\n        // coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0;\\n        return walks;\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        int emptyCell = 1, xIdx = 0, yIdx = 0;\\n        // counting the no. of empty cells and getting the position of starting square\\n        // x and y coordinate of starting square are xIdx and yIdx respectively\\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[0].length; ++j) {\\n                if(grid[i][j] == 1) {\\n                    xIdx = i;\\n                    yIdx = j;\\n                } else if(grid[i][j] == 0) {\\n                    ++emptyCell;\\n                }\\n            }\\n        }\\n        return dfs(grid, xIdx, yIdx, emptyCell);\\n    }\\n}\\n```\\n\\n\\u2714 Python:\\n\\n```\\nclass Solution:\\n    def dfs(self, grid: List[List[int]], x: int, y: int, emptyCell: int) -> int:\\n        # base cases -\\n        # 1. out of bounds and obstacles\\n        if x == -1 or x == len(grid) or y == -1 or y == len(grid[0]) or grid[x][y] == -1:\\n            return 0\\n        # 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if grid[x][y] == 2:\\n            return emptyCell == 0\\n        # since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1\\n        # do the 4-directional dfs walk from here\\n        walks = (self.dfs(grid, x + 1, y, emptyCell - 1)   # visit SOUTH \\n               + self.dfs(grid, x - 1, y, emptyCell - 1)   # visit NORTH \\n               + self.dfs(grid, x, y + 1, emptyCell - 1)   # visit EAST \\n               + self.dfs(grid, x, y - 1, emptyCell - 1))  # visit WEST \\n        # coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0\\n        return walks\\n    \\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        emptyCell, xIdx, yIdx = 1, 0, 0\\n        # counting the no. of empty cells and getting the position of starting square\\n        # x and y coordinate of starting square are xIdx and yIdx respectively\\n        for i in range (len(grid)):\\n            for j in range (len(grid[0])):\\n                if grid[i][j] == 1:\\n                    xIdx, yIdx = i, j\\n                elif grid[i][j] == 0:\\n                    emptyCell += 1\\n        return self.dfs(grid, xIdx, yIdx, emptyCell)\\n```\\n\\nThanks a lot for reading! ^_^\\n\\uD83D\\uDCAF An upvote would be appreciated.\\n\\uD83D\\uDC47 Comment down your doubts (if any).",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nTime complexity: O(4 ^ (no. of elements in grid))\\nSpace complexity: O(no. of elements in grid)\\n```\n```\\nclass Solution {\\nprivate:\\n    int dfs(vector<vector<int>> &grid, int x, int y, int emptyCell) {\\n        // base cases -\\n        // 1. out of bounds and obstacles\\n        if(x == -1 or x == grid.size() or y == -1 or y == grid[0].size() or grid[x][y] == -1) \\n            return 0;\\n        // 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if(grid[x][y] == 2)\\n            return emptyCell == 0;\\n        // since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1;\\n        // do the 4-directional dfs walk from here\\n        int walks = \\n              dfs(grid, x + 1, y, emptyCell - 1)   // visit SOUTH\\n            + dfs(grid, x - 1, y, emptyCell - 1)   // visit NORTH\\n            + dfs(grid, x, y + 1, emptyCell - 1)   // visit EAST\\n            + dfs(grid, x, y - 1, emptyCell - 1);  // visit WEST\\n        // coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0;\\n        return walks;\\n    }\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int emptyCell = 1, xIdx, yIdx;\\n        // counting the no. of empty cells and getting the position of starting square\\n        // x and y coordinate of starting square are xIdx and yIdx respectively\\n        for(int i = 0; i < grid.size(); ++i) {\\n            for(int j = 0; j < grid[0].size(); ++j) {\\n                if(grid[i][j] == 1) \\n                    xIdx = i, yIdx = j;\\n                else if(grid[i][j] == 0)\\n                    ++emptyCell;\\n            }\\n        }\\n        return dfs(grid, xIdx, yIdx, emptyCell);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int dfs(int[][] grid, int x, int y, int emptyCell) {\\n        // base cases -\\n        // 1. out of bounds and obstacles\\n        if(x == -1 || x == grid.length || y == -1 || y == grid[0].length || grid[x][y] == -1)\\n            return 0;\\n        // 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if(grid[x][y] == 2)\\n            return emptyCell == 0 ? 1 : 0;\\n        // since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1;\\n        // do the 4-directional dfs walk from here\\n        int walks = \\n              dfs(grid, x + 1, y, emptyCell - 1)   // visit SOUTH\\n            + dfs(grid, x - 1, y, emptyCell - 1)   // visit NORTH\\n            + dfs(grid, x, y + 1, emptyCell - 1)   // visit EAST\\n            + dfs(grid, x, y - 1, emptyCell - 1);  // visit WEST\\n        // coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0;\\n        return walks;\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        int emptyCell = 1, xIdx = 0, yIdx = 0;\\n        // counting the no. of empty cells and getting the position of starting square\\n        // x and y coordinate of starting square are xIdx and yIdx respectively\\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[0].length; ++j) {\\n                if(grid[i][j] == 1) {\\n                    xIdx = i;\\n                    yIdx = j;\\n                } else if(grid[i][j] == 0) {\\n                    ++emptyCell;\\n                }\\n            }\\n        }\\n        return dfs(grid, xIdx, yIdx, emptyCell);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def dfs(self, grid: List[List[int]], x: int, y: int, emptyCell: int) -> int:\\n        # base cases -\\n        # 1. out of bounds and obstacles\\n        if x == -1 or x == len(grid) or y == -1 or y == len(grid[0]) or grid[x][y] == -1:\\n            return 0\\n        # 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if grid[x][y] == 2:\\n            return emptyCell == 0\\n        # since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1\\n        # do the 4-directional dfs walk from here\\n        walks = (self.dfs(grid, x + 1, y, emptyCell - 1)   # visit SOUTH \\n               + self.dfs(grid, x - 1, y, emptyCell - 1)   # visit NORTH \\n               + self.dfs(grid, x, y + 1, emptyCell - 1)   # visit EAST \\n               + self.dfs(grid, x, y - 1, emptyCell - 1))  # visit WEST \\n        # coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0\\n        return walks\\n    \\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        emptyCell, xIdx, yIdx = 1, 0, 0\\n        # counting the no. of empty cells and getting the position of starting square\\n        # x and y coordinate of starting square are xIdx and yIdx respectively\\n        for i in range (len(grid)):\\n            for j in range (len(grid[0])):\\n                if grid[i][j] == 1:\\n                    xIdx, yIdx = i, j\\n                elif grid[i][j] == 0:\\n                    emptyCell += 1\\n        return self.dfs(grid, xIdx, yIdx, emptyCell)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478116,
                "title": "java-clean-backtracking-beats-100",
                "content": "Classic backtracking question with a condition that each visitable cell must be visited before we reach destination, we do not need memo as the matrix itself can be used, by marking the visited cells -1, essentially blocking it from further visits, and marking back as 0 as we backtrack. Since we do not have any special condition for int what way destination has to be reached we just want to visit every 0 cell, we can just keep the count of such visitable cells beforehand and subtract 1 as we reach each such cell should give us 0 at the destination if we visited all cells\\n```\\nclass Solution {\\n    int[][] g;\\n    public int uniquePathsIII(int[][] grid) {\\n        g = grid;\\n        int count = 0;\\n        int sr = 0;\\n        int sc = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 0) count++;\\n                else if(grid[i][j] == 1){\\n                    sr = i;\\n                    sc = j;\\n                }\\n            }\\n        }\\n        return dfs(sr,sc,count+1);\\n        \\n    }\\n    public int dfs(int i , int j , int count){\\n        if(i < 0 || j < 0 || i >= g.length || j >= g[0].length || g[i][j] == -1) return 0;\\n        if(g[i][j] == 2){\\n            if(count == 0)return 1;\\n            return 0;\\n        }\\n        int cc = 0;\\n        g[i][j] = -1;\\n        cc += dfs(i-1,j,count-1);\\n        cc += dfs(i+1,j,count-1);\\n        cc += dfs(i,j-1,count-1);\\n        cc += dfs(i,j+1,count-1);\\n        g[i][j] = 0;\\n        return cc;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] g;\\n    public int uniquePathsIII(int[][] grid) {\\n        g = grid;\\n        int count = 0;\\n        int sr = 0;\\n        int sc = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 0) count++;\\n                else if(grid[i][j] == 1){\\n                    sr = i;\\n                    sc = j;\\n                }\\n            }\\n        }\\n        return dfs(sr,sc,count+1);\\n        \\n    }\\n    public int dfs(int i , int j , int count){\\n        if(i < 0 || j < 0 || i >= g.length || j >= g[0].length || g[i][j] == -1) return 0;\\n        if(g[i][j] == 2){\\n            if(count == 0)return 1;\\n            return 0;\\n        }\\n        int cc = 0;\\n        g[i][j] = -1;\\n        cc += dfs(i-1,j,count-1);\\n        cc += dfs(i+1,j,count-1);\\n        cc += dfs(i,j-1,count-1);\\n        cc += dfs(i,j+1,count-1);\\n        g[i][j] = 0;\\n        return cc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856077,
                "title": "unique-paths-c-100-time-simple-dfs-traversal-with-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int i, int j, int nobs, int &count){\\n        if (i >= grid.size() || i < 0 || j >= grid[0].size() || j < 0) return;   /* if out of range */\\n        if (grid[i][j] == -1) return;   /* if obstacle */\\n        if (grid[i][j] == 2) {          /* if reached end */\\n            if (nobs == 0) count++;     /* and all non obstacles are included in the path */\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;   /* mark node visited so that it\\'s explored exactly once in the current path */\\n        nobs = nobs - 1;   /* reduce the count of non-obstacle nodes visited so far */\\n        \\n        dfs(grid, i, j-1, nobs, count); // left\\n        dfs(grid, i, j+1, nobs, count); // right\\n        dfs(grid, i-1, j, nobs, count); // up\\n        dfs(grid, i+1, j, nobs, count); // down\\n        \\n        grid[i][j] = 0; /* make the node explorable again for other paths */\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int nobs = 0, i, j;\\n        // calculate start position and non-obstacles count\\n        for (int r = 0; r < grid.size(); r++) {\\n            for (int c = 0; c < grid[0].size(); c++) {\\n                if (grid[r][c] == 1) {\\n                    i = r;\\n                    j = c;\\n                }\\n                else if (grid[r][c] != -1) { // 0 or 2\\n                    nobs++;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        dfs(grid, i, j, nobs, count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int i, int j, int nobs, int &count){\\n        if (i >= grid.size() || i < 0 || j >= grid[0].size() || j < 0) return;   /* if out of range */\\n        if (grid[i][j] == -1) return;   /* if obstacle */\\n        if (grid[i][j] == 2) {          /* if reached end */\\n            if (nobs == 0) count++;     /* and all non obstacles are included in the path */\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;   /* mark node visited so that it\\'s explored exactly once in the current path */\\n        nobs = nobs - 1;   /* reduce the count of non-obstacle nodes visited so far */\\n        \\n        dfs(grid, i, j-1, nobs, count); // left\\n        dfs(grid, i, j+1, nobs, count); // right\\n        dfs(grid, i-1, j, nobs, count); // up\\n        dfs(grid, i+1, j, nobs, count); // down\\n        \\n        grid[i][j] = 0; /* make the node explorable again for other paths */\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int nobs = 0, i, j;\\n        // calculate start position and non-obstacles count\\n        for (int r = 0; r < grid.size(); r++) {\\n            for (int c = 0; c < grid[0].size(); c++) {\\n                if (grid[r][c] == 1) {\\n                    i = r;\\n                    j = c;\\n                }\\n                else if (grid[r][c] != -1) { // 0 or 2\\n                    nobs++;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        dfs(grid, i, j, nobs, count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381218,
                "title": "c-dfs-0ms-and-8-6mb",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint uniquePathsIII(vector<vector<int>>& grid) {\\n\\t\\tint res = 0;\\n\\t\\t// find starting positions\\n        for (int i = 0; i < grid.size(); i++){\\n            for (int j = 0; j < grid[0].size(); j++){\\n                if (grid[i][j] == 1){\\n\\t\\t\\t\\t\\tres = getRes(grid, i, j);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int getRes(vector<vector<int>>& grid, int i, int j){\\n\\t\\t// check if we can move further\\n        if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == -1){\\n            return 0;\\n        }\\n\\t\\t// if we found ending square, check whether we visited all empty squares\\n        if (grid[i][j] == 2){\\n            for (int t = 0; t < grid.size(); t++){\\n                for (int k = 0; k < grid[0].size(); k++){\\n                    if (grid[t][k] == 0){\\n                        return 0;\\n                    }\\n                }\\n            }\\n            return 1;\\n        }\\n\\t\\t// we have to mark current positions as visited, and later restore it\\n        auto temp = grid[i][j];\\n        grid[i][j] = -1;\\n        \\n\\t\\t// run dfs for 4 directions\\n        int res = getRes(grid, i - 1, j);\\n        res += getRes(grid, i + 1, j);\\n        res += getRes(grid, i, j - 1);\\n        res += getRes(grid, i, j + 1);\\n        \\n\\t\\t// restore position\\n        grid[i][j] = temp;\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint uniquePathsIII(vector<vector<int>>& grid) {\\n\\t\\tint res = 0;\\n\\t\\t// find starting positions\\n        for (int i = 0; i < grid.size(); i++){\\n            for (int j = 0; j < grid[0].size(); j++){\\n                if (grid[i][j] == 1){\\n\\t\\t\\t\\t\\tres = getRes(grid, i, j);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int getRes(vector<vector<int>>& grid, int i, int j){\\n\\t\\t// check if we can move further\\n        if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == -1){\\n            return 0;\\n        }\\n\\t\\t// if we found ending square, check whether we visited all empty squares\\n        if (grid[i][j] == 2){\\n            for (int t = 0; t < grid.size(); t++){\\n                for (int k = 0; k < grid[0].size(); k++){\\n                    if (grid[t][k] == 0){\\n                        return 0;\\n                    }\\n                }\\n            }\\n            return 1;\\n        }\\n\\t\\t// we have to mark current positions as visited, and later restore it\\n        auto temp = grid[i][j];\\n        grid[i][j] = -1;\\n        \\n\\t\\t// run dfs for 4 directions\\n        int res = getRes(grid, i - 1, j);\\n        res += getRes(grid, i + 1, j);\\n        res += getRes(grid, i, j - 1);\\n        res += getRes(grid, i, j + 1);\\n        \\n\\t\\t// restore position\\n        grid[i][j] = temp;\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554872,
                "title": "step-by-step-explanation-of-maze-problems",
                "content": "## Information from the question:\\n* We have to cover all valid cells : (need to count cells in grid depending on the cell values)\\n* We have to print all paths count :  (Backtracking)\\n* There are some cells which are blocked :  (need to considere this cell while making a call)\\n\\n## Explantion with Code:\\n\\n```\\n// A direction matrix to make call in specified directions (Here 4 directions are needed)\\n  int[][] dir = {{0,-1},{0,1},{-1,0},{1,0}};\\n  //varibales storing gird\\'s information (made global just to avoiding sending them as param in function)\\n    int n=0,m=0,moves=0;\\n   \\n    public int uniquePathsIII(int[][] grid) {\\n        n = grid.length; m = grid[0].length;\\n        int ans = 0, sr = -1,sc=-1;\\n\\t\\t\\n\\t\\t//Step 1 : Count the cells from where you can move(valid cell) and find the starting point\\n\\t\\t//remember starting point is also a valid cell with just an extra identification mark that shows it is a starting point\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    sr = i;\\n                    sc = j;\\n                    moves++; //starting point is also a valid cell for movement\\n                }\\n                if(grid[i][j]==0) moves++;\\n            }\\n        }\\n        \\n        ans = floodfill(grid,sr,sc,moves);\\n        \\n        return ans;\\n    }\\n    \\n    private int floodfill(int[][] grid, int sr,int sc,int moves){\\n\\t// if we have reached the destination by covering all the valid cells \\n\\t// then tell the program you have found 1 path\\n        if(grid[sr][sc]==2 && moves==0) return 1;\\n        \\n\\t\\t//Step 2: (Marking and unmarking)\\n\\t\\t//Telling the program that you have visited the current cell and took a move for other\\n\\t\\t\\n        //mark \\n        int val = grid[sr][sc];\\n        grid[sr][sc] = -1; //making that cell invalid as we have already covered it\\n        moves--;\\n        \\n        int count = 0;\\n\\t\\t\\n\\t\\t// Go to all 4 direction\\n        for(int[] d: dir){\\n            int r = sr + d[0];\\n            int c = sc + d[1];\\n\\t\\t\\t// but only go for the path which profits you.\\n\\t\\t\\t\\n            if(r>=0 && c>=0 && r<n && c<m && grid[r][c]!=-1){\\n\\t\\t\\t//add the path count from all 4 direction\\n                count+=floodfill(grid,r,c,moves);\\n            }\\n        }\\n\\t\\t\\n        //unmark (undoing the changes)\\n\\t\\t// so when you comes here again by different path you can visit it again\\n\\t\\t//(make it a part of your new path again) having your valid move intact\\n\\t\\t\\n        grid[sr][sc]= val;\\n        moves++;\\n        \\n        return count;\\n    }\\n    \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// A direction matrix to make call in specified directions (Here 4 directions are needed)\\n  int[][] dir = {{0,-1},{0,1},{-1,0},{1,0}};\\n  //varibales storing gird\\'s information (made global just to avoiding sending them as param in function)\\n    int n=0,m=0,moves=0;\\n   \\n    public int uniquePathsIII(int[][] grid) {\\n        n = grid.length; m = grid[0].length;\\n        int ans = 0, sr = -1,sc=-1;\\n\\t\\t\\n\\t\\t//Step 1 : Count the cells from where you can move(valid cell) and find the starting point\\n\\t\\t//remember starting point is also a valid cell with just an extra identification mark that shows it is a starting point\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    sr = i;\\n                    sc = j;\\n                    moves++; //starting point is also a valid cell for movement\\n                }\\n                if(grid[i][j]==0) moves++;\\n            }\\n        }\\n        \\n        ans = floodfill(grid,sr,sc,moves);\\n        \\n        return ans;\\n    }\\n    \\n    private int floodfill(int[][] grid, int sr,int sc,int moves){\\n\\t// if we have reached the destination by covering all the valid cells \\n\\t// then tell the program you have found 1 path\\n        if(grid[sr][sc]==2 && moves==0) return 1;\\n        \\n\\t\\t//Step 2: (Marking and unmarking)\\n\\t\\t//Telling the program that you have visited the current cell and took a move for other\\n\\t\\t\\n        //mark \\n        int val = grid[sr][sc];\\n        grid[sr][sc] = -1; //making that cell invalid as we have already covered it\\n        moves--;\\n        \\n        int count = 0;\\n\\t\\t\\n\\t\\t// Go to all 4 direction\\n        for(int[] d: dir){\\n            int r = sr + d[0];\\n            int c = sc + d[1];\\n\\t\\t\\t// but only go for the path which profits you.\\n\\t\\t\\t\\n            if(r>=0 && c>=0 && r<n && c<m && grid[r][c]!=-1){\\n\\t\\t\\t//add the path count from all 4 direction\\n                count+=floodfill(grid,r,c,moves);\\n            }\\n        }\\n\\t\\t\\n        //unmark (undoing the changes)\\n\\t\\t// so when you comes here again by different path you can visit it again\\n\\t\\t//(make it a part of your new path again) having your valid move intact\\n\\t\\t\\n        grid[sr][sc]= val;\\n        moves++;\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1296914,
                "title": "java-100-faster-0ms-dfs-no-memo",
                "content": "count is count of how many zeros in grid\\nand starti and startj is the start poit where grid[starti][startj] == 1\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int startI = 0;\\n        int startJ = 0;\\n        int count = 0;\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[i].length;j++){\\n                if(grid[i][j] == 1){\\n                    startI = i;\\n                    startJ = j;\\n                }else if(grid[i][j] == 0) count++;\\n            }\\n        }\\n        return howManyPath(grid,startI,startJ,count + 1);\\n    }\\n    \\n    private int howManyPath(int[][] grid,int i,int j,int count){\\n        if(i >= grid.length || i < 0 || j >= grid[i].length || j < 0 || grid[i][j] == -1) return 0;\\n\\n        if(grid[i][j] == 2){\\n            if(count == 0) return 1;\\n            return 0;\\n        }\\n\\n\\n        int temp = grid[i][j];\\n        grid[i][j] = -1;\\n\\n        int result = howManyPath(grid,i + 1,j,count - 1) +\\n              howManyPath(grid,i - 1,j,count - 1) +\\n              howManyPath(grid,i,j + 1,count - 1) +\\n              howManyPath(grid,i,j - 1,count - 1);\\n\\n        grid[i][j] = temp;\\n        return result;\\n    \\n    }\\n \\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int startI = 0;\\n        int startJ = 0;\\n        int count = 0;\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[i].length;j++){\\n                if(grid[i][j] == 1){\\n                    startI = i;\\n                    startJ = j;\\n                }else if(grid[i][j] == 0) count++;\\n            }\\n        }\\n        return howManyPath(grid,startI,startJ,count + 1);\\n    }\\n    \\n    private int howManyPath(int[][] grid,int i,int j,int count){\\n        if(i >= grid.length || i < 0 || j >= grid[i].length || j < 0 || grid[i][j] == -1) return 0;\\n\\n        if(grid[i][j] == 2){\\n            if(count == 0) return 1;\\n            return 0;\\n        }\\n\\n\\n        int temp = grid[i][j];\\n        grid[i][j] = -1;\\n\\n        int result = howManyPath(grid,i + 1,j,count - 1) +\\n              howManyPath(grid,i - 1,j,count - 1) +\\n              howManyPath(grid,i,j + 1,count - 1) +\\n              howManyPath(grid,i,j - 1,count - 1);\\n\\n        grid[i][j] = temp;\\n        return result;\\n    \\n    }\\n \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252187,
                "title": "java-2ms-100-faster-dfs",
                "content": "Attempted to try DP for collecting most possible ways to cover all non-obstacle squares from a square but failed. Using DFS with memoize instead.. Hopefully it helps. \\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int startRow = -1;\\n        int startCol = -1;\\n        \\n        int nonObstacles = 0;\\n        \\n        int[][] memoize = new int[grid.length][grid[0].length];\\n        int[] result = {0};\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                memoize[i][j] = -1;\\n            }\\n        }\\n        \\n\\t\\t// Iterate through the grid to find out where to start and how many non-obs squares should be covered..\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j <grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    startRow = i;\\n                    startCol = j;\\n                }\\n                \\n                if (grid[i][j] != -1) {\\n                    nonObstacles++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Start an definite non-obs square, so better reduce the total by 1 for readability\\n        helper(grid, startRow, startCol,nonObstacles - 1, memoize, result);\\n        return result[0];\\n    }\\n    \\n    public void helper(int[][] grid, int row, int col, int nonObs, int[][] memoizes, int[] result) {\\n        if (row <  0 || col < 0 || row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        \\n        if (grid[row][col] == 2) {\\n            if (nonObs == 0)\\n                result[0]++;\\n            return;\\n        }\\n        \\n        // Mark the current coordinate as visited \\n        memoizes[row][col] = -2;\\n        \\n        // Try Go left\\n        if (row > 0 && grid[row - 1][col] != -1 && memoizes[row - 1][col] != -2) {\\n            helper(grid, row - 1, col, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go right\\n        if (row < grid.length -1 &&  grid[row + 1][col] != -1 && memoizes[row + 1][col] != -2) {\\n            helper(grid, row + 1, col, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go down\\n        if (col < grid[0].length -1 && grid[row][col + 1] != -1 && memoizes[row][col + 1] != -2) {\\n            helper(grid, row, col + 1, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go up\\n        if (col > 0 && grid[row][col - 1] != -1 && memoizes[row][col - 1] != -2 ) {\\n            helper(grid, row, col - 1, nonObs - 1, memoizes, result);\\n        }\\n        \\n        // Mark the current coordinate as un-visited, OK to go in\\n        memoizes[row][col] = -1;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int startRow = -1;\\n        int startCol = -1;\\n        \\n        int nonObstacles = 0;\\n        \\n        int[][] memoize = new int[grid.length][grid[0].length];\\n        int[] result = {0};\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                memoize[i][j] = -1;\\n            }\\n        }\\n        \\n\\t\\t// Iterate through the grid to find out where to start and how many non-obs squares should be covered..\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j <grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    startRow = i;\\n                    startCol = j;\\n                }\\n                \\n                if (grid[i][j] != -1) {\\n                    nonObstacles++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Start an definite non-obs square, so better reduce the total by 1 for readability\\n        helper(grid, startRow, startCol,nonObstacles - 1, memoize, result);\\n        return result[0];\\n    }\\n    \\n    public void helper(int[][] grid, int row, int col, int nonObs, int[][] memoizes, int[] result) {\\n        if (row <  0 || col < 0 || row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        \\n        if (grid[row][col] == 2) {\\n            if (nonObs == 0)\\n                result[0]++;\\n            return;\\n        }\\n        \\n        // Mark the current coordinate as visited \\n        memoizes[row][col] = -2;\\n        \\n        // Try Go left\\n        if (row > 0 && grid[row - 1][col] != -1 && memoizes[row - 1][col] != -2) {\\n            helper(grid, row - 1, col, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go right\\n        if (row < grid.length -1 &&  grid[row + 1][col] != -1 && memoizes[row + 1][col] != -2) {\\n            helper(grid, row + 1, col, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go down\\n        if (col < grid[0].length -1 && grid[row][col + 1] != -1 && memoizes[row][col + 1] != -2) {\\n            helper(grid, row, col + 1, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go up\\n        if (col > 0 && grid[row][col - 1] != -1 && memoizes[row][col - 1] != -2 ) {\\n            helper(grid, row, col - 1, nonObs - 1, memoizes, result);\\n        }\\n        \\n        // Mark the current coordinate as un-visited, OK to go in\\n        memoizes[row][col] = -1;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975556,
                "title": "c-dfs-backtracking-simple-easy",
                "content": "## DFS with Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> dr={-1,0,1,0};\\n    vector<int> dc={0,1,0,-1};\\n\\n    bool check(vector<vector<int>> &grid, vector<vector<bool>> &vis){\\n        int n= grid.size();\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==0 && vis[i][j]==false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    void dfs(int i, int j, int x, int y, vector<vector<int>> &grid, vector<vector<bool>> &vis){\\n        int n= grid.size();\\n        int m=grid[0].size();\\n\\n        if(i==x && j==y){\\n            vis[i][j]=true;\\n            if(check(grid,vis)) ans++;\\n            vis[i][j]=false;\\n            return;\\n        }\\n        vis[i][j]=true;\\n        for(int k=0; k<4; k++){\\n            int newr= i+dr[k], newc= j+dc[k];\\n            if(newr<0 || newr>=n || newc<0 || newc>=m || grid[newr][newc]==-1 || vis[newr][newc]) continue;\\n            dfs(newr,newc,x,y,grid,vis);\\n        }\\n        vis[i][j]=false;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n, vector<bool>(m,false));\\n\\n        int sr,sc,er,ec;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    sr=i, sc=j;\\n                }\\n                else if(grid[i][j]==2){\\n                    er=i, ec=j;\\n                }\\n            }\\n        }\\n        dfs(sr,sc,er,ec,grid,vis);\\n        return ans;\\n    }\\n};\\n```\\n## If you like it, Please Upvote !!.\\n\\n![06b76ed5-3118-4975-ac59-5bf422f9c72b_1674524881.1133926.webp](https://assets.leetcode.com/users/images/b2457bc0-1d8d-47d2-b0ca-f42383f0e6db_1682256289.909848.webp)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> dr={-1,0,1,0};\\n    vector<int> dc={0,1,0,-1};\\n\\n    bool check(vector<vector<int>> &grid, vector<vector<bool>> &vis){\\n        int n= grid.size();\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==0 && vis[i][j]==false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    void dfs(int i, int j, int x, int y, vector<vector<int>> &grid, vector<vector<bool>> &vis){\\n        int n= grid.size();\\n        int m=grid[0].size();\\n\\n        if(i==x && j==y){\\n            vis[i][j]=true;\\n            if(check(grid,vis)) ans++;\\n            vis[i][j]=false;\\n            return;\\n        }\\n        vis[i][j]=true;\\n        for(int k=0; k<4; k++){\\n            int newr= i+dr[k], newc= j+dc[k];\\n            if(newr<0 || newr>=n || newc<0 || newc>=m || grid[newr][newc]==-1 || vis[newr][newc]) continue;\\n            dfs(newr,newc,x,y,grid,vis);\\n        }\\n        vis[i][j]=false;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n, vector<bool>(m,false));\\n\\n        int sr,sc,er,ec;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    sr=i, sc=j;\\n                }\\n                else if(grid[i][j]==2){\\n                    er=i, ec=j;\\n                }\\n            }\\n        }\\n        dfs(sr,sc,er,ec,grid,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973873,
                "title": "dfs-solution-beats-100-shorter-simpler-than-official-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] grid;\\n    int availCells =0;\\n    int answer =0;\\n    \\n    public void dfs(int row, int col, int passedCells){\\n        if(row <0 || col < 0) return; //out of grid\\n        if(row >= grid.length || col >= grid[0].length) return; //out of grid\\n        int cellValue = grid[row][col];\\n        if(cellValue == 1 || cellValue==-1 || cellValue == -2) return; //start, obstacle or visitted cell\\n        if(cellValue == 2){\\n            if(passedCells == availCells) answer++; // we passed all avail cells, success!\\n            return;\\n        }\\n        grid[row][col] = -2; //mark as visitted\\n        passedCells++;\\n        dfs(row, col+1, passedCells);\\n        dfs(row, col-1, passedCells);\\n        dfs(row+1, col, passedCells);\\n        dfs(row-1, col, passedCells);\\n        grid[row][col] = 0;\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        this.grid = grid;\\n        int startRow=0,startCol=0;\\n        \\n        for(int row = 0; row < grid.length; row++){\\n            for(int col=0; col < grid[0].length; col++){\\n                if(grid[row][col] == 1){ // find start cell\\n                     startRow = row;\\n                     startCol = col;\\n                }\\n                if(grid[row][col] == 0)  availCells++; \\n            }\\n        }\\n        dfs(startRow+1, startCol,0);\\n        dfs(startRow-1, startCol,0);\\n        dfs(startRow, startCol+1,0);\\n        dfs(startRow, startCol-1,0);\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] grid;\\n    int availCells =0;\\n    int answer =0;\\n    \\n    public void dfs(int row, int col, int passedCells){\\n        if(row <0 || col < 0) return; //out of grid\\n        if(row >= grid.length || col >= grid[0].length) return; //out of grid\\n        int cellValue = grid[row][col];\\n        if(cellValue == 1 || cellValue==-1 || cellValue == -2) return; //start, obstacle or visitted cell\\n        if(cellValue == 2){\\n            if(passedCells == availCells) answer++; // we passed all avail cells, success!\\n            return;\\n        }\\n        grid[row][col] = -2; //mark as visitted\\n        passedCells++;\\n        dfs(row, col+1, passedCells);\\n        dfs(row, col-1, passedCells);\\n        dfs(row+1, col, passedCells);\\n        dfs(row-1, col, passedCells);\\n        grid[row][col] = 0;\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        this.grid = grid;\\n        int startRow=0,startCol=0;\\n        \\n        for(int row = 0; row < grid.length; row++){\\n            for(int col=0; col < grid[0].length; col++){\\n                if(grid[row][col] == 1){ // find start cell\\n                     startRow = row;\\n                     startCol = col;\\n                }\\n                if(grid[row][col] == 0)  availCells++; \\n            }\\n        }\\n        dfs(startRow+1, startCol,0);\\n        dfs(startRow-1, startCol,0);\\n        dfs(startRow, startCol+1,0);\\n        dfs(startRow, startCol-1,0);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973787,
                "title": "c-dfs-easy-solution",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isValid(int i,int j,int m,int n)\\n    {\\n        return i>=0 and j>=0 and i<m and j<n;\\n    }\\n    void cal(pair<int,int>& start,pair<int,int> &end,vector<vector<bool>> &vis,int emptySquare,int m,int n)\\n    {\\n        emptySquare--;\\n        if(start==end)\\n        {\\n            if(emptySquare==0)\\n            {\\n                ans++;\\n            }\\n            return ;\\n        }\\n        vis[start.first][start.second]=true;\\n        int x[]={1,-1,0,0};\\n        int y[]={0,0,1,-1};\\n        for(int k=0;k<4;k++)\\n        {\\n            int newx=start.first+x[k];\\n            int newy=start.second+y[k];\\n            if(isValid(newx,newy,m,n) and vis[newx][newy]==false)\\n            {\\n                pair<int,int> curr={newx,newy};\\n                cal(curr,end,vis,emptySquare,m,n);\\n            }\\n        }\\n        vis[start.first][start.second]=false;\\n\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        pair<int,int> start,end;\\n        int emptySquare=0;\\n        vector<vector<bool>> vis(m,vector<bool> (n,false));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    start={i,j};\\n                }\\n                if(grid[i][j]==2)\\n                {\\n                    end={i,j};\\n                }\\n                if(grid[i][j]!=-1)\\n                {\\n                    emptySquare++;\\n                }\\n                if(grid[i][j]==-1)\\n                    vis[i][j]=true;\\n            }\\n        }\\n        cal(start,end,vis,emptySquare,m,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isValid(int i,int j,int m,int n)\\n    {\\n        return i>=0 and j>=0 and i<m and j<n;\\n    }\\n    void cal(pair<int,int>& start,pair<int,int> &end,vector<vector<bool>> &vis,int emptySquare,int m,int n)\\n    {\\n        emptySquare--;\\n        if(start==end)\\n        {\\n            if(emptySquare==0)\\n            {\\n                ans++;\\n            }\\n            return ;\\n        }\\n        vis[start.first][start.second]=true;\\n        int x[]={1,-1,0,0};\\n        int y[]={0,0,1,-1};\\n        for(int k=0;k<4;k++)\\n        {\\n            int newx=start.first+x[k];\\n            int newy=start.second+y[k];\\n            if(isValid(newx,newy,m,n) and vis[newx][newy]==false)\\n            {\\n                pair<int,int> curr={newx,newy};\\n                cal(curr,end,vis,emptySquare,m,n);\\n            }\\n        }\\n        vis[start.first][start.second]=false;\\n\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        pair<int,int> start,end;\\n        int emptySquare=0;\\n        vector<vector<bool>> vis(m,vector<bool> (n,false));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    start={i,j};\\n                }\\n                if(grid[i][j]==2)\\n                {\\n                    end={i,j};\\n                }\\n                if(grid[i][j]!=-1)\\n                {\\n                    emptySquare++;\\n                }\\n                if(grid[i][j]==-1)\\n                    vis[i][j]=true;\\n            }\\n        }\\n        cal(start,end,vis,emptySquare,m,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973264,
                "title": "daily-leetcoding-challenge-december-day-31",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2251644,
                "title": "c-well-explained-backtracking-recursion",
                "content": "```\\n/*\\nso here we want to return the number of of 4-directional walks from the starting square\\nto the ending square, that walk over every non-obstacle square exactly once.\\nmeans we have to cover every cell having value 0 ,and also skip the cell with value -1.\\nTherefore we can easily right a recursive function , where we write the sufficent base conditions\\nfollowed by writing a recurrence relation which will explore all the paths i.e LEFT , RIGHT , UP , DOWN \\n___________________________________________________________________________________\\nso talking about base conditions ,\\nif(i>=n || j>=m || i<0 || j<0 || grid[i][j]==-1 )\\n            return 0;\\n            \\nthis will handle the cases where we go out of bounds , and if we come accross a cell having value -1 \\n, therefore we can not pass thorugh it to reach our destination , therefore we will simply return 0\\n, because we have not reached our destination\\n___________________________________________________________________________________\\n\\nif(grid[i][j]==2){\\n            if(zero==-1)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\nnow we have reached our destnation which is cell having value 2, now we will check\\nwhether we have travelled across all the cells having value 0 , which is our prerequisite , \\nif yes return 1 , means this path is valid , else return 0\\n___________________________________________________________________________________\\n\\ngrid[i][j]=-1; \\nzero--;\\n\\nthis is done so that we dont travel over a cell more than once and also decreamenting the \\nnumber of zeroes , because we have travelled across a cell having value 0 , \\nand we have to travel all zeroes once \\n___________________________________________________________________________________\\n\\nint l=solve(grid,zero,i,j-1,n,m);\\nint r=solve(grid,zero,i,j+1,n,m);\\nint u=solve(grid,zero,i-1,j,n,m);\\nint d=solve(grid,zero,i+1,j,n,m);\\n\\neasy recurrence relation which will explore all paths from a cell  i.e LEFT , RIGHT , UP , DOWN \\n\\n___________________________________________________________________________________\\n\\nessential step of backtracking \\n grid[i][j]=0;\\n zero++;\\nnow as have completed one path  , we again set grid[i][j]=0; and zeroes++ , so thatwe can utilise the cells again \\n\\n___________________________________________________________________________________\\nreturn l+r+u+d\\n \\n  returning all valid paths\\n*/\\n\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid,int zero,int i, int j, int n, int m){\\n        \\n        if(i>=n || j>=m || i<0 || j<0 || grid[i][j]==-1 )\\n            return 0;\\n        \\n        if(grid[i][j]==2){\\n            if(zero==-1)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n            \\n        grid[i][j]=-1; \\n        zero--;\\n        \\n        int l=solve(grid,zero,i,j-1,n,m);\\n        int r=solve(grid,zero,i,j+1,n,m);\\n        int u=solve(grid,zero,i-1,j,n,m);\\n        int d=solve(grid,zero,i+1,j,n,m);\\n        \\n        // bactrack\\n        grid[i][j]=0;\\n        zero++;\\n        \\n        return l+r+u+d;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int startRow=0,startCol=0;\\n        int zero=0;\\n       \\n        \\n        // calculating no of zeroes , which is essential , because\\n        // ATQ walk over every non-obstacle square exactly once.\\n        // also we will save our starting path which is from grid[i][j]=1\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0)  zero++;\\n                \\n                if(grid[i][j]==1){\\n                    startRow=i;\\n                    startCol=j;\\n                }\\n            }\\n        }\\n        \\n        return solve(grid,zero,startRow,startCol,n,m);\\n\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid,int zero,int i, int j, int n, int m){\\n        \\n        if(i>=n || j>=m || i<0 || j<0 || grid[i][j]==-1 )\\n            return 0;\\n        \\n        if(grid[i][j]==2){\\n            if(zero==-1)\\n                return 1;\\n            else\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1854228,
                "title": "java-0ms-self-explainatory-easy-backtracking-consise",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int blocks = 1;\\n        for(int[] arr:grid) for(int a:arr) if(a==0) blocks++;\\n        for(int i=0;i<grid.length;i++) for(int j=0;j<grid[0].length;j++) if(grid[i][j] == 1) dfs(grid,i,j,blocks);\\n        return count;\\n    }\\n    public void dfs(int[][] grid,int i,int j,int blocks){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || grid[i][j] == -2) return;\\n        if(grid[i][j] == 2 && blocks == 0){\\n            count++;\\n            return;\\n        }\\n        if(grid[i][j] == 2) return;\\n        grid[i][j] = -2;\\n        dfs(grid,i-1,j,blocks-1);\\n        dfs(grid,i,j+1,blocks-1);\\n        dfs(grid,i+1,j,blocks-1);\\n        dfs(grid,i,j-1,blocks-1);\\n        grid[i][j] = 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int blocks = 1;\\n        for(int[] arr:grid) for(int a:arr) if(a==0) blocks++;\\n        for(int i=0;i<grid.length;i++) for(int j=0;j<grid[0].length;j++) if(grid[i][j] == 1) dfs(grid,i,j,blocks);\\n        return count;\\n    }\\n    public void dfs(int[][] grid,int i,int j,int blocks){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || grid[i][j] == -2) return;\\n        if(grid[i][j] == 2 && blocks == 0){\\n            count++;\\n            return;\\n        }\\n        if(grid[i][j] == 2) return;\\n        grid[i][j] = -2;\\n        dfs(grid,i-1,j,blocks-1);\\n        dfs(grid,i,j+1,blocks-1);\\n        dfs(grid,i+1,j,blocks-1);\\n        dfs(grid,i,j-1,blocks-1);\\n        grid[i][j] = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555455,
                "title": "intuition-explained-backtracking-dfs-on-grid-c-clean-code",
                "content": "**Intuition:**\\n\\n* Idea is to traverse from **Start to End** and when all the empty cells are **visited**, we have a path that visits all the empty cells. \\n\\n* So, first of all we identify **starting** coordinate. And also **count** number of empty cells. \\n* Then, we do normal DFS on grid in all **valid directions** and decrement count of empty cells when we visit it. \\n\\n\\t* We visit a cell, move to valid direction & get count of paths. And *decrement empty cell count.*\\n\\t* Then we unvisit that cell and unvisit it. So that we can explore other possible paths. \\n\\n* Base condition is when we reach destination cell, and \\n\\t* if all empty cell are visited i.e **count is zero**, then `return 1` which means we have a unique path.\\n\\t* else we `return 0`,  which means not all empty cell are visited.\\n\\n# Code: \\n```\\nstatic int X[4] = {-1, 0, 1, 0};\\nstatic int Y[4] = {0, -1, 0, 1};\\n\\nclass Solution {\\npublic:\\n    \\n    int countPaths(vector<vector<int>>& grid, int x, int y, int empty, const int& m, const int& n) {\\n        \\n\\t\\t/*\\n\\t\\tfor(int i=0; i<m; i++) {\\n\\t\\t\\tfor(int j=0; j<n; j++) {\\n\\t\\t\\t\\tcout << grid[i][j] << \" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout << endl;\\n\\t\\t}\\n\\t\\tcout << x << \" : \" << y << \" -> \" << empty << endl << endl;\\n\\t\\t*/\\n\\t\\t\\n\\t\\t// If we reach end cell and \\n\\t\\t// All empty cells are visited, then return 1\\n\\t\\t// Else return 0\\n        if(grid[x][y] == 2) {\\n            return (empty == 0);\\n        }\\n                \\n        int count = 0;   // Count of possible paths from current cell {x,y}\\n        grid[x][y] = -1;  // Visit\\n        \\n\\t\\t// Check for all valid directions\\n        for(int k=0; k<4; k++) {\\n\\t\\t\\t// Possible adjacent coordinates\\n            int i = x + X[k];\\n            int j = y + Y[k];\\n\\t\\t\\t\\n\\t\\t\\t// Valid Moves\\n            if(i>=0 && j>=0 && i<m && j<n && grid[i][j] != -1) {\\n                count += countPaths(grid, i, j, empty-1, m, n);  // Add count of possible paths\\n            }\\n        }\\n        \\n\\t\\t// Backtrack \\n        grid[x][y] = 0;  // Unvisit\\n        \\n        return count;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size(), empty = 1;\\n        \\n        pair<int, int> start;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1) start = {i, j};\\n                else if(grid[i][j] == 0) empty++;  // Count of empty cells\\n            }\\n        }\\n        \\n\\t\\t// Explore grid from start cell\\n        return countPaths(grid, start.first, start.second, empty, m, n);\\n    }\\n};\\n```\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nstatic int X[4] = {-1, 0, 1, 0};\\nstatic int Y[4] = {0, -1, 0, 1};\\n\\nclass Solution {\\npublic:\\n    \\n    int countPaths(vector<vector<int>>& grid, int x, int y, int empty, const int& m, const int& n) {\\n        \\n\\t\\t/*\\n\\t\\tfor(int i=0; i<m; i++) {\\n\\t\\t\\tfor(int j=0; j<n; j++) {\\n\\t\\t\\t\\tcout << grid[i][j] << \" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout << endl;\\n\\t\\t}\\n\\t\\tcout << x << \" : \" << y << \" -> \" << empty << endl << endl;\\n\\t\\t*/\\n\\t\\t\\n\\t\\t// If we reach end cell and \\n\\t\\t// All empty cells are visited, then return 1\\n\\t\\t// Else return 0\\n        if(grid[x][y] == 2) {\\n            return (empty == 0);\\n        }\\n                \\n        int count = 0;   // Count of possible paths from current cell {x,y}\\n        grid[x][y] = -1;  // Visit\\n        \\n\\t\\t// Check for all valid directions\\n        for(int k=0; k<4; k++) {\\n\\t\\t\\t// Possible adjacent coordinates\\n            int i = x + X[k];\\n            int j = y + Y[k];\\n\\t\\t\\t\\n\\t\\t\\t// Valid Moves\\n            if(i>=0 && j>=0 && i<m && j<n && grid[i][j] != -1) {\\n                count += countPaths(grid, i, j, empty-1, m, n);  // Add count of possible paths\\n            }\\n        }\\n        \\n\\t\\t// Backtrack \\n        grid[x][y] = 0;  // Unvisit\\n        \\n        return count;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size(), empty = 1;\\n        \\n        pair<int, int> start;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1) start = {i, j};\\n                else if(grid[i][j] == 0) empty++;  // Count of empty cells\\n            }\\n        }\\n        \\n\\t\\t// Explore grid from start cell\\n        return countPaths(grid, start.first, start.second, empty, m, n);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1554256,
                "title": "faster-than-100-of-c-solutions-intuitive-approach-simplified-explanation",
                "content": "Hello everyone, I\\'m new to this post stuff so any feedback is appreciated. Thank you in advance for reading !!!\\n\\n**Summary:** Since, we need to find every possible ways to reach from starting to ending cell while visiting every cell of the grid, we need to find the starting cell first and also need to count the empty cells that can be visited. Then we\\'ll find every path recursively.\\n\\n**Explanation:**\\n\\n1. We first find the starting cell of the grid and count the empty cells (with value 0) that can be visited.\\n\\n2. We will use simple dfs to visit every cell and keep the track of visited cells by a booloean array.\\n\\n3. for any cell (i,j) we check whether it is a valid cell or not (can be visited or not), then we check whether this cell is our ending cell or not and also we have visited all empty cells or not (a simple variable can keep a track of that).\\n\\n4. Then we recursively traverse in all four direction from this cell and try to find ways to reach to our destination.\\n\\n5. Then we backtrack i.e. unmark this cell (change it from visited to unvisited so that other paths can consider this cell for a visit) and return the total ways we can reach to our ending cell from this current cell.\\n\\nBelow is my code for the above approach:\\n\\n```\\nclass Solution {\\npublic:\\n    int startx, starty, tot{1};\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    \\n    int find_ways(int x, int y, int blocks, vector<vector<bool>>& vis, vector<vector<int>>& grid){\\n        \\n        // not a valid cell\\n        if(x < 0 || x >=grid.size() || y >= grid[0].size() || y < 0 || vis[x][y] || grid[x][y] == -1) \\n            return 0;\\n        \\n        // ending cell\\n        if(grid[x][y] == 2){\\n            \\n            if(blocks == tot) return 1;\\n            else return 0;\\n        }\\n        \\n        int res{};\\n        \\n        vis[x][y] = true; // mark this cell as visited\\n        \\n        //Traverse in all 4 directions\\n        for(int i{}; i<4; ++i){\\n            \\n            int new_x = x + dx[i];\\n            int new_y = y + dy[i];\\n            \\n            res += find_ways(new_x, new_y, blocks+1, vis, grid);\\n        }\\n        \\n        // mark this cell as unvisited as we are going back to our previous cell\\n        // so that other paths can consider this cell to visit\\n        vis[x][y] = false; \\n        \\n        return res;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<bool>>vis(n, vector<bool>(m, false));\\n        \\n        // count empty cells and find starting cell\\n        for(int i{}; i<n; ++i){ \\n            for(int j{}; j<m; ++j){\\n                \\n                if(grid[i][j] == 0) tot++;\\n                \\n                if(grid[i][j] == 1) startx = i, starty = j;\\n            }\\n        }\\n        \\n        return find_ways(startx, starty, 0, vis, grid);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int startx, starty, tot{1};\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    \\n    int find_ways(int x, int y, int blocks, vector<vector<bool>>& vis, vector<vector<int>>& grid){\\n        \\n        // not a valid cell\\n        if(x < 0 || x >=grid.size() || y >= grid[0].size() || y < 0 || vis[x][y] || grid[x][y] == -1) \\n            return 0;\\n        \\n        // ending cell\\n        if(grid[x][y] == 2){\\n            \\n            if(blocks == tot) return 1;\\n            else return 0;\\n        }\\n        \\n        int res{};\\n        \\n        vis[x][y] = true; // mark this cell as visited\\n        \\n        //Traverse in all 4 directions\\n        for(int i{}; i<4; ++i){\\n            \\n            int new_x = x + dx[i];\\n            int new_y = y + dy[i];\\n            \\n            res += find_ways(new_x, new_y, blocks+1, vis, grid);\\n        }\\n        \\n        // mark this cell as unvisited as we are going back to our previous cell\\n        // so that other paths can consider this cell to visit\\n        vis[x][y] = false; \\n        \\n        return res;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<bool>>vis(n, vector<bool>(m, false));\\n        \\n        // count empty cells and find starting cell\\n        for(int i{}; i<n; ++i){ \\n            for(int j{}; j<m; ++j){\\n                \\n                if(grid[i][j] == 0) tot++;\\n                \\n                if(grid[i][j] == 1) startx = i, starty = j;\\n            }\\n        }\\n        \\n        return find_ways(startx, starty, 0, vis, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438002,
                "title": "c-faster-than-100-by-simple-backtracking",
                "content": "It\\'s written in pretty simple manner and with a simple logic that whenever we reach the finishing point we check that every part in the grid is visited or not... if it is then we just increase the count.\\n```\\nclass Solution {\\nprivate:\\n    void helper(vector<vector<int>>& grid, bool**visited,int m,int n,int i,int j,int &count){\\n       \\n        \\n        visited[i][j]=true;\\n        \\n        if(grid[i][j]==2){\\n            for(int a=0;a<m;a++){\\n                for(int b=0;b<n;b++){\\n                    if(visited[a][b]==false){\\n                        visited[i][j]=false;\\n                        return;\\n                    }\\n                }\\n            }\\n            count++;\\n            visited[i][j]=false;\\n            return;\\n        }\\n        \\n        for(int x=i-1;x<=i+1;x++){\\n            if(x>=0 and x<m and visited[x][j]==false){\\n                helper(grid,visited,m,n,x,j,count);\\n            }\\n        }\\n        \\n         for(int y=j-1;y<=j+1;y++){\\n            if(y>=0 and y<n and visited[i][y]==false){\\n                helper(grid,visited,m,n,i,y,count);\\n            }\\n        }\\n        \\n        visited[i][j]=false;\\n\\n    }\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool**visited=new bool*[m];\\n        for(int i=0;i<m;i++){\\n            visited[i]=new bool[n];\\n            for(int j=0;j<n;j++){\\n                visited[i][j]=false;\\n                if(grid[i][j]==-1)visited[i][j]=true;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    helper(grid,visited,m,n,i,j,count);\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    void helper(vector<vector<int>>& grid, bool**visited,int m,int n,int i,int j,int &count){\\n       \\n        \\n        visited[i][j]=true;\\n        \\n        if(grid[i][j]==2){\\n            for(int a=0;a<m;a++){\\n                for(int b=0;b<n;b++){\\n                    if(visited[a][b]==false){\\n                        visited[i][j]=false;\\n                        return;\\n                    }\\n                }\\n            }\\n            count++;\\n            visited[i][j]=false;\\n            return;\\n        }\\n        \\n        for(int x=i-1;x<=i+1;x++){\\n            if(x>=0 and x<m and visited[x][j]==false){\\n                helper(grid,visited,m,n,x,j,count);\\n            }\\n        }\\n        \\n         for(int y=j-1;y<=j+1;y++){\\n            if(y>=0 and y<n and visited[i][y]==false){\\n                helper(grid,visited,m,n,i,y,count);\\n            }\\n        }\\n        \\n        visited[i][j]=false;\\n\\n    }\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool**visited=new bool*[m];\\n        for(int i=0;i<m;i++){\\n            visited[i]=new bool[n];\\n            for(int j=0;j<n;j++){\\n                visited[i][j]=false;\\n                if(grid[i][j]==-1)visited[i][j]=true;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    helper(grid,visited,m,n,i,j,count);\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633943,
                "title": "essence-of-backtracking-brief-explanation",
                "content": "```\\nint x[] = {-1,0,1,0};   // direction coordinates for guidance of next move\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int start_i, start_j, end_i,end_j,n,m,ob;// ob == no of obstacles\\n    long long ans;\\n    \\n    void sub(vector<vector<int>> &mat , vector<vector<bool>> &vis, int si, int sj, int &mark)\\n    {\\n        if(si==end_i and sj==end_j)\\n        { \\n            if(mark== n*m-ob-1) // total cell - no of obstacle - 1 , why -1 ? as we are not counting for endi,j\\n                ans++ ; \\n            return;\\n        }\\n        \\n        for(int k=0 ; k<4 ; k++)\\n        {\\n            int newi = si+x[k]; // our new i and j\\n            int newj = sj+y[k];\\n            \\n            //we must look that newi,j is valid and not been visited and doesnot have obstacle\\n            if(newi>=0 and newi<n and newj>=0 and newj<m and mat[newi][newj]!=-1 and !vis[newi][newj])\\n            {\\n                vis[newi][newj]=true;\\n                sub(mat,vis,newi, newj, ++mark);\\n                vis[newi][newj]=false,mark--;          // backtracking step\\n            }\\n        }\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& mat) {        \\n        n = mat.size();\\n        m = mat[0].size();\\n        ans = ob = 0;\\n        int mark=0;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(mat[i][j]==-1) ob++;\\n                if(mat[i][j]==1)\\n                    start_i = i, start_j = j;\\n                if(mat[i][j]==2)\\n                    end_i = i, end_j = j;\\n            }\\n        }\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        vis[start_i][start_j] = true;\\n        sub(mat,vis,start_i , start_j,mark);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nint x[] = {-1,0,1,0};   // direction coordinates for guidance of next move\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int start_i, start_j, end_i,end_j,n,m,ob;// ob == no of obstacles\\n    long long ans;\\n    \\n    void sub(vector<vector<int>> &mat , vector<vector<bool>> &vis, int si, int sj, int &mark)\\n    {\\n        if(si==end_i and sj==end_j)\\n        { \\n            if(mark== n*m-ob-1) // total cell - no of obstacle - 1 , why -1 ? as we are not counting for endi,j\\n                ans++ ; \\n            return;\\n        }\\n        \\n        for(int k=0 ; k<4 ; k++)\\n        {\\n            int newi = si+x[k]; // our new i and j\\n            int newj = sj+y[k];\\n            \\n            //we must look that newi,j is valid and not been visited and doesnot have obstacle\\n            if(newi>=0 and newi<n and newj>=0 and newj<m and mat[newi][newj]!=-1 and !vis[newi][newj])\\n            {\\n                vis[newi][newj]=true;\\n                sub(mat,vis,newi, newj, ++mark);\\n                vis[newi][newj]=false,mark--;          // backtracking step\\n            }\\n        }\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& mat) {        \\n        n = mat.size();\\n        m = mat[0].size();\\n        ans = ob = 0;\\n        int mark=0;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(mat[i][j]==-1) ob++;\\n                if(mat[i][j]==1)\\n                    start_i = i, start_j = j;\\n                if(mat[i][j]==2)\\n                    end_i = i, end_j = j;\\n            }\\n        }\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        vis[start_i][start_j] = true;\\n        sub(mat,vis,start_i , start_j,mark);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267094,
                "title": "python3-solution-using-backtracking",
                "content": "## Thought process\\n- backtracking\\n\\t- 4 subroutine calls\\n\\t\\t- backtrack(i, j+1) + backtrack(i, j-1) + backtrack(i+1, j) + backtrack(i-1, j)\\n\\t\\t- need to be aware of the current state (grid)\\n\\t\\t- base cases\\n\\t\\t\\t- i < 0 or i == m or j < 0 or j == n\\n\\t\\t\\t- grid[i][j] == -1: return 0\\n\\t\\t\\t- grid[i][j] == 2: return 1 if all other non-empty cells are visited (by checking the remaining count), otherwise return 0\\n\\t\\t\\t- grid[i][j] == 0: mask current cell to be -1, return sum of 4 subroutine calls (remember to reset the state each subroutine calls)\\n\\n- cannot use DP for cache because of the dynamic state?\\n\\n## Code\\n```py\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        m, n = len(grid), len(grid[0])\\n        non_empty_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != -1:\\n                    non_empty_count += 1\\n                if grid[i][j] == 1:\\n                    start_i, start_j = i, j\\n                    \\n        def backtrack(i, j, remain):\\n            if i < 0 or i == m or j < 0 or j == n or grid[i][j] == -1:\\n                return 0\\n            if grid[i][j] == 2:\\n                return remain == 1\\n            res = 0\\n            grid[i][j] = -1\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                res += backtrack(x, y, remain-1)\\n            grid[i][j] = 0\\n            return res\\n\\n        return backtrack(start_i, start_j, non_empty_count)\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```py\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        m, n = len(grid), len(grid[0])\\n        non_empty_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != -1:\\n                    non_empty_count += 1\\n                if grid[i][j] == 1:\\n                    start_i, start_j = i, j\\n                    \\n        def backtrack(i, j, remain):\\n            if i < 0 or i == m or j < 0 or j == n or grid[i][j] == -1:\\n                return 0\\n            if grid[i][j] == 2:\\n                return remain == 1\\n            res = 0\\n            grid[i][j] = -1\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                res += backtrack(x, y, remain-1)\\n            grid[i][j] = 0\\n            return res\\n\\n        return backtrack(start_i, start_j, non_empty_count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222466,
                "title": "python-bit-mask-dp-solution",
                "content": "Similar to [847. Shortest Path Visiting All Nodes](https://leetcode.com/problems/shortest-path-visiting-all-nodes/), we can use DP.\\n\\nThe dp state involves visited positions and current position. The visited positions are marked by a bit mask ---- the `(a*M + b)`-th bit is set if `grid[a][b]` has been visited. The DP state should also include the current position `(i,j)`.\\n\\n`dp[(mask, i, j)]` is the number of unique paths to get to position `(i,j)` by visiting all positions marked by set bits in the `mask`. \\n\\nSay for input grid:\\n```\\n[[2,0,0,1,-1]]\\n```\\nwe start from state `(0b01000, 0, 3)` to reach `(0b01111, 0, 0)`. Initially `dp[(0b01000, 0, 3)] = 1` and we want to find out `dp[(0b01111, 0, 0)]`.\\n\\nWe can do bottom-up style DP by BFS. There are `2^(N*M)` * N * M states and also 4 choices, so O(N * M * 2^(N*M)) time complexity.\\n\\n```\\n    def uniquePathsIII(self, grid):\\n        N, M = len(grid), len(grid[0])\\n        \\n        full = 0\\n        for i, j in itertools.product(range(N), range(M)):\\n                if grid[i][j] != -1: full |= 1 <<(i*M+j)\\n                if grid[i][j] == 1: x, y = i, j\\n                elif grid[i][j] == 2: u, v = i, j\\n        \\n        dp = {(1<<(x*M+y),x,y): 1}\\n        \\n        bfs = set([(1<<(x*M+y),x,y)])\\n        while bfs:\\n            tmp = set()\\n            for mask, i, j in bfs:\\n                if (i, j) == (u, v): continue\\n                for a, b in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= a < N and 0 <= b < M and grid[a][b] != -1:\\n                        bit = 1 << (a*M + b)\\n                        if mask & bit: continue\\n                        newstate = (mask | bit, a, b)\\n                        dp[newstate] = dp.setdefault(newstate, 0) + dp[mask,i,j]\\n                        tmp.add(newstate)\\n            bfs = tmp\\n        return dp.setdefault((full,u,v), 0)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n[[2,0,0,1,-1]]\\n```\n```\\n    def uniquePathsIII(self, grid):\\n        N, M = len(grid), len(grid[0])\\n        \\n        full = 0\\n        for i, j in itertools.product(range(N), range(M)):\\n                if grid[i][j] != -1: full |= 1 <<(i*M+j)\\n                if grid[i][j] == 1: x, y = i, j\\n                elif grid[i][j] == 2: u, v = i, j\\n        \\n        dp = {(1<<(x*M+y),x,y): 1}\\n        \\n        bfs = set([(1<<(x*M+y),x,y)])\\n        while bfs:\\n            tmp = set()\\n            for mask, i, j in bfs:\\n                if (i, j) == (u, v): continue\\n                for a, b in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= a < N and 0 <= b < M and grid[a][b] != -1:\\n                        bit = 1 << (a*M + b)\\n                        if mask & bit: continue\\n                        newstate = (mask | bit, a, b)\\n                        dp[newstate] = dp.setdefault(newstate, 0) + dp[mask,i,j]\\n                        tmp.add(newstate)\\n            bfs = tmp\\n        return dp.setdefault((full,u,v), 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2975953,
                "title": "c-easy-and-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem is based on finding an appropriate path from source to destination. \\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nFirstly using recursion and Backtracking we first find all possible paths from source to destination and then select the path which covers all the cells except the cell on which we cannot walk.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int m,n,o=0;\\n    bool check(int x,int y,vector<vector<int>>& grid,vector<pair<int,int>> visited){\\n        if(x<0||x>=m||y<0||y>=n||grid[x][y]==-1){\\n            return false;\\n        }\\n        for(int i=0;i<visited.size();i++){\\n            if(visited[i].first==x&&visited[i].second==y){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solution(vector<vector<int>>& grid,int x,int y,vector<pair<int,int>> visited){\\n        if(check(x,y,grid,visited)){\\n            if(grid[x][y]==2&&visited.size()==(m*n)-o-1){b\\n                ans++;\\n                return;\\n            }\\n            if(grid[x][y]==2){\\n                return;\\n            }\\n            visited.push_back({x,y});\\n            solution(grid,x+1,y,visited);\\n            solution(grid,x,y+1,visited);\\n            solution(grid,x-1,y,visited);\\n            solution(grid,x,y-1,visited);\\n        }\\n        return;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int a,b;\\n        bool k=true;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1&&k){\\n                    k=false;\\n                    a=i;\\n                    b=j;\\n                }\\n                cout<<i<<\" \"<<j<<endl;\\n                if(grid[i][j]==-1){\\n                    o++;\\n                }\\n            }\\n        }\\n        vector<pair<int,int>> visited;\\n        solution(grid,a,b,visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int m,n,o=0;\\n    bool check(int x,int y,vector<vector<int>>& grid,vector<pair<int,int>> visited){\\n        if(x<0||x>=m||y<0||y>=n||grid[x][y]==-1){\\n            return false;\\n        }\\n        for(int i=0;i<visited.size();i++){\\n            if(visited[i].first==x&&visited[i].second==y){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solution(vector<vector<int>>& grid,int x,int y,vector<pair<int,int>> visited){\\n        if(check(x,y,grid,visited)){\\n            if(grid[x][y]==2&&visited.size()==(m*n)-o-1){b\\n                ans++;\\n                return;\\n            }\\n            if(grid[x][y]==2){\\n                return;\\n            }\\n            visited.push_back({x,y});\\n            solution(grid,x+1,y,visited);\\n            solution(grid,x,y+1,visited);\\n            solution(grid,x-1,y,visited);\\n            solution(grid,x,y-1,visited);\\n        }\\n        return;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int a,b;\\n        bool k=true;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1&&k){\\n                    k=false;\\n                    a=i;\\n                    b=j;\\n                }\\n                cout<<i<<\" \"<<j<<endl;\\n                if(grid[i][j]==-1){\\n                    o++;\\n                }\\n            }\\n        }\\n        vector<pair<int,int>> visited;\\n        solution(grid,a,b,visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2975189,
                "title": "python-simple-python-solution-using-dfs-backtracking-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 61 ms, faster than 87.68% of Python3 online submissions for Unique Paths III.\\n# Memory Usage: 13.9 MB, less than 54.63% of Python3 online submissions for Unique Paths III.\\n\\n\\tclass Solution:\\n\\t\\tdef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tdef DFS(row, col, count_zero, grid):\\n\\n\\t\\t\\t\\tif row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == -1:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tif grid[row][col] == 2:\\n\\t\\t\\t\\t\\tif count_zero == -1:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tgrid[row][col] = -1\\n\\n\\t\\t\\t\\tcount_zero = count_zero - 1\\n\\n\\t\\t\\t\\ttotal_paths = DFS(row + 1, col, count_zero, grid) + DFS(row, col + 1, count_zero, grid) + DFS(row - 1, col, count_zero, grid) + DFS(row, col - 1, count_zero, grid)\\n\\n\\t\\t\\t\\tgrid[row][col] = 0\\n\\n\\t\\t\\t\\tcount_zero = count_zero + 1\\n\\n\\t\\t\\t\\treturn total_paths\\n\\n\\t\\t\\tcount_zero = 0\\n\\t\\t\\tx,y = 0,0\\n\\n\\t\\t\\tfor r in range(len(grid)):\\n\\t\\t\\t\\tfor c in range(len(grid[0])):\\n\\n\\t\\t\\t\\t\\tif grid[r][c] == 0:\\n\\t\\t\\t\\t\\t\\tcount_zero = count_zero + 1\\n\\n\\t\\t\\t\\t\\telif grid[r][c] == 1:\\n\\t\\t\\t\\t\\t\\tx,y = r,c\\n\\n\\t\\t\\treturn DFS(x, y, count_zero, grid)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 61 ms, faster than 87.68% of Python3 online submissions for Unique Paths III.\\n# Memory Usage: 13.9 MB, less than 54.63% of Python3 online submissions for Unique Paths III.\\n\\n\\tclass Solution:\\n\\t\\tdef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tdef DFS(row, col, count_zero, grid):\\n\\n\\t\\t\\t\\tif row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == -1:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tif grid[row][col] == 2:\\n\\t\\t\\t\\t\\tif count_zero == -1:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tgrid[row][col] = -1\\n\\n\\t\\t\\t\\tcount_zero = count_zero - 1\\n\\n\\t\\t\\t\\ttotal_paths = DFS(row + 1, col, count_zero, grid) + DFS(row, col + 1, count_zero, grid) + DFS(row - 1, col, count_zero, grid) + DFS(row, col - 1, count_zero, grid)\\n\\n\\t\\t\\t\\tgrid[row][col] = 0\\n\\n\\t\\t\\t\\tcount_zero = count_zero + 1\\n\\n\\t\\t\\t\\treturn total_paths\\n\\n\\t\\t\\tcount_zero = 0\\n\\t\\t\\tx,y = 0,0\\n\\n\\t\\t\\tfor r in range(len(grid)):\\n\\t\\t\\t\\tfor c in range(len(grid[0])):\\n\\n\\t\\t\\t\\t\\tif grid[r][c] == 0:\\n\\t\\t\\t\\t\\t\\tcount_zero = count_zero + 1\\n\\n\\t\\t\\t\\t\\telif grid[r][c] == 1:\\n\\t\\t\\t\\t\\t\\tx,y = r,c\\n\\n\\t\\t\\treturn DFS(x, y, count_zero, grid)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2974852,
                "title": "c-dfs-backtracking-beats-100-0ms-runtime-explained-with-comments",
                "content": "# Intuition\\n\\nIn this problem we have to find the number of paths to reach from some point ```(x1, y1)``` to some point ```(x2, y2)``` and those paths should cover all the available cell exactly one time.\\n\\nSince we can move in all four directions, so we cannot apply any greedy algorithm.\\n\\nSo we should think about some brute-force approch which would cover all the possible paths and we will pick the valid paths.\\n\\nAfter thinking this much, we should always think about recursion and think about implementing it with backtracking.\\n\\nNote : After applying recursion, always try to think about applying Dynamic Programming to the code, in this case, it is not possible.\\n\\n# Approach\\n\\nSo first thing we should do is to find the total number of squares which we have to visit atleast once.\\n\\nAnd we need to find ```x1``` & ```y1``` (the starting coordinates).\\n\\nNow we need to calculate the total number of paths which satisfy the above condition.\\n\\nWe will create a 2-d array with name ```visited``` inwhich we will mark those coordinates as true which are already being included in the path.\\n\\nWe will write a recursive function inwhich first we check whether we are at a valid square or not , i.e., ```row``` and ```col``` should be in the range [0, m-1] and [0, n-1] respectively.\\n\\nIf the square is not valid, then we return, else we will check if the square is available or not. If ```grid[row][col]``` is equal to -1, it means it is not available and we will return.\\n\\nIf the square is already visited then we will return.\\n\\nThen we will check if the square is the ending point or not, if it is ending point then we can check the number of cells which are not being visited by the variable ```stepsRemaining```.\\n\\nIf stepsRemaining is equal to 0 then we can increment the variable ```totalNumberOfWays``` and then return.\\n\\nWe will mark the current square as visited and then call recursive function for all the four adjacent squares.\\n\\nAnd don\\'t forget to unmark the visited square.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> visited;\\n    int totalNumberOfWays = 0;\\n\\n    // Recursive function for traversing all paths\\n    void findPaths(int row, int col, int stepsRemaining, vector<vector<int>> &grid){\\n        \\n        // Checking if the square is valid or not\\n        if(row < 0 || col < 0 || row == grid.size() || col == grid[0].size()){\\n            return;\\n        }\\n\\n        // Checking whether the square is available or not\\n        if(grid[row][col] == -1 || visited[row][col] == 1){\\n            return;\\n        }\\n\\n        // Base Case\\n        if(grid[row][col] == 2){\\n            // checking if the path covered all squares or not\\n            if(stepsRemaining == 0){\\n                totalNumberOfWays++;\\n            }\\n            return;\\n        }\\n\\n        // Marking the square as visited\\n        visited[row][col] = 1;\\n\\n        // Recursive Calls for all adjacent squares\\n        findPaths(row - 1, col, stepsRemaining - 1, grid);\\n        findPaths(row + 1, col, stepsRemaining - 1, grid);\\n        findPaths(row, col - 1, stepsRemaining - 1, grid);\\n        findPaths(row, col + 1, stepsRemaining - 1, grid);\\n\\n        // Unmarking the square\\n        visited[row][col] = 0;\\n\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int x = 0;\\n        int y = 0;\\n        int totalSteps = 0;\\n        visited.resize(m, vector<int>(n, 0));\\n\\n        // counting total number of available squares\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == -1){\\n                    continue;\\n                }\\n                if(grid[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n                totalSteps++;\\n            }\\n        }\\n\\n        findPaths(x, y, totalSteps - 1, grid);\\n\\n        return totalNumberOfWays;\\n        \\n    }\\n};\\n```\\n\\nIn case of any queries, feel free to ask in the comment section.\\n\\nIf you like the explanation then please **upvote**. It took me a lot of efforts to write this article.\\n\\nThank you for reading till the end : )",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```(x1, y1)```\n```(x2, y2)```\n```x1```\n```y1```\n```visited```\n```row```\n```col```\n```grid[row][col]```\n```stepsRemaining```\n```totalNumberOfWays```\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> visited;\\n    int totalNumberOfWays = 0;\\n\\n    // Recursive function for traversing all paths\\n    void findPaths(int row, int col, int stepsRemaining, vector<vector<int>> &grid){\\n        \\n        // Checking if the square is valid or not\\n        if(row < 0 || col < 0 || row == grid.size() || col == grid[0].size()){\\n            return;\\n        }\\n\\n        // Checking whether the square is available or not\\n        if(grid[row][col] == -1 || visited[row][col] == 1){\\n            return;\\n        }\\n\\n        // Base Case\\n        if(grid[row][col] == 2){\\n            // checking if the path covered all squares or not\\n            if(stepsRemaining == 0){\\n                totalNumberOfWays++;\\n            }\\n            return;\\n        }\\n\\n        // Marking the square as visited\\n        visited[row][col] = 1;\\n\\n        // Recursive Calls for all adjacent squares\\n        findPaths(row - 1, col, stepsRemaining - 1, grid);\\n        findPaths(row + 1, col, stepsRemaining - 1, grid);\\n        findPaths(row, col - 1, stepsRemaining - 1, grid);\\n        findPaths(row, col + 1, stepsRemaining - 1, grid);\\n\\n        // Unmarking the square\\n        visited[row][col] = 0;\\n\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int x = 0;\\n        int y = 0;\\n        int totalSteps = 0;\\n        visited.resize(m, vector<int>(n, 0));\\n\\n        // counting total number of available squares\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == -1){\\n                    continue;\\n                }\\n                if(grid[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n                totalSteps++;\\n            }\\n        }\\n\\n        findPaths(x, y, totalSteps - 1, grid);\\n\\n        return totalNumberOfWays;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974379,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS + Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, ans, zero;\\n\\n    void dfs(int x, int y) {\\n        if(x < 0 or x >= n or y < 0 or y >= m or grids[x][y] == -1) {\\n            return;\\n        }\\n        if(grids[x][y] == 2) {\\n            if(zero == -1) ans++;\\n            return;\\n        }\\n        grids[x][y] = -1;\\n        zero--;\\n        dfs(x-1, y);\\n        dfs(x+1, y);\\n        dfs(x, y-1);\\n        dfs(x, y+1);\\n        zero++;\\n        grids[x][y] = 0;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        grids = grid;\\n        n = grid.size(), m = grid[0].size();\\n        int sx, sy;;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] == 1) sx = i, sy = j;\\n                else if(grid[i][j] == 0) zero++;\\n            }\\n        }\\n        dfs(sx, sy);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, ans, zero;\\n\\n    void dfs(int x, int y) {\\n        if(x < 0 or x >= n or y < 0 or y >= m or grids[x][y] == -1) {\\n            return;\\n        }\\n        if(grids[x][y] == 2) {\\n            if(zero == -1) ans++;\\n            return;\\n        }\\n        grids[x][y] = -1;\\n        zero--;\\n        dfs(x-1, y);\\n        dfs(x+1, y);\\n        dfs(x, y-1);\\n        dfs(x, y+1);\\n        zero++;\\n        grids[x][y] = 0;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        grids = grid;\\n        n = grid.size(), m = grid[0].size();\\n        int sx, sy;;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] == 1) sx = i, sy = j;\\n                else if(grid[i][j] == 0) zero++;\\n            }\\n        }\\n        dfs(sx, sy);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974071,
                "title": "c-simple-dfs-logic-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n   int f(int i,int j,vector<vector<int>> &grid,int &c,int cnt)\\n   {\\n       if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or grid[i][j]==-1)\\n           return 0;\\n       if(grid[i][j]==2)\\n       {\\n           cnt-=1;//-1 since we have also included start cell\\n           return (cnt==c)?1:0;//if all empty cells visited then returning 1 else 0\\n       }\\n       grid[i][j]=-1;\\n       int sum=0;\\n       sum=f(i+1,j,grid,c,cnt+1)+f(i,j+1,grid,c,cnt+1)+f(i-1,j,grid,c,cnt+1)+f(i,j-1,grid,c,cnt+1);\\n       grid[i][j]=0;\\n       return sum;\\n   }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<pair<int,int>> s;\\n        int c=0;//for counting no of empty cells\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    s.push_back({i,j});//for storing starting indexes\\n                if(grid[i][j]==0)\\n                    c++;\\n            }\\n        }\\n       return f(s[0].first,s[0].second,grid,c,0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n   int f(int i,int j,vector<vector<int>> &grid,int &c,int cnt)\\n   {\\n       if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or grid[i][j]==-1)\\n           return 0;\\n       if(grid[i][j]==2)\\n       {\\n           cnt-=1;//-1 since we have also included start cell\\n           return (cnt==c)?1:0;//if all empty cells visited then returning 1 else 0\\n       }\\n       grid[i][j]=-1;\\n       int sum=0;\\n       sum=f(i+1,j,grid,c,cnt+1)+f(i,j+1,grid,c,cnt+1)+f(i-1,j,grid,c,cnt+1)+f(i,j-1,grid,c,cnt+1);\\n       grid[i][j]=0;\\n       return sum;\\n   }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<pair<int,int>> s;\\n        int c=0;//for counting no of empty cells\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    s.push_back({i,j});//for storing starting indexes\\n                if(grid[i][j]==0)\\n                    c++;\\n            }\\n        }\\n       return f(s[0].first,s[0].second,grid,c,0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057209,
                "title": "c-2-solution-recursive-to-memoization-easy",
                "content": "**Recursive Solution :**\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int c,int& empty,vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;\\n        if(grid[i][j]==2){\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        grid[i][j]=-1;\\n        int up=f(i-1,j,c+1,empty,grid);\\n        int down=f(i+1,j,c+1,empty,grid);\\n        int right=f(i,j+1,c+1,empty,grid);\\n        int left=f(i,j-1,c+1,empty,grid);\\n        grid[i][j]=0;\\n        return up+down+right+left;        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i=0,j=0,empty=1,start_x=0,start_y=0;\\n        for(i;i<grid.size();i++){\\n            for(j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    start_x=i;\\n                    start_y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        return f(start_x,start_y,0,empty,grid);\\n    }\\n};\\n```\\n\\n**Memoization Solution :**\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int c,int& empty,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;        \\n        if(grid[i][j]==2){\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][c]!=-1)return dp[i][j][c];\\n        \\n        grid[i][j]=-1;\\n        int up=f(i-1,j,c+1,empty,grid,dp);\\n        int down=f(i+1,j,c+1,empty,grid,dp);\\n        int right=f(i,j+1,c+1,empty,grid,dp);\\n        int left=f(i,j-1,c+1,empty,grid,dp);\\n        grid[i][j]=0;\\n        return dp[i][j][c+1]=(up+down+right+left);        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i=0,j=0,empty=1,start_x=0,start_y=0;\\n        for(i;i<grid.size();i++){\\n            for(j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    start_x=i;\\n                    start_y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>> (grid[0].size(),vector<int> (empty+1,-1)));\\n        return f(start_x,start_y,0,empty,grid,dp);\\n    }\\n};\\n```\\n\\n**Please Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int c,int& empty,vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;\\n        if(grid[i][j]==2){\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        grid[i][j]=-1;\\n        int up=f(i-1,j,c+1,empty,grid);\\n        int down=f(i+1,j,c+1,empty,grid);\\n        int right=f(i,j+1,c+1,empty,grid);\\n        int left=f(i,j-1,c+1,empty,grid);\\n        grid[i][j]=0;\\n        return up+down+right+left;        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i=0,j=0,empty=1,start_x=0,start_y=0;\\n        for(i;i<grid.size();i++){\\n            for(j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    start_x=i;\\n                    start_y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        return f(start_x,start_y,0,empty,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int c,int& empty,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;        \\n        if(grid[i][j]==2){\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][c]!=-1)return dp[i][j][c];\\n        \\n        grid[i][j]=-1;\\n        int up=f(i-1,j,c+1,empty,grid,dp);\\n        int down=f(i+1,j,c+1,empty,grid,dp);\\n        int right=f(i,j+1,c+1,empty,grid,dp);\\n        int left=f(i,j-1,c+1,empty,grid,dp);\\n        grid[i][j]=0;\\n        return dp[i][j][c+1]=(up+down+right+left);        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i=0,j=0,empty=1,start_x=0,start_y=0;\\n        for(i;i<grid.size();i++){\\n            for(j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    start_x=i;\\n                    start_y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>> (grid[0].size(),vector<int> (empty+1,-1)));\\n        return f(start_x,start_y,0,empty,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842954,
                "title": "clean-python-dfs-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        row_movements = [1, -1, 0, 0] # Possible changes in row index\\n        col_movements = [0, 0, 1, -1] # Possible changes in row index\\n        ways = 0 # Answer variable\\n        max_row = len(grid)\\n        max_col = len(grid[0])\\n        total = max_row * max_col # Total number of blocks to cover\\n        for r in range(max_row):\\n            for c in range(max_col):\\n                if grid[r][c] == -1: # Remove the blocks which are obstacles\\n                    total -= 1\\n\\n        def backtrack(row, col, visited, current_count): # Current row, col, visited indices and number of blocks traversed so far.\\n            nonlocal ways\\n            if grid[row][col] == 2 and current_count >= total: # Breaking conditions met\\n                ways += 1\\n\\t\\t\\t\\treturn\\n            for i in range(4): # 4 Possible movements from a certain row, column index\\n                r = row + row_movements[i]\\n                c = col + col_movements[i]\\n                if 0 <= r < max_row and 0 <= c < max_col and grid[r][c] != -1 and not visited[r][c]: # If the new r, c index is in range, is not an obstacle and is not yet visited\\n                    visited[r][c] = True # Traverse forward with visited set to true\\n                    backtrack(r, c, visited, current_count + 1) # DFS traversal\\n                    visited[r][c] = False # Backtrack by setting visited to false\\n\\n        for r in range(max_row):\\n            for c in range(max_col):\\n                if grid[r][c] == 1: # Starting index found\\n                    visited = [[False] * max_col for _ in range(max_row)]\\n                    visited[r][c] = True # Set starting index to True\\n                    backtrack(r, c, visited, 1) # Start DFS from starting index\\n                    return ways\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        row_movements = [1, -1, 0, 0] # Possible changes in row index\\n        col_movements = [0, 0, 1, -1] # Possible changes in row index\\n        ways = 0 # Answer variable\\n        max_row = len(grid)\\n        max_col = len(grid[0])\\n        total = max_row * max_col # Total number of blocks to cover\\n        for r in range(max_row):\\n            for c in range(max_col):\\n                if grid[r][c] == -1: # Remove the blocks which are obstacles\\n                    total -= 1\\n\\n        def backtrack(row, col, visited, current_count): # Current row, col, visited indices and number of blocks traversed so far.\\n            nonlocal ways\\n            if grid[row][col] == 2 and current_count >= total: # Breaking conditions met\\n                ways += 1\\n\\t\\t\\t\\treturn\\n            for i in range(4): # 4 Possible movements from a certain row, column index\\n                r = row + row_movements[i]\\n                c = col + col_movements[i]\\n                if 0 <= r < max_row and 0 <= c < max_col and grid[r][c] != -1 and not visited[r][c]: # If the new r, c index is in range, is not an obstacle and is not yet visited\\n                    visited[r][c] = True # Traverse forward with visited set to true\\n                    backtrack(r, c, visited, current_count + 1) # DFS traversal\\n                    visited[r][c] = False # Backtrack by setting visited to false\\n\\n        for r in range(max_row):\\n            for c in range(max_col):\\n                if grid[r][c] == 1: # Starting index found\\n                    visited = [[False] * max_col for _ in range(max_row)]\\n                    visited[r][c] = True # Set starting index to True\\n                    backtrack(r, c, visited, 1) # Start DFS from starting index\\n                    return ways\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821266,
                "title": "one-of-the-easiest-and-simplest-explanation",
                "content": "**First Try to understand the algo of Code**![image](https://assets.leetcode.com/users/images/a8bdc530-b192-4e98-819a-acba136a730a_1646474710.3266397.jpeg)\\n\\n# Let see the code\\n\\'\\'\\'\\n\\n      public int uniquePathsIII(int[][] grid) {\\n        boolean[][] path = new boolean[grid.length][grid[0].length];\\n\\n        // Total Number of boxes in Matrix\\n        int totalBlock=grid.length * grid[0].length;\\n\\n        int minusblock=0;\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==1){\\n                    // To find the starting position of Robot\\n                    a=i;\\n                    b=j;\\n                }\\n                if(grid[i][j]==-1){\\n                    // Number of Minus Block\\n                    minusblock++;\\n                }\\n\\n            }\\n\\n        }\\n        // -1 to exclude its position\\n        totalBlock=totalBlock-minusblock-1;\\n\\n\\n        return uniquePathsIII(grid,a,b,path,totalBlock,0);\\n\\n\\n    }\\n\\n    public int uniquePathsIII(int[][] grid,int row,int column,boolean[][] path,int totalblock,int achivedblock) {\\n\\n        // Base Case\\n        if(row<0||column<0||row>=grid.length||column>=grid[row].length){\\n            return 0;\\n        }\\n        // if robot come at -1 box and come twice at same box return 0;\\n        if(grid[row][column]==-1||path[row][column]){\\n            return 0;\\n        }\\n        //  ---- If robot reach at destination but ! did not caver all Boxex then return0\\n        if(grid[row][column]==2&&achivedblock!=totalblock){\\n            return 0;\\n\\n        }\\n\\n        // ----If robot reach at destination and caver all Boxex then return 1\\n        if(grid[row][column]==2&&achivedblock==totalblock){\\n\\n\\n            return 1;\\n        }\\n\\n        path[row][column]=true;\\n\\n       // In recursion we passes acheivedblock +1 Because we cover 1 box;\\n\\n        int option1= uniquePathsIII(grid,row+1,column,path,totalblock,achivedblock+1);\\n        int option2= uniquePathsIII(grid,row-1,column,path,totalblock,achivedblock+1);\\n        int option3= uniquePathsIII(grid,row,column+1,path,totalblock,achivedblock+1);\\n        int option4= uniquePathsIII(grid,row,column-1,path,totalblock,achivedblock+1);\\n        path[row][column]=false;\\n\\n        int ans=option1+option3+option4+option2;\\n\\n        return ans;\\n    }\\n\\n\\n\\n\\'\\'\\'\\nUpvote if you like\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "**First Try to understand the algo of Code**![image](https://assets.leetcode.com/users/images/a8bdc530-b192-4e98-819a-acba136a730a_1646474710.3266397.jpeg)\\n\\n# Let see the code\\n\\'\\'\\'\\n\\n      public int uniquePathsIII(int[][] grid) {\\n        boolean[][] path = new boolean[grid.length][grid[0].length];\\n\\n        // Total Number of boxes in Matrix\\n        int totalBlock=grid.length * grid[0].length;\\n\\n        int minusblock=0;\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==1){\\n                    // To find the starting position of Robot\\n                    a=i;\\n                    b=j;\\n                }\\n                if(grid[i][j]==-1){\\n                    // Number of Minus Block\\n                    minusblock++;\\n                }\\n\\n            }\\n\\n        }\\n        // -1 to exclude its position\\n        totalBlock=totalBlock-minusblock-1;\\n\\n\\n        return uniquePathsIII(grid,a,b,path,totalBlock,0);\\n\\n\\n    }\\n\\n    public int uniquePathsIII(int[][] grid,int row,int column,boolean[][] path,int totalblock,int achivedblock) {\\n\\n        // Base Case\\n        if(row<0||column<0||row>=grid.length||column>=grid[row].length){\\n            return 0;\\n        }\\n        // if robot come at -1 box and come twice at same box return 0;\\n        if(grid[row][column]==-1||path[row][column]){\\n            return 0;\\n        }\\n        //  ---- If robot reach at destination but ! did not caver all Boxex then return0\\n        if(grid[row][column]==2&&achivedblock!=totalblock){\\n            return 0;\\n\\n        }\\n\\n        // ----If robot reach at destination and caver all Boxex then return 1\\n        if(grid[row][column]==2&&achivedblock==totalblock){\\n\\n\\n            return 1;\\n        }\\n\\n        path[row][column]=true;\\n\\n       // In recursion we passes acheivedblock +1 Because we cover 1 box;\\n\\n        int option1= uniquePathsIII(grid,row+1,column,path,totalblock,achivedblock+1);\\n        int option2= uniquePathsIII(grid,row-1,column,path,totalblock,achivedblock+1);\\n        int option3= uniquePathsIII(grid,row,column+1,path,totalblock,achivedblock+1);\\n        int option4= uniquePathsIII(grid,row,column-1,path,totalblock,achivedblock+1);\\n        path[row][column]=false;\\n\\n        int ans=option1+option3+option4+option2;\\n\\n        return ans;\\n    }\\n\\n\\n\\n\\'\\'\\'\\nUpvote if you like\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1554979,
                "title": "c-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir={{0,-1},{0,1},{1,0},{-1,0}};\\n    int fx,fy;\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int result=0;\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                    fx=i;\\n                    fy=j;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    result=DFS(grid,visited,i,j,n,m);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    int DFS(vector<vector<int>>& grid,vector<vector<int>>& visited,int i,int j,int n,int m)\\n    {\\n        if(fx==i && fy==j)\\n         { bool flag=true;\\n          visited[i][j]=1;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(visited[i][j]==0 && grid[i][j]!=-1)\\n                        flag=false;\\n                }\\n            }\\n          visited[i][j]=0;\\n           if(flag)\\n            return 1;\\n           return 0;\\n         }\\n        visited[i][j]=1;\\n        int ans=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+dir[k][0];\\n            int y=j+dir[k][1];\\n            if(x<0 || x==n || y<0 || y==m)\\n                continue;\\n            if(visited[x][y]==1)\\n                continue;\\n            if(grid[x][y]==-1)\\n                continue;\\n            ans+=DFS(grid,visited,x,y,n,m);\\n        }\\n        visited[i][j]=0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir={{0,-1},{0,1},{1,0},{-1,0}};\\n    int fx,fy;\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int result=0;\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                    fx=i;\\n                    fy=j;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    result=DFS(grid,visited,i,j,n,m);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    int DFS(vector<vector<int>>& grid,vector<vector<int>>& visited,int i,int j,int n,int m)\\n    {\\n        if(fx==i && fy==j)\\n         { bool flag=true;\\n          visited[i][j]=1;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(visited[i][j]==0 && grid[i][j]!=-1)\\n                        flag=false;\\n                }\\n            }\\n          visited[i][j]=0;\\n           if(flag)\\n            return 1;\\n           return 0;\\n         }\\n        visited[i][j]=1;\\n        int ans=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+dir[k][0];\\n            int y=j+dir[k][1];\\n            if(x<0 || x==n || y<0 || y==m)\\n                continue;\\n            if(visited[x][y]==1)\\n                continue;\\n            if(grid[x][y]==-1)\\n                continue;\\n            ans+=DFS(grid,visited,x,y,n,m);\\n        }\\n        visited[i][j]=0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554970,
                "title": "dfs-with-python-beats-100-in-time",
                "content": "```\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n    m, n = len(grid), len(grid[0])\\n    start, cell = [0, 0], 0\\n    for i in range(m):\\n        for j in range(n):\\n            if grid[i][j] == 1: start = [i, j]\\n            if grid[i][j] == 0: cell += 1\\n    dir = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n\\n    def move_next(step, x, y):\\n        ans = 0\\n        for i, j in dir:\\n            x_, y_ = x + i, y + j\\n            if n > y_ >= 0 <= x_ < m:\\n                if grid[x_][y_] == 0:\\n                    grid[x_][y_] = -1 # move one step. set it to obstacle, preventing from re-visit this cell\\n                    ans += move_next(step + 1, x_, y_)\\n                    grid[x_][y_] = 0\\n                if grid[x_][y_] == 2 and step == cell:\\n                    ans += 1\\n        return ans\\n    return move_next(0, start[0], start[1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n    m, n = len(grid), len(grid[0])\\n    start, cell = [0, 0], 0\\n    for i in range(m):\\n        for j in range(n):\\n            if grid[i][j] == 1: start = [i, j]\\n            if grid[i][j] == 0: cell += 1\\n    dir = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n\\n    def move_next(step, x, y):\\n        ans = 0\\n        for i, j in dir:\\n            x_, y_ = x + i, y + j\\n            if n > y_ >= 0 <= x_ < m:\\n                if grid[x_][y_] == 0:\\n                    grid[x_][y_] = -1 # move one step. set it to obstacle, preventing from re-visit this cell\\n                    ans += move_next(step + 1, x_, y_)\\n                    grid[x_][y_] = 0\\n                if grid[x_][y_] == 2 and step == cell:\\n                    ans += 1\\n        return ans\\n    return move_next(0, start[0], start[1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1055598,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def uniquePathsIII(self, G: List[List[int]]) -> int:\\n        m,n = len(G), len(G[0])\\n        count = m*n\\n        for i in range(m):\\n            for j in range(n):\\n                if G[i][j]==1: start = (i,j)\\n                if G[i][j] == 2: end = (i,j)\\n                if G[i][j]==-1: count -= 1\\n        \\n        self.ans = 0\\n        def backtrack(i,j,path):\\n            if path[-1]==end:\\n                if len(path)==count: self.ans+=1\\n                return\\n            for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                if 0<=x<m and 0<=y<n and G[x][y] != -1 and (x,y) not in path:\\n                    backtrack(x,y,path + [(x,y)])\\n        backtrack(start[0],start[1],[start])\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, G: List[List[int]]) -> int:\\n        m,n = len(G), len(G[0])\\n        count = m*n\\n        for i in range(m):\\n            for j in range(n):\\n                if G[i][j]==1: start = (i,j)\\n                if G[i][j] == 2: end = (i,j)\\n                if G[i][j]==-1: count -= 1\\n        \\n        self.ans = 0\\n        def backtrack(i,j,path):\\n            if path[-1]==end:\\n                if len(path)==count: self.ans+=1\\n                return\\n            for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                if 0<=x<m and 0<=y<n and G[x][y] != -1 and (x,y) not in path:\\n                    backtrack(x,y,path + [(x,y)])\\n        backtrack(start[0],start[1],[start])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904897,
                "title": "python-easy-backtracking-dfs-beats-98-time-and-100-memory",
                "content": "```\\n\\nclass Solution:\\n    def uniquePathsIII(self, grid) -> int:\\n\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        non_obs = 0\\n\\n        for i, line in enumerate(grid):\\n            for j, cell in enumerate(line):\\n                if cell == 1:\\n\\t\\t\\t\\t    grid[st_row][st_col] = 0\\n                    st_row, st_col = i, j\\n                    non_obs += 1\\n                elif cell == 0:\\n                    non_obs += 1\\n        \\n        def count_paths(row, col, crossed):\\n\\n            if row < 0 or row >= rows or col < 0 or col >= cols:\\n                return 0\\n\\n            if grid[row][col] == 2 and crossed == non_obs:\\n                return 1\\n\\n            if grid[row][col] != 0:\\n                return 0\\n\\n            grid[row][col] = -1\\n            cnt = sum([count_paths(row+1, col, crossed + 1),\\n                       count_paths(row-1, col, crossed + 1),\\n                       count_paths(row, col+1, crossed + 1),\\n                       count_paths(row, col-1, crossed + 1)])\\n            grid[row][col] = 0\\n            return cnt\\n\\n        return count_paths(st_row, st_col, 0)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution:\\n    def uniquePathsIII(self, grid) -> int:\\n\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        non_obs = 0\\n\\n        for i, line in enumerate(grid):\\n            for j, cell in enumerate(line):\\n                if cell == 1:\\n\\t\\t\\t\\t    grid[st_row][st_col] = 0\\n                    st_row, st_col = i, j\\n                    non_obs += 1\\n                elif cell == 0:\\n                    non_obs += 1\\n        \\n        def count_paths(row, col, crossed):\\n\\n            if row < 0 or row >= rows or col < 0 or col >= cols:\\n                return 0\\n\\n            if grid[row][col] == 2 and crossed == non_obs:\\n                return 1\\n\\n            if grid[row][col] != 0:\\n                return 0\\n\\n            grid[row][col] = -1\\n            cnt = sum([count_paths(row+1, col, crossed + 1),\\n                       count_paths(row-1, col, crossed + 1),\\n                       count_paths(row, col+1, crossed + 1),\\n                       count_paths(row, col-1, crossed + 1)])\\n            grid[row][col] = 0\\n            return cnt\\n\\n        return count_paths(st_row, st_col, 0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856245,
                "title": "python-clean-99-6-no-boundary-checks",
                "content": "I like to avoid checking boundary conditions, hence the solution below:\\n```\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\trows, cols = len(grid), len(grid[0])\\n\\tdirections = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\tstart_cell, end_cell = None, None\\n\\tempty_cells = {} # the set of neighbors\\' positions for each cell\\n\\n\\t# collect empty cells\\n\\tfor i in range(rows):\\n\\t\\tfor j in range(cols):\\n\\t\\t\\tif grid[i][j] in [0, 1]:\\n\\t\\t\\t\\tempty_cells[(i, j)] = set()\\n\\t\\t\\t\\tif grid[i][j] == 1: start_cell = (i, j)\\n\\t\\t\\telif grid[i][j] == 2: end_cell = (i, j)\\n\\n\\t# collect their neighbors\\n\\tfor x, y in empty_cells:\\n\\t\\tfor xch, ych in directions:\\n\\t\\t\\tneighbor = (x + xch, y + ych)\\n\\t\\t\\tif neighbor in empty_cells: empty_cells[(x, y)].add(neighbor)\\n\\n\\tnext_to_finish = set((end_cell[0] + xch, end_cell[1] + ych) for xch, ych in directions)\\n\\tvisited=set([start_cell])\\n\\tdef count_routes(cell=start_cell):\\n\\t\\tleft_to_visit = len(empty_cells) - len(visited)\\n\\t\\tif not left_to_visit: return int(cell in next_to_finish)\\n\\t\\troutes_to_end = 0\\n\\t\\tfor neighbor in (empty_cells[cell] - visited):\\n\\t\\t\\tvisited.add(neighbor)\\n\\t\\t\\troutes_to_end += count_routes(neighbor)\\n\\t\\t\\tvisited.remove(neighbor)\\n\\t\\treturn routes_to_end\\n\\n\\treturn count_routes()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\trows, cols = len(grid), len(grid[0])\\n\\tdirections = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\tstart_cell, end_cell = None, None\\n\\tempty_cells = {} # the set of neighbors\\' positions for each cell\\n\\n\\t# collect empty cells\\n\\tfor i in range(rows):\\n\\t\\tfor j in range(cols):\\n\\t\\t\\tif grid[i][j] in [0, 1]:\\n\\t\\t\\t\\tempty_cells[(i, j)] = set()\\n\\t\\t\\t\\tif grid[i][j] == 1: start_cell = (i, j)\\n\\t\\t\\telif grid[i][j] == 2: end_cell = (i, j)\\n\\n\\t# collect their neighbors\\n\\tfor x, y in empty_cells:\\n\\t\\tfor xch, ych in directions:\\n\\t\\t\\tneighbor = (x + xch, y + ych)\\n\\t\\t\\tif neighbor in empty_cells: empty_cells[(x, y)].add(neighbor)\\n\\n\\tnext_to_finish = set((end_cell[0] + xch, end_cell[1] + ych) for xch, ych in directions)\\n\\tvisited=set([start_cell])\\n\\tdef count_routes(cell=start_cell):\\n\\t\\tleft_to_visit = len(empty_cells) - len(visited)\\n\\t\\tif not left_to_visit: return int(cell in next_to_finish)\\n\\t\\troutes_to_end = 0\\n\\t\\tfor neighbor in (empty_cells[cell] - visited):\\n\\t\\t\\tvisited.add(neighbor)\\n\\t\\t\\troutes_to_end += count_routes(neighbor)\\n\\t\\t\\tvisited.remove(neighbor)\\n\\t\\treturn routes_to_end\\n\\n\\treturn count_routes()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 753062,
                "title": "c-dfs-easy-explain-and-with-well-commented-100-faster",
                "content": "Once again this problem just the combination of dfs and backtracking so...\\nlet\\'s jump to the algo..\\nWe are allowed to go for any i,j\\n1. i+1,j\\n2. i-1 ,j\\n3. i,j+1\\n4. i,j-1\\nif and only if target grid has 0..\\nif any how we reach the end square i.e. grid[i][j]==2 then check weather all empty square visited or not if any not visited then this is not a valid path...\\n```\\nclass Solution {\\nvector<vector<int>> table;\\nint n,m;\\ninline bool isValidPath(){\\n\\tfor(int i=0 ; i<n ; i++){\\n\\t\\tfor(int j=0 ; j<m ; j++)\\n\\t\\t\\tif(table[i][j]==0) return false;\\n\\t}\\n\\treturn true;\\n}\\ninline bool isValidDir(int row , int col){\\n\\treturn (row<n && row>=0 && col<m && col>=0 && (table[row][col]==0 || table[row][col]==2));\\n}\\nint dfs(int row , int col){\\n//if we are at end square just check weather all empy square is visited or not\\n//if all visited then the path by which we reached here is a valid path else not valid path\\n\\tif(table[row][col]==2) return isValidPath();\\n\\ttable[row][col]=-1;//make it blocked \\n\\tint ans=0;\\n\\t//explore all the possible direction\\n\\tif(isValidDir(row+1,col)){\\n\\t\\tans+=dfs(row+1,col);\\n\\t}\\n\\tif(isValidDir(row-1,col)){\\n\\t\\tans+=dfs(row-1 , col);\\n\\t}\\n\\tif(isValidDir(row , col+1)){\\n\\t\\tans+=dfs(row , col+1);\\n\\t}\\n\\tif(isValidDir(row , col-1)){\\n\\t\\tans+=dfs(row , col-1);\\n\\t}\\n\\t//while backtracking we are going to reset because the path which has given valid or invalide\\n\\t//path then partial path can be use for other\\'s too\\n\\ttable[row][col]=0;\\n\\treturn ans;\\n}\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n    n=grid.size();\\n    m=grid[0].size();\\n    int row=-1,col=-1;\\n    table=grid;\\n\\t//find the position of start square\\n    for(int i=0 ; i<n &&row==-1 ; i++){\\n    \\tfor(int j=0 ; j<m && row==-1;j++){\\n    \\t\\tif(grid[i][j]==1) row=i,col=j;\\n    \\t}\\n    }\\n    int ans=dfs(row , col);\\n    return ans; \\n    }\\n};\\n```\\n## We can optimise it bit more\\nfor a valid path we just need to check weather we have any empty cell which is not visited yet so we can do in constant time instead of O(N^2)..\\nlook bellow implimentation\\n```\\nclass Solution {\\nvector<vector<int>> table;\\nint n,m;\\ninline bool isValidDir(int row , int col){\\n\\treturn (row<n && row>=0 && col<m && col>=0 && (table[row][col]==0 || table[row][col]==2));\\n}\\nint dfs(int row , int col,int nEmptyCell){\\n\\tif(table[row][col]==2) return (nEmptyCell<0);//(nEmptyCell<0) because we have incuded table[row][col] also as a empty square \\n\\tint x=table[row][col];\\n\\ttable[row][col]=-1;\\n\\tint ans=0;\\n\\tif(isValidDir(row+1,col)){\\n\\t\\tans+=dfs(row+1,col,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row-1,col)){\\n\\t\\tans+=dfs(row-1 , col,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row , col+1)){\\n\\t\\tans+=dfs(row , col+1,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row , col-1)){\\n\\t\\tans+=dfs(row , col-1,nEmptyCell-1);\\n\\t}\\n\\ttable[row][col]=x;\\n\\treturn ans;\\n}\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n    n=grid.size();\\n    m=grid[0].size();\\n    int row=-1,col=-1;\\n    table=grid;\\n      int nEmptyCell=0;\\n    for(int i=0 ; i<n  ; i++){\\n    \\tfor(int j=0 ; j<m ;j++){\\n    \\t\\tif(grid[i][j]==1) row=i,col=j;\\n        if(grid[i][j]==0) nEmptyCell++;\\n    \\t}\\n    }\\n    int ans=dfs(row , col,nEmptyCell);\\n    return ans; \\n    }\\n};\\n```\\n### Time complexity analysis\\nfor any i,j we have total 3 way to go because from one way we reached current i,j\\nso total 3 way... so for n it would be 3^n\\ntime complexity: O(3^N)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nvector<vector<int>> table;\\nint n,m;\\ninline bool isValidPath(){\\n\\tfor(int i=0 ; i<n ; i++){\\n\\t\\tfor(int j=0 ; j<m ; j++)\\n\\t\\t\\tif(table[i][j]==0) return false;\\n\\t}\\n\\treturn true;\\n}\\ninline bool isValidDir(int row , int col){\\n\\treturn (row<n && row>=0 && col<m && col>=0 && (table[row][col]==0 || table[row][col]==2));\\n}\\nint dfs(int row , int col){\\n//if we are at end square just check weather all empy square is visited or not\\n//if all visited then the path by which we reached here is a valid path else not valid path\\n\\tif(table[row][col]==2) return isValidPath();\\n\\ttable[row][col]=-1;//make it blocked \\n\\tint ans=0;\\n\\t//explore all the possible direction\\n\\tif(isValidDir(row+1,col)){\\n\\t\\tans+=dfs(row+1,col);\\n\\t}\\n\\tif(isValidDir(row-1,col)){\\n\\t\\tans+=dfs(row-1 , col);\\n\\t}\\n\\tif(isValidDir(row , col+1)){\\n\\t\\tans+=dfs(row , col+1);\\n\\t}\\n\\tif(isValidDir(row , col-1)){\\n\\t\\tans+=dfs(row , col-1);\\n\\t}\\n\\t//while backtracking we are going to reset because the path which has given valid or invalide\\n\\t//path then partial path can be use for other\\'s too\\n\\ttable[row][col]=0;\\n\\treturn ans;\\n}\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n    n=grid.size();\\n    m=grid[0].size();\\n    int row=-1,col=-1;\\n    table=grid;\\n\\t//find the position of start square\\n    for(int i=0 ; i<n &&row==-1 ; i++){\\n    \\tfor(int j=0 ; j<m && row==-1;j++){\\n    \\t\\tif(grid[i][j]==1) row=i,col=j;\\n    \\t}\\n    }\\n    int ans=dfs(row , col);\\n    return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\nvector<vector<int>> table;\\nint n,m;\\ninline bool isValidDir(int row , int col){\\n\\treturn (row<n && row>=0 && col<m && col>=0 && (table[row][col]==0 || table[row][col]==2));\\n}\\nint dfs(int row , int col,int nEmptyCell){\\n\\tif(table[row][col]==2) return (nEmptyCell<0);//(nEmptyCell<0) because we have incuded table[row][col] also as a empty square \\n\\tint x=table[row][col];\\n\\ttable[row][col]=-1;\\n\\tint ans=0;\\n\\tif(isValidDir(row+1,col)){\\n\\t\\tans+=dfs(row+1,col,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row-1,col)){\\n\\t\\tans+=dfs(row-1 , col,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row , col+1)){\\n\\t\\tans+=dfs(row , col+1,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row , col-1)){\\n\\t\\tans+=dfs(row , col-1,nEmptyCell-1);\\n\\t}\\n\\ttable[row][col]=x;\\n\\treturn ans;\\n}\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n    n=grid.size();\\n    m=grid[0].size();\\n    int row=-1,col=-1;\\n    table=grid;\\n      int nEmptyCell=0;\\n    for(int i=0 ; i<n  ; i++){\\n    \\tfor(int j=0 ; j<m ;j++){\\n    \\t\\tif(grid[i][j]==1) row=i,col=j;\\n        if(grid[i][j]==0) nEmptyCell++;\\n    \\t}\\n    }\\n    int ans=dfs(row , col,nEmptyCell);\\n    return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899681,
                "title": "recursion-backtracking-beats-100-detailed-explanation-clean-code",
                "content": "# Complexity\\n- Time complexity: Exponential\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\nBecause we are using extra used 2D array of size m * n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**CLEAN CODE :**\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**CODE WITH EXPLANATION :**\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n\\n        //finding the starting square\\'s row and column\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //boolean array named (used) is used to store the squares which have already been used\\n        //till now in a particular path\\n\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n\\n        //we have arrived at the ending square. Now, it might be possible, that the path we \\n        //followed till here from starting position, does not contain all the 0 squares\\n        //therefore to decide this we call the isValid function\\n        //Also, it might happen that there\\'s an obstacle on the same ending square, in this\\n        //case we won\\'t find any path because the destination square is itself an obstacle\\n        //so we return 0. and to check this only we have put another \\n        //condition grid[row][col] != -1\\n\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        //if we have arrived at an obstacle square, then return 0, because we can\\'t obtain \\n        //any further paths including this square, because this is an obstacle\\n        //while returning, unmark this square as used, i.e. mark it as unused\\n\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        //backtrack, mark the square as unused now!\\n        used[row][col] = false;\\n\\n        return paths;\\n    }\\n\\n    //to check whether the path which we have travelled from starting square to ending square\\n    //contains all the 0 squares in it or not. If the path does not contain all the 0 sqaures\\n    //then isValid return false, and we do not count this path and hence return 0 in the count\\n    //function.\\n    //if the path contains all the 0 squares, then isValid return true, and hence \\n    //we count this path and hence in count function we return 1, as we got one path\\n    //which contains all the 0 squares.\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n**NO NEED OF ISVALID FUNCTION :**\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        int countZeros = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == 0) {\\n                    countZeros++;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col, countZeros + 1);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col, int countZeros) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0 && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col, countZeros - 1);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1, countZeros - 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col, countZeros - 1);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1, countZeros - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n}\\n```\\n![cat.jpeg](https://assets.leetcode.com/users/images/dbaf10c4-ebb1-47e6-abb2-32d99d5c3a38_1691850467.298222.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n\\n        //finding the starting square\\'s row and column\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //boolean array named (used) is used to store the squares which have already been used\\n        //till now in a particular path\\n\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n\\n        //we have arrived at the ending square. Now, it might be possible, that the path we \\n        //followed till here from starting position, does not contain all the 0 squares\\n        //therefore to decide this we call the isValid function\\n        //Also, it might happen that there\\'s an obstacle on the same ending square, in this\\n        //case we won\\'t find any path because the destination square is itself an obstacle\\n        //so we return 0. and to check this only we have put another \\n        //condition grid[row][col] != -1\\n\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        //if we have arrived at an obstacle square, then return 0, because we can\\'t obtain \\n        //any further paths including this square, because this is an obstacle\\n        //while returning, unmark this square as used, i.e. mark it as unused\\n\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        //backtrack, mark the square as unused now!\\n        used[row][col] = false;\\n\\n        return paths;\\n    }\\n\\n    //to check whether the path which we have travelled from starting square to ending square\\n    //contains all the 0 squares in it or not. If the path does not contain all the 0 sqaures\\n    //then isValid return false, and we do not count this path and hence return 0 in the count\\n    //function.\\n    //if the path contains all the 0 squares, then isValid return true, and hence \\n    //we count this path and hence in count function we return 1, as we got one path\\n    //which contains all the 0 squares.\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        int countZeros = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == 0) {\\n                    countZeros++;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col, countZeros + 1);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col, int countZeros) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0 && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col, countZeros - 1);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1, countZeros - 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col, countZeros - 1);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1, countZeros - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975638,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int empty=1;\\n    void path(vector<vector<int>>& grid, int i, int j, int c)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1)\\n        return;\\n        if(grid[i][j]==2)\\n        {\\n            if(c==empty)\\n            ans++;\\n            return;\\n        }\\n        grid[i][j]=-1;\\n        path(grid, i+1, j, c+1);\\n        path(grid, i, j+1, c+1);\\n        path(grid, i-1, j, c+1);\\n        path(grid, i, j-1, c+1);\\n        grid[i][j]=0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int r, c;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==0)\\n                empty++;\\n                if(grid[i][j]==1)\\n                r=i, c=j;\\n            }\\n        }\\n        path(grid, r, c, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int empty=1;\\n    void path(vector<vector<int>>& grid, int i, int j, int c)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1)\\n        return;\\n        if(grid[i][j]==2)\\n        {\\n            if(c==empty)\\n            ans++;\\n            return;\\n        }\\n        grid[i][j]=-1;\\n        path(grid, i+1, j, c+1);\\n        path(grid, i, j+1, c+1);\\n        path(grid, i-1, j, c+1);\\n        path(grid, i, j-1, c+1);\\n        grid[i][j]=0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int r, c;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==0)\\n                empty++;\\n                if(grid[i][j]==1)\\n                r=i, c=j;\\n            }\\n        }\\n        path(grid, r, c, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974414,
                "title": "c-backtracking-dfs-100-faster-easy-understanding-commented-code",
                "content": "**Approach:**\\n1. First of all , we need to identify start and end cell coordinates and number of steps to move to end cell.\\n \\t*No. of steps to move to end cell = No. of empty squares + 1*\\n1. Now start dfs from the start cell with visited array to keep track of visited cells\\ni) If we reached to end cell and we have visited all empty cells exactly once , then return 1 else return 0\\nii) Mark the current cell as *visited*\\niii) Move to all four directions which are feasible to go and count the number of feasible from the current cell\\niv) Mark the current cell as *unvisited* to backtrack and return the *res*\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    // function to check if the cell coordinates are valid and is feasible to visit that cell\\n    bool isSafe(vector<vector<int>>& grid,int i,int j,vector<bool>&vis){\\n        return i<grid.size() && i>=0 && j>=0 && j<grid[0].size() && !vis[i*grid[0].size()+j] && grid[i][j]!=-1;\\n    }\\n    \\n\\t// helper function to dfs and backtrack\\n    int helper(vector<vector<int>>& grid,pair<int,int> curr,pair<int,int> end,int steps,vector<bool> &vis,int n){\\n        // if we reached the end cell\\n\\t\\tif(curr==end){\\n\\t\\t\\t// if steps is 0, it means we visited every non-obstacle cell so will 1 from here i.e. 1 way else return 0\\n            return steps==0?1:0;\\n        }\\n\\t\\t// destructuring the current cell coordinates\\n        auto [i,j]=curr;\\n\\t\\t\\n\\t\\t// mark the current cell as visited\\n        vis[i*n+j]=true;\\n        \\n        int res = 0;\\n\\t\\t// direction array for four directions {0,-1},{-1,0},{0,1},{1,0}\\n        int dir[5]={0,-1,0,1,0};\\n        \\n        for(int k=0;k<4;k++){\\n            int newX = i + dir[k];\\n            int newY = j + dir[k+1];\\n\\t\\t\\t\\n\\t\\t\\t// if the moving to the cell with coordinates (newX,newY) is feasible then move to that cell\\n            if(isSafe(grid,newX,newY,vis)){\\n                res+=helper(grid,{newX,newY},end,steps-1,vis,n);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// marking cell after doing dfs to backtrack\\n        vis[i*n+j]=false;\\n\\t\\t\\n\\t\\t// returning number of ways\\n        return res;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m = grid.size(); // # of rows\\n        int n = grid[0].size(); // # of columns\\n        int steps = 1; // steps need to be covered to reach end\\n        pair<int,int> start,end; // to store coordinates of start and end cell\\n\\t\\t\\n\\t\\t// counting steps needed and getting start and end cell coordinates\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0) steps++;\\n                else if(grid[i][j]==1) start={i,j};\\n                else if(grid[i][j]==2) end={i,j};\\n            }\\n        }\\n\\t\\t// 1-d array for keep track of visited cells\\n        vector<bool> vis(n*m,false);\\n        return helper(grid,start,end,steps,vis,n);\\n    }\\n};\\n```\\n\\n**Time Complexity** : O(3^max(m,n))\\n**Space Complexity**: O(m\\\\*n) as visited array occupies space m\\\\*n , *which can be further optimised to O(max(m,n)) i.e. recursion call stack only if we modify the grid cells to keep track of visited cells*\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to check if the cell coordinates are valid and is feasible to visit that cell\\n    bool isSafe(vector<vector<int>>& grid,int i,int j,vector<bool>&vis){\\n        return i<grid.size() && i>=0 && j>=0 && j<grid[0].size() && !vis[i*grid[0].size()+j] && grid[i][j]!=-1;\\n    }\\n    \\n\\t// helper function to dfs and backtrack\\n    int helper(vector<vector<int>>& grid,pair<int,int> curr,pair<int,int> end,int steps,vector<bool> &vis,int n){\\n        // if we reached the end cell\\n\\t\\tif(curr==end){\\n\\t\\t\\t// if steps is 0, it means we visited every non-obstacle cell so will 1 from here i.e. 1 way else return 0\\n            return steps==0?1:0;\\n        }\\n\\t\\t// destructuring the current cell coordinates\\n        auto [i,j]=curr;\\n\\t\\t\\n\\t\\t// mark the current cell as visited\\n        vis[i*n+j]=true;\\n        \\n        int res = 0;\\n\\t\\t// direction array for four directions {0,-1},{-1,0},{0,1},{1,0}\\n        int dir[5]={0,-1,0,1,0};\\n        \\n        for(int k=0;k<4;k++){\\n            int newX = i + dir[k];\\n            int newY = j + dir[k+1];\\n\\t\\t\\t\\n\\t\\t\\t// if the moving to the cell with coordinates (newX,newY) is feasible then move to that cell\\n            if(isSafe(grid,newX,newY,vis)){\\n                res+=helper(grid,{newX,newY},end,steps-1,vis,n);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// marking cell after doing dfs to backtrack\\n        vis[i*n+j]=false;\\n\\t\\t\\n\\t\\t// returning number of ways\\n        return res;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m = grid.size(); // # of rows\\n        int n = grid[0].size(); // # of columns\\n        int steps = 1; // steps need to be covered to reach end\\n        pair<int,int> start,end; // to store coordinates of start and end cell\\n\\t\\t\\n\\t\\t// counting steps needed and getting start and end cell coordinates\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0) steps++;\\n                else if(grid[i][j]==1) start={i,j};\\n                else if(grid[i][j]==2) end={i,j};\\n            }\\n        }\\n\\t\\t// 1-d array for keep track of visited cells\\n        vector<bool> vis(n*m,false);\\n        return helper(grid,start,end,steps,vis,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974263,
                "title": "3d-dp-recursion-memoaization-easy-code-commented-with-explaination",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis initially looks like a hard problem , but trust me it is not.\\nThanks to striver on YouTube for making DP on grids and 3D DP so easy to solve and understand.\\n\\nBasically find the starting points of x and y using iteration and stop when grid[i][j]==1, because thats our starting point for the recursion, then call the recursive function, add the pretty simple base cases(one is out of bounds ,  and other one is if we reach the end) , then do the recursive calls for all 4 traversable directions.\\n*Note: dont forget to backtrack(yes i did forget initially :p)\\n\\nThen just return the sum of all possibilities from the directions!\\nYes, its that simple.\\nAdditionally I have memoaized the solution by creating a DP array, you can tabulate your answer too but no one would expect tabulation or space optimization at on 3D DP(although both are simple to do)\\n\\n\\nInteger c basically here kinda checks how many nodes we have visited till now , so if the count of c is equal to empty then we can say that we have reached our destination(ofc destination node needs to be checked for being == 2 at first).\\nInstead of c one could have had used an additional function for checking if visited or not! Thats totally Upto you :D\\n\\n# PLEASE UPVOTE IF FOUND HELPFUL , IT KEEPS ME MOTIVATED TO HELP THIS COMMUNITY <3\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lol(int i,int j,int c,int& empty,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp){\\n        //base case1\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;        \\n        //base case2\\n        if(grid[i][j]==2){\\n            //sees if visited\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][c]!=-1)return dp[i][j][c];\\n        \\n        grid[i][j]=-1;\\n        //running down all 4 possibilities \\n        int up=lol(i-1,j,c+1,empty,grid,dp);\\n        int down=lol(i+1,j,c+1,empty,grid,dp);\\n        int right=lol(i,j+1,c+1,empty,grid,dp);\\n        int left=lol(i,j-1,c+1,empty,grid,dp);\\n        //backtracking \\n        grid[i][j]=0;\\n        //store answer in dp and return\\n        return dp[i][j][c+1]=(up+down+right+left);        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int empty=1,x=0,y=0;\\n        //empty is cells with 0\\n        //x and y are coordinates of starting point marked with 1 in grid\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>> (grid[0].size(),vector<int> (empty+1,-1)));\\n        return lol(x,y,0,empty,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lol(int i,int j,int c,int& empty,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp){\\n        //base case1\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;        \\n        //base case2\\n        if(grid[i][j]==2){\\n            //sees if visited\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][c]!=-1)return dp[i][j][c];\\n        \\n        grid[i][j]=-1;\\n        //running down all 4 possibilities \\n        int up=lol(i-1,j,c+1,empty,grid,dp);\\n        int down=lol(i+1,j,c+1,empty,grid,dp);\\n        int right=lol(i,j+1,c+1,empty,grid,dp);\\n        int left=lol(i,j-1,c+1,empty,grid,dp);\\n        //backtracking \\n        grid[i][j]=0;\\n        //store answer in dp and return\\n        return dp[i][j][c+1]=(up+down+right+left);        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int empty=1,x=0,y=0;\\n        //empty is cells with 0\\n        //x and y are coordinates of starting point marked with 1 in grid\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>> (grid[0].size(),vector<int> (empty+1,-1)));\\n        return lol(x,y,0,empty,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973494,
                "title": "100-easy-dfs",
                "content": "# Approach\\nFind start point and count all empty cell including start, use DFS to reach end cell, if cell covers all empty cell count that path. To avoid repeat mark cell visited and unmark.\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int M, N, eCount=1, res=0;\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        M = grid.size(), N=grid[0].size();\\n        int x, y;\\n        for (int i=0; i < M; i++)\\n            for (int j=0; j<N; j++){\\n                if (grid[i][j] ==1) x= i, y=j;\\n                else if (grid[i][j] ==0) eCount++;\\n            }\\n\\n        DFS(grid, x,y,0);\\n        return res;        \\n    }\\n\\n    void DFS(vector<vector<int>>& g, int i, int j,int count){\\n        if ( i < 0 || i >= M ||  j < 0 || j >= N || g[i][j] == -1) return;\\n\\n        if(g[i][j] == 2){\\n            if (count == eCount) res++;\\n            return;\\n        }\\n        g[i][j] = -1;\\n        count++;\\n        DFS(g,i+1,j,count);\\n        DFS(g,i-1,j,count);\\n        DFS(g,i,j+1,count);\\n        DFS(g,i,j-1,count);\\n        g[i][j] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n    int M, N, eCount=1, res=0;\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        M = grid.size(), N=grid[0].size();\\n        int x, y;\\n        for (int i=0; i < M; i++)\\n            for (int j=0; j<N; j++){\\n                if (grid[i][j] ==1) x= i, y=j;\\n                else if (grid[i][j] ==0) eCount++;\\n            }\\n\\n        DFS(grid, x,y,0);\\n        return res;        \\n    }\\n\\n    void DFS(vector<vector<int>>& g, int i, int j,int count){\\n        if ( i < 0 || i >= M ||  j < 0 || j >= N || g[i][j] == -1) return;\\n\\n        if(g[i][j] == 2){\\n            if (count == eCount) res++;\\n            return;\\n        }\\n        g[i][j] = -1;\\n        count++;\\n        DFS(g,i+1,j,count);\\n        DFS(g,i-1,j,count);\\n        DFS(g,i,j+1,count);\\n        DFS(g,i,j-1,count);\\n        g[i][j] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664159,
                "title": "easy-c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>&grid, set<pair<int,int>>&vis, int &f, int cu, int r, int c, pair<int,int>&tar ,int &m, int &n, int &ans){\\n        if(r<0 or r==m or c<0 or c==n or grid[r][c]==-1 or vis.count({r,c})) return;\\n        if(r==tar.first and c==tar.second){\\n            if(cu==f) ++ans;\\n            return;\\n        }\\n        vis.insert({r,c});\\n        solve(grid,vis,f,cu+1,r+1,c,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r-1,c,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r,c+1,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r,c-1,tar,m,n,ans);\\n        vis.erase({r,c});\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        pair<int,int> start, tar;\\n        int obs=1, m=grid.size(), n=grid[0].size(), ans=0;\\n        for(int i=0; i<m; ++i)\\n            for(int j=0; j<n; ++j){\\n                if(grid[i][j]==1) start={i,j};\\n                else if(grid[i][j]==2) tar={i,j};\\n                else if(grid[i][j]==0) ++obs;\\n            }\\n        set<pair<int,int>> vis;\\n        solve(grid,vis,obs,0,start.first,start.second,tar,m,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>&grid, set<pair<int,int>>&vis, int &f, int cu, int r, int c, pair<int,int>&tar ,int &m, int &n, int &ans){\\n        if(r<0 or r==m or c<0 or c==n or grid[r][c]==-1 or vis.count({r,c})) return;\\n        if(r==tar.first and c==tar.second){\\n            if(cu==f) ++ans;\\n            return;\\n        }\\n        vis.insert({r,c});\\n        solve(grid,vis,f,cu+1,r+1,c,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r-1,c,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r,c+1,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r,c-1,tar,m,n,ans);\\n        vis.erase({r,c});\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        pair<int,int> start, tar;\\n        int obs=1, m=grid.size(), n=grid[0].size(), ans=0;\\n        for(int i=0; i<m; ++i)\\n            for(int j=0; j<n; ++j){\\n                if(grid[i][j]==1) start={i,j};\\n                else if(grid[i][j]==2) tar={i,j};\\n                else if(grid[i][j]==0) ++obs;\\n            }\\n        set<pair<int,int>> vis;\\n        solve(grid,vis,obs,0,start.first,start.second,tar,m,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448355,
                "title": "easy-c-solution-with-backtracking-3ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int helper(vector<vector<int>>& grid, int i, int j, int cellsToVisit){\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==-1 || grid[i][j]==3) \\n            return 0;\\n        if(grid[i][j]==2){\\n            if(cellsToVisit==0)\\n                return 1;\\n            return 0;\\n        } \\n        \\n        int ans = 0;\\n        // mark as visited\\n        grid[i][j] = 3;\\n        ans += helper(grid,i+1,j,cellsToVisit-1);\\n        ans += helper(grid,i,j+1,cellsToVisit-1);\\n        ans += helper(grid,i-1,j,cellsToVisit-1);\\n        ans += helper(grid,i,j-1,cellsToVisit-1);\\n        grid[i][j] = 0;\\n        \\n        return ans;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        int cellsToVisit = 0;\\n        int startx,starty;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    startx = i;\\n                    starty = j;\\n                }\\n                else if(grid[i][j] != -1) \\n                    cellsToVisit++;\\n            }\\n            \\n        return helper(grid, startx, starty, cellsToVisit);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int helper(vector<vector<int>>& grid, int i, int j, int cellsToVisit){\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==-1 || grid[i][j]==3) \\n            return 0;\\n        if(grid[i][j]==2){\\n            if(cellsToVisit==0)\\n                return 1;\\n            return 0;\\n        } \\n        \\n        int ans = 0;\\n        // mark as visited\\n        grid[i][j] = 3;\\n        ans += helper(grid,i+1,j,cellsToVisit-1);\\n        ans += helper(grid,i,j+1,cellsToVisit-1);\\n        ans += helper(grid,i-1,j,cellsToVisit-1);\\n        ans += helper(grid,i,j-1,cellsToVisit-1);\\n        grid[i][j] = 0;\\n        \\n        return ans;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        int cellsToVisit = 0;\\n        int startx,starty;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    startx = i;\\n                    starty = j;\\n                }\\n                else if(grid[i][j] != -1) \\n                    cellsToVisit++;\\n            }\\n            \\n        return helper(grid, startx, starty, cellsToVisit);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998935,
                "title": "dp-backtracking-faster-than-100-recursion-c",
                "content": "I traverse through cell making it value equal to INT_MIN, so if I visit same cell again it returns. And at last in function fonc I make value of cell (which we traversed) equal to 0, so as to get any other path (if exist).\\t\\nTake a look at code, You will understand yourself.\\n\\n\\t\\tint ans=0;\\n    void fonc(vector<vector<int>>& grid,int total,int x,int i,int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return;\\n        if(grid[i][j]==INT_MIN) return;\\n        if(grid[i][j]==2 ){\\n            if(x==total)\\n                ans++;\\n            return ;\\n        }\\n        if(grid[i][j]==-1) return;\\n        grid[i][j]=INT_MIN;\\n       \\n        fonc(grid,total,x+1,i+1,j);\\n        fonc(grid,total,x+1,i-1,j);\\n        fonc(grid,total,x+1,i,j+1);\\n        fonc(grid,total,x+1,i,j-1);\\n        grid[i][j]=0;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int total=0;\\n        int x,y;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]!=-1 && grid[i][j]!=2) total++;\\n                if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                }\\n            }\\n        }\\n        fonc(grid,total,0,x,y);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "I traverse through cell making it value equal to INT_MIN, so if I visit same cell again it returns. And at last in function fonc I make value of cell (which we traversed) equal to 0, so as to get any other path (if exist).\\t\\nTake a look at code, You will understand yourself.\\n\\n\\t\\tint ans=0;\\n    void fonc(vector<vector<int>>& grid,int total,int x,int i,int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return;\\n        if(grid[i][j]==INT_MIN) return;\\n        if(grid[i][j]==2 ){\\n            if(x==total)\\n                ans++;\\n            return ;\\n        }\\n        if(grid[i][j]==-1) return;\\n        grid[i][j]=INT_MIN;\\n       \\n        fonc(grid,total,x+1,i+1,j);\\n        fonc(grid,total,x+1,i-1,j);\\n        fonc(grid,total,x+1,i,j+1);\\n        fonc(grid,total,x+1,i,j-1);\\n        grid[i][j]=0;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int total=0;\\n        int x,y;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]!=-1 && grid[i][j]!=2) total++;\\n                if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                }\\n            }\\n        }\\n        fonc(grid,total,0,x,y);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1926876,
                "title": "c-backtracking-with-graphs-in-depth-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/d1ec8a00-adca-491b-8ac2-a4761be599be_1649438593.232334.png)\\n\\nHere\\'s a step-by-step explanation for how one could approach and solve this problem. First thing is to identify an approach:\\n\\nThere\\'s no real way to avoid testing every path, so that\\'s the best we\\'ll be able to do; testing every path from start to end and tallying the ones that traverse through every square. We can optimize this, however, which saves us a lot of time. There could theoretically be some mathematical solution to this problem, but to my knowledge that hasn\\'t been discovered yet. A couple notes about the approach:\\n\\n1. Using Graphs\\n\\tWorth mentioning first: the big thing to make this problem *significantly* easier is to use Graphs. The nature of the problem is that you are stepping from one square to another, which begs the use of connected nodes, or Graphs. You could stick to using arrays, which many people mistakenly try. While the time/space complexity is about the same, using arrays is very unintuitive, and it gets very convoluted very quickly. The best and worst case performances are pretty much the same for any approach: having to test every single path. Therefore our choice of data structure between Graphs and Arrays doesn\\'t matter much for time/space, and we\\'re left to choose the option that\\'s easier to code.\\n\\t\\n\\tA friend of mine conducts FAANG interviews, and uses pathfinding questions very similar to this problem. He\\'s mentioned that the #1 mistake prospective employees make is using Arrays to keep track of everything instead of Graphs. The vast majority of the time it leads to them getting caught up in a nightmare of Array debugging. Given that you would need to create other Arrays to keep track of things like what squares have been traversed, Graphs are as good or better for space complexity and even time complexity. However in my approach, I\\'m content to keep an unneccessary Graph[][] array, for the sake of readability and simplicity.\\n\\n2. DFS vs BFS:\\n\\tThis is a pathfinding algorithm. With pathfinding, two terms that should always come to mind are DFS, and BFS. DFS (Depth First Search) is the approach of building every path individually to their end, as opposed to BFS (Breadth First Search), which explores every path simultaneously. If the question asked us to find the *shortest* path, then we would want BFS. We would expand in every direction from Start, until a path hits End, at which point we could immediately return. However in this problem, we need to explore *every* path from Start to End, as well as keeping track of certain qualities about each of those paths. Mainly, does a given path from Start to End traverse through every square? So the strategy of choice is DFS.\\n\\n3. DFS vs BackTracking\\n\\tBacktracking and DFS are very similar approaches; arguably identical. DFS implies that you\\'re exploring every single path to its end, whereas Backtracking implies that you\\'ll immediately give up on an incomplete path under certain conditions. Indeed there are certain ways to tell that a path will not satisfy the problem\\'s stipulations (that it goes from Start to End and traverses through every square). This is why this code is better categorized as Backtracking then just DFS (although it\\'s both). This is where we get to optimize.\\n\\t\\n* Optimizations:\\n\\t* Before any Backtracking, we can immediately tell if there are 0 viable paths: if there\\'s a dead end anywhere other than the End and Start squares (e.g. a square with only 1 open square). That would mean our paths would all have to either end there, or skip that square, meaning that no paths could traverse every square from Start to End.\\n\\t* If a path reaches the End square prematurely, we immediately stop exploring. That means if a path ever traverses every square, we know it also ends on End, and we can add 1 to the number of viable paths.\\n\\t* If a path is ever next to a dead-end square, then the path can *only* go that way. This is similar to the first optimization, though we can create these \"dead-end\" squares by using all but 1 of the squares around them. If the path branched to any square *other* than that one, then we would leave a dead-end square, meaning all paths from then on won\\'t work.\\n\\t* If a path ever reaches an edge, and we\\'ve already traversed an edge, we could split our remaining available squares. If there are two squares left and they\\'re opposite one another (e.g. our path hits an edge and we can either go left or right along the edge) then we immediately return 0, because either way the path turns, it will never be able to traverse any squares on the other side.\\n\\t* When creating our Graph of nodes, we do so iteratively, through the Array of Graphs all[][]. If you wanted to further optimize you could remove this and fill the Graph recursively. However, this is simple and easy to read, allows us to immediately check for dead-ends easily, and most importantly here, allows for the easy use of print statements. Notice that all[][] isn\\'t used at all in BackTrack(), other than for the Write function.\\n\\t\\n\\t\\nSo now we know we\\'re using an Optimized DFS (or BackTracking) to search through every square. And we\\'re using Graphs to keep track of everything. Time to start coding.\\n\\nFirst thing is to declare our Graph data structure:\\n\\n```\\n\\n    public class Graph {\\n\\t\\t//To keep track of whether we\\'ve traversed this square.\\n        public bool used;\\n\\t\\t\\n\\t\\t//A collection of all adjacent squares, represented by their respective Graphs.\\n        public Graph[] nodes;\\n\\t\\t\\n\\t\\t//How many usable nodes are left from the collection above.\\n        public int count;\\n\\t\\t\\n\\t\\t//Default constructor. All nodes start off as unused, with a count of 0.\\n\\t\\t//this.nodes always has a length of 4, since every square has at most 4 adjacent squares.\\n        public Graph() {\\n            this.used = false;\\n            this.nodes = new Graph[4];\\n            this.count = 0;\\n        }\\n    }\\n```\\nWhile this.used always starts false, we actually instantiate all obstacles as nodes that are already used prior to BackTracking. The *could* stay null, however this would mean we wouldn\\'t be able to implement the wall-optimization above, since we wouldn\\'t be able to differentiate between nodes along a wall, and nodes that are adjacent to an obstacle. Therefore obstacles are instantiated as used Graphs.\\nthis.nodes[] is also a Graph[4], rather than a List< Graph>[4], since each index nodes[i] corresponds to a direction. If nodes were a List< Graph>, it would be easier to deal with Null nodes (squares on the edge/corner), but the variable length would throw off the directionality. Therefore it\\'s easier to use an Array over a List.\\nFinally, this.count is initialized to 0, and then appropriately set when we build the Graph.\\n\\nNext we declare start and end as global variables, and define our main function, UniquePathsIII(int[][] grid):\\n\\n```\\n    Graph start, end;\\n\\t\\n    public int UniquePathsIII(int[][] grid) {\\n\\t\\t//Our grid of Graph nodes.\\n        Graph[][] all = new Graph[grid.Length][];\\n\\t\\t\\n\\t\\t//The total number of squares available.\\n\\t\\t//This is different from a given Graph.count, which is the total squares that node has available to it.\\n        int count = 0;\\n\\t\\t\\n\\t\\t//Building the Graph.\\n        for (int i = 0; i < grid.Length; i++) {\\n            all[i] = new Graph[grid[0].Length];\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                all[i][j] = new Graph();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//If the square is an Obstacle, we set it to used.\\n\\t\\t\\t\\t//We also continue to the next square *before* adding to count or adding to any adjacent Graph nodes\\' counts\\n                if (grid[i][j] == -1) {\\n                    all[i][j].used = true;\\n                    continue;\\n                }\\n                count++;\\n\\t\\t\\t\\t//If we come across the Start or End, we set the global variables.\\n                if (grid[i][j] == 1) start = all[i][j];\\n                if (grid[i][j] == 2) end = all[i][j];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//We increase the node\\'s count if there are adjacent squares that aren\\'t used (i.e. that aren\\'t obstacles)\\n                if (i != 0 && !all[i-1][j].used) {\\n                    all[i][j].nodes[0] = all[i-1][j];\\n                    all[i][j].count++;\\n                    all[i-1][j].nodes[2] = all[i][j];\\n                    all[i-1][j].count++;\\n                }\\n                if (j != 0 && !all[i][j-1].used) {\\n                    all[i][j].nodes[3] = all[i][j-1];\\n                    all[i][j].count++;\\n                    all[i][j-1].nodes[1] = all[i][j];\\n                    all[i][j-1].count++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//After building the entire Graph, we then iterate through and look for any square that\\'s a dead end (Graph.count == 1).\\n\\t\\t//If it\\'s Start or End then there are still possible paths, but otherwise we immediately return 0.\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g != null && g.count == 1 && g != start && g != end) return 0;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//We then begin building a path, starting at Start.\\n        return BackTrack(grid, all, start, count-1, false);\\n    }\\n```\\nThe main function really only built the Graph, set the global variables, and then checked to make sure there weren\\'t dead ends.\\n\\nThe meat of the code is in BackTrack():\\n```\\n\\t//The only reason BackTrack() takes grid and all is for the Write statement.\\n\\t//If Write() is commented out, you can completely remove grid and all.\\n\\t//BackTrack() takes s, representing the current square, and count, representing how many squares are left.\\n\\t//It also takes wall, which simply records whether or not the current path has ever touched the edge of the grid.\\n    private int BackTrack(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n\\t\\t\\n\\t\\t//Prints the grid, with x\\'s for traversed squares/obstacles, and numbers in each open square\\n\\t\\t//representing how many available squares are adjacent to it.\\n        Write(grid, all, s, count, wall);\\n\\t\\t\\n\\t\\t//Return 1 if we traverse every path. This will only be satisfied if the current, last square is End.\\n        if (count == 0) return 1;\\n\\t\\t//If we reach the end before that, immediately return 0.\\n        if (s == end) return 0;\\n\\t\\t\\n        int sum = 0;\\n        s.used = true;\\n\\t\\t\\n\\t\\t//We use d (direction) in case there\\'s an adjacent square that\\'s a dead end.\\n        Graph d = null;\\n        for (int i = 0; i < s.nodes.Length; i++) if (s.nodes[i] != null) {\\n            Graph g = s.nodes[i];\\n\\t\\t\\t//Every adjacent node\\'s count is decreased by 1 when the current node s is used.\\n            g.count--;\\n            //This is what creates the dead ends that we can optimize for with d.\\n\\t\\t\\tif (!g.used && g != end && g.count == 1) d = g;\\n        } else {\\n\\t\\t\\n\\t\\t\\t//This in case we hit an edge (s.nodes[i] == null)\\n\\t\\t\\t//If we have only opposite squares available to turn, the path returns 0.\\n            if (wall && s.count == 2 && (s.nodes[(i+2)%4] == null || s.nodes[(i+2)%4].used)) {\\n                return 0;\\n            }\\n            wall = true;\\n        }\\n\\t\\t\\n\\t\\t//If we didn\\'t create a dead-end, we explore all of the curren\\'t square\\'s available adjacent squares (Graph g in s.nodes).\\n        if (d == null) {\\n            foreach (Graph g in s.nodes) {\\n                if (g != null && !g.used) {\\n                    sum += BackTrack(grid, all, g, count-1, false);\\n                }\\n            }\\n\\t\\t\\t//If a dead-end was found, we ignore all other possible paths, since any valid path *must* traverse through d.\\n        } else sum += BackTrack(grid, all, d, count-1, false);\\n\\t\\t\\n\\t\\t//Finally, when we\\'ve explored every path that uses s, we set it to unused again and add 1 back to its adjacent squares\\' counts.\\n        foreach (Graph g in s.nodes) if (g != null) g.count++;\\n        s.used = false;\\n\\t\\t\\n\\t\\t//Finally we return sum, which is added to the previous path\\'s sum, and so-on,\\n\\t\\t//until we get to the top BackTrack() call, from Start, which has a total sum of all possible paths.\\n        return sum;\\n    }\\n```\\n\\nIn total this is roughly O(3<sup>n</sup>) Time complexity, since each square has at most 3 possible squares to step to. Other than Start, one of its adjacent squares is already used. Space complexity is O(n), since every Graph node is O(1) space complexity, and there are n nodes. I hope this helped someone. Feel free to copy paste this and look at the print statements. It helps quite a bit to see the DFS step-by-step.\\n\\nHere is all of the code together, along with Write():\\n```\\npublic class Solution {\\n    \\n    public class Graph {\\n        public bool used;\\n        public Graph[] nodes;\\n        public int count;\\n        public Graph() {\\n            this.used = false;\\n            this.nodes = new Graph[4];\\n            this.count = 0;\\n        }\\n    }\\n    \\n    Graph start, end;\\n    \\n    public int UniquePathsIII(int[][] grid) {\\n        Graph[][] all = new Graph[grid.Length][];\\n        int count = 0;\\n        for (int i = 0; i < grid.Length; i++) {\\n            all[i] = new Graph[grid[0].Length];\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                all[i][j] = new Graph();\\n                if (grid[i][j] == -1) {\\n                    all[i][j].used = true;\\n                    continue;\\n                }\\n                count++;\\n                if (grid[i][j] == 1) start = all[i][j];\\n                if (grid[i][j] == 2) end = all[i][j];\\n                if (i != 0 && !all[i-1][j].used) {\\n                    all[i][j].nodes[0] = all[i-1][j];\\n                    all[i][j].count++;\\n                    all[i-1][j].nodes[2] = all[i][j];\\n                    all[i-1][j].count++;\\n                }\\n                if (j != 0 && !all[i][j-1].used) {\\n                    all[i][j].nodes[3] = all[i][j-1];\\n                    all[i][j].count++;\\n                    all[i][j-1].nodes[1] = all[i][j];\\n                    all[i][j-1].count++;\\n                }\\n            }\\n        }\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g != null && g.count == 1 && g != start && g != end) return 0;\\n            }\\n        }\\n        return BackTrack(grid, all, start, count-1, false);\\n    }\\n    \\n    private int BackTrack(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n        //Write(grid, all, s, count, wall);\\n        if (count == 0) return 1;\\n        if (s == end) return 0;\\n        int sum = 0;\\n        s.used = true;\\n        Graph d = null;\\n        for (int i = 0; i < s.nodes.Length; i++) if (s.nodes[i] != null) {\\n            Graph g = s.nodes[i];\\n            g.count--;\\n            if (!g.used && g != end && g.count == 1) d = g;\\n        } else {\\n            if (wall && s.count == 2 && (s.nodes[(i+2)%4] == null || s.nodes[(i+2)%4].used)) {\\n                return 0;\\n            }\\n            wall = true;\\n        }\\n        if (d == null) {\\n            foreach (Graph g in s.nodes) {\\n                if (g != null && !g.used) {\\n                    sum += BackTrack(grid, all, g, count-1, false);\\n                }\\n            }\\n        } else sum += BackTrack(grid, all, d, count-1, false);\\n        foreach (Graph g in s.nodes) if (g != null) g.count++;\\n        s.used = false;\\n        return sum;\\n    }\\n    private void Write(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g == null) {\\n                    Console.Write(0 + \", \");\\n                    continue;\\n                }\\n                Console.Write((s == g || g.used? \"x\" : g.count) + \", \");\\n            }\\n            Console.WriteLine();\\n        }\\n        Console.WriteLine(\"Total Nodes: \" + count);\\n        if (s == end) Console.WriteLine(\"Reached the end with \" + count + \" nodes left.\");\\n        Console.WriteLine();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public class Graph {\\n\\t\\t//To keep track of whether we\\'ve traversed this square.\\n        public bool used;\\n\\t\\t\\n\\t\\t//A collection of all adjacent squares, represented by their respective Graphs.\\n        public Graph[] nodes;\\n\\t\\t\\n\\t\\t//How many usable nodes are left from the collection above.\\n        public int count;\\n\\t\\t\\n\\t\\t//Default constructor. All nodes start off as unused, with a count of 0.\\n\\t\\t//this.nodes always has a length of 4, since every square has at most 4 adjacent squares.\\n        public Graph() {\\n            this.used = false;\\n            this.nodes = new Graph[4];\\n            this.count = 0;\\n        }\\n    }\\n```\n```\\n    Graph start, end;\\n\\t\\n    public int UniquePathsIII(int[][] grid) {\\n\\t\\t//Our grid of Graph nodes.\\n        Graph[][] all = new Graph[grid.Length][];\\n\\t\\t\\n\\t\\t//The total number of squares available.\\n\\t\\t//This is different from a given Graph.count, which is the total squares that node has available to it.\\n        int count = 0;\\n\\t\\t\\n\\t\\t//Building the Graph.\\n        for (int i = 0; i < grid.Length; i++) {\\n            all[i] = new Graph[grid[0].Length];\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                all[i][j] = new Graph();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//If the square is an Obstacle, we set it to used.\\n\\t\\t\\t\\t//We also continue to the next square *before* adding to count or adding to any adjacent Graph nodes\\' counts\\n                if (grid[i][j] == -1) {\\n                    all[i][j].used = true;\\n                    continue;\\n                }\\n                count++;\\n\\t\\t\\t\\t//If we come across the Start or End, we set the global variables.\\n                if (grid[i][j] == 1) start = all[i][j];\\n                if (grid[i][j] == 2) end = all[i][j];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//We increase the node\\'s count if there are adjacent squares that aren\\'t used (i.e. that aren\\'t obstacles)\\n                if (i != 0 && !all[i-1][j].used) {\\n                    all[i][j].nodes[0] = all[i-1][j];\\n                    all[i][j].count++;\\n                    all[i-1][j].nodes[2] = all[i][j];\\n                    all[i-1][j].count++;\\n                }\\n                if (j != 0 && !all[i][j-1].used) {\\n                    all[i][j].nodes[3] = all[i][j-1];\\n                    all[i][j].count++;\\n                    all[i][j-1].nodes[1] = all[i][j];\\n                    all[i][j-1].count++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//After building the entire Graph, we then iterate through and look for any square that\\'s a dead end (Graph.count == 1).\\n\\t\\t//If it\\'s Start or End then there are still possible paths, but otherwise we immediately return 0.\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g != null && g.count == 1 && g != start && g != end) return 0;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//We then begin building a path, starting at Start.\\n        return BackTrack(grid, all, start, count-1, false);\\n    }\\n```\n```\\n\\t//The only reason BackTrack() takes grid and all is for the Write statement.\\n\\t//If Write() is commented out, you can completely remove grid and all.\\n\\t//BackTrack() takes s, representing the current square, and count, representing how many squares are left.\\n\\t//It also takes wall, which simply records whether or not the current path has ever touched the edge of the grid.\\n    private int BackTrack(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n\\t\\t\\n\\t\\t//Prints the grid, with x\\'s for traversed squares/obstacles, and numbers in each open square\\n\\t\\t//representing how many available squares are adjacent to it.\\n        Write(grid, all, s, count, wall);\\n\\t\\t\\n\\t\\t//Return 1 if we traverse every path. This will only be satisfied if the current, last square is End.\\n        if (count == 0) return 1;\\n\\t\\t//If we reach the end before that, immediately return 0.\\n        if (s == end) return 0;\\n\\t\\t\\n        int sum = 0;\\n        s.used = true;\\n\\t\\t\\n\\t\\t//We use d (direction) in case there\\'s an adjacent square that\\'s a dead end.\\n        Graph d = null;\\n        for (int i = 0; i < s.nodes.Length; i++) if (s.nodes[i] != null) {\\n            Graph g = s.nodes[i];\\n\\t\\t\\t//Every adjacent node\\'s count is decreased by 1 when the current node s is used.\\n            g.count--;\\n            //This is what creates the dead ends that we can optimize for with d.\\n\\t\\t\\tif (!g.used && g != end && g.count == 1) d = g;\\n        } else {\\n\\t\\t\\n\\t\\t\\t//This in case we hit an edge (s.nodes[i] == null)\\n\\t\\t\\t//If we have only opposite squares available to turn, the path returns 0.\\n            if (wall && s.count == 2 && (s.nodes[(i+2)%4] == null || s.nodes[(i+2)%4].used)) {\\n                return 0;\\n            }\\n            wall = true;\\n        }\\n\\t\\t\\n\\t\\t//If we didn\\'t create a dead-end, we explore all of the curren\\'t square\\'s available adjacent squares (Graph g in s.nodes).\\n        if (d == null) {\\n            foreach (Graph g in s.nodes) {\\n                if (g != null && !g.used) {\\n                    sum += BackTrack(grid, all, g, count-1, false);\\n                }\\n            }\\n\\t\\t\\t//If a dead-end was found, we ignore all other possible paths, since any valid path *must* traverse through d.\\n        } else sum += BackTrack(grid, all, d, count-1, false);\\n\\t\\t\\n\\t\\t//Finally, when we\\'ve explored every path that uses s, we set it to unused again and add 1 back to its adjacent squares\\' counts.\\n        foreach (Graph g in s.nodes) if (g != null) g.count++;\\n        s.used = false;\\n\\t\\t\\n\\t\\t//Finally we return sum, which is added to the previous path\\'s sum, and so-on,\\n\\t\\t//until we get to the top BackTrack() call, from Start, which has a total sum of all possible paths.\\n        return sum;\\n    }\\n```\n```\\npublic class Solution {\\n    \\n    public class Graph {\\n        public bool used;\\n        public Graph[] nodes;\\n        public int count;\\n        public Graph() {\\n            this.used = false;\\n            this.nodes = new Graph[4];\\n            this.count = 0;\\n        }\\n    }\\n    \\n    Graph start, end;\\n    \\n    public int UniquePathsIII(int[][] grid) {\\n        Graph[][] all = new Graph[grid.Length][];\\n        int count = 0;\\n        for (int i = 0; i < grid.Length; i++) {\\n            all[i] = new Graph[grid[0].Length];\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                all[i][j] = new Graph();\\n                if (grid[i][j] == -1) {\\n                    all[i][j].used = true;\\n                    continue;\\n                }\\n                count++;\\n                if (grid[i][j] == 1) start = all[i][j];\\n                if (grid[i][j] == 2) end = all[i][j];\\n                if (i != 0 && !all[i-1][j].used) {\\n                    all[i][j].nodes[0] = all[i-1][j];\\n                    all[i][j].count++;\\n                    all[i-1][j].nodes[2] = all[i][j];\\n                    all[i-1][j].count++;\\n                }\\n                if (j != 0 && !all[i][j-1].used) {\\n                    all[i][j].nodes[3] = all[i][j-1];\\n                    all[i][j].count++;\\n                    all[i][j-1].nodes[1] = all[i][j];\\n                    all[i][j-1].count++;\\n                }\\n            }\\n        }\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g != null && g.count == 1 && g != start && g != end) return 0;\\n            }\\n        }\\n        return BackTrack(grid, all, start, count-1, false);\\n    }\\n    \\n    private int BackTrack(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n        //Write(grid, all, s, count, wall);\\n        if (count == 0) return 1;\\n        if (s == end) return 0;\\n        int sum = 0;\\n        s.used = true;\\n        Graph d = null;\\n        for (int i = 0; i < s.nodes.Length; i++) if (s.nodes[i] != null) {\\n            Graph g = s.nodes[i];\\n            g.count--;\\n            if (!g.used && g != end && g.count == 1) d = g;\\n        } else {\\n            if (wall && s.count == 2 && (s.nodes[(i+2)%4] == null || s.nodes[(i+2)%4].used)) {\\n                return 0;\\n            }\\n            wall = true;\\n        }\\n        if (d == null) {\\n            foreach (Graph g in s.nodes) {\\n                if (g != null && !g.used) {\\n                    sum += BackTrack(grid, all, g, count-1, false);\\n                }\\n            }\\n        } else sum += BackTrack(grid, all, d, count-1, false);\\n        foreach (Graph g in s.nodes) if (g != null) g.count++;\\n        s.used = false;\\n        return sum;\\n    }\\n    private void Write(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g == null) {\\n                    Console.Write(0 + \", \");\\n                    continue;\\n                }\\n                Console.Write((s == g || g.used? \"x\" : g.count) + \", \");\\n            }\\n            Console.WriteLine();\\n        }\\n        Console.WriteLine(\"Total Nodes: \" + count);\\n        if (s == end) Console.WriteLine(\"Reached the end with \" + count + \" nodes left.\");\\n        Console.WriteLine();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807446,
                "title": "easy-sol-beats-100-of-solution-on-leetcode-with-comments",
                "content": "class Solution {\\npublic:\\n    int help(vector<vector<int>>& g,int i,int j,int n,int m,int c,int t){\\n    \\n        if(i<0||j<0||i>=n||j>=m||g[i][j]==-1)//i and j cannot be outside of grid and here i am not \\n            return 0;                                      //using extra space just using grid to mark whether \\n\\t  \\t                                                     //we have visited a cell or not by making it -1;\\n        if(g[i][j]==2){\\n           if(c==t)\\n            return 1;\\n            return 0;\\n        }\\n        g[i][j]=-1;                             //marking current cell as visited\\n        int a=0;\\n         a+=help(g,i+1,j,n,m,c+1,t);\\n         a+=help(g,i,j+1,n,m,c+1,t);\\n         a+=help(g,i-1,j,n,m,c+1,t);\\n         a+=help(g,i,j-1,n,m,c+1,t);\\n        g[i][j]=0;                        //backtracking and then marking cell as unvisited\\n        return a;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int s1=-1,s2=-1,b=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){// finding the starting postion of robot \\n                    s1=i;\\n                    s2=j;\\n                }\\n                if(grid[i][j]==-1)//finding total number of blocks in grid\\n                    b++;\\n            }\\n        }\\n        int t=n*m-b;//total number of free cells that we have travel before reaching final state i.e. 2\\n        if(s1==-1)\\n            return 0;\\n        return help(grid,s1,s2,n,m,1,t);//function call\\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int help(vector<vector<int>>& g,int i,int j,int n,int m,int c,int t){\\n    \\n        if(i<0||j<0||i>=n||j>=m||g[i][j]==-1)//i and j cannot be outside of grid and here i am not \\n            return 0;                                      //using extra space just using grid to mark whether \\n\\t  \\t                                                     //we have visited a cell or not by making it -1;\\n        if(g[i][j]==2){\\n           if(c==t)\\n            return 1;\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1752390,
                "title": "recursive-backtracking-solution-java-runtime-1ms",
                "content": "**Approach:**\\n* We can move in four directions: up, down, left, right\\n* Each non-obstacle square has to be visited exactly once. Hence, we keep a count of all the safe squares  and as we visit them we reduce the count.\\n* We keep a visited array to keep track of all the visited square to prevent stack overflow and also to visit each safe square exactly once.\\n* We find the indices of the starting position and send them to the recursive function to count all the possible paths.\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        //to keep a track of all the visited squares\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        //count of all the safe squares\\n        int nonObstacles = 0;\\n        int row = 0;\\n        int col = 0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                //finding the coords of starting position\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                } else if(grid[i][j]==0)\\n                    nonObstacles++;\\n            }\\n        }\\n        return uniquePaths(row, col, vis, grid, nonObstacles);\\n    }\\n    \\n    public int uniquePaths(int row, int col, boolean[][] vis, int[][] grid, int nonObstacles) {\\n        //reaching the destination\\n        if(grid[row][col] == 2) {\\n            //visited all safe squares\\n            if(nonObstacles < 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        //keeping a count of all the paths\\n        int paths = 0;\\n        \\n        //to avoid visiting the already visited squares\\n        if(!vis[row][col]) {\\n            //marking the square as visited\\n            vis[row][col] = true;\\n            \\n            //move up\\n            if(row > 0 && grid[row-1][col]!=-1)\\n                paths += uniquePaths(row-1, col, vis, grid, nonObstacles-1);\\n             \\n            //move down\\n            if(row < grid.length-1 && grid[row+1][col]!=-1)\\n                paths += uniquePaths(row+1, col, vis, grid, nonObstacles-1);\\n            \\n            //move left\\n            if(col > 0 && grid[row][col-1]!=-1)\\n                paths += uniquePaths(row, col-1, vis, grid, nonObstacles-1);\\n            \\n            //move right\\n            if(col < grid[0].length-1 && grid[row][col+1]!=-1)\\n                paths += uniquePaths(row, col+1, vis, grid, nonObstacles-1);\\n            \\n            //backtracking\\n            vis[row][col] = false;\\n        }\\n        return paths;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        //to keep a track of all the visited squares\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        //count of all the safe squares\\n        int nonObstacles = 0;\\n        int row = 0;\\n        int col = 0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                //finding the coords of starting position\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                } else if(grid[i][j]==0)\\n                    nonObstacles++;\\n            }\\n        }\\n        return uniquePaths(row, col, vis, grid, nonObstacles);\\n    }\\n    \\n    public int uniquePaths(int row, int col, boolean[][] vis, int[][] grid, int nonObstacles) {\\n        //reaching the destination\\n        if(grid[row][col] == 2) {\\n            //visited all safe squares\\n            if(nonObstacles < 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        //keeping a count of all the paths\\n        int paths = 0;\\n        \\n        //to avoid visiting the already visited squares\\n        if(!vis[row][col]) {\\n            //marking the square as visited\\n            vis[row][col] = true;\\n            \\n            //move up\\n            if(row > 0 && grid[row-1][col]!=-1)\\n                paths += uniquePaths(row-1, col, vis, grid, nonObstacles-1);\\n             \\n            //move down\\n            if(row < grid.length-1 && grid[row+1][col]!=-1)\\n                paths += uniquePaths(row+1, col, vis, grid, nonObstacles-1);\\n            \\n            //move left\\n            if(col > 0 && grid[row][col-1]!=-1)\\n                paths += uniquePaths(row, col-1, vis, grid, nonObstacles-1);\\n            \\n            //move right\\n            if(col < grid[0].length-1 && grid[row][col+1]!=-1)\\n                paths += uniquePaths(row, col+1, vis, grid, nonObstacles-1);\\n            \\n            //backtracking\\n            vis[row][col] = false;\\n        }\\n        return paths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555177,
                "title": "c-o-rc-2-rc-top-down-dp-memoization",
                "content": "**\\u2714\\uFE0F Solution 1 (Top-Down DP, Memoization)**\\nThis is a DP problem. We can use a top-down approach to solve it.\\n\\n**Main idea**\\ndp\\\\[row\\\\]\\\\[col\\\\]\\\\[emptyCellsMask\\\\] is the number of valid paths starting at (row, col) such that currently empty cells of the grid are encoded as 1-bits in emptyCellsMask;\\n\\nBase cases:\\ndp\\\\[row\\\\]\\\\[col\\\\]\\\\[0\\\\] = 0, if (row, col) is not the ending cell;\\ndp\\\\[row\\\\]\\\\[col\\\\]\\\\[0\\\\] = 1, if (row, col) is the ending cell;\\n\\nRecurrence:\\ndp\\\\[row\\\\]\\\\[col\\\\]\\\\[emptyCellsMask\\\\] =\\ndp\\\\[row_1\\\\]\\\\[col_1\\\\]\\\\[emptyCellsMask - (1 << getIdx(row_1, col_1)\\\\] +\\ndp\\\\[row_2\\\\]\\\\[col_2\\\\]\\\\[emptyCellsMask - (1 << getIdx(row_2, col_2)\\\\] +\\ndp\\\\[row_3\\\\]\\\\[col_3\\\\]\\\\[emptyCellsMask - (1 << getIdx(row_3, col_3)\\\\] +\\ndp\\\\[row_4\\\\]\\\\[col_4\\\\]\\\\[emptyCellsMask - (1 << getIdx(row_4, col_4)\\\\];\\n\\n(row_1, col_1), (row_2, col_2), (row_3, col_3), (row_4, col_4) are neighbors of (row, col) cell;\\nContribution of a neghboring cell (row_i, col_i) is added to dp\\\\[row\\\\]\\\\[col\\\\]\\\\[emptyCellsMask\\\\] if and only if (row_i, col_i) cell is encoded as empty in emptyCellsMask or is the ending cell;\\n\\ngetIdx(row, col) returns the index of (row, col) cell in a grid of size (R, C);\\ngetIdx(row, col) => row * C + col;\\n\\n**Some implementation details**\\n* To avoid redundant computations, we cache all (row, col, emptyCellsMask) states in `memo`.\\nThis reduces the time complexity of DP solution from O(3^(RC)) to O(RC * 2^(RC)).\\n* In below implementation, a state (row, col, emptyCellsMask) is represented with a single 32-bit signed integer as `(getIdx(row, col, COLS) << 20) | emptyCellsMask`.\\n\\n**Time Complexity:** `O(RC * 2^(RC))`\\n**Space Complexity:** `O(RC * 2^(RC))`\\nR is the number of rows and C is the number of columns of the grid;\\n\\n**Code**\\n```\\nclass Solution {\\nprivate:\\n    int getIdx(int row, int col, const int& COLS){\\n        return row * COLS + col;\\n    }\\n    \\n    int solve(int row, int col, int emptyCellsMask, vector<vector<int>>& grid, unordered_map<int, int>& memo){\\n        static const vector<pair<int, int>> DIRECTIONS = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        \\n        int totalWalks = 0;\\n        int state = (getIdx(row, col, COLS) << 20) | emptyCellsMask;\\n        if(memo.count(state)){\\n            totalWalks = memo[state];\\n        }else if(grid[row][col] == 2){\\n            if(emptyCellsMask == 0){\\n                totalWalks = 1;\\n            }\\n        }else{\\n            for(const pair<int, int>& DIRECTION: DIRECTIONS){\\n                int nextRow = row + DIRECTION.first;\\n                int nextCol = col + DIRECTION.second;\\n                int nextIdx = getIdx(nextRow, nextCol, COLS);\\n                if(0 <= nextRow && nextRow < ROWS && 0 <= nextCol && nextCol < COLS && grid[nextRow][nextCol] != -1){\\n                    if(((emptyCellsMask >> nextIdx) & 1) || grid[nextRow][nextCol] == 2){\\n                        int nextEmptyCellsMask = emptyCellsMask - (int)(grid[nextRow][nextCol] != 2) * (1 << nextIdx);\\n                        totalWalks += solve(nextRow, nextCol, nextEmptyCellsMask, grid, memo);\\n                    }\\n                }\\n            }\\n        }\\n        memo[state] = totalWalks;\\n        return totalWalks;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        \\n        int startRow = 0;\\n        int startCol = 0;\\n        int emptyCellsMask = 0;\\n        for(int row = 0; row < ROWS; ++row){\\n            for(int col = 0; col < COLS; ++col){\\n                if(grid[row][col] == 1){\\n                    startRow = row;\\n                    startCol = col;\\n                }else if(grid[row][col] == 0){\\n                    emptyCellsMask |= (1 << getIdx(row, col, COLS));\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> memo;\\n        return solve(startRow, startCol, emptyCellsMask, grid, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getIdx(int row, int col, const int& COLS){\\n        return row * COLS + col;\\n    }\\n    \\n    int solve(int row, int col, int emptyCellsMask, vector<vector<int>>& grid, unordered_map<int, int>& memo){\\n        static const vector<pair<int, int>> DIRECTIONS = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        \\n        int totalWalks = 0;\\n        int state = (getIdx(row, col, COLS) << 20) | emptyCellsMask;\\n        if(memo.count(state)){\\n            totalWalks = memo[state];\\n        }else if(grid[row][col] == 2){\\n            if(emptyCellsMask == 0){\\n                totalWalks = 1;\\n            }\\n        }else{\\n            for(const pair<int, int>& DIRECTION: DIRECTIONS){\\n                int nextRow = row + DIRECTION.first;\\n                int nextCol = col + DIRECTION.second;\\n                int nextIdx = getIdx(nextRow, nextCol, COLS);\\n                if(0 <= nextRow && nextRow < ROWS && 0 <= nextCol && nextCol < COLS && grid[nextRow][nextCol] != -1){\\n                    if(((emptyCellsMask >> nextIdx) & 1) || grid[nextRow][nextCol] == 2){\\n                        int nextEmptyCellsMask = emptyCellsMask - (int)(grid[nextRow][nextCol] != 2) * (1 << nextIdx);\\n                        totalWalks += solve(nextRow, nextCol, nextEmptyCellsMask, grid, memo);\\n                    }\\n                }\\n            }\\n        }\\n        memo[state] = totalWalks;\\n        return totalWalks;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        \\n        int startRow = 0;\\n        int startCol = 0;\\n        int emptyCellsMask = 0;\\n        for(int row = 0; row < ROWS; ++row){\\n            for(int col = 0; col < COLS; ++col){\\n                if(grid[row][col] == 1){\\n                    startRow = row;\\n                    startCol = col;\\n                }else if(grid[row][col] == 0){\\n                    emptyCellsMask |= (1 << getIdx(row, col, COLS));\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> memo;\\n        return solve(startRow, startCol, emptyCellsMask, grid, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554765,
                "title": "c-4ms-dfs-backtracking-code-explaination",
                "content": "### **Statement Deduction**\\n<hr>\\n\\nGiven a grid, we must count paths those start at index `i,j` such that `grid[i][j] = 1` and end at `grid[i][j] = 2` such that `steps taken = no. of 0s + 2 (for beginning and ending cells)`\\n\\n### **Approach**\\n<hr>\\n\\nNaively, we can see that from the set of all the paths starting at `grid[i][j] = 1` and ending at `grid[i][j] = 2`, we need a subset that satisfies the condition given above.\\n\\nmodelling the problem as a DFS + backtracking problem:\\n\\n1. We need to check every path from start cell to end cell - Use DFS\\n2. We want all the cells to be visited exactly once for a path - Use `vector<vector<bool>> visited`\\n3. We want to check for the above condition - Use a variable in the method and subtract 1 every time we visit a new cell\\n\\n### **Code**\\n<hr>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long ans = 0; // A global variable that keeps track of no of paths those visite all nodes\\n    \\n    void dfsmod(vector<vector<int>>& grid, int n, int m, int si, int sj, int ei, int ej, int total, vector<vector<bool>>& visited){\\n        if(si < 0 || si >= n || sj < 0 || sj >= m) return; // out of grid\\n        if(si == ei && sj == ej){\\n            if(total == 0) ans++; // if all cells visited\\n            return;\\n        }\\n        if(visited[si][sj] || grid[si][sj] == -1) return; // obstacle or already visited cell\\n        visited[si][sj] = 1;\\n        dfsmod(grid, n, m, si+1, sj, ei, ej, total-1, visited); // go down\\n        dfsmod(grid, n, m, si-1, sj, ei, ej, total-1, visited); // go up\\n        dfsmod(grid, n, m, si, sj+1, ei, ej, total-1, visited); // go right\\n        dfsmod(grid, n, m, si, sj-1, ei, ej, total-1, visited); // go left\\n        visited[si][sj] = 0; // marked as 0 so that the cell can be visited for other paths\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si, sj, ei, ej, total = 0;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 0) total++;\\n                else if(grid[i][j] == 1){\\n                    si = i;\\n                    sj = j;\\n                    total++;\\n                }else if(grid[i][j] == 2){\\n                    ei = i;\\n                    ej = j;\\n                    total++;\\n                }\\n            }\\n        }\\n        vector<vector<bool>> visited(n, vector<bool> (m, 0));\\n        dfsmod(grid, n, m, si, sj, ei, ej, total-1, visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long ans = 0; // A global variable that keeps track of no of paths those visite all nodes\\n    \\n    void dfsmod(vector<vector<int>>& grid, int n, int m, int si, int sj, int ei, int ej, int total, vector<vector<bool>>& visited){\\n        if(si < 0 || si >= n || sj < 0 || sj >= m) return; // out of grid\\n        if(si == ei && sj == ej){\\n            if(total == 0) ans++; // if all cells visited\\n            return;\\n        }\\n        if(visited[si][sj] || grid[si][sj] == -1) return; // obstacle or already visited cell\\n        visited[si][sj] = 1;\\n        dfsmod(grid, n, m, si+1, sj, ei, ej, total-1, visited); // go down\\n        dfsmod(grid, n, m, si-1, sj, ei, ej, total-1, visited); // go up\\n        dfsmod(grid, n, m, si, sj+1, ei, ej, total-1, visited); // go right\\n        dfsmod(grid, n, m, si, sj-1, ei, ej, total-1, visited); // go left\\n        visited[si][sj] = 0; // marked as 0 so that the cell can be visited for other paths\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si, sj, ei, ej, total = 0;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 0) total++;\\n                else if(grid[i][j] == 1){\\n                    si = i;\\n                    sj = j;\\n                    total++;\\n                }else if(grid[i][j] == 2){\\n                    ei = i;\\n                    ej = j;\\n                    total++;\\n                }\\n            }\\n        }\\n        vector<vector<bool>> visited(n, vector<bool> (m, 0));\\n        dfsmod(grid, n, m, si, sj, ei, ej, total-1, visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554549,
                "title": "c-easy-to-understand-dfs-100-faster",
                "content": "**Please Support Me, I\\'m Only 11! Thank You Very Much!**\\nI promise I did not read any other solutions when writing my code. \\nMy first idea was to convert to 1D but that would be not be efficient because make two other vectors. It runs but not very quickly. \\nThe Idea:\\n* Count the number of \\'0\\' cells.\\n* Recurse through the grid mark visited cells as \\'-1\\' or something else so we never repeat it again.\\n* If we reach the end(\\'2\\') we will see if the number of \\'0\\' cells we have visited is the total of \\'0\\' cells in the whole grid.\\n* If the statement above is correct we have another way. \\n\\nWe do not need to worry about repeats because we never go in the same direction. Meaning we do not need to implement ```unordered_set``` or ```unordered_map```.\\n\\nTime Complexity --> O(N * M * 4)\\nSpace Complexity --> O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int solutions = 0;//We will the number of solutions here.\\n    int empty = 1;//We will store the number of \\'0\\' cell here.\\n    \\n    void DFS(vector<vector<int>>& grid, int x, int y, int count) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1){\\n            //If grid[x][y] doesn\\'t exist OR grid[x][y] has already been visited we will stop.\\n            return;\\n        }\\n        \\n        if (grid[x][y] == 2) {\\n            //If we\\'ve reached the end ...\\n            if(empty == count){\\n                //... and we\\'ve crossed every single \\'0\\' we\\'ve found another solution.\\n                solutions++; \\n            }\\n            //If not return anyway.\\n            return;\\n        }\\n        \\n        //If we haven\\'t reached the end and it\\'s valid.\\n        //Mark grid[x][y] as \\'-1\\'.\\n        grid[x][y] = -1;\\n        \\n        //Recurse to the next 4 positions.\\n        DFS(grid, x+1, y, count+1);\\n        DFS(grid, x-1, y, count+1);\\n        DFS(grid, x, y+1, count+1);\\n        DFS(grid, x, y-1, count+1);\\n        \\n        //Reset grid[x][y] because we are using the actual grid, not a copy.\\n        grid[x][y] = 0;        \\n        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int start_x = 0;\\n        int start_y = 0;\\n        \\n        //Find start_x and start_y and initialise empty, the number of \\'0\\' cells.\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1){ \\n                    start_x = i, start_y = j;\\n                }\\n                if (grid[i][j] == 0) {\\n                    empty++;\\n                }                     \\n                 \\n            }\\n        }\\n        //Run the DFS.\\n        DFS(grid, start_x, start_y, 0);\\n        //Return the number of solutions.\\n        return solutions;\\n    }\\n};\\n```\\n\\u263AThanks for reading this! \\u263B\\n\\u2705 Please Upvote! \\u2705\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```unordered_set```\n```unordered_map```\n```\\nclass Solution {\\npublic:\\n    int solutions = 0;//We will the number of solutions here.\\n    int empty = 1;//We will store the number of \\'0\\' cell here.\\n    \\n    void DFS(vector<vector<int>>& grid, int x, int y, int count) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1){\\n            //If grid[x][y] doesn\\'t exist OR grid[x][y] has already been visited we will stop.\\n            return;\\n        }\\n        \\n        if (grid[x][y] == 2) {\\n            //If we\\'ve reached the end ...\\n            if(empty == count){\\n                //... and we\\'ve crossed every single \\'0\\' we\\'ve found another solution.\\n                solutions++; \\n            }\\n            //If not return anyway.\\n            return;\\n        }\\n        \\n        //If we haven\\'t reached the end and it\\'s valid.\\n        //Mark grid[x][y] as \\'-1\\'.\\n        grid[x][y] = -1;\\n        \\n        //Recurse to the next 4 positions.\\n        DFS(grid, x+1, y, count+1);\\n        DFS(grid, x-1, y, count+1);\\n        DFS(grid, x, y+1, count+1);\\n        DFS(grid, x, y-1, count+1);\\n        \\n        //Reset grid[x][y] because we are using the actual grid, not a copy.\\n        grid[x][y] = 0;        \\n        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int start_x = 0;\\n        int start_y = 0;\\n        \\n        //Find start_x and start_y and initialise empty, the number of \\'0\\' cells.\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1){ \\n                    start_x = i, start_y = j;\\n                }\\n                if (grid[i][j] == 0) {\\n                    empty++;\\n                }                     \\n                 \\n            }\\n        }\\n        //Run the DFS.\\n        DFS(grid, start_x, start_y, 0);\\n        //Return the number of solutions.\\n        return solutions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554434,
                "title": "simple-dfs-solution-commented-self-explanatory-code",
                "content": "Idea is to do standard dfs to visit every cell. Since every cell can be visited only once, we will mark that cell as -1 and do dfs for other 4-direction adjacent cells, then backtrack for checking other possibilities.\\n```\\nclass Solution {\\npublic:\\n    int ans=0,empty=1;\\n    void dfs(vector<vector<int>>& grid,int x,int y,int count){\\n        // base case\\n        if(x<0 or x>=grid.size() or y<0 or y>=grid[0].size() or grid[x][y]==-1)\\n            return;\\n        \\n        // termination case when robot reaches the cell marked 2\\n        if(grid[x][y]==2){\\n            // increment ans only when all the cells have been visited (as per the question)\\n            if(empty==count)\\n                ans++;\\n            return;\\n        }\\n        \\n        // mark the cell as visited (-1 as it cannot be walked over again (as per the ques))\\n        grid[x][y] = -1;\\n        \\n        dfs(grid,x+1,y,count+1);\\n        dfs(grid,x-1,y,count+1);\\n        dfs(grid,x,y+1,count+1);\\n        dfs(grid,x,y-1,count+1);\\n        \\n        // backtrack\\n        grid[x][y] = 0;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int startX,startY;\\n        \\n        // traverse the grid\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j]==1){\\n                    startX = i;\\n                    startY = j;\\n                }\\n                else if(grid[i][j]==0){\\n                    empty++;\\n                }\\n            }\\n        }\\n        \\n        dfs(grid,startX,startY,0);\\n        \\n        return ans;\\n    }\\n};\\n```\\nif you found this useful please upvote.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0,empty=1;\\n    void dfs(vector<vector<int>>& grid,int x,int y,int count){\\n        // base case\\n        if(x<0 or x>=grid.size() or y<0 or y>=grid[0].size() or grid[x][y]==-1)\\n            return;\\n        \\n        // termination case when robot reaches the cell marked 2\\n        if(grid[x][y]==2){\\n            // increment ans only when all the cells have been visited (as per the question)\\n            if(empty==count)\\n                ans++;\\n            return;\\n        }\\n        \\n        // mark the cell as visited (-1 as it cannot be walked over again (as per the ques))\\n        grid[x][y] = -1;\\n        \\n        dfs(grid,x+1,y,count+1);\\n        dfs(grid,x-1,y,count+1);\\n        dfs(grid,x,y+1,count+1);\\n        dfs(grid,x,y-1,count+1);\\n        \\n        // backtrack\\n        grid[x][y] = 0;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int startX,startY;\\n        \\n        // traverse the grid\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j]==1){\\n                    startX = i;\\n                    startY = j;\\n                }\\n                else if(grid[i][j]==0){\\n                    empty++;\\n                }\\n            }\\n        }\\n        \\n        dfs(grid,startX,startY,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554119,
                "title": "unique-paths-iii-c-dfs-easy-solution",
                "content": "class Solution {\\npublic:\\n    int ans=0;\\n    void findcount(vector<vector<int>>& grid,int sr,int sc,vector<vector<int>>&dir,int cnt)\\n    {    \\n         \\n        if(sr<0 or sc<0 or sr>=grid.size() or sc>=grid[0].size() or grid[sr][sc]==-10 or grid[sr][sc]==-1) return;\\n        \\n        if(cnt==0 and grid[sr][sc]==2)\\n        {\\n            ans++;\\n            return;\\n        }\\n        if(grid[sr][sc]==0)\\n            cnt--;\\n        \\n        int temp=grid[sr][sc];\\n        grid[sr][sc]=-10;\\n        for(auto ele:dir){\\n            int r=sr+ele[0];\\n            int c=sc+ele[1];\\n            \\n            findcount(grid,r,c,dir,cnt);\\n        }\\n        grid[sr][sc]=temp;\\n        return;\\n        \\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0]==2 or grid[0][0]==-1) return 0;\\n        \\n        int cnt=0; // count of all places from where robot can walk through\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        int sr=0,sc=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    cnt++;\\n                if(grid[i][j]==1)\\n                {\\n                    sr=i;\\n                    sc=j;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> dir={{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        findcount(grid,sr,sc,dir,cnt);\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    void findcount(vector<vector<int>>& grid,int sr,int sc,vector<vector<int>>&dir,int cnt)\\n    {    \\n         \\n        if(sr<0 or sc<0 or sr>=grid.size() or sc>=grid[0].size() or grid[sr][sc]==-10 or grid[sr][sc]==-1) return;\\n        \\n        if(cnt==0 and grid[sr][sc]==2)\\n        {\\n            ans++;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1553971,
                "title": "simple-c-backtracting-solution",
                "content": "class Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& grid,int i,int j,int n,int m,int count,int curr,int &total)\\n    {\\n        if(i>=n or j>=m or i<0 or j<0 or grid[i][j]==-1)\\n            return;\\n        \\n        if(grid[i][j]==2)\\n        {\\n            if(count==curr)\\n            {\\n                total++;\\n            }\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;\\n        \\n        dfs(grid,i,j+1,n,m,count,curr+1,total);\\n        dfs(grid,i,j-1,n,m,count,curr+1,total);\\n        dfs(grid,i+1,j,n,m,count,curr+1,total);\\n        dfs(grid,i-1,j,n,m,count,curr+1,total);\\n        \\n        grid[i][j] = 0;\\n        \\n        return;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int x,y;\\n        \\n        int count = 0; // total number of empty squares we can walk over + one final destination\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x = i;\\n                    y = j;\\n                }\\n                else if(grid[i][j]==0 or grid[i][j]==2)\\n                    count++;\\n            }\\n        }\\n        \\n        int total = 0;  // total number of ways we have\\n        int curr = 0;   //currently how many empty squares we have passed\\n        dfs(grid,x,y,n,m,count,curr,total);\\n        return total;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& grid,int i,int j,int n,int m,int count,int curr,int &total)\\n    {\\n        if(i>=n or j>=m or i<0 or j<0 or grid[i][j]==-1)\\n            return;\\n        \\n        if(grid[i][j]==2)\\n        {\\n            if(count==curr)\\n            {\\n                total++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1491985,
                "title": "simple-java-backtracking-soln-similar-to-no-of-islands-ques-concept",
                "content": "**Explanation**:\\n1. Count totalSteps needed to reach dest using all valid blocks.\\n2. Also store start position, in the same loop.\\n3. Using recursive func, find the path to dest with steps == totalSteps.\\n4. Once found, don\\'t end recursion completely here. Stop that branch only, then do backtracking and find new paths if available using the for loop of direction vector.\\n\\nIf you couldn\\'t understand now, believe me, just go through the code once, it will become absolutely clear...\\n\\n**Code**:\\n```\\nclass Solution {\\n    int m, n;\\n    int totalSteps = 0;\\n    int count = 0;\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        int startX = -1, startY = -1;   \\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0 || grid[i][j] == 2)\\n                    totalSteps++;\\n                if(grid[i][j] == 1){\\n                    startX = i;\\n                    startY = j;\\n                } \\n            }\\n                \\n        path(grid, startX, startY, 0);\\n        \\n        return count;\\n    }\\n    \\n    public void path(int[][] grid, int r, int c, int steps){\\n        \\n        if(steps == totalSteps && grid[r][c] == 2){\\n            count++;\\n            return;\\n        }\\n        \\n        if(grid[r][c] == 2)     // to stops path which pass through \"2\" twice & satisfying\\n            return;             // steps cond fianlly, & hence increasing count falsely.\\n        \\n\\t\\t//Direction Vector\\n        int DIR[] = {0, -1, 0, 1, 0};\\n        for(int i = 0; i < 4; i++){\\n            int nr = r + DIR[i], nc = c + DIR[i+1];\\n            \\n            if(nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] != -1 && grid[nr][nc] != 1){\\n                steps++;\\n                if(grid[nr][nc] != 2)\\n                    grid[nr][nc] = -1;\\n                \\n                path(grid, nr, nc, steps);\\n                \\n                //backtracking lines: \\n                steps--;\\n                if(grid[nr][nc] == -1)\\n                    grid[nr][nc] = 0;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nPlease upvote if you are able to understand the solution and it helped in clearing your doubts.\\nThanks!!",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    int totalSteps = 0;\\n    int count = 0;\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        int startX = -1, startY = -1;   \\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0 || grid[i][j] == 2)\\n                    totalSteps++;\\n                if(grid[i][j] == 1){\\n                    startX = i;\\n                    startY = j;\\n                } \\n            }\\n                \\n        path(grid, startX, startY, 0);\\n        \\n        return count;\\n    }\\n    \\n    public void path(int[][] grid, int r, int c, int steps){\\n        \\n        if(steps == totalSteps && grid[r][c] == 2){\\n            count++;\\n            return;\\n        }\\n        \\n        if(grid[r][c] == 2)     // to stops path which pass through \"2\" twice & satisfying\\n            return;             // steps cond fianlly, & hence increasing count falsely.\\n        \\n\\t\\t//Direction Vector\\n        int DIR[] = {0, -1, 0, 1, 0};\\n        for(int i = 0; i < 4; i++){\\n            int nr = r + DIR[i], nc = c + DIR[i+1];\\n            \\n            if(nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] != -1 && grid[nr][nc] != 1){\\n                steps++;\\n                if(grid[nr][nc] != 2)\\n                    grid[nr][nc] = -1;\\n                \\n                path(grid, nr, nc, steps);\\n                \\n                //backtracking lines: \\n                steps--;\\n                if(grid[nr][nc] == -1)\\n                    grid[nr][nc] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465949,
                "title": "super-easy-java-backtracking-implementation-100",
                "content": "```\\nclass Solution { int totalCount = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int starti=-1,startj=-1, zeros = 0;\\n        \\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    starti = i;\\n                    startj = j;\\n                }\\n                else if(grid[i][j] == 0)\\n                    zeros++;\\n            }\\n        }\\n        \\n        solve(grid,starti,startj,0,zeros);\\n        \\n        return totalCount;\\n    }\\n    \\n    public void solve(int[][] grid, int i, int j, int count,int zeros)\\n    {\\n        if(i > grid.length-1 || j > grid[0].length-1 || i < 0 || j < 0 || grid[i][j] == -1)\\n            return;\\n        \\n        if(grid[i][j] == 2)\\n        {\\n            if(count == zeros+1)\\n                totalCount++;\\n            \\n            return;\\n        }\\n        \\n        grid[i][j] = -1;\\n        count++;\\n        \\n        solve(grid,i,j+1,count,zeros);\\n        solve(grid,i+1,j,count,zeros);\\n        solve(grid,i-1,j,count,zeros);\\n        solve(grid,i,j-1,count,zeros);\\n        \\n        grid[i][j] = 0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution { int totalCount = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int starti=-1,startj=-1, zeros = 0;\\n        \\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    starti = i;\\n                    startj = j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1417373,
                "title": "c-easy-sol-with-dfs-commented",
                "content": "we have to traverse all the squares except obstacles, i.e -1\\n```\\nclass Solution {\\npublic:\\n    int startx;\\n    int starty;\\n    int endx;\\n    int endy;\\n    int ans=0;\\n    int squares_which_are_path;//squares which we have to travel\\n    int m;\\n    int n;\\n    vector<int> dx = {0,0,1,-1};\\n    vector<int> dy = {1,-1,0,0};\\n    void dfs(vector<vector<int>> &grid, int i, int j, int path)\\n    {\\n        //we have reached ending point i.e 2 after walking all squares\\n        if(i==endx && j==endy && path == squares_which_are_path)\\n        {\\n            ans++;\\n            return;\\n        }\\n        grid[i][j] = -1;//marking current as visited, so we don\\'t calculate calculated values again\\n        \\n        for(int k=0; k<4; k++)\\n        {\\n            int x = i+dx[k];\\n            int y = j+dy[k];\\n            //we can walk all the paths excluding obstacles i.e -1\\n            if(x>=0 and x<m and y>=0 and y<n and grid[x][y] != -1)\\n                dfs(grid, x, y, path+1);  \\n        }\\n        grid[i][j] = 0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        squares_which_are_path = m*n;//total if we also include -1\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 1)//our starting point\\n                {\\n                    startx = i;\\n                    starty = j;\\n                }\\n                else if(grid[i][j] == 2)//our ending point\\n                {\\n                    endx = i;\\n                    endy = j;\\n                }\\n                else if(grid[i][j] == -1)\\n                {\\n                    squares_which_are_path--;\\n                    //subtract as -1 will not form a path, it is obstacle\\n                }\\n            }\\n        }\\n        dfs(grid, startx, starty,1);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int startx;\\n    int starty;\\n    int endx;\\n    int endy;\\n    int ans=0;\\n    int squares_which_are_path;//squares which we have to travel\\n    int m;\\n    int n;\\n    vector<int> dx = {0,0,1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1131802,
                "title": "rust-0ms-dfs-back-tracking",
                "content": "```\\nimpl Solution {\\n    pub fn unique_paths_iii(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let (start_x, start_y) = (0..grid.len())\\n            .flat_map(|y| (0..grid[0].len()).map(move |x| (x, y)))\\n            .find(|&(x, y)| grid[y][x] == 1)\\n            .expect(\"grid doesn\\'t have a starting square!\");\\n        let num_empty = grid\\n            .iter()\\n            .flat_map(|r| r.iter().filter(|&&c| c != -1))\\n            .count();\\n\\n        Self::dfs(&mut grid, start_x, start_y, num_empty - 1) as _\\n    }\\n\\n    fn dfs(grid: &mut Vec<Vec<i32>>, x: usize, y: usize, num_empty_unvisited: usize) -> usize {\\n        if x >= grid[0].len() || y >= grid.len() {\\n            return 0;\\n        }\\n        match grid[y][x] {\\n            0 | 1 => {\\n                grid[y][x] = -1; // mark as visited\\n                let num_valid_paths_from_here = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n                    .iter()\\n                    .map(|&(dx, dy)| ((x as isize + dx) as _, (y as isize + dy) as _))\\n                    .map(|(nx, ny)| Self::dfs(grid, nx, ny, num_empty_unvisited - 1))\\n                    .sum();\\n                grid[y][x] = 0; // backtrack and un-mark\\n\\n                num_valid_paths_from_here\\n            }\\n            2 if num_empty_unvisited == 0 => 1,\\n            _ => 0,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn unique_paths_iii(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let (start_x, start_y) = (0..grid.len())\\n            .flat_map(|y| (0..grid[0].len()).map(move |x| (x, y)))\\n            .find(|&(x, y)| grid[y][x] == 1)\\n            .expect(\"grid doesn\\'t have a starting square!\");\\n        let num_empty = grid\\n            .iter()\\n            .flat_map(|r| r.iter().filter(|&&c| c != -1))\\n            .count();\\n\\n        Self::dfs(&mut grid, start_x, start_y, num_empty - 1) as _\\n    }\\n\\n    fn dfs(grid: &mut Vec<Vec<i32>>, x: usize, y: usize, num_empty_unvisited: usize) -> usize {\\n        if x >= grid[0].len() || y >= grid.len() {\\n            return 0;\\n        }\\n        match grid[y][x] {\\n            0 | 1 => {\\n                grid[y][x] = -1; // mark as visited\\n                let num_valid_paths_from_here = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n                    .iter()\\n                    .map(|&(dx, dy)| ((x as isize + dx) as _, (y as isize + dy) as _))\\n                    .map(|(nx, ny)| Self::dfs(grid, nx, ny, num_empty_unvisited - 1))\\n                    .sum();\\n                grid[y][x] = 0; // backtrack and un-mark\\n\\n                num_valid_paths_from_here\\n            }\\n            2 if num_empty_unvisited == 0 => 1,\\n            _ => 0,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121327,
                "title": "java-backtracking-easy-understanding",
                "content": "Hint -> **1 <= grid.length * grid[0].length <= 20** , if  **length is less , Backtracking** is one of the **acceptable** solution .\\n\\nStore the starting point indexes and count the no of empty cells in the matrix;\\nPerform DFS , if we reach the ending square and visited all empty cells, considered it into the result otherwise ignore.\\n\\n```\\nclass Solution {\\n    int empty =1;// starting square considered as empty too\\n    public int uniquePathsIII(int[][] grid) {    \\n        int tR = grid.length;int tC = grid[0].length;int sR=-1,sC=-1;\\n        for( int i =0 ; i < tR; i++ ){\\n            for( int j =0; j< tC; j++ )\\n\\t\\t\\t{\\n                if( grid[i][j] == 1 ) { sR = i; sC = j;}\\n                else if( grid[i][j] == 0 )   empty++;\\n            }\\n        }\\n    return dfs( sR,sC, grid );\\n    }\\n    public int dfs( int i, int j,int[][] grid )\\n    {\\n        int count = 0;\\n        if( i < 0  || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -2 || grid[i][j] == -1 ) // ignoring obstacles and visiting square\\n            return 0 ;\\n        \\n        if( grid[i][j]== 2 ) //ending square\\n            if( empty == 0 ) return 1; //visited all empty cells\\n        \\n        int temp = grid[i][j]; //before marking as visited save the value so that we can assign it after recursion calls\\n        grid[i][j] =-2; // no need of visited 2d array, -2 value means we have visited it\\n        empty--;\\n        count += dfs( i+1,j,grid) + dfs( i-1,j,grid) + dfs( i,j+1,grid) + dfs( i,j-1,grid); // 4 direction walk\\n        grid[i][j] = temp;\\n        empty++;\\n     return count;       \\n    }   \\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int empty =1;// starting square considered as empty too\\n    public int uniquePathsIII(int[][] grid) {    \\n        int tR = grid.length;int tC = grid[0].length;int sR=-1,sC=-1;\\n        for( int i =0 ; i < tR; i++ ){\\n            for( int j =0; j< tC; j++ )\\n\\t\\t\\t{\\n                if( grid[i][j] == 1 ) { sR = i; sC = j;}",
                "codeTag": "Java"
            },
            {
                "id": 857773,
                "title": "easy-to-understand-backtracking-solution-video-explanation-c",
                "content": "[Drop a like if you find this helpful <3](https://www.youtube.com/watch?v=tnVl8hFLPc4)\\n\\n```\\npublic class Solution {\\n    int count;\\n    public int UniquePathsIII(int[][] grid) {\\n        int startX = 0;\\n        int startY = 0;\\n        int countZeros = 1;\\n        count = 0;\\n        \\n        for(int i = 0; i < grid.Length; i++) {\\n            for(int j = 0; j < grid[0].Length; j++) {\\n                if(grid[i][j] == 0) countZeros++;\\n                else if(grid[i][j] == 1) { startX = i; startY = j;}\\n            }\\n        }\\n        \\n        UniquePathsIIIUtil(grid, startX, startY, countZeros);\\n        \\n        return count;\\n    }\\n    \\n    private void UniquePathsIIIUtil(int[][] grid, int row, int col, int countZeros) {\\n        if(row < 0 || col < 0 ||\\n           row >= grid.Length ||\\n           col >= grid[0].Length ||\\n           countZeros < 0 || grid[row][col] == -1)\\n            return;\\n        \\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0) count++;\\n            return;\\n        }\\n        \\n        grid[row][col] = -1;\\n        \\n        UniquePathsIIIUtil(grid, row + 1, col, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row, col + 1, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row - 1, col, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row, col - 1, countZeros - 1);\\n        \\n        grid[row][col] = 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    int count;\\n    public int UniquePathsIII(int[][] grid) {\\n        int startX = 0;\\n        int startY = 0;\\n        int countZeros = 1;\\n        count = 0;\\n        \\n        for(int i = 0; i < grid.Length; i++) {\\n            for(int j = 0; j < grid[0].Length; j++) {\\n                if(grid[i][j] == 0) countZeros++;\\n                else if(grid[i][j] == 1) { startX = i; startY = j;}\\n            }\\n        }\\n        \\n        UniquePathsIIIUtil(grid, startX, startY, countZeros);\\n        \\n        return count;\\n    }\\n    \\n    private void UniquePathsIIIUtil(int[][] grid, int row, int col, int countZeros) {\\n        if(row < 0 || col < 0 ||\\n           row >= grid.Length ||\\n           col >= grid[0].Length ||\\n           countZeros < 0 || grid[row][col] == -1)\\n            return;\\n        \\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0) count++;\\n            return;\\n        }\\n        \\n        grid[row][col] = -1;\\n        \\n        UniquePathsIIIUtil(grid, row + 1, col, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row, col + 1, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row - 1, col, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row, col - 1, countZeros - 1);\\n        \\n        grid[row][col] = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856885,
                "title": "go-golang-dfs-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Unique Paths III.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Unique Paths III.\\n\\n```go\\nfunc uniquePathsIII(grid [][]int) int {\\n    x, y, n := -1, -1, 0\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] == 0 { n++ }\\n            if grid[i][j] == 1 { x, y, n = i, j, n + 1 }\\n        }\\n    }\\n    return dfs(&grid, x, y, n)\\n}\\n\\nfunc dfs(grid *[][]int, x, y, n int) int {\\n    if x < 0 || x >= len(*grid) || y < 0 || y >= len((*grid)[0]) || (*grid)[x][y] == -1 { return 0 }\\n    if (*grid)[x][y] == 2 { if n == 0 { return 1 }; return 0 }\\n    (*grid)[x][y] = -1\\n    paths := dfs(grid, x + 1, y, n - 1) +\\n             dfs(grid, x - 1, y, n - 1) + \\n             dfs(grid, x, y + 1, n - 1) +\\n             dfs(grid, x, y - 1, n - 1)\\n    (*grid)[x][y] = 0\\n    return paths\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc uniquePathsIII(grid [][]int) int {\\n    x, y, n := -1, -1, 0\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] == 0 { n++ }\\n            if grid[i][j] == 1 { x, y, n = i, j, n + 1 }\\n        }\\n    }\\n    return dfs(&grid, x, y, n)\\n}\\n\\nfunc dfs(grid *[][]int, x, y, n int) int {\\n    if x < 0 || x >= len(*grid) || y < 0 || y >= len((*grid)[0]) || (*grid)[x][y] == -1 { return 0 }\\n    if (*grid)[x][y] == 2 { if n == 0 { return 1 }; return 0 }\\n    (*grid)[x][y] = -1\\n    paths := dfs(grid, x + 1, y, n - 1) +\\n             dfs(grid, x - 1, y, n - 1) + \\n             dfs(grid, x, y + 1, n - 1) +\\n             dfs(grid, x, y - 1, n - 1)\\n    (*grid)[x][y] = 0\\n    return paths\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855927,
                "title": "unique-paths-python",
                "content": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        output=0\\n        squares=0\\n        h=len(grid)\\n        w=len(grid[0])\\n        for i in range(h):\\n            for j in range(w):\\n                if grid[i][j]==1:\\n                    start=(j,i)\\n                elif grid[i][j]==2:\\n                    end=(j,i)\\n                elif grid[i][j]==0:\\n                    squares+=1\\n        \\n        dire=[(1,0),(0,1),(-1,0),(0,-1)]\\n        \\n        def dfs(cur,his):\\n            nonlocal output\\n            x,y=cur\\n            for dx,dy in dire:\\n                x_=x+dx\\n                y_=y+dy\\n                if 0<=x_<w and 0<=y_<h and (x_,y_) not in his and grid[y_][x_]!=-1:\\n                    if (x_,y_)==end:\\n                        if len(his)==squares+1:\\n                            output+=1\\n                            break\\n                        else:\\n                            continue\\n                    else:\\n                        dfs((x_,y_),his+[(x_,y_)])\\n                        \\n        dfs(start,[start])   \\n        return output\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        output=0\\n        squares=0\\n        h=len(grid)\\n        w=len(grid[0])\\n        for i in range(h):\\n            for j in range(w):\\n                if grid[i][j]==1:\\n                    start=(j,i)\\n                elif grid[i][j]==2:\\n                    end=(j,i)\\n                elif grid[i][j]==0:\\n                    squares+=1\\n        \\n        dire=[(1,0),(0,1),(-1,0),(0,-1)]\\n        \\n        def dfs(cur,his):\\n            nonlocal output\\n            x,y=cur\\n            for dx,dy in dire:\\n                x_=x+dx\\n                y_=y+dy\\n                if 0<=x_<w and 0<=y_<h and (x_,y_) not in his and grid[y_][x_]!=-1:\\n                    if (x_,y_)==end:\\n                        if len(his)==squares+1:\\n                            output+=1\\n                            break\\n                        else:\\n                            continue\\n                    else:\\n                        dfs((x_,y_),his+[(x_,y_)])\\n                        \\n        dfs(start,[start])   \\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 855754,
                "title": "c-0ms-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    void dfs(int x,int y,vector<vector<int>>& grid, int count,int total)\\n    {\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size() || grid[x][y]==-1)\\n        {\\n            return;\\n        }\\n        if(grid[x][y]==2 && total==count)\\n        {\\n            sol++;\\n            return;\\n        }\\n        if(grid[x][y]==2 && total!=count)\\n            return;\\n        if(total>=count)\\n            return;\\n        grid[x][y]=-1;\\n        dfs(x+1,y,grid,count,total+1);\\n        dfs(x-1,y,grid,count,total+1);\\n        dfs(x,y+1,grid,count,total+1);\\n        dfs(x,y-1,grid,count,total+1);\\n        grid[x][y]=0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int count=0;\\n        int x,y;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                if(grid[i][j]==0)\\n                    count++;\\n            }\\n        }\\n        dfs(x,y,grid,count+1,0);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    void dfs(int x,int y,vector<vector<int>>& grid, int count,int total)\\n    {\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size() || grid[x][y]==-1)\\n        {\\n            return;\\n        }\\n        if(grid[x][y]==2 && total==count)\\n        {\\n            sol++;\\n            return;\\n        }\\n        if(grid[x][y]==2 && total!=count)\\n            return;\\n        if(total>=count)\\n            return;\\n        grid[x][y]=-1;\\n        dfs(x+1,y,grid,count,total+1);\\n        dfs(x-1,y,grid,count,total+1);\\n        dfs(x,y+1,grid,count,total+1);\\n        dfs(x,y-1,grid,count,total+1);\\n        grid[x][y]=0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int count=0;\\n        int x,y;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                if(grid[i][j]==0)\\n                    count++;\\n            }\\n        }\\n        dfs(x,y,grid,count+1,0);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899529,
                "title": "a-c-solution",
                "content": "another way to write the same idea as the others :(\\n# Code\\n```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit, int spaces) {\\n    if(row < 0 || row > rLimit || col < 0 || col > cLimit || grid[row][col] == -1) return 0;\\n    if(grid[row][col] == 2) return (spaces == 0)? 1 : 0;\\n\\n    int ans = 0;\\n    grid[row][col] = -1;\\n    ans += traverse(grid, row - 1, col, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row + 1, col, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row, col - 1, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row, col + 1, rLimit, cLimit, spaces - 1);\\n    grid[row][col] = 0;\\n\\n    return ans;\\n}\\n\\nint uniquePathsIII(int** grid, int gridSize, int* gridColSize){\\n    int startRow = 0, startCol = 0;\\n    int spaces = 1;\\n    int rLimit = gridSize - 1;\\n    int cLimit = *gridColSize - 1;\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j] == 1) {\\n                startRow = i;\\n                startCol = j;\\n            }\\n            else if(!grid[i][j]) spaces++;\\n        }\\n    }\\n    \\n    return traverse(grid, startRow, startCol, rLimit, cLimit, spaces);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit, int spaces) {\\n    if(row < 0 || row > rLimit || col < 0 || col > cLimit || grid[row][col] == -1) return 0;\\n    if(grid[row][col] == 2) return (spaces == 0)? 1 : 0;\\n\\n    int ans = 0;\\n    grid[row][col] = -1;\\n    ans += traverse(grid, row - 1, col, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row + 1, col, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row, col - 1, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row, col + 1, rLimit, cLimit, spaces - 1);\\n    grid[row][col] = 0;\\n\\n    return ans;\\n}\\n\\nint uniquePathsIII(int** grid, int gridSize, int* gridColSize){\\n    int startRow = 0, startCol = 0;\\n    int spaces = 1;\\n    int rLimit = gridSize - 1;\\n    int cLimit = *gridColSize - 1;\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j] == 1) {\\n                startRow = i;\\n                startCol = j;\\n            }\\n            else if(!grid[i][j]) spaces++;\\n        }\\n    }\\n    \\n    return traverse(grid, startRow, startCol, rLimit, cLimit, spaces);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3617462,
                "title": "100-beats-c-dfs",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<vector<int>> &g, int i, int j, int s, int t_s)\\n    {\\n        if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1)\\n            return 0;\\n        if (g[i][j] == 2)\\n            return s == t_s ? 1 : 0;\\n        g[i][j] = -1;\\n        int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n                    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n        g[i][j] = 0;\\n        return paths;\\n    }\\n    int uniquePathsIII(vector<vector<int>> &g)\\n    {\\n        auto i1 = 0, j1 = 0, t_steps = 0;\\n        for (auto i = 0; i < g.size(); ++i)\\n            for (auto j = 0; j < g[0].size(); ++j)\\n            {\\n                if (g[i][j] == 1)\\n                    i1 = i, j1 = j;\\n                if (g[i][j] != -1)\\n                    ++t_steps;\\n            }\\n        return dfs(g, i1, j1, 1, t_steps);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<vector<int>> &g, int i, int j, int s, int t_s)\\n    {\\n        if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1)\\n            return 0;\\n        if (g[i][j] == 2)\\n            return s == t_s ? 1 : 0;\\n        g[i][j] = -1;\\n        int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n                    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n        g[i][j] = 0;\\n        return paths;\\n    }\\n    int uniquePathsIII(vector<vector<int>> &g)\\n    {\\n        auto i1 = 0, j1 = 0, t_steps = 0;\\n        for (auto i = 0; i < g.size(); ++i)\\n            for (auto j = 0; j < g[0].size(); ++j)\\n            {\\n                if (g[i][j] == 1)\\n                    i1 = i, j1 = j;\\n                if (g[i][j] != -1)\\n                    ++t_steps;\\n            }\\n        return dfs(g, i1, j1, 1, t_steps);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310059,
                "title": "100-faster-make-a-counter-dfs-brute-force-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int sr,int sc,int &er,int &ec,int &m,int &n,int &ans,vector<vector<int>> &g,int x,int k){\\n        if(sr<0||sc<0||sr>=m||sc>=n||g[sr][sc]==3||g[sr][sc]==-1){\\n            return;\\n        }\\n        if(sr==er&&sc==ec){\\n            if(k==-1)\\n            ans++;\\n            return;\\n        }\\n        g[sr][sc] = 3;\\n        solve(sr+1,sc,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr,sc+1,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr-1,sc,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr,sc-1,er,ec,m,n,ans,g,x,k-1);\\n        g[sr][sc] = 0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i = 0, j = 0, m = grid.size(), n = grid[0].size(),sr,sc,er,ec,k=0;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]==1){\\n                    sr = i;\\n                    sc = j;\\n                }else if(grid[i][j] == 2){\\n                    er = i;\\n                    ec = j;\\n                }else if(grid[i][j]==0){\\n                    k++;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        solve(sr,sc,er,ec,m,n,ans,grid,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int sr,int sc,int &er,int &ec,int &m,int &n,int &ans,vector<vector<int>> &g,int x,int k){\\n        if(sr<0||sc<0||sr>=m||sc>=n||g[sr][sc]==3||g[sr][sc]==-1){\\n            return;\\n        }\\n        if(sr==er&&sc==ec){\\n            if(k==-1)\\n            ans++;\\n            return;\\n        }\\n        g[sr][sc] = 3;\\n        solve(sr+1,sc,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr,sc+1,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr-1,sc,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr,sc-1,er,ec,m,n,ans,g,x,k-1);\\n        g[sr][sc] = 0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i = 0, j = 0, m = grid.size(), n = grid[0].size(),sr,sc,er,ec,k=0;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]==1){\\n                    sr = i;\\n                    sc = j;\\n                }else if(grid[i][j] == 2){\\n                    er = i;\\n                    ec = j;\\n                }else if(grid[i][j]==0){\\n                    k++;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        solve(sr,sc,er,ec,m,n,ans,grid,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229428,
                "title": "python-approch-99-beat",
                "content": "# Intuition\\n this is not really a hard problem you have first solve island perimeter question the approach this problem. -->\\nthis code beat 99%\\n\\n# Approach\\n   just using backtracking concept \\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n   it just taking stack memory not any extra memory O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def infy(row,col,zero):\\n            if row < 0 or col < 0 or row >=m or col >= n or grid[row][col] == -1:\\n                return 0\\n            if grid[row][col] == 2:\\n                return 1 if zero == -1 else 0 \\n\\n            grid[row][col] = -1\\n            zero -= 1\\n            peri = infy(row+1,col,zero) +infy(row,col+1,zero) + infy(row-1,col,zero)+infy(row,col-1,zero)\\n            grid[row][col] = 1\\n            zero += 1\\n            return peri\\n\\n        x ,y,zero = 0,0,0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    zero+=1\\n                elif grid[i][j] == 1:\\n                    x = i\\n                    y = j\\n        return infy(x,y,zero)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def infy(row,col,zero):\\n            if row < 0 or col < 0 or row >=m or col >= n or grid[row][col] == -1:\\n                return 0\\n            if grid[row][col] == 2:\\n                return 1 if zero == -1 else 0 \\n\\n            grid[row][col] = -1\\n            zero -= 1\\n            peri = infy(row+1,col,zero) +infy(row,col+1,zero) + infy(row-1,col,zero)+infy(row,col-1,zero)\\n            grid[row][col] = 1\\n            zero += 1\\n            return peri\\n\\n        x ,y,zero = 0,0,0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    zero+=1\\n                elif grid[i][j] == 1:\\n                    x = i\\n                    y = j\\n        return infy(x,y,zero)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221990,
                "title": "java-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int count=0;\\n    static int[] dx = {-1, 0, 1, 0};\\n    static int[] dy = {0, 1, 0, -1};\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0; \\n        int sx = 0; \\n        int sy = 0; \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        boolean v[][]=new boolean[m][n];\\n        for(int r = 0; r < grid.length; r++){ \\n            for(int c = 0; c < grid[0].length; c++){ \\n                if(grid[r][c] == 0) zero++;\\n                else if(grid[r][c] == 1){\\n                    sx = r; \\n                    sy = c;\\n                }\\n                else if(grid[r][c]==-1){\\n                    v[r][c]=true;\\n                }\\n            }\\n        }\\n        count=0;\\n        backtrack(grid, sx, sy, zero,v);\\n        return count;\\n    }\\n    public void backtrack(int grid[][], int x, int y, int zero,boolean v[][]){\\n       \\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length \\n         ||v[x][y]) return ;\\n\\n        if(grid[x][y] == 2 && zero==-1)\\n        {\\n           count++;\\n           return;\\n        }\\n\\n        v[x][y]=true;\\n        zero--; \\n        // up right down left\\n        for (int i = 0; i < 4; i++) {\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n            backtrack(grid,nx,ny,zero,v);\\n        }\\n       \\n        v[x][y]=false;\\n        zero++;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int count=0;\\n    static int[] dx = {-1, 0, 1, 0};\\n    static int[] dy = {0, 1, 0, -1};\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0; \\n        int sx = 0; \\n        int sy = 0; \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        boolean v[][]=new boolean[m][n];\\n        for(int r = 0; r < grid.length; r++){ \\n            for(int c = 0; c < grid[0].length; c++){ \\n                if(grid[r][c] == 0) zero++;\\n                else if(grid[r][c] == 1){\\n                    sx = r; \\n                    sy = c;\\n                }\\n                else if(grid[r][c]==-1){\\n                    v[r][c]=true;\\n                }\\n            }\\n        }\\n        count=0;\\n        backtrack(grid, sx, sy, zero,v);\\n        return count;\\n    }\\n    public void backtrack(int grid[][], int x, int y, int zero,boolean v[][]){\\n       \\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length \\n         ||v[x][y]) return ;\\n\\n        if(grid[x][y] == 2 && zero==-1)\\n        {\\n           count++;\\n           return;\\n        }\\n\\n        v[x][y]=true;\\n        zero--; \\n        // up right down left\\n        for (int i = 0; i < 4; i++) {\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n            backtrack(grid,nx,ny,zero,v);\\n        }\\n       \\n        v[x][y]=false;\\n        zero++;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975900,
                "title": "c-begineer-friendly-easy-understanding-dfs-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/172yYUwdf-I\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\u2003int ans = 0;\\n    int nonObstacle = 1;\\n    // dfs from the starting position.\\n   void dfs(int i,int j,vector<vector<int>>&grid,int count){\\n    //    base condtion.\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() ||grid[i][j] == -1){\\n        return ;\\n    }\\n    if(grid[i][j] == 2){\\n        // if we got all the nonobstacle cover.\\n       if(count == nonObstacle){\\n            ans++;\\n       }\\n       return;\\n    }\\n\\n    // make current node visited.\\n    grid[i][j] = -1;\\n\\n    // Traversal.\\n    dfs(i+1,j,grid,count+1);\\n    dfs(i-1,j,grid,count+1);\\n    dfs(i,j+1,grid,count+1);\\n    dfs(i,j-1,grid,count+1);\\n\\n\\n    // backtracking make it non-visited.\\n    grid[i][j] = 0;\\n   }\\n\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n\\n        // store the starting position.\\n        int startX = 0;\\n        int startY = 0;\\n        // find the starting location and number of non-obstacle square.\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++){\\n                // if we got the starting position.\\n                if(grid[i][j] == 1){startX = i; startY =j;}\\n                else if(grid[i][j] == 0){nonObstacle++;}\\n            }\\n        }\\n\\n        // call the dfs from the starting position.\\n        dfs(startX,startY,grid,0);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\u2003int ans = 0;\\n    int nonObstacle = 1;\\n    // dfs from the starting position.\\n   void dfs(int i,int j,vector<vector<int>>&grid,int count){\\n    //    base condtion.\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() ||grid[i][j] == -1){\\n        return ;\\n    }\\n    if(grid[i][j] == 2){\\n        // if we got all the nonobstacle cover.\\n       if(count == nonObstacle){\\n            ans++;\\n       }\\n       return;\\n    }\\n\\n    // make current node visited.\\n    grid[i][j] = -1;\\n\\n    // Traversal.\\n    dfs(i+1,j,grid,count+1);\\n    dfs(i-1,j,grid,count+1);\\n    dfs(i,j+1,grid,count+1);\\n    dfs(i,j-1,grid,count+1);\\n\\n\\n    // backtracking make it non-visited.\\n    grid[i][j] = 0;\\n   }\\n\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n\\n        // store the starting position.\\n        int startX = 0;\\n        int startY = 0;\\n        // find the starting location and number of non-obstacle square.\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++){\\n                // if we got the starting position.\\n                if(grid[i][j] == 1){startX = i; startY =j;}\\n                else if(grid[i][j] == 0){nonObstacle++;}\\n            }\\n        }\\n\\n        // call the dfs from the starting position.\\n        dfs(startX,startY,grid,0);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974790,
                "title": "c-and-java-solution",
                "content": "# BruteForce DFS+BackTracking Soluion\\n\\n# Java Code\\n```\\nclass Solution {\\n    private int dfs(int[][] grid, int x, int y, int zero){\\n        if(x>=grid.length || y >= grid[0].length || x<0 || y<0 || grid[x][y]==-1) return 0;\\n        if(grid[x][y]==2){\\n            return (zero==-1) ? 1 : 0;\\n        }\\n        grid[x][y]=-1;\\n        zero--;\\n        int totpath = dfs(grid, x+1, y, zero) + dfs(grid, x, y+1, zero) + dfs(grid, x-1, y, zero) + dfs(grid, x, y-1, zero);\\n        grid[x][y]=0;\\n        zero++;\\n        return totpath;\\n\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero=0, sx=0, sy=0;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j]==0)zero++;\\n                if(grid[i][j]==1){\\n                    sx=i;\\n                    sy=j;\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, int zero){\\n        if(x>=grid.size() || y >= grid[0].size() || x<0 || y<0 || grid[x][y]==-1) return 0;\\n        if(grid[x][y]==2){\\n            return (zero==-1) ? 1 : 0;\\n        }\\n        grid[x][y]=-1;\\n        zero--;\\n        int totpath = dfs(grid, x+1, y, zero) + dfs(grid, x, y+1, zero) + dfs(grid, x-1, y, zero) + dfs(grid, x, y-1, zero);\\n        grid[x][y]=0;\\n        zero++;\\n        return totpath;\\n\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zero=0, sx, sy;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]==0)zero++;\\n                if(grid[i][j]==1){\\n                    sx=i;\\n                    sy=j;\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int dfs(int[][] grid, int x, int y, int zero){\\n        if(x>=grid.length || y >= grid[0].length || x<0 || y<0 || grid[x][y]==-1) return 0;\\n        if(grid[x][y]==2){\\n            return (zero==-1) ? 1 : 0;\\n        }\\n        grid[x][y]=-1;\\n        zero--;\\n        int totpath = dfs(grid, x+1, y, zero) + dfs(grid, x, y+1, zero) + dfs(grid, x-1, y, zero) + dfs(grid, x, y-1, zero);\\n        grid[x][y]=0;\\n        zero++;\\n        return totpath;\\n\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero=0, sx=0, sy=0;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j]==0)zero++;\\n                if(grid[i][j]==1){\\n                    sx=i;\\n                    sy=j;\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, int zero){\\n        if(x>=grid.size() || y >= grid[0].size() || x<0 || y<0 || grid[x][y]==-1) return 0;\\n        if(grid[x][y]==2){\\n            return (zero==-1) ? 1 : 0;\\n        }\\n        grid[x][y]=-1;\\n        zero--;\\n        int totpath = dfs(grid, x+1, y, zero) + dfs(grid, x, y+1, zero) + dfs(grid, x-1, y, zero) + dfs(grid, x, y-1, zero);\\n        grid[x][y]=0;\\n        zero++;\\n        return totpath;\\n\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zero=0, sx, sy;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]==0)zero++;\\n                if(grid[i][j]==1){\\n                    sx=i;\\n                    sy=j;\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974419,
                "title": "100-faster-approach-backtrack-recursion-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(4^n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int zeroCount){\\n             int m=grid.size(),n=grid[0].size();\\n             if(i>=m || j>=n ||i<0 || j<0 || grid[i][j]==-1 )return 0;\\n             if(grid[i][j]==2){\\n                 return (zeroCount==-1)?1:0;\\n             }\\n            \\n            grid[i][j]=-1;\\n            zeroCount--;\\n            int totalPaths=solve(i,j+1,grid,zeroCount)+\\n            solve(i,j-1,grid,zeroCount)+\\n            solve(i+1,j,grid,zeroCount)+\\n            solve(i-1,j,grid,zeroCount);\\n            grid[i][j]=0;\\n            return totalPaths;\\n           \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int ans=0,i,j,m=grid.size(),n=grid[0].size(),zeroCount=0;\\n        int i_st,j_st;\\n        for(i=0;i<m;i++){\\n            for(j=0;j<n;j++){\\n                if(grid[i][j]==0)zeroCount++;\\n                if(grid[i][j]==1){i_st=i;j_st=j;}\\n            }\\n        }\\n        return solve(i_st,j_st,grid,zeroCount);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int zeroCount){\\n             int m=grid.size(),n=grid[0].size();\\n             if(i>=m || j>=n ||i<0 || j<0 || grid[i][j]==-1 )return 0;\\n             if(grid[i][j]==2){\\n                 return (zeroCount==-1)?1:0;\\n             }\\n            \\n            grid[i][j]=-1;\\n            zeroCount--;\\n            int totalPaths=solve(i,j+1,grid,zeroCount)+\\n            solve(i,j-1,grid,zeroCount)+\\n            solve(i+1,j,grid,zeroCount)+\\n            solve(i-1,j,grid,zeroCount);\\n            grid[i][j]=0;\\n            return totalPaths;\\n           \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int ans=0,i,j,m=grid.size(),n=grid[0].size(),zeroCount=0;\\n        int i_st,j_st;\\n        for(i=0;i<m;i++){\\n            for(j=0;j<n;j++){\\n                if(grid[i][j]==0)zeroCount++;\\n                if(grid[i][j]==1){i_st=i;j_st=j;}\\n            }\\n        }\\n        return solve(i_st,j_st,grid,zeroCount);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974129,
                "title": "100-0ms-pruning-consice-explain-proof",
                "content": "# UPVOTE PLS\\n\\n![image.png](https://assets.leetcode.com/users/images/fc731627-2269-435b-9061-204a5e14cbc5_1672467688.743408.png)\\n\\n# EXPLAINATION \\nFirst find out where the start and the end is.\\nAlso We need to know the number of empty cells.\\n\\nWe we try to explore a cell,\\nit will change 0 to -1 and do a dfs in 4 direction.\\n\\nIf we hit the target and pass all empty cells, increment the result.\\n\\n# Code\\n```\\n    int res=0,em=1,sx,sy,ex,ey,m=0,n=0;\\n    public int uniquePathsIII(int[][] G) {\\n        m=G.length;n=G[0].length;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(G[i][j]==0) em++;\\n                else if(G[i][j]==1){\\n                    sx=i; sy=j;\\n                }\\n            }\\n        dfs(G,sx,sy);\\n        return res;\\n    }\\n    private void dfs(int G[][],int x,int y){\\n        if(x<0||x>=m || y<0 || y>=n || G[x][y]<0) return;\\n        if(G[x][y]==2){\\n            if(em==0) res++;\\n            return;\\n        }\\n        G[x][y]=-1;\\n        em--;\\n        dfs(G,x+1,y); dfs(G,x-1,y); dfs(G,x,y+1); dfs(G,x,y-1); \\n        G[x][y]=0;\\n        em++;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    int res=0,em=1,sx,sy,ex,ey,m=0,n=0;\\n    public int uniquePathsIII(int[][] G) {\\n        m=G.length;n=G[0].length;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(G[i][j]==0) em++;\\n                else if(G[i][j]==1){\\n                    sx=i; sy=j;\\n                }\\n            }\\n        dfs(G,sx,sy);\\n        return res;\\n    }\\n    private void dfs(int G[][],int x,int y){\\n        if(x<0||x>=m || y<0 || y>=n || G[x][y]<0) return;\\n        if(G[x][y]==2){\\n            if(em==0) res++;\\n            return;\\n        }\\n        G[x][y]=-1;\\n        em--;\\n        dfs(G,x+1,y); dfs(G,x-1,y); dfs(G,x,y+1); dfs(G,x,y-1); \\n        G[x][y]=0;\\n        em++;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974067,
                "title": "beats-92-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        rows,cols = len(grid),len(grid[0])\\n        sr, sc, zeros = [(r, c, sum(1 for row in grid for element in row if element == 0)) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c] == 1][0]\\n        def dfs(r,c,zeros):\\n            if r not in range(rows) or c not in range(cols) or grid[r][c] == -1:\\n                return 0\\n            if grid[r][c] == 2:\\n                return 1 if zeros == -1 else 0\\n            grid[r][c] = -1\\n            zeros-=1\\n            ans = (dfs(r+1,c,zeros) + dfs(r,c+1,zeros) + dfs(r-1,c,zeros) + dfs(r,c-1,zeros))\\n            grid[r][c] = 0\\n            zeros+=1\\n            return ans\\n        return dfs(sr,sc,zeros)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        rows,cols = len(grid),len(grid[0])\\n        sr, sc, zeros = [(r, c, sum(1 for row in grid for element in row if element == 0)) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c] == 1][0]\\n        def dfs(r,c,zeros):\\n            if r not in range(rows) or c not in range(cols) or grid[r][c] == -1:\\n                return 0\\n            if grid[r][c] == 2:\\n                return 1 if zeros == -1 else 0\\n            grid[r][c] = -1\\n            zeros-=1\\n            ans = (dfs(r+1,c,zeros) + dfs(r,c+1,zeros) + dfs(r-1,c,zeros) + dfs(r,c-1,zeros))\\n            grid[r][c] = 0\\n            zeros+=1\\n            return ans\\n        return dfs(sr,sc,zeros)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974016,
                "title": "easy-standard-c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int row,int col,int steps,vector<vector<int>>&grid,int totStepsCnt)\\n    {\\n        \\n        if(grid[row][col]==2 ) \\n        {\\n            return steps==totStepsCnt;\\n        }\\n        \\n        int orig=grid[row][col];\\n        grid[row][col]=-1;\\n        \\n        int dr[]={-1,0,+1,0};\\n        int dc[]={0,+1,0,-1};\\n        int paths=0;\\n        for(int i=0;i<4;i++)\\n        {\\n                int nrow=row+dr[i];\\n                int ncol=col+dc[i];\\n                \\n                if(nrow<grid.size() && ncol<grid[0].size() && grid[nrow][ncol]!=-1)\\n                {\\n                    paths+=f(nrow,ncol,steps+1,grid,totStepsCnt);    \\n                }\\n        }\\n        \\n        grid[row][col]=orig;\\n            \\n        return paths;\\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int i,j;//start point\\n        int stepCnt=0;\\n        for(int row=0;row<grid.size();row++)\\n        {\\n            for(int col=0;col<grid[0].size();col++)\\n            {\\n                if(grid[row][col]==1)\\n                {\\n                    i=row;\\n                    j=col;\\n                }\\n                if(grid[row][col]!=-1) stepCnt++;\\n            }\\n        }\\n        \\n        \\n        return f(i,j,1,grid,stepCnt);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int row,int col,int steps,vector<vector<int>>&grid,int totStepsCnt)\\n    {\\n        \\n        if(grid[row][col]==2 ) \\n        {\\n            return steps==totStepsCnt;\\n        }\\n        \\n        int orig=grid[row][col];\\n        grid[row][col]=-1;\\n        \\n        int dr[]={-1,0,+1,0};\\n        int dc[]={0,+1,0,-1};\\n        int paths=0;\\n        for(int i=0;i<4;i++)\\n        {\\n                int nrow=row+dr[i];\\n                int ncol=col+dc[i];\\n                \\n                if(nrow<grid.size() && ncol<grid[0].size() && grid[nrow][ncol]!=-1)\\n                {\\n                    paths+=f(nrow,ncol,steps+1,grid,totStepsCnt);    \\n                }\\n        }\\n        \\n        grid[row][col]=orig;\\n            \\n        return paths;\\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int i,j;//start point\\n        int stepCnt=0;\\n        for(int row=0;row<grid.size();row++)\\n        {\\n            for(int col=0;col<grid[0].size();col++)\\n            {\\n                if(grid[row][col]==1)\\n                {\\n                    i=row;\\n                    j=col;\\n                }\\n                if(grid[row][col]!=-1) stepCnt++;\\n            }\\n        }\\n        \\n        \\n        return f(i,j,1,grid,stepCnt);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973564,
                "title": "easy-to-understand-backtracking-dfs",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/backtracking/UniquePathsIII.java",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2973353,
                "title": "c-simple-dfs-easy-to-understand-100-accepted",
                "content": "# Complexity\\n- ***Time Complexity*** : **O(3^m * n)** At every cell (except the start cell), we can continue the path exploration in 3 direction (after excuding previous visited cell) and there can be O(m*n) cells in total to be visited.\\n\\n- ***Space Complexity*** : **O(m*n)** required for implicit recursive stack in dfs.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m, n, startx, starty, endx, endy, viscount = 0, ans = 0;\\n    vector<int> dirx = {1, 0, -1, 0}, diry = {0, 1, 0, -1};\\n    vector<vector<bool>> visited;\\n\\n    void dfs(int x, int y) {\\n        if (x == endx and y == endy) {\\n            if (viscount == m * n - 1) ans++;\\n            return;\\n        }\\n        viscount++;\\n        visited[y][x] = true;\\n        for (int i = 0; i < 4; i++) {\\n            int newx = x + dirx[i], newy = y + diry[i];\\n            if ((newx < 0 or newx >= n) or (newy < 0 or newy >= m)) \\n            continue;\\n            if (not visited[newy][newx]) \\n            dfs(newx, newy);\\n        }\\n        viscount--;\\n        visited[y][x] = false;\\n        return;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        visited.resize(m, vector<bool>(n));\\n        for (int y = 0; y < m; y++) {\\n            for (int x = 0; x < n; x++) {\\n                if (grid[y][x] == -1) {\\n                    viscount++;\\n                    visited[y][x] = true;\\n                }\\n                else if (grid[y][x] == 1) {\\n                    startx = x;\\n                    starty = y;\\n                }\\n                else if (grid[y][x] == 2) {\\n                    endx = x;\\n                    endy = y;\\n                }\\n            }\\n        }\\n        dfs(startx, starty);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n, startx, starty, endx, endy, viscount = 0, ans = 0;\\n    vector<int> dirx = {1, 0, -1, 0}, diry = {0, 1, 0, -1};\\n    vector<vector<bool>> visited;\\n\\n    void dfs(int x, int y) {\\n        if (x == endx and y == endy) {\\n            if (viscount == m * n - 1) ans++;\\n            return;\\n        }\\n        viscount++;\\n        visited[y][x] = true;\\n        for (int i = 0; i < 4; i++) {\\n            int newx = x + dirx[i], newy = y + diry[i];\\n            if ((newx < 0 or newx >= n) or (newy < 0 or newy >= m)) \\n            continue;\\n            if (not visited[newy][newx]) \\n            dfs(newx, newy);\\n        }\\n        viscount--;\\n        visited[y][x] = false;\\n        return;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        visited.resize(m, vector<bool>(n));\\n        for (int y = 0; y < m; y++) {\\n            for (int x = 0; x < n; x++) {\\n                if (grid[y][x] == -1) {\\n                    viscount++;\\n                    visited[y][x] = true;\\n                }\\n                else if (grid[y][x] == 1) {\\n                    startx = x;\\n                    starty = y;\\n                }\\n                else if (grid[y][x] == 2) {\\n                    endx = x;\\n                    endy = y;\\n                }\\n            }\\n        }\\n        dfs(startx, starty);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940184,
                "title": "easy-backtracking-recursive-solution-0ms-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int zeroes = 1;\\n    int totalPath = 0;\\n\\n    void dfs(int[][] grid, int x, int y){\\n\\n        if(x<0 || x>=grid.length || y<0 || y>= grid[0].length || grid[x][y] <0)\\n            return;\\n        \\n        if(grid[x][y] == 2){\\n            if(zeroes == 0) totalPath++;\\n            return;\\n        }\\n        grid[x][y] = -2;\\n        zeroes--;\\n\\n        dfs(grid, x+1, y);\\n        dfs(grid, x-1, y);\\n        dfs(grid, x, y+1);\\n        dfs(grid, x, y-1);\\n        grid[x][y] = 0;\\n        zeroes++;\\n    }\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        int sr = 0, sc = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 0)\\n                    zeroes++;\\n                else if(grid[i][j] == 1){\\n                    sr = i;\\n                    sc = j;\\n                }\\n            }\\n        }\\n        dfs(grid, sr, sc);\\n        return totalPath;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int zeroes = 1;\\n    int totalPath = 0;\\n\\n    void dfs(int[][] grid, int x, int y){\\n\\n        if(x<0 || x>=grid.length || y<0 || y>= grid[0].length || grid[x][y] <0)\\n            return;\\n        \\n        if(grid[x][y] == 2){\\n            if(zeroes == 0) totalPath++;\\n            return;\\n        }\\n        grid[x][y] = -2;\\n        zeroes--;\\n\\n        dfs(grid, x+1, y);\\n        dfs(grid, x-1, y);\\n        dfs(grid, x, y+1);\\n        dfs(grid, x, y-1);\\n        grid[x][y] = 0;\\n        zeroes++;\\n    }\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        int sr = 0, sc = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 0)\\n                    zeroes++;\\n                else if(grid[i][j] == 1){\\n                    sr = i;\\n                    sc = j;\\n                }\\n            }\\n        }\\n        dfs(grid, sr, sc);\\n        return totalPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865796,
                "title": "9ms-easy-understand-dfs-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<vector<int>> &g, int i, int j, int s, int t_s)\\n    {\\n        if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1)\\n            return 0;\\n        if (g[i][j] == 2)\\n            return s == t_s ? 1 : 0;\\n        g[i][j] = -1;\\n        int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n                    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n        g[i][j] = 0;\\n        return paths;\\n    }\\n    int uniquePathsIII(vector<vector<int>> &g)\\n    {\\n        auto i1 = 0, j1 = 0, t_steps = 0;\\n        for (auto i = 0; i < g.size(); ++i)\\n            for (auto j = 0; j < g[0].size(); ++j)\\n            {\\n                if (g[i][j] == 1)\\n                    i1 = i, j1 = j;\\n                if (g[i][j] != -1)\\n                    ++t_steps;\\n            }\\n        return dfs(g, i1, j1, 1, t_steps);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<vector<int>> &g, int i, int j, int s, int t_s)\\n    {\\n        if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1)\\n            return 0;\\n        if (g[i][j] == 2)\\n            return s == t_s ? 1 : 0;\\n        g[i][j] = -1;\\n        int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n                    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n        g[i][j] = 0;\\n        return paths;\\n    }\\n    int uniquePathsIII(vector<vector<int>> &g)\\n    {\\n        auto i1 = 0, j1 = 0, t_steps = 0;\\n        for (auto i = 0; i < g.size(); ++i)\\n            for (auto j = 0; j < g[0].size(); ++j)\\n            {\\n                if (g[i][j] == 1)\\n                    i1 = i, j1 = j;\\n                if (g[i][j] != -1)\\n                    ++t_steps;\\n            }\\n        return dfs(g, i1, j1, 1, t_steps);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775551,
                "title": "python-easy-solution-dfs-backtracking",
                "content": "# Intuition\\nThis is a Game !! \\uD83E\\uDD16\\nIn simpler words, we need to find the count of possible paths for a robot to reach from starting to ending point without encountering a obstacle.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst of all, lets calculate the starting position, ending position and total number of empty cells present in the grid. And using Depth First Search (DFS) algorithm and Backtracking, we can check the possible paths having no obstacles and add find the valid path using visited set. If a valid path is found, then increment the output.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N\\xB2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n\\n        start_row,start_col,end_row,end_col = 0,0,0,0\\n        empty_cells = 0\\n\\n        # Traversing the grid to find the start and end index\\n        for i in range(0,rows):\\n            for j in range(0,cols):\\n                if (grid[i][j] == 1):\\n                    start_row,start_col = i,j\\n                elif (grid[i][j] == 2):\\n                    end_row,end_col = i,j\\n                elif (grid[i][j] == 0):\\n                    empty_cells += 1\\n        \\n        self.output = 0\\n        visited = set()\\n\\n        def dfs(r,c,visited,walk):\\n            if (r == end_row and c == end_col):\\n                if (walk == empty_cells+1):\\n                    self.output += 1  # Path found\\n                return\\n\\n            if (0<= r < rows and 0<= c < cols and grid[r][c] != -1 and (r,c) not in visited):\\n                visited.add((r,c))\\n                for i,j in [(0,-1),(0,1),(1,0),(-1,0)]:\\n                    dfs(r+i,c+j,visited,walk+1)\\n                visited.remove((r,c))\\n            \\n        dfs(start_row,start_col,visited,0)\\n\\n        return self.output\\n```\\n# Result\\n- Runtime: 150 ms beats 35%\\n- Memory: 14 MB beats 58%\\n\\n![image.png](https://assets.leetcode.com/users/images/6016c7e7-9769-45f0-9bb5-c98493be8fec_1667526533.989835.png)\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n\\n        start_row,start_col,end_row,end_col = 0,0,0,0\\n        empty_cells = 0\\n\\n        # Traversing the grid to find the start and end index\\n        for i in range(0,rows):\\n            for j in range(0,cols):\\n                if (grid[i][j] == 1):\\n                    start_row,start_col = i,j\\n                elif (grid[i][j] == 2):\\n                    end_row,end_col = i,j\\n                elif (grid[i][j] == 0):\\n                    empty_cells += 1\\n        \\n        self.output = 0\\n        visited = set()\\n\\n        def dfs(r,c,visited,walk):\\n            if (r == end_row and c == end_col):\\n                if (walk == empty_cells+1):\\n                    self.output += 1  # Path found\\n                return\\n\\n            if (0<= r < rows and 0<= c < cols and grid[r][c] != -1 and (r,c) not in visited):\\n                visited.add((r,c))\\n                for i,j in [(0,-1),(0,1),(1,0),(-1,0)]:\\n                    dfs(r+i,c+j,visited,walk+1)\\n                visited.remove((r,c))\\n            \\n        dfs(start_row,start_col,visited,0)\\n\\n        return self.output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638005,
                "title": "c-python-backtracking-dfs",
                "content": "# C++\\n```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int e, int &ans) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == -1) return;\\n        if(grid[i][j] == 2) {\\n            if(!e) ans++;\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;\\n        dfs(i + 1, j, grid, e - 1, ans);\\n        dfs(i - 1, j, grid, e - 1, ans);\\n        dfs(i, j + 1, grid, e - 1, ans);\\n        dfs(i, j - 1, grid, e - 1, ans);\\n        grid[i][j] = 0;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int e = 0, x, y, ans = 0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                if(grid[i][j] == 1) x = i, y = j;\\n                else if(grid[i][j] == 0) e++;\\n            }\\n        }\\n        \\n        dfs(x, y, grid, e + 1, ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def uniquePathsIII(self, grid):\\n        e, x, y = 0, 0, 0\\n        self.ans = 0\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1: x, y = i, j\\n                elif not grid[i][j]: e += 1\\n        \\n        def dfs(i, j, e):\\n            if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]) or grid[i][j] == -1: return\\n            if grid[i][j] == 2:\\n                if not e: self.ans += 1\\n                return\\n            \\n            grid[i][j] = -1\\n            dfs(i + 1, j, e - 1)\\n            dfs(i - 1, j, e - 1)\\n            dfs(i, j + 1, e - 1)\\n            dfs(i, j - 1, e - 1)\\n            grid[i][j] = 0\\n        \\n        dfs(x, y, e + 1)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int e, int &ans) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == -1) return;\\n        if(grid[i][j] == 2) {\\n            if(!e) ans++;\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;\\n        dfs(i + 1, j, grid, e - 1, ans);\\n        dfs(i - 1, j, grid, e - 1, ans);\\n        dfs(i, j + 1, grid, e - 1, ans);\\n        dfs(i, j - 1, grid, e - 1, ans);\\n        grid[i][j] = 0;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int e = 0, x, y, ans = 0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                if(grid[i][j] == 1) x = i, y = j;\\n                else if(grid[i][j] == 0) e++;\\n            }\\n        }\\n        \\n        dfs(x, y, grid, e + 1, ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def uniquePathsIII(self, grid):\\n        e, x, y = 0, 0, 0\\n        self.ans = 0\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1: x, y = i, j\\n                elif not grid[i][j]: e += 1\\n        \\n        def dfs(i, j, e):\\n            if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]) or grid[i][j] == -1: return\\n            if grid[i][j] == 2:\\n                if not e: self.ans += 1\\n                return\\n            \\n            grid[i][j] = -1\\n            dfs(i + 1, j, e - 1)\\n            dfs(i - 1, j, e - 1)\\n            dfs(i, j + 1, e - 1)\\n            dfs(i, j - 1, e - 1)\\n            grid[i][j] = 0\\n        \\n        dfs(x, y, e + 1)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522134,
                "title": "java-backtracking-recursion-1ms",
                "content": "class Solution {\\n    \\n    \\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int count  = 0,xpos = 0, ypos = 0 ;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(grid[i][j] == 0){\\n                    count++;\\n                }\\n                else if(grid[i][j] == 1){\\n                    xpos = i;\\n                    ypos = j;\\n                }\\n            }\\n        }\\n        \\n        return helper(grid , xpos , ypos ,n , m, count);\\n    }\\n    \\n    public int helper(int[][]grid , int i , int j ,int n , int m, int count){\\n        \\n        if(i < 0 || i>=n || j<0 || j>=m || grid[i][j] == -1){\\n            return 0;\\n        }\\n        \\n        if(grid[i][j] == 2)return count == -1? 1 : 0;\\n        \\n        grid[i][j] = -1;\\n        count--;\\n        \\n        int top = helper(grid , i-1, j ,n , m , count);\\n        int down = helper(grid , i+1, j ,n , m , count);\\n        int left = helper(grid , i, j-1 ,n , m , count);\\n        int right = helper(grid , i, j+1 ,n , m , count);\\n        \\n        grid[i][j] = 0;\\n        \\n        return top+down+left+right;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    \\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int count  = 0,xpos = 0, ypos = 0 ;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(grid[i][j] == 0){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2476820,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int ie,je,m,n;\\n    \\n    int func(int i,int j,vector<vector<int>>&grid, vector<vector<int>>&vis,int t){\\n        if(i<0 || j<0 || i>=m || j>=n || grid[i][j]==-1 || vis[i][j])return 0;\\n        \\n        if(i==ie && j==je){\\n            return t==0;\\n        }\\n        \\n        vis[i][j]=1;\\n        \\n        int a=0;\\n        a=func(i+1,j,grid,vis,t-1)+func(i-1,j,grid,vis,t-1)+func(i,j+1,grid,vis,t-1)+func(i,j-1,grid,vis,t-1);\\n        \\n        vis[i][j]=0;\\n        return a;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        m=grid.size(),n=grid[0].size();\\n        \\n        int is,js,t=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){\\n                    ie=i;\\n                    je=j;\\n                }\\n                \\n                if(grid[i][j]==1){\\n                    is=i;\\n                    js=j;\\n                }\\n                \\n                if(grid[i][j]==0)t++;\\n            }\\n        }\\n        \\n        vector<vector<int>>vis(m,vector<int>(n));\\n        return func(is,js,grid,vis,t+1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int ie,je,m,n;\\n    \\n    int func(int i,int j,vector<vector<int>>&grid, vector<vector<int>>&vis,int t){\\n        if(i<0 || j<0 || i>=m || j>=n || grid[i][j]==-1 || vis[i][j])return 0;\\n        \\n        if(i==ie && j==je){\\n            return t==0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2425851,
                "title": "c-easiest-solution-faster-than-100-dfs-and-backtracking-0ms-with-comments",
                "content": "```\\nclass Solution {\\n    \\n      int startrow = 0, startcol = 0, count = 0, ans  = 0;\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, int i , int j , int cellvisited)\\n    {\\n        if(i<0 || j<0 || i>= grid.size() || j>= grid[0].size() || grid[i][j] == -1 )\\n            return ;\\n        \\n        // If You Have come to ending Position \\n        if(grid[i][j] == 2 )\\n        {\\n            if(cellvisited == count)\\n                ans++;\\n            return ;\\n        }\\n        // Marking The Cell as Visited\\n        grid[i][j] = -1;\\n        \\n        // DFS Traversal in all possible direction\\n        dfs(grid, i+1 , j , cellvisited+1);\\n        dfs(grid, i-1 , j , cellvisited+1);\\n        dfs(grid, i , j+1 , cellvisited+1);\\n        dfs(grid, i , j-1 , cellvisited+1);\\n        \\n        // Backtracking\\n        grid[i][j] = 0;\\n    }\\n  \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n      // Storing Starting Position, Ending Position and count of empty cell \\n        for(int i = 0 ; i<grid.size() ; i++)\\n        {\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    startrow = i, startcol = j;\\n                else if(grid[i][j] == 0)\\n                    count++;\\n            }\\n        }\\n        \\n        //This is for starting cell\\n        count++;\\n        \\n        // Making Variable to store the count of visited cell in dfs traversal\\n        int cellvisited = 0;\\n        //Start\\n        dfs(grid, startrow, startcol, cellvisited);\\n        return ans;\\n    }\\n};\\n\\n//Pls upvote If you Like It\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b7a72cac-101f-4bc1-b31c-7f99eb9fb33b_1660502121.285097.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n      int startrow = 0, startcol = 0, count = 0, ans  = 0;\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, int i , int j , int cellvisited)\\n    {\\n        if(i<0 || j<0 || i>= grid.size() || j>= grid[0].size() || grid[i][j] == -1 )\\n            return ;\\n        \\n        // If You Have come to ending Position \\n        if(grid[i][j] == 2 )\\n        {\\n            if(cellvisited == count)\\n                ans++;\\n            return ;\\n        }\\n        // Marking The Cell as Visited\\n        grid[i][j] = -1;\\n        \\n        // DFS Traversal in all possible direction\\n        dfs(grid, i+1 , j , cellvisited+1);\\n        dfs(grid, i-1 , j , cellvisited+1);\\n        dfs(grid, i , j+1 , cellvisited+1);\\n        dfs(grid, i , j-1 , cellvisited+1);\\n        \\n        // Backtracking\\n        grid[i][j] = 0;\\n    }\\n  \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n      // Storing Starting Position, Ending Position and count of empty cell \\n        for(int i = 0 ; i<grid.size() ; i++)\\n        {\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    startrow = i, startcol = j;\\n                else if(grid[i][j] == 0)\\n                    count++;\\n            }\\n        }\\n        \\n        //This is for starting cell\\n        count++;\\n        \\n        // Making Variable to store the count of visited cell in dfs traversal\\n        int cellvisited = 0;\\n        //Start\\n        dfs(grid, startrow, startcol, cellvisited);\\n        return ans;\\n    }\\n};\\n\\n//Pls upvote If you Like It\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420674,
                "title": "easy-and-naive-approach-c",
                "content": "Here, we have checked the all paths which lead us to result.\\n\\n\\n//THIS IS MY FIRST POST\\n\\nExplaination is given below with code \\n///\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void helper(vector<vector<int>>&grid,int ri,int ci,int rd,int cd,string asf,int count,vector<vector<bool>> &check)\\n    {\\n        if(ri < 0 || ci < 0 || ri >= rd || ci >= cd || grid[ri][ci] == -1 || check[ri][ci] == true)  // boundary condition\\n            return;\\n        if(grid[ri][ci] == 2)\\n        {\\n            if(asf.size() == count) // if count is equal to path size the increment ans\\n            {\\n                ans++;\\n            }  \\n            return;\\n        }\\n        check[ri][ci] = true;\\n        helper(grid,ri+1,ci,rd,cd,asf + \"D\",count,check);\\n        helper(grid,ri-1,ci,rd,cd,asf + \"U\",count,check);\\n        helper(grid,ri,ci+1,rd,cd,asf + \"R\",count,check);\\n        helper(grid,ri,ci-1,rd,cd,asf + \"L\",count,check);\\n        check[ri][ci] = false;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int count = 0;    //To count the number of blocks to be covered\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ri=0,ci=0;       // To get the starting index of the block \\n        \\n        vector<vector<bool>> check(m,vector<bool>(n,false));   // To check if we have visited that block on the grid  \\n        for(auto i = 0 ; i< m ; i++)\\n        {\\n            for(auto j = 0 ; j<n;j++)\\n            {\\n                if(grid[i][j] == 0)\\n                    count++;\\n                if(grid[i][j] == 1)\\n                {\\n                    ri = i;\\n                    ci = j;\\n                }\\n            }\\n        }\\n         helper(grid,ri,ci,m,n,\"\",count+1,check);     // Giving call with count +1 , where +1 is done because\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //we have to consider the destination block too\\n         return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void helper(vector<vector<int>>&grid,int ri,int ci,int rd,int cd,string asf,int count,vector<vector<bool>> &check)\\n    {\\n        if(ri < 0 || ci < 0 || ri >= rd || ci >= cd || grid[ri][ci] == -1 || check[ri][ci] == true)  // boundary condition\\n            return;\\n        if(grid[ri][ci] == 2)\\n        {\\n            if(asf.size() == count) // if count is equal to path size the increment ans\\n            {\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2409680,
                "title": "faster-than-100-00-of-c-online-submissions",
                "content": "int solve(vector<vector<int>>& arr,int i,int j,int &n,int &m,int k){\\n    if (i<0 || j<0 || i==n || j==m || arr[i][j]==-1)\\n    {\\n       return 0;\\n    }\\n    if (arr[i][j]==2)\\n    {\\n        if (k==0)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n       int x=arr[i][j];\\n    arr[i][j]=-1;\\n    int ans=solve(arr,i-1,j,n,m,k-1);\\n        ans+=solve(arr,i,j+1,n,m,k-1);\\n       ans+=solve(arr,i,j-1,n,m,k-1);\\n    ans+=solve(arr,i+1,j,n,m,k-1);\\n    arr[i][j]=x;\\n   \\n    return ans;\\n    \\n    \\n    \\n}\\n int uniquePathsIII(vector<vector<int>>& arr) {\\n        int k=0,x=-1,y=-1;\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (arr[i][j]==0)\\n                {\\n                    k++;\\n                }\\n                if (arr[i][j]==1)\\n                {\\n                    x=i,y=j;\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        return solve(arr,x,y,n,m,k+1);\\n\\n        \\n    }",
                "solutionTags": [],
                "code": "int solve(vector<vector<int>>& arr,int i,int j,int &n,int &m,int k){\\n    if (i<0 || j<0 || i==n || j==m || arr[i][j]==-1)\\n    {\\n       return 0;\\n    }\\n    if (arr[i][j]==2)\\n    {\\n        if (k==0)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n       int x=arr[i][j];\\n    arr[i][j]=-1;\\n    int ans=solve(arr,i-1,j,n,m,k-1);\\n        ans+=solve(arr,i,j+1,n,m,k-1);\\n       ans+=solve(arr,i,j-1,n,m,k-1);\\n    ans+=solve(arr,i+1,j,n,m,k-1);\\n    arr[i][j]=x;\\n   \\n    return ans;\\n    \\n    \\n    \\n}\\n int uniquePathsIII(vector<vector<int>>& arr) {\\n        int k=0,x=-1,y=-1;\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (arr[i][j]==0)\\n                {\\n                    k++;\\n                }\\n                if (arr[i][j]==1)\\n                {\\n                    x=i,y=j;\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        return solve(arr,x,y,n,m,k+1);\\n\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2159888,
                "title": "java-solution-using-backtracking",
                "content": "First find starting position and no of 0 positions . Now backtrack through every position and if you find 2 and count also becomes equal then increment answer.\\n```\\nclass Solution {\\n    int ans=0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int r=-1;\\n        int c=-1;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    r=i;\\n                    c=j;\\n                }\\n                if(grid[i][j]==0)count++;\\n            }\\n        }\\n        findPath(grid,r,c,n,m,count,0);\\n        return ans;\\n        \\n    }\\n    void findPath(int[][]grid,int row,int col,int n,int m,int count,int k){\\n        if(row<0||row>=n||col<0||col>=m||grid[row][col]==-1)return;\\n        if(grid[row][col]==2){\\n            if(count==k)\\n            ans++;\\n            return;\\n        }\\n        grid[row][col]=-1;\\n        findPath(grid,row+1,col,n,m,count,k+1);\\n        findPath(grid,row-1,col,n,m,count,k+1);\\n        findPath(grid,row,col+1,n,m,count,k+1);\\n        findPath(grid,row,col-1,n,m,count,k+1);\\n        grid[row][col]=0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int r=-1;\\n        int c=-1;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    r=i;\\n                    c=j;\\n                }\\n                if(grid[i][j]==0)count++;\\n            }\\n        }\\n        findPath(grid,r,c,n,m,count,0);\\n        return ans;\\n        \\n    }\\n    void findPath(int[][]grid,int row,int col,int n,int m,int count,int k){\\n        if(row<0||row>=n||col<0||col>=m||grid[row][col]==-1)return;\\n        if(grid[row][col]==2){\\n            if(count==k)\\n            ans++;\\n            return;\\n        }\\n        grid[row][col]=-1;\\n        findPath(grid,row+1,col,n,m,count,k+1);\\n        findPath(grid,row-1,col,n,m,count,k+1);\\n        findPath(grid,row,col+1,n,m,count,k+1);\\n        findPath(grid,row,col-1,n,m,count,k+1);\\n        grid[row][col]=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157068,
                "title": "java-detailed-explanation-of-backtracking-approach",
                "content": "## Problem\\n\\nGiven a grid containing a starting point, and ending point, and obstacles, return the number of ways to get from the starting point to the ending point visiting all squares in the grid once, and avoiding all obstacles. \\n\\n## Backtracking Approach\\n\\nThe best way to approach this problem is by using a DFS with backtracking. In order to perform the DFS, we need to know where to start, and how many empty cells there are in the board. The reason we need this is because when our DFS reaches the ending point, the path we have found is only valid if we have visited all open cells before we reached the end cell, so if we know how many open cells there are, we can tell if a path is valid. So before we call the recursive method, we go through `grid`, find the starting position, and count the number of open cells. After we have done so, we make the initial recursive call.\\n\\nOur DFS takes in 4 parameters: `row` and `col` being the row and column respectively of our current cell in `grid`, the grid `grid`, and an integer `count` being the number of cells that we have found in our path. \\n\\nIn this DFS, to avoid having to use an external array to mark visited cells, we can use `grid` itself. Plus, since we are backtracking and we have to unmark visited cells, after all the recursive calls are done, `grid` will be left unchanged. How we can use `grid` to mark visited cells is if we run into an open cell (i.e. a `0`), we change its value to `-1`. This essentially puts an obstacle at this cell so in later recursive calls, we can not revisit this cell. \\n\\nThe base case of our DFS occurs when either `[row][col]` is outside the grid, or `grid[row][col]` is an obstacle (i.e. `-1`). Since we used `-1` to mark visited cells, seeing if the cell has been visited is the same thing as checking if there is an obstacle there. In any of these cases, we can not continue our DFS, so we return to the previous recursive call. The other of bases case we need to check is if we have reached the ending point (`grid[row][col] = 2`). At this point, we check if `count` is equal to the number of open cells, if so, then we have found a valid path, so we increment a counter variable (say `numPaths`), if not, we do nothing.\\n\\n If none of these base cases are met, we mark `[row][col]` as visited by setting its value to `-1`, then call DFS on all 4 directions, passing in `count + 1` since we have found a new cell. Once these recursive calls come back, we unmark cell `[row][col]` by setting its value to `0` (i.e. removing the obstacle we put there), then return to the previous recursive call. In the end, `numPaths` will have the total number of valid paths from our starting point to the end point. \\n\\n## Code\\n\\n**Java**\\n\\n```java\\nclass Solution {\\n    int m; //number of rows in grid\\n    int n; //number of columns in grid\\n    int openSquares; //number of open cells in grid\\n    int numPaths; //number of valid paths from the starting point to the ending point\\n    public int uniquePathsIII(int[][] grid) {\\n        int startRow = 0;\\n        int startCol = 0;\\n        int count = 0;\\n        \\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        //find the starting point and count the number of open cells\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){ //found the starting point, which is also an open cell\\n                    startRow = i;\\n                    startCol = j;\\n                    openSquares++;\\n                }else if(grid[i][j] == 0){ //found an open cell\\n                    openSquares++;\\n                }        \\n            }\\n        }\\n        //note: the reason we do not consider the end point as an open cell is because we terminate our \\n        //      search at that point and don\\'t increase our counter\\n        \\n        dfs(startRow, startCol, grid, 0);\\n        return numPaths;\\n    }\\n    \\n    private void dfs(int row, int col, int[][] grid, int count){\\n        //base case --> if [row][col] is outside of grid, is an obstacle cell or has been visited\\n        //              (means the same as an obstacle), we stop our DFS and return to the previous recursive call\\n        if(row < 0 || row > m-1 || col < 0 || col > n-1 || grid[row][col] == -1){\\n            return;\\n        }\\n        \\n        //base case --> if we reached our endpoint, and we have visited all open cells, we increment numPaths before\\n        //              returning, otherwise, we just return since the path was invalid\\n        if(grid[row][col] == 2){\\n            if(count == openSquares){\\n                numPaths++;\\n            }\\n            return;\\n        }\\n        \\n        //mark the current cell as visited by essentially placing an obstacle there\\n        grid[row][col] = -1;\\n        \\n        //call the dfs on all 4 adjacent cells, passing in count + 1 since we visited a new cell\\n        dfs(row-1, col, grid, count + 1);\\n        dfs(row+1, col, grid, count + 1);\\n        dfs(row, col-1, grid, count + 1);\\n        dfs(row, col+1, grid, count + 1);\\n        \\n        //unmark the current cell by essentially removing the obstacle\\n        grid[row][col] = 0;\\n    }\\n}\\n```\\n\\n## Time and Space Complexity\\n\\nTime Complexity: `O(3^(mn))`\\n\\nWe will be making 3 recursive calls at each cell (recursive call for the direction we came from will lead to a base case), of which there are `mn` of them\\n\\nSpace Complexity: `O(mn)`\\n\\nSince we are not using any external data structures, our space complexity is the max depth of the recursion tree (i.e. `mn`)\\n  \\n    \\n\\t\\n**Please Upvote** if you find this helpful!!",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    int m; //number of rows in grid\\n    int n; //number of columns in grid\\n    int openSquares; //number of open cells in grid\\n    int numPaths; //number of valid paths from the starting point to the ending point\\n    public int uniquePathsIII(int[][] grid) {\\n        int startRow = 0;\\n        int startCol = 0;\\n        int count = 0;\\n        \\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        //find the starting point and count the number of open cells\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){ //found the starting point, which is also an open cell\\n                    startRow = i;\\n                    startCol = j;\\n                    openSquares++;\\n                }else if(grid[i][j] == 0){ //found an open cell\\n                    openSquares++;\\n                }        \\n            }\\n        }\\n        //note: the reason we do not consider the end point as an open cell is because we terminate our \\n        //      search at that point and don\\'t increase our counter\\n        \\n        dfs(startRow, startCol, grid, 0);\\n        return numPaths;\\n    }\\n    \\n    private void dfs(int row, int col, int[][] grid, int count){\\n        //base case --> if [row][col] is outside of grid, is an obstacle cell or has been visited\\n        //              (means the same as an obstacle), we stop our DFS and return to the previous recursive call\\n        if(row < 0 || row > m-1 || col < 0 || col > n-1 || grid[row][col] == -1){\\n            return;\\n        }\\n        \\n        //base case --> if we reached our endpoint, and we have visited all open cells, we increment numPaths before\\n        //              returning, otherwise, we just return since the path was invalid\\n        if(grid[row][col] == 2){\\n            if(count == openSquares){\\n                numPaths++;\\n            }\\n            return;\\n        }\\n        \\n        //mark the current cell as visited by essentially placing an obstacle there\\n        grid[row][col] = -1;\\n        \\n        //call the dfs on all 4 adjacent cells, passing in count + 1 since we visited a new cell\\n        dfs(row-1, col, grid, count + 1);\\n        dfs(row+1, col, grid, count + 1);\\n        dfs(row, col-1, grid, count + 1);\\n        dfs(row, col+1, grid, count + 1);\\n        \\n        //unmark the current cell by essentially removing the obstacle\\n        grid[row][col] = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150439,
                "title": "simple-golang-solution-with-backtracking-beats-100",
                "content": "```\\nfunc uniquePathsIII(grid [][]int) int {\\n    \\n    remaining := 0\\n    startX := 0 \\n    startY := 0 \\n    \\n    for i:=0 ; i<len(grid); i++ {\\n        for j:=0 ; j<len(grid[i]); j++ {\\n            if grid[i][j] == 0 {\\n                remaining += 1\\n            } else if grid[i][j] == 1 {\\n                startX = i\\n                startY = j\\n            }\\n        }\\n    }\\n    \\n\\n    \\n    return uniquePathHelper(grid, remaining, startX, startY)\\n    \\n}\\n\\nfunc uniquePathHelper(grid [][]int, remaining, i, j int) int {\\n    result := 0\\n    \\n    // value being -1 is obstacle or visited and 1 being the starting square\\n    if i<0 || i == len(grid) || j <0 || j == len(grid[i]) || grid[i][j] == -1 {\\n                \\n        return 0\\n                \\n        } else if grid[i][j] == 0 || grid[i][j] == 1 {\\n                \\n            grid[i][j] = -1\\n\\n                result = uniquePathHelper(grid, remaining-1, i-1, j) + \\n                        uniquePathHelper(grid, remaining-1, i+1, j) +\\n                        uniquePathHelper(grid, remaining-1, i, j+1) +\\n                        uniquePathHelper(grid, remaining-1, i, j-1)\\n\\n            grid[i][j] = 0\\n                \\n            // the remaining is less than 0 because all the 0 cells are covered\\n            } else if grid[i][j] == 2 && remaining < 0 {\\n                \\n                return 1\\n            } \\n    \\n    return result\\n}",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc uniquePathsIII(grid [][]int) int {\\n    \\n    remaining := 0\\n    startX := 0 \\n    startY := 0 \\n    \\n    for i:=0 ; i<len(grid); i++ {\\n        for j:=0 ; j<len(grid[i]); j++ {\\n            if grid[i][j] == 0 {\\n                remaining += 1\\n            } else if grid[i][j] == 1 {\\n                startX = i\\n                startY = j\\n            }\\n        }\\n    }\\n    \\n\\n    \\n    return uniquePathHelper(grid, remaining, startX, startY)\\n    \\n}\\n\\nfunc uniquePathHelper(grid [][]int, remaining, i, j int) int {\\n    result := 0\\n    \\n    // value being -1 is obstacle or visited and 1 being the starting square\\n    if i<0 || i == len(grid) || j <0 || j == len(grid[i]) || grid[i][j] == -1 {\\n                \\n        return 0\\n                \\n        } else if grid[i][j] == 0 || grid[i][j] == 1 {\\n                \\n            grid[i][j] = -1\\n\\n                result = uniquePathHelper(grid, remaining-1, i-1, j) + \\n                        uniquePathHelper(grid, remaining-1, i+1, j) +\\n                        uniquePathHelper(grid, remaining-1, i, j+1) +\\n                        uniquePathHelper(grid, remaining-1, i, j-1)\\n\\n            grid[i][j] = 0\\n                \\n            // the remaining is less than 0 because all the 0 cells are covered\\n            } else if grid[i][j] == 2 && remaining < 0 {\\n                \\n                return 1\\n            } \\n    \\n    return result\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2132372,
                "title": "c-simple-and-clean-bfs-solution-code",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans;\\n\\tvoid pass(vector<vector<int>> &grid, int i, int j, int n, int m, int step)\\n\\t{\\n\\t\\t//Base Condition\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == -1)\\n\\t\\t\\treturn;\\n        //Main Condition\\n\\t\\tif (grid[i][j] == 2)\\n\\t\\t{\\n\\t\\t\\tif (step == 1)\\n\\t\\t\\t\\tans++;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tgrid[i][j] = -1;\\n\\t\\t\\tpass(grid, i - 1, j, n, m, step - 1);\\n\\t\\t\\tpass(grid, i + 1, j, n, m, step - 1);\\n\\t\\t\\tpass(grid, i, j + 1, n, m, step - 1);\\n\\t\\t\\tpass(grid, i, j - 1, n, m, step - 1);\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\tint uniquePathsIII(vector<vector<int>> &grid)\\n\\t{\\n\\t\\tans = 0;\\n\\t\\tint i = 0, j = 0;\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tbool bat = 0;\\n\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (j = 0; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbat = 1;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (bat)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint brick = 0;\\n\\t\\tfor (int ii = 0; ii < n; ii++)\\n\\t\\t{\\n\\t\\t\\tfor (int jj = 0; jj < m; jj++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[ii][jj] == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbrick++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpass(grid, i, j, n, m, (n * m) - brick);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans;\\n\\tvoid pass(vector<vector<int>> &grid, int i, int j, int n, int m, int step)\\n\\t{\\n\\t\\t//Base Condition\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == -1)\\n\\t\\t\\treturn;\\n        //Main Condition\\n\\t\\tif (grid[i][j] == 2)\\n\\t\\t{\\n\\t\\t\\tif (step == 1)\\n\\t\\t\\t\\tans++;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tgrid[i][j] = -1;\\n\\t\\t\\tpass(grid, i - 1, j, n, m, step - 1);\\n\\t\\t\\tpass(grid, i + 1, j, n, m, step - 1);\\n\\t\\t\\tpass(grid, i, j + 1, n, m, step - 1);\\n\\t\\t\\tpass(grid, i, j - 1, n, m, step - 1);\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\tint uniquePathsIII(vector<vector<int>> &grid)\\n\\t{\\n\\t\\tans = 0;\\n\\t\\tint i = 0, j = 0;\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tbool bat = 0;\\n\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (j = 0; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbat = 1;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (bat)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint brick = 0;\\n\\t\\tfor (int ii = 0; ii < n; ii++)\\n\\t\\t{\\n\\t\\t\\tfor (int jj = 0; jj < m; jj++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[ii][jj] == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbrick++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpass(grid, i, j, n, m, (n * m) - brick);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124366,
                "title": "python3-simple-backtracking-based-solution",
                "content": "```\\n\"\"\"https://leetcode.com/problems/unique-paths-iii/\"\"\"\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.res = 0\\n\\n    def uniquePathsIII(self, A):\\n        def dfs(x, y, empty):\\n            if 0 <= x < m and 0 <= y < n and A[x][y] >= 0:\\n                if A[x][y] == 2:\\n                    # destination reached, update count only if empty count is also zero, which implies that\\n                    # each empty cell has been explored\\n                    self.res += empty == 0\\n                    return\\n                A[x][y] = -2\\n                for (dx, dy) in directions:\\n                    dfs(x + dx, y + dy, empty - 1)\\n                A[x][y] = 0\\n\\n        m, n, empty_counts = len(A), len(A[0]), 1\\n        start_x, start_y = None, None\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    # start_node\\n                    start_x, start_y = (i, j)\\n                elif A[i][j] == 0:\\n                    empty_counts += 1\\n\\n        dfs(start_x, start_y, empty_counts)\\n        return self.res\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/unique-paths-iii/\"\"\"\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.res = 0\\n\\n    def uniquePathsIII(self, A):\\n        def dfs(x, y, empty):\\n            if 0 <= x < m and 0 <= y < n and A[x][y] >= 0:\\n                if A[x][y] == 2:\\n                    # destination reached, update count only if empty count is also zero, which implies that\\n                    # each empty cell has been explored\\n                    self.res += empty == 0\\n                    return\\n                A[x][y] = -2\\n                for (dx, dy) in directions:\\n                    dfs(x + dx, y + dy, empty - 1)\\n                A[x][y] = 0\\n\\n        m, n, empty_counts = len(A), len(A[0]), 1\\n        start_x, start_y = None, None\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    # start_node\\n                    start_x, start_y = (i, j)\\n                elif A[i][j] == 0:\\n                    empty_counts += 1\\n\\n        dfs(start_x, start_y, empty_counts)\\n        return self.res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1977130,
                "title": "c-0ms-simple-backtracking-code",
                "content": "**Please do upvote if you liked my efforts ;)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=0;\\n    \\n    void helper(vector<vector<int>>& grid, int i, int j, int empty, int currEmpty)\\n    {\\n        if(i<0 or j<0 or i >= grid.size() or j >= grid[0].size() or grid[i][j] == -1 or grid[i][j] == 10) return;\\n        \\n        if(grid[i][j] == 2 and currEmpty == empty) ++ans;\\n        if(grid[i][j] == 0) ++currEmpty;\\n        \\n        int temp = grid[i][j];\\n        grid[i][j] = 10;\\n        \\n        helper(grid, i+1, j, empty, currEmpty);\\n        helper(grid, i-1, j, empty, currEmpty);\\n        helper(grid, i, j+1, empty, currEmpty);\\n        helper(grid, i, j-1, empty, currEmpty);\\n        \\n        grid[i][j] = temp;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        int start_x, start_y, empty=0;\\n        \\n        for(int i=0; i<grid.size(); i++)\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    start_x = i, start_y = j;\\n                else if(grid[i][j] == 0) ++empty;\\n            }\\n        \\n        helper(grid, start_x, start_y, empty, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ans=0;\\n    \\n    void helper(vector<vector<int>>& grid, int i, int j, int empty, int currEmpty)\\n    {\\n        if(i<0 or j<0 or i >= grid.size() or j >= grid[0].size() or grid[i][j] == -1 or grid[i][j] == 10) return;\\n        \\n        if(grid[i][j] == 2 and currEmpty == empty) ++ans;\\n        if(grid[i][j] == 0) ++currEmpty;\\n        \\n        int temp = grid[i][j];\\n        grid[i][j] = 10;\\n        \\n        helper(grid, i+1, j, empty, currEmpty);\\n        helper(grid, i-1, j, empty, currEmpty);\\n        helper(grid, i, j+1, empty, currEmpty);\\n        helper(grid, i, j-1, empty, currEmpty);\\n        \\n        grid[i][j] = temp;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        int start_x, start_y, empty=0;\\n        \\n        for(int i=0; i<grid.size(); i++)\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    start_x = i, start_y = j;\\n                else if(grid[i][j] == 0) ++empty;\\n            }\\n        \\n        helper(grid, start_x, start_y, empty, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891952,
                "title": "c-bitmasking-dfs-simple-method",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> p[4] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; //path from each index\\n    int target_mask = 0; // each bit represent a cell \\n    int ans= 0;\\n    void dfs(vector<vector<int>>& grid, int i, int j, int mask, int& n, int& m){\\n        if(grid[i][j] == 2) {\\n            if( (mask | (1<<(i*m + j))) == target_mask) //checking if we have visited all cells before target\\n            ans++;\\n            return;\\n        }\\n        for(auto a: p){\\n            int x = a.first + i, y = a.second + j;\\n            if(x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == -1 or mask&(1<<(x*m + y))) continue;\\n            dfs(grid, x, y, mask | (1<<(x*m + y)), n, m); //masking the cell bit as visited while making dfs call\\n        }\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        target_mask = (1 << n*m) -1; //making every bit as visited for target mask \\n        int row, col;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){  // getting the starting index address\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == -1){\\n                    target_mask = target_mask^(1<<(i*m + j)); // changing the -1 cell\\'s bit to 0\\n                }\\n            }\\n        }\\n        dfs(grid, row, col, (0 | (1<<(row*m + col))), n, m); //making the beginning node visited and making dfs call \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> p[4] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; //path from each index\\n    int target_mask = 0; // each bit represent a cell \\n    int ans= 0;\\n    void dfs(vector<vector<int>>& grid, int i, int j, int mask, int& n, int& m){\\n        if(grid[i][j] == 2) {\\n            if( (mask | (1<<(i*m + j))) == target_mask) //checking if we have visited all cells before target\\n            ans++;\\n            return;\\n        }\\n        for(auto a: p){\\n            int x = a.first + i, y = a.second + j;\\n            if(x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == -1 or mask&(1<<(x*m + y))) continue;\\n            dfs(grid, x, y, mask | (1<<(x*m + y)), n, m); //masking the cell bit as visited while making dfs call\\n        }\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        target_mask = (1 << n*m) -1; //making every bit as visited for target mask \\n        int row, col;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){  // getting the starting index address\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == -1){\\n                    target_mask = target_mask^(1<<(i*m + j)); // changing the -1 cell\\'s bit to 0\\n                }\\n            }\\n        }\\n        dfs(grid, row, col, (0 | (1<<(row*m + col))), n, m); //making the beginning node visited and making dfs call \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691482,
                "title": "simple-c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& dp, \\n             int i, int j, int m, int n, int val, int& count, int space) {\\n        \\n        //cout << i << \":\" << j << \":\" << \":\" << val << endl;\\n        if (i < 0 || i == m || j < 0 || j == n)  return;\\n        if (grid[i][j] == -1 || dp[i][j] == 1)   return;\\n        if (grid[i][j] == 2) {\\n            if (space == val)   count++;\\n            return;\\n        }\\n        dp[i][j] = 1;\\n        for (int k = 0; k < dir.size(); k++) {\\n            int x = i + dir[k][0], y = j + dir[k][1];\\n            dfs(grid, dp, x, y, m, n, val + 1, count, space);\\n        }\\n        dp[i][j] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int space = 0, m = grid.size(), n = grid[0].size(), x, y;\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0)    space++;\\n                else if (grid[i][j] == 1)  {\\n                    x = i; y = j;\\n                }\\n            }\\n        }\\n        int val = -1, count = 0;\\n        grid[x][y] = 0;\\n        dfs(grid, dp, x, y, m, n, val, count, space);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& dp, \\n             int i, int j, int m, int n, int val, int& count, int space) {\\n        \\n        //cout << i << \":\" << j << \":\" << \":\" << val << endl;\\n        if (i < 0 || i == m || j < 0 || j == n)  return;\\n        if (grid[i][j] == -1 || dp[i][j] == 1)   return;\\n        if (grid[i][j] == 2) {\\n            if (space == val)   count++;\\n            return;\\n        }\\n        dp[i][j] = 1;\\n        for (int k = 0; k < dir.size(); k++) {\\n            int x = i + dir[k][0], y = j + dir[k][1];\\n            dfs(grid, dp, x, y, m, n, val + 1, count, space);\\n        }\\n        dp[i][j] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int space = 0, m = grid.size(), n = grid[0].size(), x, y;\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0)    space++;\\n                else if (grid[i][j] == 1)  {\\n                    x = i; y = j;\\n                }\\n            }\\n        }\\n        int val = -1, count = 0;\\n        grid[x][y] = 0;\\n        dfs(grid, dp, x, y, m, n, val, count, space);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1652022,
                "title": "c-dfs-backtracking-solution",
                "content": "Please upvote if you like :)\\n\\n```\\nclass Solution {\\nprivate:\\n    int dfs(vector<vector<int>> &grid, int x, int y, int zeros){\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size() || grid[x][y] == -1){  // base cases\\n            return 0;\\n        }\\n        \\n        if(grid[x][y] == 2){\\n            // reaching required end\\n            return zeros == -1 ? 1 : 0;   //check if all zeros covered, then it\\'s a possible path \\n        }\\n        \\n        grid[x][y] = -1;        // marking as visisted \\n        zeros--;\\n        \\n        int totalPath = dfs(grid, x + 1, y, zeros) +        // right \\n                        dfs(grid, x, y + 1, zeros) +        // down  \\n                        dfs(grid, x - 1, y, zeros) +        // left \\n                        dfs(grid, x, y - 1, zeros);         // top \\n        \\n        grid[x][y] = 0;     // these steps are added \\n        zeros++;            // to backtrack \\n        \\n        return totalPath;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zeros = 0, sx = 0, sy = 0;      // sx & sy are starting positions\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 0) zeros++;\\n                else if (grid[i][j] == 1){\\n                    sx = i;\\n                    sy = j;\\n                } \\n            }\\n        }\\n        \\n        return dfs(grid, sx, sy, zeros);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(vector<vector<int>> &grid, int x, int y, int zeros){\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size() || grid[x][y] == -1){  // base cases\\n            return 0;\\n        }\\n        \\n        if(grid[x][y] == 2){\\n            // reaching required end\\n            return zeros == -1 ? 1 : 0;   //check if all zeros covered, then it\\'s a possible path \\n        }\\n        \\n        grid[x][y] = -1;        // marking as visisted \\n        zeros--;\\n        \\n        int totalPath = dfs(grid, x + 1, y, zeros) +        // right \\n                        dfs(grid, x, y + 1, zeros) +        // down  \\n                        dfs(grid, x - 1, y, zeros) +        // left \\n                        dfs(grid, x, y - 1, zeros);         // top \\n        \\n        grid[x][y] = 0;     // these steps are added \\n        zeros++;            // to backtrack \\n        \\n        return totalPath;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zeros = 0, sx = 0, sy = 0;      // sx & sy are starting positions\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 0) zeros++;\\n                else if (grid[i][j] == 1){\\n                    sx = i;\\n                    sy = j;\\n                } \\n            }\\n        }\\n        \\n        return dfs(grid, sx, sy, zeros);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645101,
                "title": "space-and-time-complexity-explained-simple-code-c",
                "content": "//time complexity->3^(m*n) because first box hai 4 choices and rest have 3\\n// space->m*n coz space is equal to the height of stack and in worst case stack can have all elements\\n\\nclass Solution {\\npublic:\\n   typedef pair<int,int> Pair;\\n\\n  int solution(int starti,int startj,vector<vector<int>>& grid,int initialcount){\\n   \\n      \\n         if(starti<0 || startj<0 || starti>=grid.size() || startj>=grid[0].size() || grid[starti][startj]==-1){\\n            return 0;\\n        }\\n      \\n        if(grid[starti][startj]==2){\\n            if( initialcount==-1)//because for last box when we reach destination the count be also decrease by 1 extra time\\n          return 1;\\n            else\\n                return 0;\\n        }\\n        \\n     \\n        \\n      \\n        grid[starti][startj]=-1;\\n        initialcount--;\\n             int path1=solution(starti,startj+1,grid,initialcount);\\n             int path2=solution(starti+1,startj,grid,initialcount);\\n             int path3=solution(starti,startj-1,grid,initialcount);\\n             int path4=solution(starti-1,startj,grid,initialcount);\\n\\n        initialcount++;\\n        grid[starti][startj]=0;\\n      \\n     int ans= path1+path2+path3+path4;\\n   return ans;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n     \\n        \\n        \\n             int count=0;\\n        int starti=0;\\n            int startj=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0){\\n                    count++;\\n                }\\n               else if(grid[i][j]==1){\\n                    starti=i;\\n                    startj=j;\\n                }\\n               \\n           \\n            }  \\n        }\\n      return  solution(starti,startj,grid,count);\\n    }\\n};\\n//pls upvote if you like my solution : )",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n   typedef pair<int,int> Pair;\\n\\n  int solution(int starti,int startj,vector<vector<int>>& grid,int initialcount){\\n   \\n      \\n         if(starti<0 || startj<0 || starti>=grid.size() || startj>=grid[0].size() || grid[starti][startj]==-1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1628825,
                "title": "java-dfs-solution-backtracking-easy-clean-code",
                "content": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        if(grid==null || grid.length==0) return 0;\\n        \\n        int zero=0;\\n        int x=-1;\\n        int y=-1;\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0) zero++;\\n                else if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                }\\n            }\\n        }\\n        return helper(grid,x,y,zero);\\n    }\\n    \\n    public int helper(int[][] grid, int x, int y, int zero){\\n        if(x<0 || y<0 || x>=grid.length || y>=grid[0].length || grid[x][y]==-1) return 0;\\n        \\n        if(grid[x][y]==2) return zero == -1 ? 1 : 0;\\n        \\n        grid[x][y]=-1;\\n        zero--;\\n        \\n        int ans = helper(grid,x+1,y,zero)\\n                + helper(grid,x-1,y,zero)\\n                + helper(grid,x,y+1,zero)\\n                + helper(grid,x,y-1,zero);\\n        \\n        zero++;\\n        grid[x][y]=0;\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        if(grid==null || grid.length==0) return 0;\\n        \\n        int zero=0;\\n        int x=-1;\\n        int y=-1;\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0) zero++;\\n                else if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                }\\n            }\\n        }\\n        return helper(grid,x,y,zero);\\n    }\\n    \\n    public int helper(int[][] grid, int x, int y, int zero){\\n        if(x<0 || y<0 || x>=grid.length || y>=grid[0].length || grid[x][y]==-1) return 0;\\n        \\n        if(grid[x][y]==2) return zero == -1 ? 1 : 0;\\n        \\n        grid[x][y]=-1;\\n        zero--;\\n        \\n        int ans = helper(grid,x+1,y,zero)\\n                + helper(grid,x-1,y,zero)\\n                + helper(grid,x,y+1,zero)\\n                + helper(grid,x,y-1,zero);\\n        \\n        zero++;\\n        grid[x][y]=0;\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555480,
                "title": "november-challenge-day-2-unique-paths-3-c-code-with-comments",
                "content": "```\\n// we need to count total no. of 0s and also find out which cell is start point\\n    int zeroCells = 1, res = 0; // zeroCells starts w 1 to account for start point\\n    // which is 1 and not 0 \\n    \\n    void dfs(vector<vector<int>>& grid, int x, int y, int countZeros){\\n        // base cases\\n        if(x < 0 || y < 0 || x >=grid.size() || y>=grid[0].size() || grid[x][y] == -1)\\n            return;\\n        \\n        if(grid[x][y] == 2) {\\n            if (countZeros == zeroCells)  res += 1;\\n            return; // we reached destination and all cells w 0 have been visited -> inc. unique path count (res) by 1. Else just return\\n        }\\n        \\n        grid[x][y] = -1; // mark curr cell visited\\n        \\n        // dfs\\n        dfs(grid, x+1, y, countZeros+1);\\n        dfs(grid, x-1, y, countZeros+1);\\n        dfs(grid, x, y+1, countZeros+1);\\n        dfs(grid, x, y-1, countZeros+1);\\n        \\n        // backtrack before trying to find new path\\n        grid[x][y] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // fast\\n        ios_base::sync_with_stdio(false);\\n        int start_x, start_y;\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        for(int i = 0; i<rows; i++){\\n            for(int j = 0; j<cols; j++){\\n                if(grid[i][j] == 1) start_x = i, start_y = j;\\n                else if(grid[i][j] == 0) zeroCells += 1;\\n            }\\n        }\\n        \\n        // now do dfs from start\\n        dfs(grid, start_x, start_y, 0);\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// we need to count total no. of 0s and also find out which cell is start point\\n    int zeroCells = 1, res = 0; // zeroCells starts w 1 to account for start point\\n    // which is 1 and not 0 \\n    \\n    void dfs(vector<vector<int>>& grid, int x, int y, int countZeros){\\n        // base cases\\n        if(x < 0 || y < 0 || x >=grid.size() || y>=grid[0].size() || grid[x][y] == -1)\\n            return;\\n        \\n        if(grid[x][y] == 2) {\\n            if (countZeros == zeroCells)  res += 1;\\n            return; // we reached destination and all cells w 0 have been visited -> inc. unique path count (res) by 1. Else just return\\n        }\\n        \\n        grid[x][y] = -1; // mark curr cell visited\\n        \\n        // dfs\\n        dfs(grid, x+1, y, countZeros+1);\\n        dfs(grid, x-1, y, countZeros+1);\\n        dfs(grid, x, y+1, countZeros+1);\\n        dfs(grid, x, y-1, countZeros+1);\\n        \\n        // backtrack before trying to find new path\\n        grid[x][y] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // fast\\n        ios_base::sync_with_stdio(false);\\n        int start_x, start_y;\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        for(int i = 0; i<rows; i++){\\n            for(int j = 0; j<cols; j++){\\n                if(grid[i][j] == 1) start_x = i, start_y = j;\\n                else if(grid[i][j] == 0) zeroCells += 1;\\n            }\\n        }\\n        \\n        // now do dfs from start\\n        dfs(grid, start_x, start_y, 0);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554465,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar uniquePathsIII = function(obstacleGrid) {\\n    let rows = obstacleGrid.length;\\n    let columns = obstacleGrid[0].length;\\n    \\n    let directions = [ [1, 0], [0, 1], [-1, 0], [0, -1] ];\\n    let nonObstacles = 0;\\n    let startX, startY;\\n    \\n    for(let g=0; g<rows; g++){\\n        for(let k=0; k<columns; k++){\\n            if(obstacleGrid[g][k] == 1){\\n                startX = g;\\n                startY = k;\\n                \\n            }\\n            else if (obstacleGrid[g][k] == 0){\\n                     nonObstacles++;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n    const compute = (x, y, count) => {\\n        if(x >= rows || y>= columns || x<0 || y<0) return 0;\\n        if( obstacleGrid[x][y] == -1 || obstacleGrid[x][y] == \\'V\\') return 0;\\n        if( obstacleGrid[x][y] == 2 && count == nonObstacles+1  ) {\\n            return 1;\\n        }\\n        let res = 0;\\n        let oldValue =  obstacleGrid[x][y] ;\\n        obstacleGrid[x][y] = \\'V\\';\\n        for(let [dx, dy] of directions) {\\n             let curRes   = compute(x+dx, y+dy, count+1);\\n             res = curRes + res;\\n        }\\n        obstacleGrid[x][y] = oldValue;\\n        return res;\\n    }\\n    return compute(startX, startY, 0);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar uniquePathsIII = function(obstacleGrid) {\\n    let rows = obstacleGrid.length;\\n    let columns = obstacleGrid[0].length;\\n    \\n    let directions = [ [1, 0], [0, 1], [-1, 0], [0, -1] ];\\n    let nonObstacles = 0;\\n    let startX, startY;\\n    \\n    for(let g=0; g<rows; g++){\\n        for(let k=0; k<columns; k++){\\n            if(obstacleGrid[g][k] == 1){\\n                startX = g;\\n                startY = k;\\n                \\n            }\\n            else if (obstacleGrid[g][k] == 0){\\n                     nonObstacles++;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n    const compute = (x, y, count) => {\\n        if(x >= rows || y>= columns || x<0 || y<0) return 0;\\n        if( obstacleGrid[x][y] == -1 || obstacleGrid[x][y] == \\'V\\') return 0;\\n        if( obstacleGrid[x][y] == 2 && count == nonObstacles+1  ) {\\n            return 1;\\n        }\\n        let res = 0;\\n        let oldValue =  obstacleGrid[x][y] ;\\n        obstacleGrid[x][y] = \\'V\\';\\n        for(let [dx, dy] of directions) {\\n             let curRes   = compute(x+dx, y+dy, count+1);\\n             res = curRes + res;\\n        }\\n        obstacleGrid[x][y] = oldValue;\\n        return res;\\n    }\\n    return compute(startX, startY, 0);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554325,
                "title": "c-backtracking-optimized-solution-with-comments-beats-100",
                "content": "```\\n#define vvi vector<vector<int>>\\n\\n//for 4 directions\\nint rowArr[] = {1,-1,0,0};\\nint colArr[] = {0,0,1,-1};\\n\\n//variable to keep track of no. of paths\\nint cnt = 0;\\n    \\n\\t//function to check if current cell is inside grid\\n\\t//and is not obstacle/starting point/already visited cell\\n    bool isValid(vvi &grid,int row,int col)\\n    {\\n        if(row<0 || col<0 || \\n           row>=grid.size() || col>=grid[0].size()\\n           || grid[row][col] == -1 || grid[row][col] == 1)\\n            return false;\\n        return true;\\n    }\\n    \\n\\t//function to look for valid paths\\n    void dfs(vvi &grid,int row,int col,int sq,int total)\\n    {\\n\\t//if current cell is invalid , just return\\n        if(!isValid(grid,row,col)) return;\\n\\t\\t\\n\\t\\t//if the current cell is ending point, do cnt++ if \\n\\t\\t//no. of empty cells visited is equal to total \\n\\t\\t//empty cells is the grid and return\\n        if(grid[row][col] == 2)\\n        {\\n            cnt+= (sq == total);\\n            return;\\n        }\\n        \\n\\t\\t//change value of current cell to -1 to mark it as visited\\n        grid[row][col] = -1;\\n\\t\\t\\n\\t\\t//move in all 4 directions from this current cell\\n        for(int i=0;i<4;i++) \\n            dfs(grid,row+rowArr[i],col+colArr[i],sq+1,total);\\n\\t\\t\\n\\t\\t//after coming back from all 4 directions\\n\\t\\t//mark current cell as unvisited(0) again\\n        grid[row][col] = 0;\\n    }\\n\\t\\n\\t int uniquePathsIII(vector<vector<int>>& grid) {\\n        cnt=0;\\n        int total = 0;\\n        int x,y;\\n\\t\\t//iterate over grid to find the starting point and\\n\\t\\t//count no. of empty cells\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j] == 0) total++;\\n                else if(grid[i][j] == 1) x=i,y=j;\\n            }\\n        }\\n        // from the starting point move in all 4 directions to count \\n\\t\\t//no. of valid paths\\n        for(int i=0;i<4;i++) dfs(grid,x+rowArr[i],y+colArr[i],0,total);\\n        \\n\\t\\t\\n\\t\\t//return the count of valid paths\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\n\\n//for 4 directions\\nint rowArr[] = {1,-1,0,0};\\nint colArr[] = {0,0,1,-1};\\n\\n//variable to keep track of no. of paths\\nint cnt = 0;\\n    \\n\\t//function to check if current cell is inside grid\\n\\t//and is not obstacle/starting point/already visited cell\\n    bool isValid(vvi &grid,int row,int col)\\n    {\\n        if(row<0 || col<0 || \\n           row>=grid.size() || col>=grid[0].size()\\n           || grid[row][col] == -1 || grid[row][col] == 1)\\n            return false;\\n        return true;\\n    }\\n    \\n\\t//function to look for valid paths\\n    void dfs(vvi &grid,int row,int col,int sq,int total)\\n    {\\n\\t//if current cell is invalid , just return\\n        if(!isValid(grid,row,col)) return;\\n\\t\\t\\n\\t\\t//if the current cell is ending point, do cnt++ if \\n\\t\\t//no. of empty cells visited is equal to total \\n\\t\\t//empty cells is the grid and return\\n        if(grid[row][col] == 2)\\n        {\\n            cnt+= (sq == total);\\n            return;\\n        }\\n        \\n\\t\\t//change value of current cell to -1 to mark it as visited\\n        grid[row][col] = -1;\\n\\t\\t\\n\\t\\t//move in all 4 directions from this current cell\\n        for(int i=0;i<4;i++) \\n            dfs(grid,row+rowArr[i],col+colArr[i],sq+1,total);\\n\\t\\t\\n\\t\\t//after coming back from all 4 directions\\n\\t\\t//mark current cell as unvisited(0) again\\n        grid[row][col] = 0;\\n    }\\n\\t\\n\\t int uniquePathsIII(vector<vector<int>>& grid) {\\n        cnt=0;\\n        int total = 0;\\n        int x,y;\\n\\t\\t//iterate over grid to find the starting point and\\n\\t\\t//count no. of empty cells\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j] == 0) total++;\\n                else if(grid[i][j] == 1) x=i,y=j;\\n            }\\n        }\\n        // from the starting point move in all 4 directions to count \\n\\t\\t//no. of valid paths\\n        for(int i=0;i<4;i++) dfs(grid,x+rowArr[i],y+colArr[i],0,total);\\n        \\n\\t\\t\\n\\t\\t//return the count of valid paths\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554140,
                "title": "c-dfs-approach",
                "content": "1. DFS\\n```\\n\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> &grid, vector<vector<bool>> &visited, int i, int j, int ei, int ej, int count0) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = 0;\\n\\n        // cout<<i<<\" \"<<j<<\" \"<<\" \"<<count0<<endl;\\n        if (i == ei && j == ej) {\\n            if (count0 == -1)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n\\n        visited[i][j] = true;\\n\\n        //up\\n        if (i - 1 >= 0 && !visited[i - 1][j] && grid[i - 1][j] != -1)\\n            ans += dfs(grid, visited, i - 1, j, ei, ej, count0 - 1);\\n        //down\\n        if (i + 1 < m && !visited[i + 1][j] && grid[i + 1][j] != -1)\\n            ans += dfs(grid, visited, i + 1, j, ei, ej, count0 - 1);\\n        //left\\n        if (j - 1 >= 0 && !visited[i][j - 1] && grid[i][j - 1] != -1)\\n            ans += dfs(grid, visited, i, j - 1, ei, ej, count0 - 1);\\n        //right\\n        if (j + 1 < n && !visited[i][j + 1] && grid[i][j + 1] != -1)\\n            ans += dfs(grid, visited, i, j + 1, ei, ej, count0 - 1);\\n\\n        visited[i][j] = false;\\n\\n        return ans;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>> &grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        int si,sj,ei,ej,count0=0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n\\n                if (grid[i][j] == 2) {\\n                    ei = i;\\n                    ej = j;\\n                }\\n\\n                if (grid[i][j] == 0) {\\n                    count0++;\\n                }\\n\\n            }\\n        }\\n\\n        return dfs(grid, visited, si, sj, ei, ej, count0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> &grid, vector<vector<bool>> &visited, int i, int j, int ei, int ej, int count0) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = 0;\\n\\n        // cout<<i<<\" \"<<j<<\" \"<<\" \"<<count0<<endl;\\n        if (i == ei && j == ej) {\\n            if (count0 == -1)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n\\n        visited[i][j] = true;\\n\\n        //up\\n        if (i - 1 >= 0 && !visited[i - 1][j] && grid[i - 1][j] != -1)\\n            ans += dfs(grid, visited, i - 1, j, ei, ej, count0 - 1);\\n        //down\\n        if (i + 1 < m && !visited[i + 1][j] && grid[i + 1][j] != -1)\\n            ans += dfs(grid, visited, i + 1, j, ei, ej, count0 - 1);\\n        //left\\n        if (j - 1 >= 0 && !visited[i][j - 1] && grid[i][j - 1] != -1)\\n            ans += dfs(grid, visited, i, j - 1, ei, ej, count0 - 1);\\n        //right\\n        if (j + 1 < n && !visited[i][j + 1] && grid[i][j + 1] != -1)\\n            ans += dfs(grid, visited, i, j + 1, ei, ej, count0 - 1);\\n\\n        visited[i][j] = false;\\n\\n        return ans;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>> &grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        int si,sj,ei,ej,count0=0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n\\n                if (grid[i][j] == 2) {\\n                    ei = i;\\n                    ej = j;\\n                }\\n\\n                if (grid[i][j] == 0) {\\n                    count0++;\\n                }\\n\\n            }\\n        }\\n\\n        return dfs(grid, visited, si, sj, ei, ej, count0);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1553995,
                "title": "c-with-explanation-clean-code",
                "content": "**Idea:-**\\n1. Iterate over ```grid``` and find the start position and count the umber of empty cells(including start position,that\\'s why i initilized empty with 1).\\n2. Now start backtrackin  from start posiiton and mark visited to every empty cells(by assigning it ```-2``` or other different value) and also decrease ```empty```.\\n3. When we complete backtracking from current cell then restore the previous values(empty++,grid[row][col]=0). \\n4. When we reach ```end``` position our ```empty``` variable should be ```0``` because we have to count number of paths that include every ```empty cell.```.\\n\\n**Time Complexity:-** ```O(3^(m*n))```,where m,n are row,columns of grid.\\n4th one is not included because we can\\'t go back to same posiiton.\\n**Space Complexity:-** ```O(1)```, I am not using stack space as i am passing by ```reference```.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n       int m=grid.size(),n=grid[0].size(),ans=0,startRow,startCol,empty=1;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    startRow=i; startCol=j;\\n                }\\n                else if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        helper(grid,startRow,startCol,ans,m,n,empty);\\n          return ans;          \\n    }\\n    void helper(vector<vector<int>>& grid,int &row,int&col,int &ans,int &m,int &n,int &empty){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]==-1 || grid[row][col]==-2)\\n            return;\\n        if(grid[row][col]==2){\\n            if(empty==0)\\n              ans++;\\n            return;\\n        }\\n        grid[row][col]=-2;  empty--;\\n        vector<vector<int>>dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto & i:dirs){\\n            row+=i[0];   col+=i[1];\\n            helper(grid,row,col,ans,m,n,empty);\\n            row-=i[0];  col-=i[1];\\n        }\\n        grid[row][col]=0; empty++;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps:)\\nIf you have any doubt or suggestion then please ask in comment section.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```grid```\n```-2```\n```empty```\n```end```\n```empty```\n```0```\n```empty cell.```\n```O(3^(m*n))```\n```O(1)```\n```reference```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n       int m=grid.size(),n=grid[0].size(),ans=0,startRow,startCol,empty=1;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    startRow=i; startCol=j;\\n                }\\n                else if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        helper(grid,startRow,startCol,ans,m,n,empty);\\n          return ans;          \\n    }\\n    void helper(vector<vector<int>>& grid,int &row,int&col,int &ans,int &m,int &n,int &empty){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]==-1 || grid[row][col]==-2)\\n            return;\\n        if(grid[row][col]==2){\\n            if(empty==0)\\n              ans++;\\n            return;\\n        }\\n        grid[row][col]=-2;  empty--;\\n        vector<vector<int>>dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto & i:dirs){\\n            row+=i[0];   col+=i[1];\\n            helper(grid,row,col,ans,m,n,empty);\\n            row-=i[0];  col-=i[1];\\n        }\\n        grid[row][col]=0; empty++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553968,
                "title": "python-dfs-and-backtracking-a-few-lines-of-code",
                "content": "\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        visit=set() # need to be visted\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==0:\\n                    visit.add((i,j))\\n                elif grid[i][j]==1:\\n                    start = (i,j)\\n                elif grid[i][j]==2:\\n                    end= (i,j)\\n                    visit.add((i,j))\\n        \\n        def back(i,j):\\n            if grid[i][j]==2 and len(visit)==0:\\n                return 1\\n            rst = 0\\n            \\n            for v in [(i-1,j), (i+1,j), (i,j-1),(i,j+1)]: # DFS 4 direct\\n                if v in visit:\\n                    visit.remove(v)\\n                    rst += back(v[0], v[1])\\n                    visit.add(v) # must added back for the other path\\n            return rst\\n\\n        return back(start[0], start[1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        visit=set() # need to be visted\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==0:\\n                    visit.add((i,j))\\n                elif grid[i][j]==1:\\n                    start = (i,j)\\n                elif grid[i][j]==2:\\n                    end= (i,j)\\n                    visit.add((i,j))\\n        \\n        def back(i,j):\\n            if grid[i][j]==2 and len(visit)==0:\\n                return 1\\n            rst = 0\\n            \\n            for v in [(i-1,j), (i+1,j), (i,j-1),(i,j+1)]: # DFS 4 direct\\n                if v in visit:\\n                    visit.remove(v)\\n                    rst += back(v[0], v[1])\\n                    visit.add(v) # must added back for the other path\\n            return rst\\n\\n        return back(start[0], start[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553933,
                "title": "simple-easy-code-c",
                "content": "class Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void check(vector<vector<int>>&v ,int i , int j , int c){\\n        if(i<0 || i>=v.size() || j<0 || j>=v[0].size() || v[i][j]==INT_MIN || v[i][j]==-1 ) return ;\\n        \\n        if(v[i][j]==2){\\n            if(c==-1){\\n                ans+=1;\\n            }\\n            return ;\\n        }\\n        \\n         \\n        v[i][j] = INT_MIN;  // MARK AS VISITED\\n        check(v , i+1 , j , c-1);\\n        check(v ,i-1 , j, c-1);\\n        check(v, i , j+1 ,c-1);\\n        check(v , i, j-1 , c-1);\\n        v[i][j] = 0;  // UNMARK\\n    } \\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int c =0;\\n        int s=0,e=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0){\\n                    c++;  // COUNT TOTAL ZEROES\\n                }\\n                else if(grid[i][j]==1){\\n                    s = i;  // START POINT ROW\\n                    e = j; // START POINT COLOUMN\\n                }\\n            }\\n        }\\n        \\n        check(grid , s , e , c);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void check(vector<vector<int>>&v ,int i , int j , int c){\\n        if(i<0 || i>=v.size() || j<0 || j>=v[0].size() || v[i][j]==INT_MIN || v[i][j]==-1 ) return ;\\n        \\n        if(v[i][j]==2){\\n            if(c==-1){\\n                ans+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1553895,
                "title": "simple-ruby-3-liner",
                "content": "```\\ndef unique_paths_iii(g, h={}) [*0...g.size].product([*0...g[0].size]){|i,j| h[[i,j]]=g[i][j]}\\n  (dfs = -> i,j,h{[[i+1,j], [i-1,j], [i,j+1], [i,j-1]].sum{|n| h[n]==0 ?\\n    dfs[*n, h.merge(n=>1)] : h[n]!=2 ? 0 : h.key(0) ? 0 : 1}})[*h.key(1), h] end\\n```",
                "solutionTags": [],
                "code": "```\\ndef unique_paths_iii(g, h={}) [*0...g.size].product([*0...g[0].size]){|i,j| h[[i,j]]=g[i][j]}\\n  (dfs = -> i,j,h{[[i+1,j], [i-1,j], [i,j+1], [i,j-1]].sum{|n| h[n]==0 ?\\n    dfs[*n, h.merge(n=>1)] : h[n]!=2 ? 0 : h.key(0) ? 0 : 1}})[*h.key(1), h] end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1547183,
                "title": "python-solution-with-complex-numbers-faster-than-99-5",
                "content": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\n        self.maze = set()\\n        for y, row in enumerate(grid):\\n            for x, sq in enumerate(row):\\n                pos = x + 1j * y\\n                if sq == 1:\\n                    start = pos\\n                elif sq == 2:\\n                    end = pos\\n                if sq != -1:\\n                    self.maze.add(pos)\\n        self.maze.remove(start)\\n\\n        self.solutions = 0\\n\\n        self.solve(start, end)\\n        return self.solutions\\n\\n    def solve(self, pos, end):\\n        if pos == end:\\n            if not self.maze:\\n                self.solutions += 1\\n            return\\n\\n        for dv in 1, -1, 1j, -1j:\\n            np = pos + dv\\n            if np not in self.maze:\\n                continue\\n\\n            self.maze.remove(np)\\n            self.solve(np, end)\\n            self.maze.add(np)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\n        self.maze = set()\\n        for y, row in enumerate(grid):\\n            for x, sq in enumerate(row):\\n                pos = x + 1j * y\\n                if sq == 1:\\n                    start = pos\\n                elif sq == 2:\\n                    end = pos\\n                if sq != -1:\\n                    self.maze.add(pos)\\n        self.maze.remove(start)\\n\\n        self.solutions = 0\\n\\n        self.solve(start, end)\\n        return self.solutions\\n\\n    def solve(self, pos, end):\\n        if pos == end:\\n            if not self.maze:\\n                self.solutions += 1\\n            return\\n\\n        for dv in 1, -1, 1j, -1j:\\n            np = pos + dv\\n            if np not in self.maze:\\n                continue\\n\\n            self.maze.remove(np)\\n            self.solve(np, end)\\n            self.maze.add(np)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408339,
                "title": "java-dfs-and-backtracking-templates-time-beats-100",
                "content": "**Idea:** Use backtracking and grid DFS templates\\n>**T/S:** O(3\\u207F)/O(n), where n = total number of cells in the grid\\n```\\nprivate static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\t\\npublic int uniquePathsIII(int[][] grid) {\\n\\t// 0 and 1 will both be treated as empty even though their values are different.\\n\\t// This initialization is for counting the starting square as there will always be one.\\n\\tvar empty = 1;\\n\\tvar startX = -1;\\n\\tvar startY = -1;\\n\\n\\tfor (var i = 0; i < grid.length; i++)\\n\\t\\tfor (var j = 0; j < grid[0].length; j++)\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tstartX = i;\\n\\t\\t\\t\\tstartY = j;\\n\\t\\t\\t} else if (grid[i][j] == 0) {\\n\\t\\t\\t\\tempty++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\treturn dfs(grid, startX, startY, new int[]{empty});\\n}\\n\\n// most of the grid DFS questions have this template. Number of Islands is the most popular one\\nprivate int dfs(int[][] grid, int i, int j, int[] empty) {\\n\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -1)\\n\\t\\treturn 0; // invalid cell\\n\\tif (grid[i][j] == 2)\\n\\t\\treturn (empty[0] == 0) ? 1 : 0; // terminate early if empty cells haven\\'t exhausted when ending square is reached\\n\\n\\t// use backtracking template: choose-explore-unchoose\\n\\t// choose (change)\\n\\tempty[0]--;\\n\\tvar temp = grid[i][j]; // here temp is used to account for 0 and 1 valid traversable values\\n\\tgrid[i][j] = -1;\\n\\n\\t// explore\\n\\tvar paths = 0;\\n\\tfor (var dir : DIRS)\\n\\t\\tpaths += dfs(grid, i + dir[0], j + dir[1], empty);\\n\\n\\t// unchoose (restore)\\n\\tgrid[i][j] = temp;\\n\\tempty[0]++;\\n\\treturn paths;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\t\\npublic int uniquePathsIII(int[][] grid) {\\n\\t// 0 and 1 will both be treated as empty even though their values are different.\\n\\t// This initialization is for counting the starting square as there will always be one.\\n\\tvar empty = 1;\\n\\tvar startX = -1;\\n\\tvar startY = -1;\\n\\n\\tfor (var i = 0; i < grid.length; i++)\\n\\t\\tfor (var j = 0; j < grid[0].length; j++)\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tstartX = i;\\n\\t\\t\\t\\tstartY = j;\\n\\t\\t\\t} else if (grid[i][j] == 0) {\\n\\t\\t\\t\\tempty++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\treturn dfs(grid, startX, startY, new int[]{empty});\\n}\\n\\n// most of the grid DFS questions have this template. Number of Islands is the most popular one\\nprivate int dfs(int[][] grid, int i, int j, int[] empty) {\\n\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -1)\\n\\t\\treturn 0; // invalid cell\\n\\tif (grid[i][j] == 2)\\n\\t\\treturn (empty[0] == 0) ? 1 : 0; // terminate early if empty cells haven\\'t exhausted when ending square is reached\\n\\n\\t// use backtracking template: choose-explore-unchoose\\n\\t// choose (change)\\n\\tempty[0]--;\\n\\tvar temp = grid[i][j]; // here temp is used to account for 0 and 1 valid traversable values\\n\\tgrid[i][j] = -1;\\n\\n\\t// explore\\n\\tvar paths = 0;\\n\\tfor (var dir : DIRS)\\n\\t\\tpaths += dfs(grid, i + dir[0], j + dir[1], empty);\\n\\n\\t// unchoose (restore)\\n\\tgrid[i][j] = temp;\\n\\tempty[0]++;\\n\\treturn paths;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390740,
                "title": "java-100-faster-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n        int[] start = new int[2];\\n        int emptySquares = 0;\\n        \\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j] == 1){\\n                    start[0] = i;\\n                    start[1] = j;\\n                }else if(grid[i][j] == 0){\\n                    emptySquares++;\\n                }\\n            }\\n        }\\n        \\n        return countPaths(start[0], start[1], grid, emptySquares);\\n    }\\n    \\n    private int countPaths(int row, int col, int[][] grid, int emptySquares){\\n        if(row<0 || col<0 || row>=grid.length || col>=grid[0].length){\\n            return 0;\\n        }else if(grid[row][col] == -1 || grid[row][col] == 3){\\n            return 0;\\n        }else if(grid[row][col] == 2){\\n            return emptySquares == -1 ? 1 : 0;\\n        }\\n        \\n        grid[row][col] = 3;\\n        \\n        int countPaths = 0;\\n        \\n        for(int[] d : directions){\\n            countPaths += countPaths(row+d[0], col+d[1], grid, emptySquares-1);\\n        }\\n        \\n        grid[row][col] = 0;\\n        return countPaths;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n        int[] start = new int[2];\\n        int emptySquares = 0;\\n        \\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j] == 1){\\n                    start[0] = i;\\n                    start[1] = j;\\n                }else if(grid[i][j] == 0){\\n                    emptySquares++;\\n                }\\n            }\\n        }\\n        \\n        return countPaths(start[0], start[1], grid, emptySquares);\\n    }\\n    \\n    private int countPaths(int row, int col, int[][] grid, int emptySquares){\\n        if(row<0 || col<0 || row>=grid.length || col>=grid[0].length){\\n            return 0;\\n        }else if(grid[row][col] == -1 || grid[row][col] == 3){\\n            return 0;\\n        }else if(grid[row][col] == 2){\\n            return emptySquares == -1 ? 1 : 0;\\n        }\\n        \\n        grid[row][col] = 3;\\n        \\n        int countPaths = 0;\\n        \\n        for(int[] d : directions){\\n            countPaths += countPaths(row+d[0], col+d[1], grid, emptySquares-1);\\n        }\\n        \\n        grid[row][col] = 0;\\n        return countPaths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390421,
                "title": "c-backtracking-solution-commented",
                "content": "This problem is a slight modification of the `rat in a maze` problem, the only difference being: we have to find only those paths that cover every block (except the hurdles of course). So, a simple modification in the base case is, we have to return only that path for which all the blocks have been visited. (Now try again without looking at the code below.)\\n``` \\nint getPaths(int i, int j, vector<vector<int>> &mat, int m, int n, vector<vector<int>> &visited, int* di, int* dj){\\n        if (i<0 || j<0 || i==m || j==n || visited[i][j]==1 || mat[i][j]==-1)\\n            return 0;\\n        \\n        if (mat[i][j]==2){  // base case (hit the target)\\n            for (int a=0;a<m;a++)  // checking if any block in the visited array is unvisited\\n                for (int b=0;b<n;b++)\\n                    if (mat[a][b]!=-1 && mat[a][b]!=2 && visited[a][b]==0)\\n                        return 0;\\n            return 1;\\n        }\\n\\n        visited[i][j] = 1;\\n        int counter = 0;\\n        for (int k=0;k<4;k++)\\n            counter += getPaths(i+di[k], j+dj[k], mat, m, n, visited, di, dj);\\n        visited[i][j] = 0;\\n        return counter;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int di[4] = {1, 0, -1, 0};\\n        int dj[4] = {0, 1, 0, -1};\\n        int i, j;\\n        bool flag = false;\\n        for (i=0; i<m && flag==false; i++)  // searching for the starting point (grid[i][j]=1)\\n            for (j=0;j<n;j++)\\n                if (grid[i][j]==1){\\n                    flag = true;\\n                    break;\\n                }\\n        return getPaths(--i, j, grid, m, n, visited, di, dj);  // --i to get the correct position of the starting point (due to the method used to break out of 2 for loops)\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\nint getPaths(int i, int j, vector<vector<int>> &mat, int m, int n, vector<vector<int>> &visited, int* di, int* dj){\\n        if (i<0 || j<0 || i==m || j==n || visited[i][j]==1 || mat[i][j]==-1)\\n            return 0;\\n        \\n        if (mat[i][j]==2){  // base case (hit the target)\\n            for (int a=0;a<m;a++)  // checking if any block in the visited array is unvisited\\n                for (int b=0;b<n;b++)\\n                    if (mat[a][b]!=-1 && mat[a][b]!=2 && visited[a][b]==0)\\n                        return 0;\\n            return 1;\\n        }\\n\\n        visited[i][j] = 1;\\n        int counter = 0;\\n        for (int k=0;k<4;k++)\\n            counter += getPaths(i+di[k], j+dj[k], mat, m, n, visited, di, dj);\\n        visited[i][j] = 0;\\n        return counter;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int di[4] = {1, 0, -1, 0};\\n        int dj[4] = {0, 1, 0, -1};\\n        int i, j;\\n        bool flag = false;\\n        for (i=0; i<m && flag==false; i++)  // searching for the starting point (grid[i][j]=1)\\n            for (j=0;j<n;j++)\\n                if (grid[i][j]==1){\\n                    flag = true;\\n                    break;\\n                }\\n        return getPaths(--i, j, grid, m, n, visited, di, dj);  // --i to get the correct position of the starting point (due to the method used to break out of 2 for loops)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373845,
                "title": "c-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int answer , countZeros , n , m;\\n    bool vis[30][30];\\n    \\n    bool valid(int i,int j){\\n        return (i>=0 and j>=0 and i<n and j<m);\\n    }\\n    \\n    void dfs(int i,int j,int ct0,vector<vector<int>>& grid){\\n        if(valid(i,j) == 0 or vis[i][j] or grid[i][j] == -1)\\n            return;\\n        vis[i][j] = 1;\\n        if(grid[i][j] == 0)\\n            ++ct0;\\n        if(ct0 == countZeros and grid[i][j] == 2)\\n            ++answer;\\n        \\n        dfs(i+1,j,ct0,grid);\\n        dfs(i,j+1,ct0,grid);\\n        dfs(i-1,j,ct0,grid);\\n        dfs(i,j-1,ct0,grid);\\n        \\n        if(grid[i][j] == 0)\\n            --ct0;\\n        vis[i][j] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        answer = 0 , countZeros = 0;\\n        memset(vis,0,sizeof vis);\\n        for(auto it : grid){\\n            for(auto it2 : it)\\n                countZeros += (it2 == 0);\\n        }\\n        n = grid.size() , m = grid[0].size();\\n        \\n        int startx, starty , flag = 1;\\n        for(int i=0;i<n and flag;++i){\\n            for(int j=0;j<m and flag;++j){\\n                if(grid[i][j] == 1){\\n                    startx = i, starty = j;\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n        }\\n        dfs(startx,starty,0,grid);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int answer , countZeros , n , m;\\n    bool vis[30][30];\\n    \\n    bool valid(int i,int j){\\n        return (i>=0 and j>=0 and i<n and j<m);\\n    }\\n    \\n    void dfs(int i,int j,int ct0,vector<vector<int>>& grid){\\n        if(valid(i,j) == 0 or vis[i][j] or grid[i][j] == -1)\\n            return;\\n        vis[i][j] = 1;\\n        if(grid[i][j] == 0)\\n            ++ct0;\\n        if(ct0 == countZeros and grid[i][j] == 2)\\n            ++answer;\\n        \\n        dfs(i+1,j,ct0,grid);\\n        dfs(i,j+1,ct0,grid);\\n        dfs(i-1,j,ct0,grid);\\n        dfs(i,j-1,ct0,grid);\\n        \\n        if(grid[i][j] == 0)\\n            --ct0;\\n        vis[i][j] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        answer = 0 , countZeros = 0;\\n        memset(vis,0,sizeof vis);\\n        for(auto it : grid){\\n            for(auto it2 : it)\\n                countZeros += (it2 == 0);\\n        }\\n        n = grid.size() , m = grid[0].size();\\n        \\n        int startx, starty , flag = 1;\\n        for(int i=0;i<n and flag;++i){\\n            for(int j=0;j<m and flag;++j){\\n                if(grid[i][j] == 1){\\n                    startx = i, starty = j;\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n        }\\n        dfs(startx,starty,0,grid);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333542,
                "title": "c-solution-with-explanation",
                "content": "**This problem is similar to basic backtracking problems like find the shortest path from start to bottom if you don\\'t know that one then try them first and then come to this problem **\\n\\n**So lets begin, in this problem it is given that we have to find no. of ways to reach end from start so 1st thing in our mind is to where is start so we first find it by finding it index and we have to cover all routes that have values zero so 2nd thing in our mind is how many zero we have to covered to reach end so for this we calculate no. of zeroes **\\n**Now the problem is simplified to basic backtracking problem where we have to go in all directions and if we covered all zeroes then we have to return it as valid path or otherwise not valid and sum up all the valid paths  **\\n```\\nclass Solution {\\npublic:\\n       int rec(vector<vector<int>>& grid , int x , int y , int zero){ \\n         if(x < 0 ||y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1 ) return 0; \\n      if(grid[x][y] == 2){     \\n      if(zero == -1){\\n          return 1; \\n      } return 0; \\n          }\\n           grid[x][y] = -1;\\n          int paths =  rec(grid , x-1 , y , zero-1) + rec(grid ,  x+1 , y  , zero-1) + rec(grid ,  x , y-1  , zero-1) + rec(grid ,  x , y+1  , zero-1);  \\n           grid[x][y] = 0; \\n           zero++; \\n       return paths;\\n       }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int start  = 0 ; \\n        int end = 0; \\n        int zero  = 0; \\n          for( int i = 0; i < grid.size() ; i++){ \\n              for(int j = 0; j<grid[0].size() ; j++){ \\n                  if(grid[i][j] ==  1 ) { \\n                    start = i; \\n                      end = j; \\n                  }\\n                  if(grid[i][j] == 0) zero++; \\n              }\\n          }  \\n      return rec(grid , start , end , zero);   \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n       int rec(vector<vector<int>>& grid , int x , int y , int zero){ \\n         if(x < 0 ||y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1 ) return 0; \\n      if(grid[x][y] == 2){     \\n      if(zero == -1){\\n          return 1; \\n      } return 0; \\n          }\\n           grid[x][y] = -1;\\n          int paths =  rec(grid , x-1 , y , zero-1) + rec(grid ,  x+1 , y  , zero-1) + rec(grid ,  x , y-1  , zero-1) + rec(grid ,  x , y+1  , zero-1);  \\n           grid[x][y] = 0; \\n           zero++; \\n       return paths;\\n       }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int start  = 0 ; \\n        int end = 0; \\n        int zero  = 0; \\n          for( int i = 0; i < grid.size() ; i++){ \\n              for(int j = 0; j<grid[0].size() ; j++){ \\n                  if(grid[i][j] ==  1 ) { \\n                    start = i; \\n                      end = j; \\n                  }\\n                  if(grid[i][j] == 0) zero++; \\n              }\\n          }  \\n      return rec(grid , start , end , zero);   \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252027,
                "title": "simple-java-solution-commented",
                "content": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] A) {\\n\\t\\tint i = 0, j = 0, n = A.length, m = A[0].length;\\n\\t\\tint p = 0, q = 0, zero = 0;\\n\\t\\tfor (i = 0; i < n; i++) {\\n\\t\\t\\tfor (j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (A[i][j] == 1) {\\n\\t\\t\\t\\t\\tp = i;\\n\\t\\t\\t\\t\\tq = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (A[i][j] == 0)\\n\\t\\t\\t\\t\\tzero += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//p and q are starting position\\n\\t\\tint totalPath = getPathCount(p, q, A, zero, 0);\\n\\t\\treturn totalPath;\\n\\t}\\n\\n\\tprivate int getPathCount(int x, int y, int[][] path, int zero, int cnt) {\\n\\t   // If any of this condition is true we will not be having any path. (checking for out of bound and          obstacle)\\n\\t\\tif (x < 0 || y < 0 || x == path.length || y == path[0].length || path[x][y] == -1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (path[x][y] == 2) {\\n\\t\\t    // Found path, then check for total non-obstacle .\\n\\t\\t\\tif (cnt == zero + 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tpath[x][y] = -1;  // making this grid as obstacle to avoid looping in same path \\n\\t\\tcnt += 1;  \\n\\t\\tint d1 = getPathCount(x + 1, y, path, zero, cnt);\\n\\t\\tint d2 = getPathCount(x - 1, y, path, zero, cnt);\\n\\t\\tint d3 = getPathCount(x, y + 1, path, zero, cnt);\\n\\t\\tint d4 = getPathCount(x, y - 1, path, zero, cnt);\\n\\t\\tpath[x][y] = 0;  // re-setting path as non-obstacle.\\n\\t\\treturn d1 + d2 + d3 + d4;\\n\\n\\t}\\n}\\n```\\n**Time Complexity:**\\nSince for every sqaure we are traversing in 4 direction and we can have (N*M)-2  sqaure with 0 (in worst case).\\nTC: O(4^NM) \\n\\n**Space Complexity:**\\nSC: O(NM)",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] A) {\\n\\t\\tint i = 0, j = 0, n = A.length, m = A[0].length;\\n\\t\\tint p = 0, q = 0, zero = 0;\\n\\t\\tfor (i = 0; i < n; i++) {\\n\\t\\t\\tfor (j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (A[i][j] == 1) {\\n\\t\\t\\t\\t\\tp = i;\\n\\t\\t\\t\\t\\tq = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (A[i][j] == 0)\\n\\t\\t\\t\\t\\tzero += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//p and q are starting position\\n\\t\\tint totalPath = getPathCount(p, q, A, zero, 0);\\n\\t\\treturn totalPath;\\n\\t}\\n\\n\\tprivate int getPathCount(int x, int y, int[][] path, int zero, int cnt) {\\n\\t   // If any of this condition is true we will not be having any path. (checking for out of bound and          obstacle)\\n\\t\\tif (x < 0 || y < 0 || x == path.length || y == path[0].length || path[x][y] == -1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (path[x][y] == 2) {\\n\\t\\t    // Found path, then check for total non-obstacle .\\n\\t\\t\\tif (cnt == zero + 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tpath[x][y] = -1;  // making this grid as obstacle to avoid looping in same path \\n\\t\\tcnt += 1;  \\n\\t\\tint d1 = getPathCount(x + 1, y, path, zero, cnt);\\n\\t\\tint d2 = getPathCount(x - 1, y, path, zero, cnt);\\n\\t\\tint d3 = getPathCount(x, y + 1, path, zero, cnt);\\n\\t\\tint d4 = getPathCount(x, y - 1, path, zero, cnt);\\n\\t\\tpath[x][y] = 0;  // re-setting path as non-obstacle.\\n\\t\\treturn d1 + d2 + d3 + d4;\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219366,
                "title": "dfs-and-backtracking",
                "content": "This question uses DFS or flood fill algorithm to traverse the grid.\\nStep 1: Find the starting point in the given grid\\nStep 2: Make a **visited matrix** and **initialize it to 0** also make an **answer variable** and **initialize it to 0** as well\\nStep 3: Make a call to the DFS function \\n____________DFS function accepts  following parameters:-\\n__________GRID , ROW INDEX(starting) , COLUMN INDEX(starting), ans, visited \\n\\n\\n\\n**Inside DFS function:**\\n\\nStep 1: Check the **validity of row and column** also **check if it is non movable block** and **check for visited**. If any of the conditions are met we just return\\nStep 2: Check if the position we are current on is the ending position or not\\n--->**if yes,**  then traverse the **entire visited matrix** , if any block is not visited just return.\\n--->**else**, if every block is visited** increment the ans by  1 and return**\\n Step 3: If it is **not the final position** then **mark the visited as 1**  and perform DFS on the neighbouring cells \\n -->i,e.** row+1, col  || row-1, col || row, col+1 || row, col-1**\\n \\n After  all the DFS calls are completed just return the ans from the main function\\n \\n```\\n\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&grid,int row,int col,int &ans,vector<vector<int>>vis){\\n//// CHECK FOR ALL THE INVALID CASES\\nif(row<0 || row>=grid.size() || col<0 || col>=grid[0].size() || vis[row][col]==1 || grid[row][col]==-1){\\nreturn;\\n}\\n\\n/// CHECK FOR ENDING POSITION\\nif(grid[row][col]==2){\\nvis[row][col]=1;\\nfor(int i=0;i<grid.size();i++){\\nfor(int j=0;j<grid[0].size();j++){\\nif(vis[i][j]==0 and grid[i][j]!=-1){\\nreturn;\\n}\\n\\n}\\n}\\nans+=1;\\nreturn;\\n}\\n\\n//// MARKING THE VISITED AS TRUE \\nvis[row][col]=1;\\n\\n//// DFS CALL FOR THE NEIGHBOURS\\nsolve(grid,row+1,col,ans,vis);\\nsolve(grid,row-1,col,ans,vis);\\nsolve(grid,row,col+1,ans,vis);\\nsolve(grid,row,col-1,ans,vis);\\n\\n}\\nint uniquePathsIII(vector<vector<int>>& grid) {\\nint ans=0;\\nint n=grid.size();\\nint m=grid[0].size();\\nint i=0;\\nint j=0;\\n\\n////  VISITED ARRAY \\nvector<vector<int>>vis(n,vector<int>(m,0));\\n\\n///// FINDING THE STARTING ROW  AND COLUMN \\nfor(;i<n;i++){\\nfor(j=0;j<m;j++){\\nif(grid[i][j]==1)break;\\n}\\nif(j!=m)break;\\n}\\n\\n/// CALLING THE DFS FUNCTION \\nsolve(grid,i,j,ans,vis);\\n\\n\\nreturn ans;\\n}\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&grid,int row,int col,int &ans,vector<vector<int>>vis){\\n//// CHECK FOR ALL THE INVALID CASES\\nif(row<0 || row>=grid.size() || col<0 || col>=grid[0].size() || vis[row][col]==1 || grid[row][col]==-1){\\nreturn;\\n}\\n\\n/// CHECK FOR ENDING POSITION\\nif(grid[row][col]==2){\\nvis[row][col]=1;\\nfor(int i=0;i<grid.size();i++){\\nfor(int j=0;j<grid[0].size();j++){\\nif(vis[i][j]==0 and grid[i][j]!=-1){\\nreturn;\\n}\\n\\n}\\n}\\nans+=1;\\nreturn;\\n}\\n\\n//// MARKING THE VISITED AS TRUE \\nvis[row][col]=1;\\n\\n//// DFS CALL FOR THE NEIGHBOURS\\nsolve(grid,row+1,col,ans,vis);\\nsolve(grid,row-1,col,ans,vis);\\nsolve(grid,row,col+1,ans,vis);\\nsolve(grid,row,col-1,ans,vis);\\n\\n}\\nint uniquePathsIII(vector<vector<int>>& grid) {\\nint ans=0;\\nint n=grid.size();\\nint m=grid[0].size();\\nint i=0;\\nint j=0;\\n\\n////  VISITED ARRAY \\nvector<vector<int>>vis(n,vector<int>(m,0));\\n\\n///// FINDING THE STARTING ROW  AND COLUMN \\nfor(;i<n;i++){\\nfor(j=0;j<m;j++){\\nif(grid[i][j]==1)break;\\n}\\nif(j!=m)break;\\n}\\n\\n/// CALLING THE DFS FUNCTION \\nsolve(grid,i,j,ans,vis);\\n\\n\\nreturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113808,
                "title": "java-better-than-100-of-submissions-backtracking",
                "content": "```\\nclass Solution {\\n    int res=0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero=0,is=0,js=0,ie=0,je=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0)   zero++;\\n                else if(grid[i][j]==1){\\n                    is=i;\\n                    js=j;\\n                }\\n                else if(grid[i][j]==2){\\n                    ie=i;\\n                    je=j;\\n                }\\n            }\\n        }\\n        func(grid,is+1,js,zero);\\n        func(grid,is-1,js,zero);\\n        func(grid,is,js+1,zero);\\n        func(grid,is,js-1,zero);\\n        return res;\\n    }\\n    private void func(int[][] g, int i, int j, int zero){\\n        if(i<0 || i==g.length || j<0 || j==g[0].length) return;\\n        else if(g[i][j]==2){\\n            if(zero==0)  res++;\\n            return;\\n        }\\n        else if(g[i][j]==-1)    return;\\n        else if(g[i][j]==1) return;\\n        g[i][j]=-1;\\n        zero--;\\n        func(g,i+1,j,zero);\\n        func(g,i-1,j,zero);\\n        func(g,i,j+1,zero);\\n        func(g,i,j-1,zero);\\n        zero++;\\n        g[i][j]=0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero=0,is=0,js=0,ie=0,je=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0)   zero++;\\n                else if(grid[i][j]==1){\\n                    is=i;\\n                    js=j;\\n                }\\n                else if(grid[i][j]==2){\\n                    ie=i;\\n                    je=j;\\n                }\\n            }\\n        }\\n        func(grid,is+1,js,zero);\\n        func(grid,is-1,js,zero);\\n        func(grid,is,js+1,zero);\\n        func(grid,is,js-1,zero);\\n        return res;\\n    }\\n    private void func(int[][] g, int i, int j, int zero){\\n        if(i<0 || i==g.length || j<0 || j==g[0].length) return;\\n        else if(g[i][j]==2){\\n            if(zero==0)  res++;\\n            return;\\n        }\\n        else if(g[i][j]==-1)    return;\\n        else if(g[i][j]==1) return;\\n        g[i][j]=-1;\\n        zero--;\\n        func(g,i+1,j,zero);\\n        func(g,i-1,j,zero);\\n        func(g,i,j+1,zero);\\n        func(g,i,j-1,zero);\\n        zero++;\\n        g[i][j]=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096139,
                "title": "c-bitmask-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    using pii = pair<int, int>;\\n    using vi = vector<int>;\\n    using vii = vector<vi>;\\n    using viii = vector<vii>;\\n\\n    int rows;\\n    int cols;\\n    int validCells;\\n    viii dp;\\n\\n    int piiToNum(pii point) {\\n        return point.first * cols + point.second;\\n    }\\n    \\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, -1, 1};\\n    \\n    int solve(pii now, pii target, int mask, vector<vector<int>>& grid) {\\n        if (now == target) {\\n            return validCells == __builtin_popcount(mask);\\n        }\\n        int& ret = dp[now.first][now.second][mask];\\n        if (ret != -1) {\\n            return ret;\\n        }\\n        \\n        ret = 0;\\n        for (int k = 0; k < 4; k++) {\\n            pii nxt = {now.first + dx[k], now.second + dy[k]};\\n            if (nxt.first >= 0 && nxt.first < rows && nxt.second >= 0 && nxt.second < cols && grid[nxt.first][nxt.second] != -1) {\\n                int bit = piiToNum(nxt);\\n                if (!(mask & (1 << bit)) && grid[nxt.first][nxt.second] != -1) {\\n                    ret += solve(nxt, target, mask | (1 << bit), grid);\\n                }   \\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        rows = grid.size();\\n        cols = grid[0].size();\\n        \\n        int obstacles = 0;\\n        pii start, target;\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == -1) {\\n                    obstacles++;\\n                } else if (grid[i][j] == 1) {\\n                    start = {i, j};\\n                } else if (grid[i][j] == 2) {\\n                    target = {i, j};\\n                }\\n            }\\n        }\\n        \\n        validCells = rows * cols - obstacles;\\n        dp = viii(rows, vii(cols, vi(1 << (rows * cols), -1)));\\n        \\n        return solve(start, target, 1 << piiToNum(start), grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using pii = pair<int, int>;\\n    using vi = vector<int>;\\n    using vii = vector<vi>;\\n    using viii = vector<vii>;\\n\\n    int rows;\\n    int cols;\\n    int validCells;\\n    viii dp;\\n\\n    int piiToNum(pii point) {\\n        return point.first * cols + point.second;\\n    }\\n    \\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, -1, 1};\\n    \\n    int solve(pii now, pii target, int mask, vector<vector<int>>& grid) {\\n        if (now == target) {\\n            return validCells == __builtin_popcount(mask);\\n        }\\n        int& ret = dp[now.first][now.second][mask];\\n        if (ret != -1) {\\n            return ret;\\n        }\\n        \\n        ret = 0;\\n        for (int k = 0; k < 4; k++) {\\n            pii nxt = {now.first + dx[k], now.second + dy[k]};\\n            if (nxt.first >= 0 && nxt.first < rows && nxt.second >= 0 && nxt.second < cols && grid[nxt.first][nxt.second] != -1) {\\n                int bit = piiToNum(nxt);\\n                if (!(mask & (1 << bit)) && grid[nxt.first][nxt.second] != -1) {\\n                    ret += solve(nxt, target, mask | (1 << bit), grid);\\n                }   \\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        rows = grid.size();\\n        cols = grid[0].size();\\n        \\n        int obstacles = 0;\\n        pii start, target;\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == -1) {\\n                    obstacles++;\\n                } else if (grid[i][j] == 1) {\\n                    start = {i, j};\\n                } else if (grid[i][j] == 2) {\\n                    target = {i, j};\\n                }\\n            }\\n        }\\n        \\n        validCells = rows * cols - obstacles;\\n        dp = viii(rows, vii(cols, vi(1 << (rows * cols), -1)));\\n        \\n        return solve(start, target, 1 << piiToNum(start), grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061049,
                "title": "python-backtracking-with-comments",
                "content": "The most important thing to keep in mind is the conditions:\\n- walk over every \"0\"?\\n\\t- For this, we need to count how many zeros we have first, no?\\n- do not walk over any -1\\n\\t- This can be a termination condition\\n- start at 1\\n\\t- Only start the backtracking if we reach a 1\\n- end at 2\\n\\t- If we reach a two and have touched all of the zeros, we can return/count this as one path!\\n\\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        \\n        global result\\n        result = 0\\n                    \\n        def backtrack(i, j, squares):\\n            global result\\n            \\n\\t\\t\\t# all the code below here is pretty much termination conditions from above bullet points...\\n\\t\\t\\t\\n            if not (0 <= i < len(grid)): return\\n            if not (0 <= j < len(grid[0])): return\\n            \\n            if grid[i][j] == -1: return # ignore obstacles\\n            \\n            if grid[i][j] == 2: # return\\n                if squares == 0:\\n                    result += 1 # only add result if we\\'ve reached all squares\\n                return             \\n            \\n            if grid[i][j] == 0:\\n                squares -= 1 # one less square to touch\\n\\t\\t\\t\\t\\n\\t\\t\\t# backtracking code to avoid walking in circles\\n\\t\\t\\t# ....\\n                \\n            grid[i][j] = -1\\n                \\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                backtrack(x, y, squares)\\n                \\n            grid[i][j] = 0\\n                \\n                                \\n        # Figure out how many zeros we need?\\n        num_zeros = 0\\n        for i in grid:\\n            num_zeros += collections.Counter(i)[0]\\n               \\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    backtrack(i, j, num_zeros)\\n        \\n        return result\\n```\\n\\n---\\n\\nCode without comments:\\n\\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        \\n\\t\\t\\n        global result\\n        result = 0\\n\\t\\t\\n                    \\n        def backtrack(i, j, squares):\\n            global result\\n            \\n            if not (0 <= i < len(grid)): return\\n            if not (0 <= j < len(grid[0])): return\\n            if grid[i][j] == -1: return\\n\\t\\t\\tif grid[i][j] == 0: squares -= 1\\n            if grid[i][j] == 2:\\n                if squares == 0: result += 1\\n                return\\n\\t\\t\\t\\t\\n            grid[i][j] = -1\\n\\t\\t\\t\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                backtrack(x, y, squares)\\n\\t\\t\\t\\t\\n            grid[i][j] = 0\\n\\t\\t\\n                \\n        num_zeros = 0\\n        for i in grid:\\n            num_zeros += collections.Counter(i)[0]\\n\\t\\t\\n               \\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    backtrack(i, j, num_zeros)\\n        \\n\\t\\t\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        \\n        global result\\n        result = 0\\n                    \\n        def backtrack(i, j, squares):\\n            global result\\n            \\n\\t\\t\\t# all the code below here is pretty much termination conditions from above bullet points...\\n\\t\\t\\t\\n            if not (0 <= i < len(grid)): return\\n            if not (0 <= j < len(grid[0])): return\\n            \\n            if grid[i][j] == -1: return # ignore obstacles\\n            \\n            if grid[i][j] == 2: # return\\n                if squares == 0:\\n                    result += 1 # only add result if we\\'ve reached all squares\\n                return             \\n            \\n            if grid[i][j] == 0:\\n                squares -= 1 # one less square to touch\\n\\t\\t\\t\\t\\n\\t\\t\\t# backtracking code to avoid walking in circles\\n\\t\\t\\t# ....\\n                \\n            grid[i][j] = -1\\n                \\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                backtrack(x, y, squares)\\n                \\n            grid[i][j] = 0\\n                \\n                                \\n        # Figure out how many zeros we need?\\n        num_zeros = 0\\n        for i in grid:\\n            num_zeros += collections.Counter(i)[0]\\n               \\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    backtrack(i, j, num_zeros)\\n        \\n        return result\\n```\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        \\n\\t\\t\\n        global result\\n        result = 0\\n\\t\\t\\n                    \\n        def backtrack(i, j, squares):\\n            global result\\n            \\n            if not (0 <= i < len(grid)): return\\n            if not (0 <= j < len(grid[0])): return\\n            if grid[i][j] == -1: return\\n\\t\\t\\tif grid[i][j] == 0: squares -= 1\\n            if grid[i][j] == 2:\\n                if squares == 0: result += 1\\n                return\\n\\t\\t\\t\\t\\n            grid[i][j] = -1\\n\\t\\t\\t\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                backtrack(x, y, squares)\\n\\t\\t\\t\\t\\n            grid[i][j] = 0\\n\\t\\t\\n                \\n        num_zeros = 0\\n        for i in grid:\\n            num_zeros += collections.Counter(i)[0]\\n\\t\\t\\n               \\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    backtrack(i, j, num_zeros)\\n        \\n\\t\\t\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936811,
                "title": "java-dfs-solution",
                "content": "credits to : @lee215\\n```\\nclass Solution {\\n    int ans = 0;\\n    int totalEmpty = 1;\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        int row = -1;\\n        int col = -1;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    row = i;\\n                    col = j;\\n                }else if(grid[i][j] == 0){\\n                    totalEmpty++;\\n                }\\n            }\\n        }\\n        \\n        dfs(grid, row, col);\\n        return ans;\\n    }\\n    \\n    public void dfs(int [][]grid, int r, int c){\\n        \\n        if(r < 0 || c <0 || r >= grid.length || c >= grid[0].length || grid[r][c] < 0)\\n            return;\\n        \\n        if(grid[r][c] == 2){\\n            if(totalEmpty == 0)\\n            ans += 1;\\n            return;\\n        }\\n        \\n        grid[r][c] = -2;\\n        totalEmpty--;\\n        dfs(grid, r+1,c);\\n        dfs(grid, r-1,c);\\n        dfs(grid, r,c+1);\\n        dfs(grid, r,c-1);\\n        grid[r][c] = 0;\\n        totalEmpty++;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    int totalEmpty = 1;\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        int row = -1;\\n        int col = -1;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    row = i;\\n                    col = j;\\n                }else if(grid[i][j] == 0){\\n                    totalEmpty++;\\n                }\\n            }\\n        }\\n        \\n        dfs(grid, row, col);\\n        return ans;\\n    }\\n    \\n    public void dfs(int [][]grid, int r, int c){\\n        \\n        if(r < 0 || c <0 || r >= grid.length || c >= grid[0].length || grid[r][c] < 0)\\n            return;\\n        \\n        if(grid[r][c] == 2){\\n            if(totalEmpty == 0)\\n            ans += 1;\\n            return;\\n        }\\n        \\n        grid[r][c] = -2;\\n        totalEmpty--;\\n        dfs(grid, r+1,c);\\n        dfs(grid, r-1,c);\\n        dfs(grid, r,c+1);\\n        dfs(grid, r,c-1);\\n        grid[r][c] = 0;\\n        totalEmpty++;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899021,
                "title": "java-100-fast-explained-dfs",
                "content": "If you found the solution helpful, kindly upvote. :)\\n       \\n\\t   **METHOD**\\n\\t   \\n        1. Count the total number of zeroes in the grid\\n        2. Find the coordinates of the starting index and store it.\\n        3. Call dfs in all 4 directions, and if the path has all zeroes covered, increment result.\\n \\n\\n```\\nclass Solution {\\n        public int uniquePathsIII(int[][] grid) {\\n        /*\\n        \\n        */\\n        \\n        int rows= grid.length;\\n        int cols= grid[0].length;\\n        int numZero=0, sx=0, sy=0;\\n\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j]==1){\\n                    sx=i; sy=j;\\n                }\\n                else if(grid[i][j]==0)\\n                    numZero++;\\n            }\\n        }\\n        \\n        return dfs(grid, sx, sy, numZero);\\n    }\\n\\n    private int dfs(int[][] grid, int sx, int sy, int numZero) {\\n        //Boundary checks\\n        if(sx<0 || sy<0 ||sx>=grid.length || sy>=grid[0].length || grid[sx][sy]==-1)\\n            return 0;\\n        //If the destination is reached\\n        if(grid[sx][sy]==2)\\n            return numZero==-1? 1:0;\\n\\n        //Marking the cell\\n        grid[sx][sy]=-1;\\n        numZero--;\\n        int totalPath= dfs(grid, sx+1, sy, numZero)+\\n                        dfs(grid, sx-1, sy, numZero)+\\n                        dfs(grid, sx, sy+1, numZero)+\\n                        dfs(grid, sx, sy-1, numZero);\\n        //Backtracking\\n        grid[sx][sy]=0;\\n        numZero++;\\n        return totalPath;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int uniquePathsIII(int[][] grid) {\\n        /*\\n        \\n        */\\n        \\n        int rows= grid.length;\\n        int cols= grid[0].length;\\n        int numZero=0, sx=0, sy=0;\\n\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j]==1){\\n                    sx=i; sy=j;\\n                }\\n                else if(grid[i][j]==0)\\n                    numZero++;\\n            }\\n        }\\n        \\n        return dfs(grid, sx, sy, numZero);\\n    }\\n\\n    private int dfs(int[][] grid, int sx, int sy, int numZero) {\\n        //Boundary checks\\n        if(sx<0 || sy<0 ||sx>=grid.length || sy>=grid[0].length || grid[sx][sy]==-1)\\n            return 0;\\n        //If the destination is reached\\n        if(grid[sx][sy]==2)\\n            return numZero==-1? 1:0;\\n\\n        //Marking the cell\\n        grid[sx][sy]=-1;\\n        numZero--;\\n        int totalPath= dfs(grid, sx+1, sy, numZero)+\\n                        dfs(grid, sx-1, sy, numZero)+\\n                        dfs(grid, sx, sy+1, numZero)+\\n                        dfs(grid, sx, sy-1, numZero);\\n        //Backtracking\\n        grid[sx][sy]=0;\\n        numZero++;\\n        return totalPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878600,
                "title": "java-backtracking-clean-code-with-full-comments-100-speed-95-29-space",
                "content": "```\\n    int count = 0;  // Set counter.\\n    int startPointX = 0; // Set index for the starting point.\\n    int startPointY = 0;\\n    \\n    public int uniquePathsIII(int[][] grid) // Main method.\\n    {\\n       for(int i = 0; i < grid.length; i++) // The nested for loops are responsible for locating the starting point.\\n       {\\n           for(int j = 0; j < grid[0].length; j++)\\n           {\\n               if(grid[i][j] == 1) // When the starting point has been found, assigned the starting index x & y.\\n               {\\n                   startPointX = i;\\n                   startPointY = j;\\n               }\\n               if(grid[i][j] == 0) // When the value in a given spot are zero, count it.\\n               {\\n                   count++;\\n               }\\n           }\\n       }\\n          return helper(grid, startPointX, startPointY, count); \\n    }\\n    \\n    private int helper(int[][] grid, int x, int y, int count) // Helper method.\\n    {\\n        \\n        if(x < 0 || grid.length-1 < x || y < 0 || grid[0].length-1 < y || grid[x][y] == -1) // Boundaries, visited spots and forbidden spots check.\\n        {\\n            return 0;\\n        }\\n        \\n        if(grid[x][y] == 2) // If we stumbled upon a spot with value of two, thats mean that we have finish the current iteration.\\n        {\\n            if(count == -1) // Check for valid count.\\n            {\\n                return 1;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n            int temp = grid[x][y]; // Copy a current spots value in order to not repeat it in the current iteration.\\n            grid[x][y] = -1; // Overwrite the current value white zero so that we will know that we have been here before.\\n            count--;\\n\\t\\t\\t\\n            int up = helper(grid, x-1, y,count);   // valid movements for traversing the matrix.\\n            int down = helper(grid, x+1, y, count);\\n            int left = helper(grid, x, y-1, count);\\n            int right = helper(grid, x, y+1,count);\\n            \\n            grid[x][y] = temp; // After traversing return the original value of a spot for the next iteration.\\n            count++; // count the iteration.\\n            return up + down + left + right; // return a valid movement. (backtracking keeps all movements of a current iteration untill the end of it).\\n\\t\\t\\t\\n     }  // Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths III.\\n\\t    // Memory Usage: 36.4 MB, less than 95.29% of Java online submissions for Unique Paths III.",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n    int count = 0;  // Set counter.\\n    int startPointX = 0; // Set index for the starting point.\\n    int startPointY = 0;\\n    \\n    public int uniquePathsIII(int[][] grid) // Main method.\\n    {\\n       for(int i = 0; i < grid.length; i++) // The nested for loops are responsible for locating the starting point.\\n       {\\n           for(int j = 0; j < grid[0].length; j++)\\n           {\\n               if(grid[i][j] == 1) // When the starting point has been found, assigned the starting index x & y.\\n               {\\n                   startPointX = i;\\n                   startPointY = j;\\n               }\\n               if(grid[i][j] == 0) // When the value in a given spot are zero, count it.\\n               {\\n                   count++;\\n               }\\n           }\\n       }\\n          return helper(grid, startPointX, startPointY, count); \\n    }\\n    \\n    private int helper(int[][] grid, int x, int y, int count) // Helper method.\\n    {\\n        \\n        if(x < 0 || grid.length-1 < x || y < 0 || grid[0].length-1 < y || grid[x][y] == -1) // Boundaries, visited spots and forbidden spots check.\\n        {\\n            return 0;\\n        }\\n        \\n        if(grid[x][y] == 2) // If we stumbled upon a spot with value of two, thats mean that we have finish the current iteration.\\n        {\\n            if(count == -1) // Check for valid count.\\n            {\\n                return 1;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n            int temp = grid[x][y]; // Copy a current spots value in order to not repeat it in the current iteration.\\n            grid[x][y] = -1; // Overwrite the current value white zero so that we will know that we have been here before.\\n            count--;\\n\\t\\t\\t\\n            int up = helper(grid, x-1, y,count);   // valid movements for traversing the matrix.\\n            int down = helper(grid, x+1, y, count);\\n            int left = helper(grid, x, y-1, count);\\n            int right = helper(grid, x, y+1,count);\\n            \\n            grid[x][y] = temp; // After traversing return the original value of a spot for the next iteration.\\n            count++; // count the iteration.\\n            return up + down + left + right; // return a valid movement. (backtracking keeps all movements of a current iteration untill the end of it).\\n\\t\\t\\t\\n     }  // Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths III.\\n\\t    // Memory Usage: 36.4 MB, less than 95.29% of Java online submissions for Unique Paths III.",
                "codeTag": "Unknown"
            },
            {
                "id": 857674,
                "title": "simple-dfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f=0;\\n    void func(vector<vector<int>> grid,int i,int j,int c)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==-1 || grid[i][j]==3)\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==2 && c==0)\\n        {\\n            f++;\\n            return;\\n        }\\n        if(grid[i][j]==2)\\n        {\\n            return;\\n        }\\n        grid[i][j]=3; /// mark the point as visited\\n        func(grid,i,j+1,c-1);\\n        func(grid,i+1,j,c-1);\\n        func(grid,i-1,j,c-1);\\n        func(grid,i,j-1,c-1);\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int x,y,c=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                if(grid[i][j]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        func(grid,x,y,c+1);\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f=0;\\n    void func(vector<vector<int>> grid,int i,int j,int c)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==-1 || grid[i][j]==3)\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==2 && c==0)\\n        {\\n            f++;\\n            return;\\n        }\\n        if(grid[i][j]==2)\\n        {\\n            return;\\n        }\\n        grid[i][j]=3; /// mark the point as visited\\n        func(grid,i,j+1,c-1);\\n        func(grid,i+1,j,c-1);\\n        func(grid,i-1,j,c-1);\\n        func(grid,i,j-1,c-1);\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int x,y,c=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                if(grid[i][j]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        func(grid,x,y,c+1);\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856749,
                "title": "why-doesn-t-memoization-work",
                "content": "Could anyone explain why the following memoization strategy to reduce the time complexity gives a wrong answer?\\n\\nThe idea is the same as that of the official solution. We simply do the DFS with backtracking to count the number of answers. In addition, the following solution caches the solutions to subproblems in a 2D matrix `memo`.\\n\\n```java\\nclass Solution {\\n    int targetPathLen = 1;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int startRow = -1;\\n        int startCol= -1;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < m; col++) {\\n                if (grid[row][col] == 1) {\\n                    startRow = row;\\n                    startCol = col;\\n                } else if (grid[row][col] == 0) {\\n                    targetPathLen++;\\n                }\\n            }\\n        }\\n        \\n        boolean[][] onStack = new boolean[n][m];\\n        int[][] memo = new int[n][m];\\n        for (int row = 0; row < n; row++) {\\n            for(int col = 0; col < m; col++) {\\n                memo[row][col] = -1;\\n            }\\n        }\\n        \\n        return dfs(grid, startRow, startCol, onStack, memo, 0);\\n    }\\n    \\n    private int dfs(int[][] grid, int row, int col, boolean[][] onStack, int[][] memo, int coveredLen) {\\n        if (row < 0 || row > grid.length - 1 || col < 0 || col > grid[0].length - 1) {\\n            return 0;\\n        }\\n        \\n        int val = grid[row][col];\\n        if (val == -1 || onStack[row][col]) {\\n            return 0;\\n        }\\n        \\n        if (memo[row][col] != -1) {\\n            return memo[row][col];\\n        }\\n        \\n        if (val == 2) {\\n            if (targetPathLen == coveredLen) {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n    \\n        onStack[row][col] = true;\\n\\n        int ans = dfs(grid, row-1, col, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row+1, col, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row, col-1, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row, col+1, onStack, memo, coveredLen + 1);\\n\\n        onStack[row][col] = false;\\n\\n        memo[row][col] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int targetPathLen = 1;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int startRow = -1;\\n        int startCol= -1;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < m; col++) {\\n                if (grid[row][col] == 1) {\\n                    startRow = row;\\n                    startCol = col;\\n                } else if (grid[row][col] == 0) {\\n                    targetPathLen++;\\n                }\\n            }\\n        }\\n        \\n        boolean[][] onStack = new boolean[n][m];\\n        int[][] memo = new int[n][m];\\n        for (int row = 0; row < n; row++) {\\n            for(int col = 0; col < m; col++) {\\n                memo[row][col] = -1;\\n            }\\n        }\\n        \\n        return dfs(grid, startRow, startCol, onStack, memo, 0);\\n    }\\n    \\n    private int dfs(int[][] grid, int row, int col, boolean[][] onStack, int[][] memo, int coveredLen) {\\n        if (row < 0 || row > grid.length - 1 || col < 0 || col > grid[0].length - 1) {\\n            return 0;\\n        }\\n        \\n        int val = grid[row][col];\\n        if (val == -1 || onStack[row][col]) {\\n            return 0;\\n        }\\n        \\n        if (memo[row][col] != -1) {\\n            return memo[row][col];\\n        }\\n        \\n        if (val == 2) {\\n            if (targetPathLen == coveredLen) {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n    \\n        onStack[row][col] = true;\\n\\n        int ans = dfs(grid, row-1, col, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row+1, col, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row, col-1, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row, col+1, onStack, memo, coveredLen + 1);\\n\\n        onStack[row][col] = false;\\n\\n        memo[row][col] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856578,
                "title": "python-simple-concise-backtrack",
                "content": "```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        def isvalid(x, y): return 0 <= x < m and 0 <= y < n            \\n        def dfs(x, y, zeros_remaining):\\n            if zeros_remaining == 0:\\n                # find if there is end box\\n                for xx, yy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    if isvalid(x + xx, y + yy) and grid[x + xx][y + yy] == 2: self.path += 1\\n            else:\\n                # go to neighboring empty grid\\n                temp, grid[x][y] = grid[x][y], VISITED\\n                for xx, yy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    if isvalid(x + xx, y + yy) and grid[x + xx][y + yy] == 0: dfs(x + xx, y + yy, zeros_remaining - 1)\\n                grid[x][y] = temp\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # find start index, and count zeros\\n        zeros, startx, starty = 0, 0, 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1: startx, starty = r, c\\n                if grid[r][c] == 0: zeros += 1\\n\\t\\t\\t\\t\\n        self.path, VISITED = 0, \\'#\\'\\n        dfs(startx, starty, zeros)\\n        return self.path\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        def isvalid(x, y): return 0 <= x < m and 0 <= y < n            \\n        def dfs(x, y, zeros_remaining):\\n            if zeros_remaining == 0:\\n                # find if there is end box\\n                for xx, yy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    if isvalid(x + xx, y + yy) and grid[x + xx][y + yy] == 2: self.path += 1\\n            else:\\n                # go to neighboring empty grid\\n                temp, grid[x][y] = grid[x][y], VISITED\\n                for xx, yy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    if isvalid(x + xx, y + yy) and grid[x + xx][y + yy] == 0: dfs(x + xx, y + yy, zeros_remaining - 1)\\n                grid[x][y] = temp\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # find start index, and count zeros\\n        zeros, startx, starty = 0, 0, 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1: startx, starty = r, c\\n                if grid[r][c] == 0: zeros += 1\\n\\t\\t\\t\\t\\n        self.path, VISITED = 0, \\'#\\'\\n        dfs(startx, starty, zeros)\\n        return self.path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856354,
                "title": "alternative-solution-using-dp-and-bitmask-o-2-n-n",
                "content": "Most solutions with dfs / backtracking have runtime complexity O(3^N), where N is the number of cells. Alternative solution is to do this with dp and bitmask, which achieves a better runtime complexity of O(2^N * N).\\n\\nLet `bits` be a bitmap of current visited cells, `r` and `c` be current location. Traversing the four possible directions take O(1) time with memoization. If we ever reach 2 and all valid zeros in the bitmap has been set, we get a valid path. `dp` sums number of valid paths for all four directions.\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        count0 = sum([row.count(0) for row in grid])\\n        @lru_cache(None)\\n        def dp(bits, r, c):\\n            res = 0\\n            count1 = bin(bits).count(\\'1\\')\\n            nbits = bits | (1 << (r * C + c))\\n            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                nr = r + dr\\n                nc = c + dc\\n                if 0 <= nr < R and 0 <= nc < C:\\n                    if grid[nr][nc] == 0 and not ((bits >> (nr * C + nc)) & 1):\\n                        res += dp(nbits, nr, nc)\\n                    elif grid[nr][nc] == 2 and count1 == count0:\\n                        res += 1\\n            return res\\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == 1:    \\n                    return dp(0, r, c)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        count0 = sum([row.count(0) for row in grid])\\n        @lru_cache(None)\\n        def dp(bits, r, c):\\n            res = 0\\n            count1 = bin(bits).count(\\'1\\')\\n            nbits = bits | (1 << (r * C + c))\\n            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                nr = r + dr\\n                nc = c + dc\\n                if 0 <= nr < R and 0 <= nc < C:\\n                    if grid[nr][nc] == 0 and not ((bits >> (nr * C + nc)) & 1):\\n                        res += dp(nbits, nr, nc)\\n                    elif grid[nr][nc] == 2 and count1 == count0:\\n                        res += 1\\n            return res\\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == 1:    \\n                    return dp(0, r, c)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855687,
                "title": "simple-java-dfs-backtracking-solution-with-explanation-0-ms-100",
                "content": "**EXPLANATION**\\n\\n**Let me explain the problem statement first.**  *You need to find the count of all the paths from the source cell to target cell.  The only contraint here is that your path must traverse over all the 0s present in the grid.*\\n\\n**Brute force** idea is simple.  Whenever you find a *1, i.e. the starting cell*, start performing DFS from that cell.  Whene you reach a *2, i.e. the target cell*, check if there is any *0* remaining in the grid.  If there is a *0* remaining it means that all *0* have not been covered in the current path so return without incrementing the count.  If there is no remaining *0*, then increment the count and return.  Finally return the count.\\n\\n**Optimized solution** is even simpler.  Before starting the DFS traversal, count all the *0s* present in the grid and store it in a variable *totalZeros*.  Now, start the DFS from the starting cell, i.e. *1* and keep incrementing the current count of visited *0s* in the recursive function itself through the variable *currentZeros*.  In the base condition check the following:\\n\\n**if (current cell is the target cell) -> if *\"currentZeros\"* is equal to *\"totalZeros\"*, then return 1 else return 0.**\\n\\n*------This is the only modification required to optimize the normal DFS.------*\\n\\n**Note:**\\n\\n***We are initializing \"currentZeros\" with -1 because we are starting with the cell having value \"1\", i.e the starting cell. If we would have started \"currentZeros\" with 0, then the actual count when the recursion hits the target cell would have been (total number of zeros + 1) because it would have counted the cell having value \"1\" also.  Hence, for simplicity, we are initializing it with -1.***\\n\\nPlease upvote if you like the solution. Comment if you have any queries/doubts.\\n\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII (int[][] grid) {\\n        if (grid == null || grid.length == 0)\\n            return 0;\\n        int totalZeros = 0, x = 0, y = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid [i][j] == 0)\\n                    totalZeros++;\\n                if (grid [i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        return DFS (grid, totalZeros, -1, x, y);\\n    }\\n    \\n    public int DFS (int grid [][], int totalZeros, int currentZeros, int i, int j) {\\n        if (!isValid (grid, i, j))\\n            return 0;\\n        if (grid [i][j] == 2) {\\n            if (currentZeros == totalZeros)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        grid [i][j] = -1;\\n        int v1 = DFS (grid, totalZeros, currentZeros+1, i+1, j);\\n        int v2 = DFS (grid, totalZeros, currentZeros+1, i-1, j);\\n        int v3 = DFS (grid, totalZeros, currentZeros+1, i, j+1);\\n        int v4 = DFS (grid, totalZeros, currentZeros+1, i, j-1);\\n        grid [i][j] = 0;\\n        return (v1 + v2 + v3 + v4);\\n    }\\n    \\n    public boolean isValid (int grid [][], int i, int j) {\\n        if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid [i][j] != -1)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII (int[][] grid) {\\n        if (grid == null || grid.length == 0)\\n            return 0;\\n        int totalZeros = 0, x = 0, y = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid [i][j] == 0)\\n                    totalZeros++;\\n                if (grid [i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        return DFS (grid, totalZeros, -1, x, y);\\n    }\\n    \\n    public int DFS (int grid [][], int totalZeros, int currentZeros, int i, int j) {\\n        if (!isValid (grid, i, j))\\n            return 0;\\n        if (grid [i][j] == 2) {\\n            if (currentZeros == totalZeros)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        grid [i][j] = -1;\\n        int v1 = DFS (grid, totalZeros, currentZeros+1, i+1, j);\\n        int v2 = DFS (grid, totalZeros, currentZeros+1, i-1, j);\\n        int v3 = DFS (grid, totalZeros, currentZeros+1, i, j+1);\\n        int v4 = DFS (grid, totalZeros, currentZeros+1, i, j-1);\\n        grid [i][j] = 0;\\n        return (v1 + v2 + v3 + v4);\\n    }\\n    \\n    public boolean isValid (int grid [][], int i, int j) {\\n        if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid [i][j] != -1)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825590,
                "title": "java-dfs-backtracking-with-explanation-easy-to-understand",
                "content": "* Iterate through the grid once, record the start coordinate and count the number of total \"non-obstacle\" cells.\\n*  Using a boolean visited array, we could simply mark the obstacles as \"visited\" so that in helper method, if we meet the obstacle, return directly.\\n\\nHelper Method:\\n* In helper method, the two base cases are: \\n\\t* first check if the index i,j is still within boundary or if the cell has been visited. If not, return directly. \\n\\t* Otherwise, check when reach the end `2` if `remain` equals 1, if so, we\\'ve found a new path. `count += 1` and return. \\n* Recursive case is:\\n\\t* mark current cell as visited, visit all four directions.\\n\\t* after recursion, put the cell back to unvisited.\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int r = 0, c = 0; // start point\\n        int remain = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] >= 0) {\\n                    remain++;\\n                    if (grid[i][j] == 1){\\n                        r = i;\\n                        c = j;\\n                    } \\n                } else {\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        helper(grid, r, c, remain, visited);\\n        return count;\\n    }\\n    \\n    private void helper(int[][]grid, int i, int j, int remain, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= visited.length || j >= visited[0].length || visited[i][j] == true) {\\n            return;\\n        }\\n        if (grid[i][j] == 2 && remain == 1) {\\n            this.count+=1;\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        helper(grid, i+1, j, remain - 1, visited);\\n        helper(grid, i-1, j, remain - 1, visited);\\n        helper(grid, i, j+1, remain - 1, visited);\\n        helper(grid, i, j-1, remain - 1, visited);\\n        \\n        visited[i][j] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int r = 0, c = 0; // start point\\n        int remain = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] >= 0) {\\n                    remain++;\\n                    if (grid[i][j] == 1){\\n                        r = i;\\n                        c = j;\\n                    } \\n                } else {\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        helper(grid, r, c, remain, visited);\\n        return count;\\n    }\\n    \\n    private void helper(int[][]grid, int i, int j, int remain, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= visited.length || j >= visited[0].length || visited[i][j] == true) {\\n            return;\\n        }\\n        if (grid[i][j] == 2 && remain == 1) {\\n            this.count+=1;\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        helper(grid, i+1, j, remain - 1, visited);\\n        helper(grid, i-1, j, remain - 1, visited);\\n        helper(grid, i, j+1, remain - 1, visited);\\n        helper(grid, i, j-1, remain - 1, visited);\\n        \\n        visited[i][j] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824910,
                "title": "java-backtracking-without-global-variable-100",
                "content": "```\\nclass Solution {\\n   \\n    int solve(int[][]grid,int x, int y, int m, int n, int nonObstacles){\\n        if(x<0 || x>=m || y<0 || y>=n || grid[x][y]==-1 || grid[x][y]==1) return 0; //sanity check\\n        if(grid[x][y]==2){ //destination\\n            if(nonObstacles==0) return 1; // every non-obstacle square is visited (the only valid condition)\\n            return 0; //every non-obstacle square is not visited\\n        }\\n        if(nonObstacles==0) return 0; //without reaching the target all non-obstacle squares are visited  \\n        grid[x][y] = -1; //mark visited\\n        int way1 = solve(grid,x+1,y,m,n,nonObstacles-1);\\n        int way2 = solve(grid,x-1,y,m,n,nonObstacles-1);\\n        int way3 = solve(grid,x,y+1,m,n,nonObstacles-1);\\n        int way4 = solve(grid,x,y-1,m,n,nonObstacles-1);\\n        grid[x][y] = 0; //backtrack\\n        return way1+way2+way3+way4;\\n    }\\n    \\n    public int uniquePathsIII(int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int nonObstacles = 0;\\n        \\n        for(int[] row : grid){ //count the number of obstacles that are needed to be visited before reaching the destination\\n            for(int i=0;i<row.length;i++) if(row[i]==0) nonObstacles++;\\n        }\\n      \\n        for(int x=0;x<m;x++){ //find the starting point \\n            for(int y=0;y<n;y++){\\n                if(grid[x][y]==1){\\n                    return solve(grid,x+1,y,m,n,nonObstacles)+\\n                    solve(grid,x-1,y,m,n,nonObstacles)+\\n                    solve(grid,x,y+1,m,n,nonObstacles)+\\n                    solve(grid,x,y-1,m,n,nonObstacles);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\n    int solve(int[][]grid,int x, int y, int m, int n, int nonObstacles){\\n        if(x<0 || x>=m || y<0 || y>=n || grid[x][y]==-1 || grid[x][y]==1) return 0; //sanity check\\n        if(grid[x][y]==2){ //destination\\n            if(nonObstacles==0) return 1; // every non-obstacle square is visited (the only valid condition)\\n            return 0; //every non-obstacle square is not visited\\n        }\\n        if(nonObstacles==0) return 0; //without reaching the target all non-obstacle squares are visited  \\n        grid[x][y] = -1; //mark visited\\n        int way1 = solve(grid,x+1,y,m,n,nonObstacles-1);\\n        int way2 = solve(grid,x-1,y,m,n,nonObstacles-1);\\n        int way3 = solve(grid,x,y+1,m,n,nonObstacles-1);\\n        int way4 = solve(grid,x,y-1,m,n,nonObstacles-1);\\n        grid[x][y] = 0; //backtrack\\n        return way1+way2+way3+way4;\\n    }\\n    \\n    public int uniquePathsIII(int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int nonObstacles = 0;\\n        \\n        for(int[] row : grid){ //count the number of obstacles that are needed to be visited before reaching the destination\\n            for(int i=0;i<row.length;i++) if(row[i]==0) nonObstacles++;\\n        }\\n      \\n        for(int x=0;x<m;x++){ //find the starting point \\n            for(int y=0;y<n;y++){\\n                if(grid[x][y]==1){\\n                    return solve(grid,x+1,y,m,n,nonObstacles)+\\n                    solve(grid,x-1,y,m,n,nonObstacles)+\\n                    solve(grid,x,y+1,m,n,nonObstacles)+\\n                    solve(grid,x,y-1,m,n,nonObstacles);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1734811,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734812,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1564874,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1566997,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734859,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734998,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734932,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734819,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1575921,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1568772,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734811,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734812,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1564874,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1566997,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734859,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734998,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734932,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734819,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1575921,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1568772,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1735428,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735382,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735317,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735188,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735080,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735845,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735372,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1734990,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1734985,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1734915,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735402,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 2048976,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 2030605,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 2010201,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735908,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735891,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735867,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735849,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735789,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735779,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735765,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735756,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735678,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735666,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735665,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735663,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735424,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735386,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735363,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735300,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735232,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735216,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735206,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735149,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735135,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735108,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735089,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735082,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735040,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735016,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1734968,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734952,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734943,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734936,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734930,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734923,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734830,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734818,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1725311,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1711056,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            }
        ]
    },
    {
        "title": "Time Based Key-Value Store",
        "question_content": "<p>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&#39;s value at a certain timestamp.</p>\n\n<p>Implement the <code>TimeMap</code> class:</p>\n\n<ul>\n\t<li><code>TimeMap()</code> Initializes the object of the data structure.</li>\n\t<li><code>void set(String key, String value, int timestamp)</code> Stores the key <code>key</code> with the value <code>value </code>at the given time <code>timestamp</code>.</li>\n\t<li><code>String get(String key, int timestamp)</code> Returns a value such that <code>set</code> was called previously, with <code>timestamp_prev &lt;= timestamp</code>. If there are multiple such values, it returns the value associated with the largest <code>timestamp_prev</code>. If there are no values, it returns <code>&quot;&quot;</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;TimeMap&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;]\n[[], [&quot;foo&quot;, &quot;bar&quot;, 1], [&quot;foo&quot;, 1], [&quot;foo&quot;, 3], [&quot;foo&quot;, &quot;bar2&quot;, 4], [&quot;foo&quot;, 4], [&quot;foo&quot;, 5]]\n<strong>Output</strong>\n[null, null, &quot;bar&quot;, &quot;bar&quot;, null, &quot;bar2&quot;, &quot;bar2&quot;]\n\n<strong>Explanation</strong>\nTimeMap timeMap = new TimeMap();\ntimeMap.set(&quot;foo&quot;, &quot;bar&quot;, 1);  // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1.\ntimeMap.get(&quot;foo&quot;, 1);         // return &quot;bar&quot;\ntimeMap.get(&quot;foo&quot;, 3);         // return &quot;bar&quot;, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is &quot;bar&quot;.\ntimeMap.set(&quot;foo&quot;, &quot;bar2&quot;, 4); // store the key &quot;foo&quot; and value &quot;bar2&quot; along with timestamp = 4.\ntimeMap.get(&quot;foo&quot;, 4);         // return &quot;bar2&quot;\ntimeMap.get(&quot;foo&quot;, 5);         // return &quot;bar2&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length, value.length &lt;= 100</code></li>\n\t<li><code>key</code> and <code>value</code> consist of lowercase English letters and digits.</li>\n\t<li><code>1 &lt;= timestamp &lt;= 10<sup>7</sup></code></li>\n\t<li>All the timestamps <code>timestamp</code> of <code>set</code> are strictly increasing.</li>\n\t<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>set</code> and <code>get</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 226664,
                "title": "c-3-lines-hash-map-map",
                "content": "We use hash map to lookup ordered ```{timestamp, value}``` pairs by key in O(1). Then, we use binary search to find the value with a timestamp less or equal than the requested one.\\n```\\nunordered_map<string, map<int, string>> m;\\nvoid set(string key, string value, int timestamp) {\\n  m[key].insert({ timestamp, value });\\n}\\nstring get(string key, int timestamp) {\\n  auto it = m[key].upper_bound(timestamp);\\n  return it == m[key].begin() ? \"\" : prev(it)->second;\\n}\\n```\\nSince our timestamps are only increasing, we can use a vector instead of a map, though it\\'s not as concise.\\n```\\nunordered_map<string, vector<pair<int, string>>> m;\\nvoid set(string key, string value, int timestamp) {\\n  m[key].push_back({ timestamp, value });\\n}\\nstring get(string key, int timestamp) {\\n  auto it = upper_bound(begin(m[key]), end(m[key]), pair<int, string>(timestamp, \"\"), [](\\n    const pair<int, string>& a, const pair<int, string>& b) { return a.first < b.first; });\\n  return it == m[key].begin() ? \"\" : prev(it)->second;\\n}\\n```\\n# Complexity analysis\\nAssuming ```n``` is the number of set operations, and ```m``` is the number of get operations:\\n- Time Complexity: \\n    - Set: ```O(1)``` single operation, and total ```O(n)```.\\nNote: assuing timestamps are only increasing. If not, it\\'s ```O(n log n)```.\\n    - Get: ```O(log n)``` for a single operation, and total ```O(m log n)```.\\n- Space Complexity: ```O(n)``` (assuming every ```{ timestamp, value }``` is unique).",
                "solutionTags": [],
                "code": "```{timestamp, value}```\n```\\nunordered_map<string, map<int, string>> m;\\nvoid set(string key, string value, int timestamp) {\\n  m[key].insert({ timestamp, value });\\n}\\nstring get(string key, int timestamp) {\\n  auto it = m[key].upper_bound(timestamp);\\n  return it == m[key].begin() ? \"\" : prev(it)->second;\\n}\\n```\n```\\nunordered_map<string, vector<pair<int, string>>> m;\\nvoid set(string key, string value, int timestamp) {\\n  m[key].push_back({ timestamp, value });\\n}\\nstring get(string key, int timestamp) {\\n  auto it = upper_bound(begin(m[key]), end(m[key]), pair<int, string>(timestamp, \"\"), [](\\n    const pair<int, string>& a, const pair<int, string>& b) { return a.first < b.first; });\\n  return it == m[key].begin() ? \"\" : prev(it)->second;\\n}\\n```\n```n```\n```m```\n```O(1)```\n```O(n)```\n```O(n log n)```\n```O(log n)```\n```O(m log n)```\n```O(n)```\n```{ timestamp, value }```",
                "codeTag": "Unknown"
            },
            {
                "id": 226663,
                "title": "treemap-solution-java",
                "content": "```\\npublic class TimeMap {\\n\\n    private Map<String,TreeMap<Integer,String>> map;\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)) {\\n            map.put(key,new TreeMap<>());\\n        }\\n        map.get(key).put(timestamp,value);\\n    }\\n\\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer,String> treeMap = map.get(key);\\n        if(treeMap==null) {\\n            return \"\";\\n        }\\n        Integer floor = treeMap.floorKey(timestamp);\\n        if(floor==null) {\\n            return \"\";\\n        }\\n        return treeMap.get(floor);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class TimeMap {\\n\\n    private Map<String,TreeMap<Integer,String>> map;\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)) {\\n            map.put(key,new TreeMap<>());\\n        }\\n        map.get(key).put(timestamp,value);\\n    }\\n\\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer,String> treeMap = map.get(key);\\n        if(treeMap==null) {\\n            return \"\";\\n        }\\n        Integer floor = treeMap.floorKey(timestamp);\\n        if(floor==null) {\\n            return \"\";\\n        }\\n        return treeMap.get(floor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227943,
                "title": "python-dict-and-binary-search-implementation",
                "content": "Most of the solution here doesn\\'t give you the binary search implementation, but you propabaly needs to write it during the interview...\\n\\n```\\nclass TimeMap(object):\\n\\n    def __init__(self):\\n        self.dic = collections.defaultdict(list)\\n        \\n\\n    def set(self, key, value, timestamp):\\n        self.dic[key].append([timestamp, value])\\n\\n    def get(self, key, timestamp):\\n        arr = self.dic[key]\\n        n = len(arr)\\n        \\n        left = 0\\n        right = n\\n        \\n        while left < right:\\n            mid = (left + right) / 2\\n            if arr[mid][0] <= timestamp:\\n                left = mid + 1\\n            elif arr[mid][0] > timestamp:\\n                right = mid\\n        \\n        return \"\" if right == 0 else arr[right - 1][1]\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass TimeMap(object):\\n\\n    def __init__(self):\\n        self.dic = collections.defaultdict(list)\\n        \\n\\n    def set(self, key, value, timestamp):\\n        self.dic[key].append([timestamp, value])\\n\\n    def get(self, key, timestamp):\\n        arr = self.dic[key]\\n        n = len(arr)\\n        \\n        left = 0\\n        right = n\\n        \\n        while left < right:\\n            mid = (left + right) / 2\\n            if arr[mid][0] <= timestamp:\\n                left = mid + 1\\n            elif arr[mid][0] > timestamp:\\n                right = mid\\n        \\n        return \"\" if right == 0 else arr[right - 1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244229,
                "title": "java-beats-100",
                "content": "```\\nclass Data {\\n    String val;\\n    int time;\\n    Data(String val, int time) {\\n        this.val = val;\\n        this.time = time;\\n    }\\n}\\nclass TimeMap {\\n\\n    /** Initialize your data structure here. */\\n    Map<String, List<Data>> map;\\n    public TimeMap() {\\n        map = new HashMap<String, List<Data>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if (!map.containsKey(key)) map.put(key, new ArrayList<Data>());\\n        map.get(key).add(new Data(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (!map.containsKey(key)) return \"\";\\n        return binarySearch(map.get(key), timestamp);\\n    }\\n    \\n    protected String binarySearch(List<Data> list, int time) {\\n        int low = 0, high = list.size() - 1;\\n        while (low < high) {\\n            int mid = (low + high) >> 1;\\n            if (list.get(mid).time == time) return list.get(mid).val;\\n            if (list.get(mid).time < time) {\\n                if (list.get(mid+1).time > time) return list.get(mid).val;\\n                low = mid + 1;\\n            }\\n            else high = mid -1;\\n        }\\n        return list.get(low).time <= time ? list.get(low).val : \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Data {\\n    String val;\\n    int time;\\n    Data(String val, int time) {\\n        this.val = val;\\n        this.time = time;\\n    }\\n}\\nclass TimeMap {\\n\\n    /** Initialize your data structure here. */\\n    Map<String, List<Data>> map;\\n    public TimeMap() {\\n        map = new HashMap<String, List<Data>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if (!map.containsKey(key)) map.put(key, new ArrayList<Data>());\\n        map.get(key).add(new Data(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (!map.containsKey(key)) return \"\";\\n        return binarySearch(map.get(key), timestamp);\\n    }\\n    \\n    protected String binarySearch(List<Data> list, int time) {\\n        int low = 0, high = list.size() - 1;\\n        while (low < high) {\\n            int mid = (low + high) >> 1;\\n            if (list.get(mid).time == time) return list.get(mid).val;\\n            if (list.get(mid).time < time) {\\n                if (list.get(mid+1).time > time) return list.get(mid).val;\\n                low = mid + 1;\\n            }\\n            else high = mid -1;\\n        }\\n        return list.get(low).time <= time ? list.get(low).val : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247130,
                "title": "python-concise-6-liner",
                "content": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.times = collections.defaultdict(list)\\n        self.values = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.times[key].append(timestamp)\\n        self.values[key].append(value)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        i = bisect.bisect(self.times[key], timestamp)\\n        return self.values[key][i - 1] if i else \\'\\'\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.times = collections.defaultdict(list)\\n        self.values = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.times[key].append(timestamp)\\n        self.values[key].append(value)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        i = bisect.bisect(self.times[key], timestamp)\\n        return self.values[key][i - 1] if i else \\'\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299520,
                "title": "c-unordered-map-binary-search-last-occurrence",
                "content": "```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, vector<pair<int, string>>> m;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(!m.count(key))\\n            return \"\";\\n        int start = 0, end = m[key].size();\\n        while(start < end) {\\n            int mid = start + (end-start)/2;\\n            if(m[key][mid].first > timestamp)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        return start > 0 and start <= m[key].size() ? m[key][start-1].second : \"\";\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, vector<pair<int, string>>> m;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(!m.count(key))\\n            return \"\";\\n        int start = 0, end = m[key].size();\\n        while(start < end) {\\n            int mid = start + (end-start)/2;\\n            if(m[key][mid].first > timestamp)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        return start > 0 and start <= m[key].size() ? m[key][start-1].second : \"\";\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282703,
                "title": "java-binary-search-treemap-solution",
                "content": "Binary search:\\n```\\nclass TimeMap {\\n\\n    class Node {\\n        String value;\\n        int timestamp;\\n        Node(String value, int timestamp) {\\n            this.value = value;\\n            this.timestamp = timestamp;\\n        }\\n    }\\n    \\n    Map<String, List<Node>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.putIfAbsent(key, new ArrayList());\\n        map.get(key).add(new Node(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        List<Node> nodes = map.get(key);\\n        if (nodes == null) return \"\";\\n        \\n        int left = 0, right = nodes.size() - 1;\\n        while (left + 1 < right) {\\n            int mid = left + (right - left) / 2;\\n            Node node = nodes.get(mid);\\n            if (node.timestamp == timestamp) {\\n                return node.value;\\n            } else if (node.timestamp < timestamp) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        if (nodes.get(right).timestamp <= timestamp) return nodes.get(right).value;\\n        else if (nodes.get(left).timestamp <= timestamp) return nodes.get(left).value;\\n        return \"\";\\n    }\\n}\\n```\\n\\nTreeMap:\\n```\\nclass TimeMap {\\n\\n    Map<String, TreeMap<Integer, String>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.putIfAbsent(key, new TreeMap());\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer, String> treeMap = map.get(key);\\n        \\n        if (treeMap == null) return \"\";\\n        \\n        Integer floorKey = treeMap.floorKey(timestamp);\\n        \\n        if (floorKey == null) return \"\";\\n        return treeMap.get(floorKey);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\n\\n    class Node {\\n        String value;\\n        int timestamp;\\n        Node(String value, int timestamp) {\\n            this.value = value;\\n            this.timestamp = timestamp;\\n        }\\n    }\\n    \\n    Map<String, List<Node>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.putIfAbsent(key, new ArrayList());\\n        map.get(key).add(new Node(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        List<Node> nodes = map.get(key);\\n        if (nodes == null) return \"\";\\n        \\n        int left = 0, right = nodes.size() - 1;\\n        while (left + 1 < right) {\\n            int mid = left + (right - left) / 2;\\n            Node node = nodes.get(mid);\\n            if (node.timestamp == timestamp) {\\n                return node.value;\\n            } else if (node.timestamp < timestamp) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        if (nodes.get(right).timestamp <= timestamp) return nodes.get(right).value;\\n        else if (nodes.get(left).timestamp <= timestamp) return nodes.get(left).value;\\n        return \"\";\\n    }\\n}\\n```\n```\\nclass TimeMap {\\n\\n    Map<String, TreeMap<Integer, String>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.putIfAbsent(key, new TreeMap());\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer, String> treeMap = map.get(key);\\n        \\n        if (treeMap == null) return \"\";\\n        \\n        Integer floorKey = treeMap.floorKey(timestamp);\\n        \\n        if (floorKey == null) return \"\";\\n        return treeMap.get(floorKey);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408651,
                "title": "python-clean-solution-binary-search",
                "content": "```\\nclass TimeMap(object):\\n\\n    def __init__(self):\\n        self.map = collections.defaultdict(list)\\n        \\n\\n    def set(self, key, value, timestamp):\\n        self.map[key].append((timestamp, value))\\n        \\n\\n    def get(self, key, timestamp):\\n        values = self.map[key]\\n        if not values: return \\'\\'\\n        left, right = 0, len(values) - 1\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            pre_time, value = values[mid]\\n            if pre_time > timestamp:\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return values[left][1] if values[left][0] <= timestamp else \\'\\'\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap(object):\\n\\n    def __init__(self):\\n        self.map = collections.defaultdict(list)\\n        \\n\\n    def set(self, key, value, timestamp):\\n        self.map[key].append((timestamp, value))\\n        \\n\\n    def get(self, key, timestamp):\\n        values = self.map[key]\\n        if not values: return \\'\\'\\n        left, right = 0, len(values) - 1\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            pre_time, value = values[mid]\\n            if pre_time > timestamp:\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return values[left][1] if values[left][0] <= timestamp else \\'\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226654,
                "title": "easy-c-7-lines-of-code",
                "content": "```\\nclass TimeMap {\\npublic:\\n   /** Initialize your data structure here. */\\n   unordered_map<string, map<int, string>> m;\\n\\n   TimeMap() {}\\n\\n   void set(string key, string value, int timestamp) {\\n      auto& inner_map = m[key];\\n      inner_map[-timestamp] = value;\\n   }\\n\\n   string get(string key, int timestamp) {\\n      auto i = m.find(key);\\n      if (i == m.end()) return \"\";\\n      auto j = i->second.lower_bound(-timestamp);\\n      return j != i->second.end() ? j->second : \"\";\\n   }\\n};",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\npublic:\\n   /** Initialize your data structure here. */\\n   unordered_map<string, map<int, string>> m;\\n\\n   TimeMap() {}\\n\\n   void set(string key, string value, int timestamp) {\\n      auto& inner_map = m[key];\\n      inner_map[-timestamp] = value;\\n   }\\n\\n   string get(string key, int timestamp) {\\n      auto i = m.find(key);\\n      if (i == m.end()) return \"\";\\n      auto j = i->second.lower_bound(-timestamp);\\n      return j != i->second.end() ? j->second : \"\";\\n   }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2667042,
                "title": "time-based-key-value-store-95-83-faster-3-line-c-code-runtime-333-ms",
                "content": "**SHIVAM DAILY LEETCODE SOLUTIONS || CHECK : [https://bit.ly/leetcode-solutions](https://bit.ly/leetcode-solutions)\\nRuntime: 333 ms, faster than 95.83% of C++ online submissions for Time Based Key-Value Store.\\nMemory Usage: 130.7 MB, less than 29.45% of C++ online submissions for Time Based Key-Value Store.**\\n\\n```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,map<int,string>>m;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key][timestamp]=value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto it=m[key].upper_bound(timestamp);\\n        if(it==m[key].begin())return \"\";\\n        it--;\\n        return it->second;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3de1d293-f182-4684-b0a5-6a9bfa6821ad_1665031416.4489112.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,map<int,string>>m;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key][timestamp]=value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto it=m[key].upper_bound(timestamp);\\n        if(it==m[key].begin())return \"\";\\n        it--;\\n        return it->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294419,
                "title": "python-binary-search-solution",
                "content": "The idea is using binary search to find the closest timestamp_prev in TimeMap\\n\\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self._dic = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self._dic[key].append((value, timestamp,))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key in self._dic:\\n            li = self._dic[key]\\n            l, r = 0, len(self._dic[key]) - 1\\n            \\n            if li[l][1] > timestamp:\\n                return \"\"\\n            elif li[r][1] <= timestamp:\\n                return li[r][0]\\n            else:\\n                while l <= r:\\n                    mid = l + (r - l) // 2\\n\\n                    if li[mid][1] == timestamp:\\n                        return li[mid][0]\\n\\n                    if li[mid][1] < timestamp:\\n                        l = mid + 1\\n                    else:\\n                        r = mid - 1\\n\\n                return li[r][0]\\n        return \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self._dic = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self._dic[key].append((value, timestamp,))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key in self._dic:\\n            li = self._dic[key]\\n            l, r = 0, len(self._dic[key]) - 1\\n            \\n            if li[l][1] > timestamp:\\n                return \"\"\\n            elif li[r][1] <= timestamp:\\n                return li[r][0]\\n            else:\\n                while l <= r:\\n                    mid = l + (r - l) // 2\\n\\n                    if li[mid][1] == timestamp:\\n                        return li[mid][0]\\n\\n                    if li[mid][1] < timestamp:\\n                        l = mid + 1\\n                    else:\\n                        r = mid - 1\\n\\n                return li[r][0]\\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425691,
                "title": "javascript-map",
                "content": "```javascript\\nvar TimeMap = function() {\\n    this.map = new Map();\\n};\\n\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    if (!this.map.has(key)) this.map.set(key, []);\\n    this.map.get(key)[timestamp] = value;\\n};\\n\\nTimeMap.prototype.get = function(key, timestamp) {\\n    if (!this.map.has(key)) return \\'\\';\\n    const item = this.map.get(key);\\n    if (item[timestamp]) return item[timestamp];\\n    while (timestamp-- > -1) {\\n        if (item[timestamp]) return item[timestamp];\\n    }\\n    return \\'\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar TimeMap = function() {\\n    this.map = new Map();\\n};\\n\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    if (!this.map.has(key)) this.map.set(key, []);\\n    this.map.get(key)[timestamp] = value;\\n};\\n\\nTimeMap.prototype.get = function(key, timestamp) {\\n    if (!this.map.has(key)) return \\'\\';\\n    const item = this.map.get(key);\\n    if (item[timestamp]) return item[timestamp];\\n    while (timestamp-- > -1) {\\n        if (item[timestamp]) return item[timestamp];\\n    }\\n    return \\'\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381893,
                "title": "3-solutions-binary-linear-fastest-tree-easy-to-understand-95-beat-java",
                "content": "**Intuition**\\n\\n1. As we need to find the values corresponding to a key: `HashMap`  would be the choice\\n2. We need to find those values whose `timestampPrev <= timestamp`. i.e. means we need to store all the values of a key of different timestamp. Since we are looking `timestampPrev <= timestamp` then keeping those values sorted would make sense. Note, we don\\'t need to maintain the sorted order as `timestamp` is always in increasing order\\n\\nHence, we need `HashMap<Key, List<Values>>`. \\n\\n**Algo 1:** Do Binary Search on values\\n\\n```\\n\\n/**\\n * Runtime: 204 ms, faster than 82.02% of Java online submissions for Time Based Key-Value Store.\\n * Memory Usage: 140.2 MB, less than 27.03% of Java online submissions for Time Based Key-Value Store.\\n */\\nclass TimeMapUsingMapBinarySearch implements ITimeMap {\\n\\n    /**\\n     * Node holding data\\n     */\\n    private static class Node {\\n\\n        final String value;\\n        final int timeStamp;\\n\\n        public Node(String value, int timeStamp) {\\n            this.value = value;\\n            this.timeStamp = timeStamp;\\n        }\\n    }\\n\\n\\n    private final Map<String, List<Node>> timeMap;\\n\\n    public TimeMapUsingMapBinarySearch() {\\n        this.timeMap = new HashMap<>();\\n    }\\n\\n    //O(1)\\n    public void set(String key, String value, int timestamp) {\\n\\n        if (!timeMap.containsKey(key))\\n            timeMap.put(key, new ArrayList<>());\\n\\n        timeMap.get(key).add(new Node(value, timestamp));\\n\\n    }\\n\\n    //O(log(L)) ; L is the length of values in a key\\n    public String get(String key, int timestamp) {\\n        final String EMPTY_RESPONSE = \"\";\\n        if (!timeMap.containsKey(key))\\n            return EMPTY_RESPONSE;\\n\\n        Node returnValue = binarySearch(timeMap.get(key), timestamp);\\n        return returnValue == null ? EMPTY_RESPONSE : returnValue.value;\\n    }\\n\\n\\n    /**\\n     * O(log(L))\\n     * Since we need to find timestamp_prev <= timestamp. then whenever we move right, cache the value you have seen as potential solution\\n     *\\n     * @param nodes     nodes\\n     * @param timeStamp timeStamp\\n     * @return {@code Node} when found otherwise null\\n     */\\n    private Node binarySearch(final List<Node> nodes, int timeStamp) {\\n\\n        if (nodes.isEmpty())\\n            return null;\\n\\n\\n        int low = 0, high = nodes.size() - 1;\\n        Node returnValue = null;\\n\\n        while (low <= high) {\\n\\n            int mid = (high + low) >> 1;\\n\\n            final Node current = nodes.get(mid);\\n\\n            if (current.timeStamp == timeStamp)\\n                return returnValue = nodes.get(mid);\\n\\n            else if (current.timeStamp > timeStamp)\\n                high = mid - 1;\\n            else {\\n                returnValue = current;\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return returnValue;\\n    }\\n\\n\\n    /**\\n     * Another way\\n     */\\n    protected String binarySearch1(List<Node> nodes, int time) {\\n        int low = 0, high = nodes.size() - 1;\\n        while (low < high) {\\n            int mid = (low + high) >> 1;\\n            final Node current = nodes.get(mid);\\n\\n            if (current.timeStamp == time)\\n                return current.value;\\n\\n            if (current.timeStamp < time) {\\n\\n                if (nodes.get(mid + 1).timeStamp > time)\\n                    return current.value;\\n\\n                low = mid + 1;\\n            } else\\n                high = mid - 1;\\n        }\\n        return nodes.get(low).timeStamp <= time ? nodes.get(low).value : \"\";\\n    }\\n}\\n\\n\\n```\\n\\n**Algo 2:** Do reverse search on values\\n* Run through from end, this will make slight advantage as we may able to break the condition much before as compare to BinarySearch because of timestamp in increasing order\\n\\n```\\n\\n/**\\n * Runtime: 187 ms, faster than 93.87% of Java online submissions for Time Based Key-Value Store.\\n * Memory Usage: 143.4 MB, less than 8.11% of Java online submissions for Time Based Key-Value Store.\\n */\\nclass TimeMapUsingMapBinarySearchLinkedList implements ITimeMap {\\n\\n    /**\\n     * Node holding data\\n     */\\n    private static class Node {\\n\\n        final String key;\\n        final String value;\\n        final int timeStamp;\\n\\n        public Node(String key, String value, int timeStamp) {\\n            this.key = key;\\n            this.value = value;\\n            this.timeStamp = timeStamp;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Node{\" +\\n                    \"key=\\'\" + key + \\'\\\\\\'\\' +\\n                    \", value=\\'\" + value + \\'\\\\\\'\\' +\\n                    \", timeStamp=\" + timeStamp +\\n                    \\'}\\';\\n        }\\n    }\\n\\n\\n    private final Map<String, LinkedList<Node>> timeMap;\\n\\n    public TimeMapUsingMapBinarySearchLinkedList() {\\n        this.timeMap = new HashMap<>();\\n    }\\n\\n    //O(1)\\n    public void set(String key, String value, int timestamp) {\\n\\n        if (!timeMap.containsKey(key))\\n            timeMap.put(key, new LinkedList<>());\\n\\n        timeMap.get(key).add(new Node(key, value, timestamp));\\n\\n    }\\n\\n    //O(L) ; L is the length of values in a key\\n    public String get(String key, int timestamp) {\\n\\n        final String EMPTY_RESPONSE = \"\";\\n\\n        if (!timeMap.containsKey(key))\\n            return EMPTY_RESPONSE;\\n\\n        //Run through from end, this will make slight advantage as we may able to break the condition much before as compare to BinarySearch because of timestamp in increasing order\\n        final Iterator<Node> iterator = timeMap.get(key).descendingIterator();\\n\\n        while (iterator.hasNext()) {\\n            Node node = iterator.next();\\n            if (node.timeStamp > timestamp)\\n                continue;\\n\\n            return node.value;\\n        }\\n\\n        return EMPTY_RESPONSE;\\n    }\\n\\n\\n}\\n```\\n\\n**Algo 3:**\\nUtilize java inbuild search functionality using `TreeMap`\\n\\n```\\n\\n//243 ms\\nclass TimeMapUsingTreeMap implements ITimeMap {\\n\\n\\n    //Holds the key vs tree map of timestamp vs values\\n    private final Map<String, TreeMap<Integer, String>> timeMap;\\n\\n    public TimeMapUsingTreeMap() {\\n        this.timeMap = new HashMap<>();\\n    }\\n\\n    //O(1)\\n    public void set(String key, String value, int timestamp) {\\n\\n        if (!timeMap.containsKey(key))\\n            timeMap.put(key, new TreeMap<>());\\n\\n        timeMap.get(key).put(timestamp, value);\\n\\n    }\\n\\n    //O(log(L)) ; L is the length of values in a key\\n    public String get(String key, int timestamp) {\\n\\n        final String EMPTY_RESPONSE = \"\";\\n\\n        if (!timeMap.containsKey(key))\\n            return EMPTY_RESPONSE;\\n\\n        final Map.Entry<Integer, String> entry = timeMap.get(key).floorEntry(timestamp);\\n        return entry == null ? EMPTY_RESPONSE : entry.getValue();\\n\\n    }\\n\\n\\n}\\n\\n```\\n\\n\\nInterface\\n\\n```\\n\\ninterface ITimeMap {\\n\\n    /**\\n     * Stores the key and value, along with the given timestamp.\\n     *\\n     * @param key       key\\n     * @param value     value\\n     * @param timestamp timestamp\\n     */\\n    void set(String key, String value, int timestamp);\\n\\n    /**\\n     * @param key       key\\n     * @param timestamp timestamp\\n     * @return * Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\\n     * * If there are multiple such values, it returns the one with the largest timestamp_prev.\\n     * * If there are no values, it returns the empty string (\"\").\\n     */\\n    String get(String key, int timestamp);\\n}\\n\\n```\\n\\nQuote\\n`Solving the question is as important as desiging the solution`",
                "solutionTags": [
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\n\\n/**\\n * Runtime: 204 ms, faster than 82.02% of Java online submissions for Time Based Key-Value Store.\\n * Memory Usage: 140.2 MB, less than 27.03% of Java online submissions for Time Based Key-Value Store.\\n */\\nclass TimeMapUsingMapBinarySearch implements ITimeMap {\\n\\n    /**\\n     * Node holding data\\n     */\\n    private static class Node {\\n\\n        final String value;\\n        final int timeStamp;\\n\\n        public Node(String value, int timeStamp) {\\n            this.value = value;\\n            this.timeStamp = timeStamp;\\n        }\\n    }\\n\\n\\n    private final Map<String, List<Node>> timeMap;\\n\\n    public TimeMapUsingMapBinarySearch() {\\n        this.timeMap = new HashMap<>();\\n    }\\n\\n    //O(1)\\n    public void set(String key, String value, int timestamp) {\\n\\n        if (!timeMap.containsKey(key))\\n            timeMap.put(key, new ArrayList<>());\\n\\n        timeMap.get(key).add(new Node(value, timestamp));\\n\\n    }\\n\\n    //O(log(L)) ; L is the length of values in a key\\n    public String get(String key, int timestamp) {\\n        final String EMPTY_RESPONSE = \"\";\\n        if (!timeMap.containsKey(key))\\n            return EMPTY_RESPONSE;\\n\\n        Node returnValue = binarySearch(timeMap.get(key), timestamp);\\n        return returnValue == null ? EMPTY_RESPONSE : returnValue.value;\\n    }\\n\\n\\n    /**\\n     * O(log(L))\\n     * Since we need to find timestamp_prev <= timestamp. then whenever we move right, cache the value you have seen as potential solution\\n     *\\n     * @param nodes     nodes\\n     * @param timeStamp timeStamp\\n     * @return {@code Node} when found otherwise null\\n     */\\n    private Node binarySearch(final List<Node> nodes, int timeStamp) {\\n\\n        if (nodes.isEmpty())\\n            return null;\\n\\n\\n        int low = 0, high = nodes.size() - 1;\\n        Node returnValue = null;\\n\\n        while (low <= high) {\\n\\n            int mid = (high + low) >> 1;\\n\\n            final Node current = nodes.get(mid);\\n\\n            if (current.timeStamp == timeStamp)\\n                return returnValue = nodes.get(mid);\\n\\n            else if (current.timeStamp > timeStamp)\\n                high = mid - 1;\\n            else {\\n                returnValue = current;\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return returnValue;\\n    }\\n\\n\\n    /**\\n     * Another way\\n     */\\n    protected String binarySearch1(List<Node> nodes, int time) {\\n        int low = 0, high = nodes.size() - 1;\\n        while (low < high) {\\n            int mid = (low + high) >> 1;\\n            final Node current = nodes.get(mid);\\n\\n            if (current.timeStamp == time)\\n                return current.value;\\n\\n            if (current.timeStamp < time) {\\n\\n                if (nodes.get(mid + 1).timeStamp > time)\\n                    return current.value;\\n\\n                low = mid + 1;\\n            } else\\n                high = mid - 1;\\n        }\\n        return nodes.get(low).timeStamp <= time ? nodes.get(low).value : \"\";\\n    }\\n}\\n\\n\\n```\n```\\n\\n/**\\n * Runtime: 187 ms, faster than 93.87% of Java online submissions for Time Based Key-Value Store.\\n * Memory Usage: 143.4 MB, less than 8.11% of Java online submissions for Time Based Key-Value Store.\\n */\\nclass TimeMapUsingMapBinarySearchLinkedList implements ITimeMap {\\n\\n    /**\\n     * Node holding data\\n     */\\n    private static class Node {\\n\\n        final String key;\\n        final String value;\\n        final int timeStamp;\\n\\n        public Node(String key, String value, int timeStamp) {\\n            this.key = key;\\n            this.value = value;\\n            this.timeStamp = timeStamp;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Node{\" +\\n                    \"key=\\'\" + key + \\'\\\\\\'\\' +\\n                    \", value=\\'\" + value + \\'\\\\\\'\\' +\\n                    \", timeStamp=\" + timeStamp +\\n                    \\'}\\';\\n        }\\n    }\\n\\n\\n    private final Map<String, LinkedList<Node>> timeMap;\\n\\n    public TimeMapUsingMapBinarySearchLinkedList() {\\n        this.timeMap = new HashMap<>();\\n    }\\n\\n    //O(1)\\n    public void set(String key, String value, int timestamp) {\\n\\n        if (!timeMap.containsKey(key))\\n            timeMap.put(key, new LinkedList<>());\\n\\n        timeMap.get(key).add(new Node(key, value, timestamp));\\n\\n    }\\n\\n    //O(L) ; L is the length of values in a key\\n    public String get(String key, int timestamp) {\\n\\n        final String EMPTY_RESPONSE = \"\";\\n\\n        if (!timeMap.containsKey(key))\\n            return EMPTY_RESPONSE;\\n\\n        //Run through from end, this will make slight advantage as we may able to break the condition much before as compare to BinarySearch because of timestamp in increasing order\\n        final Iterator<Node> iterator = timeMap.get(key).descendingIterator();\\n\\n        while (iterator.hasNext()) {\\n            Node node = iterator.next();\\n            if (node.timeStamp > timestamp)\\n                continue;\\n\\n            return node.value;\\n        }\\n\\n        return EMPTY_RESPONSE;\\n    }\\n\\n\\n}\\n```\n```\\n\\n//243 ms\\nclass TimeMapUsingTreeMap implements ITimeMap {\\n\\n\\n    //Holds the key vs tree map of timestamp vs values\\n    private final Map<String, TreeMap<Integer, String>> timeMap;\\n\\n    public TimeMapUsingTreeMap() {\\n        this.timeMap = new HashMap<>();\\n    }\\n\\n    //O(1)\\n    public void set(String key, String value, int timestamp) {\\n\\n        if (!timeMap.containsKey(key))\\n            timeMap.put(key, new TreeMap<>());\\n\\n        timeMap.get(key).put(timestamp, value);\\n\\n    }\\n\\n    //O(log(L)) ; L is the length of values in a key\\n    public String get(String key, int timestamp) {\\n\\n        final String EMPTY_RESPONSE = \"\";\\n\\n        if (!timeMap.containsKey(key))\\n            return EMPTY_RESPONSE;\\n\\n        final Map.Entry<Integer, String> entry = timeMap.get(key).floorEntry(timestamp);\\n        return entry == null ? EMPTY_RESPONSE : entry.getValue();\\n\\n    }\\n\\n\\n}\\n\\n```\n```\\n\\ninterface ITimeMap {\\n\\n    /**\\n     * Stores the key and value, along with the given timestamp.\\n     *\\n     * @param key       key\\n     * @param value     value\\n     * @param timestamp timestamp\\n     */\\n    void set(String key, String value, int timestamp);\\n\\n    /**\\n     * @param key       key\\n     * @param timestamp timestamp\\n     * @return * Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\\n     * * If there are multiple such values, it returns the one with the largest timestamp_prev.\\n     * * If there are no values, it returns the empty string (\"\").\\n     */\\n    String get(String key, int timestamp);\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223226,
                "title": "python3-clean-and-efficient-code-o-1-o-log-n",
                "content": "## Code\\n```python\\nclass TimeMap:\\n    def __init__(self):\\n        self.meta = collections.defaultdict(list)\\n        self.data = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.meta[key].append(timestamp)\\n        self.data[key].append(value)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        idx = bisect.bisect(self.meta[key], timestamp)\\n        if idx == 0:\\n            return \\'\\'\\n        return self.data[key][idx - 1]\\n```\\n\\n## Comment\\nThis question is very similar to [1146. Snapshot Array](https://leetcode.com/problems/snapshot-array/). Keep two dictionaries of lists, where `self.meta<str, List<int>>` keeps track of the list of timestamps for each key, and `self.data<str, List<str>>` keeps track of the corresponding data.\\n\\nThen, `set` is very easy. Just append the timestamp and the value to their respective lists.\\nOn the other hand, `get` requires a search through the list of timestamps in order to find the largest timestamp less than or equal to the given timestamp. This can be done efficiently using binary search. Notice that `bisect.bisect` is actually synonymous to `bisect.bisect_right`, meaning that it returns the index of the first element that is strictly greater than the requested value. Therefore, you need to use `idx - 1` when indexing.\\n\\n## Complexity \\nTime: `O(1)` for `set`. `O(log k)` for `get`, where `k` is the length of the list corresponding to the key. In the worst case where `k == n`, the complexity becomes `O(log n)`.\\nSpace: `O(n)`, where `n` is the total number of values to track.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass TimeMap:\\n    def __init__(self):\\n        self.meta = collections.defaultdict(list)\\n        self.data = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.meta[key].append(timestamp)\\n        self.data[key].append(value)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        idx = bisect.bisect(self.meta[key], timestamp)\\n        if idx == 0:\\n            return \\'\\'\\n        return self.data[key][idx - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460087,
                "title": "java-treemap-solution-time-o-logn-space-o-n",
                "content": "A two dimensional hashmap. The second dimension is sorted. \\n\\n\\n```\\nclass TimeMap {\\n    private static final String DEFAULT_VALUE = \"\";\\n    private final HashMap<String, TreeMap<Integer, String>> map;\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        TreeMap<Integer, String> timeMap;\\n        if (map.containsKey(key)) {\\n            timeMap = map.get(key);\\n        } else {\\n            timeMap = new TreeMap<>();\\n            map.put(key, timeMap);\\n        }\\n        timeMap.put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (map.containsKey(key)) {\\n            TreeMap<Integer, String> timeMap = map.get(key);\\n            Integer floorKey = timeMap.floorKey(timestamp);\\n            if (floorKey != null) {\\n                return timeMap.get(floorKey);\\n            }\\n        }\\n        return DEFAULT_VALUE;\\n    }\\n}\\n ```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    private static final String DEFAULT_VALUE = \"\";\\n    private final HashMap<String, TreeMap<Integer, String>> map;\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        TreeMap<Integer, String> timeMap;\\n        if (map.containsKey(key)) {\\n            timeMap = map.get(key);\\n        } else {\\n            timeMap = new TreeMap<>();\\n            map.put(key, timeMap);\\n        }\\n        timeMap.put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (map.containsKey(key)) {\\n            TreeMap<Integer, String> timeMap = map.get(key);\\n            Integer floorKey = timeMap.floorKey(timestamp);\\n            if (floorKey != null) {\\n                return timeMap.get(floorKey);\\n            }\\n        }\\n        return DEFAULT_VALUE;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 442787,
                "title": "commented-easy-to-understand-faster-100-less-memory-javascript-solution",
                "content": "**Please do upvote, it motivates me to write more such posts\\uD83D\\uDE03**\\n\\n```\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    let obj = this.obj;\\n    if(!obj[key]){\\n        obj[key] = [];\\n    }\\n    obj[key].push([value, timestamp]);  \\n};\\n\\n\\nTimeMap.prototype.get = function(key, timestamp) {\\n    let obj = this.obj;\\n    let out = []\\n    let arr = obj[key];\\n    let end = arr.length-1;\\n    let start = 0;\\n    \\n//     Doing simple binary search\\n    while(start<end){   \\n        let mid = Math.floor((start + end)/2);\\n        let time = arr[mid][1];\\n        let val = arr[mid][0];\\n        if(time<timestamp){\\n            start = mid+1;\\n//             Storing the last known value which is less than timestamp\\n            out = arr[mid];\\n        }\\n        else if(time>timestamp){\\n            end = mid-1;\\n        }\\n        else{\\n            return val;\\n        }  \\n    }\\n    \\n    \\n    try{\\n        if(arr[end][1]<=timestamp) return arr[end][0];\\n        else if(out[1]<timestamp) return out[0];\\n    }\\n    catch(err){\\n        return \"\";\\n    }\\n    // return out;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    let obj = this.obj;\\n    if(!obj[key]){\\n        obj[key] = [];\\n    }\\n    obj[key].push([value, timestamp]);  \\n};\\n\\n\\nTimeMap.prototype.get = function(key, timestamp) {\\n    let obj = this.obj;\\n    let out = []\\n    let arr = obj[key];\\n    let end = arr.length-1;\\n    let start = 0;\\n    \\n//     Doing simple binary search\\n    while(start<end){   \\n        let mid = Math.floor((start + end)/2);\\n        let time = arr[mid][1];\\n        let val = arr[mid][0];\\n        if(time<timestamp){\\n            start = mid+1;\\n//             Storing the last known value which is less than timestamp\\n            out = arr[mid];\\n        }\\n        else if(time>timestamp){\\n            end = mid-1;\\n        }\\n        else{\\n            return val;\\n        }  \\n    }\\n    \\n    \\n    try{\\n        if(arr[end][1]<=timestamp) return arr[end][0];\\n        else if(out[1]<timestamp) return out[0];\\n    }\\n    catch(err){\\n        return \"\";\\n    }\\n    // return out;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449517,
                "title": "python-solution",
                "content": "Using Heaps\\n```\\nfrom heapq import *\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.times = collections.defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        # -1 to make it a maxheap\\n        heappush(self.times[key], (timestamp*-1, value))\\n        \\n    def get(self, key: str, timestamp: int) -> str:\\n        res = \"\"\\n        for value in self.times[key]:\\n            if abs(value[0]) <= timestamp:\\n                res = value[1]\\n                break\\n        return res\\n```\\n\\nBinary search:\\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.times = collections.defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.times[key].append((timestamp, value))\\n        \\n    def get(self, key: str, timestamp: int) -> str:\\n        values = self.times[key]\\n        if not values: return \\'\\'\\n        left, right = 0, len(values) - 1\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            pre_time, value = values[mid]\\n            if pre_time > timestamp:\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return values[left][1] if values[left][0] <= timestamp else \\'\\'\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.times = collections.defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        # -1 to make it a maxheap\\n        heappush(self.times[key], (timestamp*-1, value))\\n        \\n    def get(self, key: str, timestamp: int) -> str:\\n        res = \"\"\\n        for value in self.times[key]:\\n            if abs(value[0]) <= timestamp:\\n                res = value[1]\\n                break\\n        return res\\n```\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.times = collections.defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.times[key].append((timestamp, value))\\n        \\n    def get(self, key: str, timestamp: int) -> str:\\n        values = self.times[key]\\n        if not values: return \\'\\'\\n        left, right = 0, len(values) - 1\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            pre_time, value = values[mid]\\n            if pre_time > timestamp:\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return values[left][1] if values[left][0] <= timestamp else \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226647,
                "title": "short-python-binary-search-solution",
                "content": "The idea is to have a map, with the values as a list with timestamp attached.\\nFor get, its then a simple binary search in the list.\\n\\n```\\nfrom collections import defaultdict\\nfrom bisect import bisect_right\\n\\nclass TimeMap:\\n    def __init__(self):\\n        self.ktimestamp = defaultdict(list)\\n        self.kv = defaultdict(list)\\n\\n    def set(self, key: \\'str\\', value: \\'str\\', timestamp: \\'int\\') -> \\'None\\':\\n        self.kv[key].append(value)\\n        self.ktimestamp[key].append(timestamp)\\n\\n    def get(self, key: \\'str\\', timestamp: \\'int\\') -> \\'str\\':\\n        if key not in self.kv: return \\'\\'\\n        idx = bisect_right(self.ktimestamp[key], timestamp)\\n        return \\'\\' if idx == 0 else self.kv[key][idx-1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_right\\n\\nclass TimeMap:\\n    def __init__(self):\\n        self.ktimestamp = defaultdict(list)\\n        self.kv = defaultdict(list)\\n\\n    def set(self, key: \\'str\\', value: \\'str\\', timestamp: \\'int\\') -> \\'None\\':\\n        self.kv[key].append(value)\\n        self.ktimestamp[key].append(timestamp)\\n\\n    def get(self, key: \\'str\\', timestamp: \\'int\\') -> \\'str\\':\\n        if key not in self.kv: return \\'\\'\\n        idx = bisect_right(self.ktimestamp[key], timestamp)\\n        return \\'\\' if idx == 0 else self.kv[key][idx-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557382,
                "title": "easy-to-read-c-solution-binary-search-with-hashmap",
                "content": "```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, vector<pair<string, int>>> map; // key, {value, timestamp}\\n    \\n    string searchVal(vector<pair<string, int>> &vec, const int &timestamp) {\\n        int low = 0;\\n        int high = vec.size() - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if (vec[mid].second > timestamp) {\\n                high = mid - 1;\\n            } else if (vec[mid].second < timestamp) {\\n                low = mid + 1;\\n            } else {\\n                return vec[mid].first;\\n            }\\n        }\\n        \\n        return high >= 0 ? vec[high].first : \"\";\\n    }\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        map[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if (map.find(key) == map.end()) {\\n            return \"\";\\n        }\\n        return searchVal(map[key], timestamp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, vector<pair<string, int>>> map; // key, {value, timestamp}\\n    \\n    string searchVal(vector<pair<string, int>> &vec, const int &timestamp) {\\n        int low = 0;\\n        int high = vec.size() - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if (vec[mid].second > timestamp) {\\n                high = mid - 1;\\n            } else if (vec[mid].second < timestamp) {\\n                low = mid + 1;\\n            } else {\\n                return vec[mid].first;\\n            }\\n        }\\n        \\n        return high >= 0 ? vec[high].first : \"\";\\n    }\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        map[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if (map.find(key) == map.end()) {\\n            return \"\";\\n        }\\n        return searchVal(map[key], timestamp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204570,
                "title": "python-line-by-line-perfect-explanations-fast-well-commented-using-defaultdict",
                "content": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        #Declare Default Dictionary because we want to append [values,timestamp] to the key\\n        self.d = defaultdict(list)\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        \\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        #Append the value to the key with the timestamp\\n        self.d[key].append([value,timestamp])\\n        \\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        #Store the value of key in a variable\\n        if key in self.d:\\n            temp = self.d[key]\\n        \\n        #print(temp) to get clear idea\\n        \\n        #Edgecase 1\\n        if not temp:\\n            return \"\"\\n        \\n        #Edgecase2\\n        if timestamp>temp[-1][1]:\\n            return temp[-1][0]\\n        \\n        #Egdecase3\\n        if timestamp<temp[0][1]:\\n            return \"\"\\n        \\n        #We will have an array with timestamp values and we have to find a particular timestamp value or smaller than it\\n        #We will use binary search O(logN) time\\n        l = 0\\n        r = len(temp)-1\\n        while l<=r:\\n            mid = (l+r)//2\\n            if temp[mid][1]>timestamp:\\n                r = mid-1\\n            else:\\n                l = mid +1\\n        \\n        #Return the matching value\\n        if l<len(temp)-1:\\n            return temp[l][0]\\n        else:\\n            return temp[r][0]\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        #Declare Default Dictionary because we want to append [values,timestamp] to the key\\n        self.d = defaultdict(list)\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        \\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        #Append the value to the key with the timestamp\\n        self.d[key].append([value,timestamp])\\n        \\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        #Store the value of key in a variable\\n        if key in self.d:\\n            temp = self.d[key]\\n        \\n        #print(temp) to get clear idea\\n        \\n        #Edgecase 1\\n        if not temp:\\n            return \"\"\\n        \\n        #Edgecase2\\n        if timestamp>temp[-1][1]:\\n            return temp[-1][0]\\n        \\n        #Egdecase3\\n        if timestamp<temp[0][1]:\\n            return \"\"\\n        \\n        #We will have an array with timestamp values and we have to find a particular timestamp value or smaller than it\\n        #We will use binary search O(logN) time\\n        l = 0\\n        r = len(temp)-1\\n        while l<=r:\\n            mid = (l+r)//2\\n            if temp[mid][1]>timestamp:\\n                r = mid-1\\n            else:\\n                l = mid +1\\n        \\n        #Return the matching value\\n        if l<len(temp)-1:\\n            return temp[l][0]\\n        else:\\n            return temp[r][0]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2668479,
                "title": "c-binary-search-in-map-of-string-vector",
                "content": "```\\nclass TimeMap {\\npublic:\\n    map<string, vector<pair<int,string>>> mp;\\n//     TimeMap() {\\n        \\n//     }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        string ans=\"\";\\n        // for(auto &it : mp[key] )\\n        // {\\n        //     if(it.first>timestamp) break;\\n        //     ans=it.second;\\n        // }\\n        int left=0,right=mp[key].size()-1,mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(mp[key][mid].first<timestamp) left=mid+1;\\n            else if(mp[key][mid].first==timestamp) return mp[key][mid].second;\\n            else right=mid-1;\\n            \\n        }\\n        if(right>=0) ans=mp[key][right].second;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\npublic:\\n    map<string, vector<pair<int,string>>> mp;\\n//     TimeMap() {\\n        \\n//     }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        string ans=\"\";\\n        // for(auto &it : mp[key] )\\n        // {\\n        //     if(it.first>timestamp) break;\\n        //     ans=it.second;\\n        // }\\n        int left=0,right=mp[key].size()-1,mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(mp[key][mid].first<timestamp) left=mid+1;\\n            else if(mp[key][mid].first==timestamp) return mp[key][mid].second;\\n            else right=mid-1;\\n            \\n        }\\n        if(right>=0) ans=mp[key][right].second;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667050,
                "title": "java-98-faster-code-hashmap",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass TimeMap {\\n\\n    Map<String, List<Pair<String, Integer>>> map = new HashMap<>();\\n    public TimeMap() { }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)) {\\n            map.put(key, new ArrayList<>());\\n        }\\n        map.get(key).add(new Pair(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)) {\\n            return \"\";\\n        }\\n        return binaryGet(map.get(key), 0, map.get(key).size() - 1, timestamp);\\n    }\\n    \\n    private String binaryGet(List<Pair<String, Integer>> list, int start, int end, int timestamp) {\\n    \\n        if(start > end) return \"\";\\n        \\n        int mid = start + (end - start) / 2;\\n        Pair<String, Integer> midItem = list.get(mid);\\n        \\n        if(timestamp == midItem.getValue()) return midItem.getKey();\\n        \\n        if(timestamp < midItem.getValue()) {\\n            if(mid - 1 < 0) return \"\";\\n            if(list.get(mid - 1).getValue() <= timestamp) return list.get(mid - 1).getKey();\\n            return binaryGet(list, start, mid - 1, timestamp);\\n        }\\n        else {\\n            if(mid + 1 >= list.size()) return midItem.getKey();\\n            if(list.get(mid + 1).getValue() == timestamp) return list.get(mid + 1).getKey();\\n            return binaryGet(list, mid + 1, end, timestamp);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TimeMap {\\n\\n    Map<String, List<Pair<String, Integer>>> map = new HashMap<>();\\n    public TimeMap() { }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)) {\\n            map.put(key, new ArrayList<>());\\n        }\\n        map.get(key).add(new Pair(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)) {\\n            return \"\";\\n        }\\n        return binaryGet(map.get(key), 0, map.get(key).size() - 1, timestamp);\\n    }\\n    \\n    private String binaryGet(List<Pair<String, Integer>> list, int start, int end, int timestamp) {\\n    \\n        if(start > end) return \"\";\\n        \\n        int mid = start + (end - start) / 2;\\n        Pair<String, Integer> midItem = list.get(mid);\\n        \\n        if(timestamp == midItem.getValue()) return midItem.getKey();\\n        \\n        if(timestamp < midItem.getValue()) {\\n            if(mid - 1 < 0) return \"\";\\n            if(list.get(mid - 1).getValue() <= timestamp) return list.get(mid - 1).getKey();\\n            return binaryGet(list, start, mid - 1, timestamp);\\n        }\\n        else {\\n            if(mid + 1 >= list.size()) return midItem.getKey();\\n            if(list.get(mid + 1).getValue() == timestamp) return list.get(mid + 1).getKey();\\n            return binaryGet(list, mid + 1, end, timestamp);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587306,
                "title": "java-100-faster-easy-solution-binary-search",
                "content": "```\\nclass TimeValue {\\n    String val;\\n    int timestamp;\\n    \\n    public TimeValue(String val, int time){\\n        this.val = val;\\n        timestamp = time;\\n    }\\n}\\nclass TimeMap {\\n    Map<String, List<TimeValue>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key, k -> new ArrayList<>()).add(new TimeValue(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        List<TimeValue> list = map.getOrDefault(key, null);\\n        if(list == null) return \"\";\\n        int low = 0, high = list.size()-1;\\n        if(list.get(low).timestamp > timestamp) return \"\";\\n        if(list.get(high).timestamp <= timestamp) return list.get(high).val;\\n        while(low < high){\\n           int mid = (low + high) / 2;\\n           if(list.get(mid).timestamp == timestamp) return list.get(mid).val;\\n           if(list.get(mid).timestamp < timestamp) low = mid + 1;\\n           else high = mid - 1;\\n            \\n        }\\n        return list.get(low - 1).val;\\n        \\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeValue {\\n    String val;\\n    int timestamp;\\n    \\n    public TimeValue(String val, int time){\\n        this.val = val;\\n        timestamp = time;\\n    }\\n}\\nclass TimeMap {\\n    Map<String, List<TimeValue>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key, k -> new ArrayList<>()).add(new TimeValue(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        List<TimeValue> list = map.getOrDefault(key, null);\\n        if(list == null) return \"\";\\n        int low = 0, high = list.size()-1;\\n        if(list.get(low).timestamp > timestamp) return \"\";\\n        if(list.get(high).timestamp <= timestamp) return list.get(high).val;\\n        while(low < high){\\n           int mid = (low + high) / 2;\\n           if(list.get(mid).timestamp == timestamp) return list.get(mid).val;\\n           if(list.get(mid).timestamp < timestamp) low = mid + 1;\\n           else high = mid - 1;\\n            \\n        }\\n        return list.get(low - 1).val;\\n        \\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629603,
                "title": "c-supper-short-map-and-unordered-map",
                "content": "```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, map<int, string>> m;\\npublic:\\n    /** Initialize your data structure here. */\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if (m.find(key) == m.end()) {\\n            return \"\";\\n        }\\n        auto it = m[key].upper_bound(timestamp);\\n        if (it != m[key].begin()) {\\n            it--;\\n            return it->second;\\n        } else {\\n            return \"\";\\n        }\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, map<int, string>> m;\\npublic:\\n    /** Initialize your data structure here. */\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if (m.find(key) == m.end()) {\\n            return \"\";\\n        }\\n        auto it = m[key].upper_bound(timestamp);\\n        if (it != m[key].begin()) {\\n            it--;\\n            return it->second;\\n        } else {\\n            return \"\";\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351712,
                "title": "c-3-line-code-binary-search-in-map-of-pair-in-1-line",
                "content": "\\n\\n# Code\\n```\\nclass TimeMap {\\npublic:\\n    map<pair<string , int> , string > mp;\\n\\n    TimeMap() {}\\n\\n    void set(string key, string val, int tt) { mp[{key , tt}] = val; }\\n\\n    string get(string key, int tt) {\\n        auto it = mp.lower_bound({key,tt});\\n        if(it != mp.end()) if((*it).first.first == key && (*it).first.second <= tt ) return (*it).second; it--;\\n        if((*it).first.first == key && (*it).first.second <= tt ) return (*it).second; return \"\";\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    map<pair<string , int> , string > mp;\\n\\n    TimeMap() {}\\n\\n    void set(string key, string val, int tt) { mp[{key , tt}] = val; }\\n\\n    string get(string key, int tt) {\\n        auto it = mp.lower_bound({key,tt});\\n        if(it != mp.end()) if((*it).first.first == key && (*it).first.second <= tt ) return (*it).second; it--;\\n        if((*it).first.first == key && (*it).first.second <= tt ) return (*it).second; return \"\";\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667216,
                "title": "java-hashmap-treemap-solution",
                "content": "```\\nclass TimeMap {\\n    HashMap<String,TreeMap<Integer,String>> hm;\\n    public TimeMap() {\\n        hm=new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!hm.containsKey(key)){\\n            TreeMap<Integer,String> hm2=new TreeMap<>();\\n            hm2.put(timestamp,value);\\n            hm.put(key,hm2);\\n        }\\n        else{\\n            hm.get(key).put(timestamp,value);\\n        }\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(hm.containsKey(key)){\\n            if(hm.get(key).containsKey(timestamp)){\\n                return hm.get(key).get(timestamp);\\n            }\\n            else{\\n                Integer prevTimestamp=hm.get(key).floorKey(timestamp);\\n                if(prevTimestamp!=null){\\n                    return hm.get(key).get(prevTimestamp);\\n                }\\n                // for(int i=timestamp;i>=1;i--){\\n                //     if(hm.get(key).containsKey(i)){\\n                //         return hm.get(key).get(i);\\n                //     }\\n                // }\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    HashMap<String,TreeMap<Integer,String>> hm;\\n    public TimeMap() {\\n        hm=new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!hm.containsKey(key)){\\n            TreeMap<Integer,String> hm2=new TreeMap<>();\\n            hm2.put(timestamp,value);\\n            hm.put(key,hm2);\\n        }\\n        else{\\n            hm.get(key).put(timestamp,value);\\n        }\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(hm.containsKey(key)){\\n            if(hm.get(key).containsKey(timestamp)){\\n                return hm.get(key).get(timestamp);\\n            }\\n            else{\\n                Integer prevTimestamp=hm.get(key).floorKey(timestamp);\\n                if(prevTimestamp!=null){\\n                    return hm.get(key).get(prevTimestamp);\\n                }\\n                // for(int i=timestamp;i>=1;i--){\\n                //     if(hm.get(key).containsKey(i)){\\n                //         return hm.get(key).get(i);\\n                //     }\\n                // }\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067666,
                "title": "c-two-approaches-using-binary-search-map",
                "content": "**Using Map**\\n```\\nclass TimeMap {\\npublic:\\n    unordered_map<string, map<int, string, greater<int>>> mp;\\n    TimeMap() {}\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        auto &v = mp[key];\\n        \\n        auto itm = v.lower_bound(timestamp);\\n        if(itm == v.end()) return \"\";\\n        \\n        return itm->second;\\n\\n    }\\n};\\n```\\n**Using Binary Search**\\n```\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, vector<pair<int, string>>> mp;\\n    TimeMap() {}\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        auto &v = mp[key];\\n        \\n        int low = 0;\\n        int high = v.size()-1;\\n        int idx = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(v[mid].first <= timestamp)\\n            {\\n                idx = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        if(idx == -1) return \"\";\\n        return v[idx].second;\\n\\n    }\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string, map<int, string, greater<int>>> mp;\\n    TimeMap() {}\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        auto &v = mp[key];\\n        \\n        auto itm = v.lower_bound(timestamp);\\n        if(itm == v.end()) return \"\";\\n        \\n        return itm->second;\\n\\n    }\\n};\\n```\n```\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, vector<pair<int, string>>> mp;\\n    TimeMap() {}\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        auto &v = mp[key];\\n        \\n        int low = 0;\\n        int high = v.size()-1;\\n        int idx = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(v[mid].first <= timestamp)\\n            {\\n                idx = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        if(idx == -1) return \"\";\\n        return v[idx].second;\\n\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430730,
                "title": "js-using-hashmap-and-binary-search",
                "content": "```\\nclass TimeMap {\\n    constructor() {             // O(1)\\n        this.map = new Map();   // SC: O(T)\\n    }\\n    set(key, value, timestamp) {    // O(1)\\n        const keyVals = this.map.has(key) ? this.map.get(key) : [];\\n        keyVals.push([timestamp, value]);\\n        this.map.set(key, keyVals);\\n    }\\n    get(key, timestamp) {           // O(logT)\\n        const keyTimestamps = this.map.has(key) ? this.map.get(key) : [];\\n        let left = 0,\\n            right = keyTimestamps.length - 1,\\n            mid, ts = null\\n        \\n\\t\\t// using binary search to find the ts <= timestamp\\n        while(left <= right) {\\n            mid = left + Math.floor((right - left) / 2);\\n            if(keyTimestamps[mid][0] <= timestamp) {\\n                ts = keyTimestamps[mid][1];\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return ts === null ? \"\" : ts;\\n    }\\n}\\n```\\nTime Complexity:\\n`set: O(1)`\\n`get: O(logT)`\\nSpace Complexity: `O(T)`\\n[T - number of timestamps]\\n\\nSimilar approach as https://leetcode.com/problems/snapshot-array/discuss/1429705/JS-Initial-and-Optimised-solution Solution 2 and 3",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    constructor() {             // O(1)\\n        this.map = new Map();   // SC: O(T)\\n    }\\n    set(key, value, timestamp) {    // O(1)\\n        const keyVals = this.map.has(key) ? this.map.get(key) : [];\\n        keyVals.push([timestamp, value]);\\n        this.map.set(key, keyVals);\\n    }\\n    get(key, timestamp) {           // O(logT)\\n        const keyTimestamps = this.map.has(key) ? this.map.get(key) : [];\\n        let left = 0,\\n            right = keyTimestamps.length - 1,\\n            mid, ts = null\\n        \\n\\t\\t// using binary search to find the ts <= timestamp\\n        while(left <= right) {\\n            mid = left + Math.floor((right - left) / 2);\\n            if(keyTimestamps[mid][0] <= timestamp) {\\n                ts = keyTimestamps[mid][1];\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return ts === null ? \"\" : ts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414522,
                "title": "java-using-hashmap-upperbound",
                "content": "\\n\\n    class pair{\\n    int x;\\n    String y;\\n    pair(int x1,String y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\n       \\n\\t  class TimeMap {\\n        Map<String,List<pair>> m;\\n        Map<Integer,String> m1;\\n    public TimeMap() {\\n        m=new HashMap<>();\\n        m1=new HashMap<>();\\n    }\\n    \\n    public void set(String key, String val, int time) {\\n        if(!m.containsKey(key)){\\n            m.put(key,new ArrayList<>());\\n        }\\n        m.get(key).add(new pair(time,val));\\n        m1.put(time,val);\\n    }\\n    \\n    public String get(String key, int time) {\\n        if(!m.containsKey(key))return \"\";\\n        List<pair> l=m.get(key);\\n        \\n        int ind=upperbound(l,time);\\n        \\n        if(ind==-1)return \"\";\\n        return m1.get(ind);\\n    }\\n    public int upperbound(List<pair> l,int x1){\\n        int i=0;\\n        int j=l.size()-1;\\n        int ans=-1;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(l.get(mid).x<=x1){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else j=mid-1;\\n        }\\n        if(ans==-1)return -1;\\n        return l.get(ans).x;\\n    }\\n}\\n\\n  \\n    /**\\n     * Your TimeMap object will be instantiated and called as such:\\n     * TimeMap obj = new TimeMap();\\n     * obj.set(key,value,timestamp);\\n     * String param_2 = obj.get(key,timestamp);\\n     */",
                "solutionTags": [],
                "code": "\\n\\n    class pair{\\n    int x;\\n    String y;\\n    pair(int x1,String y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\n       \\n\\t  class TimeMap {\\n        Map<String,List<pair>> m;\\n        Map<Integer,String> m1;\\n    public TimeMap() {\\n        m=new HashMap<>();\\n        m1=new HashMap<>();\\n    }\\n    \\n    public void set(String key, String val, int time) {\\n        if(!m.containsKey(key)){\\n            m.put(key,new ArrayList<>());\\n        }\\n        m.get(key).add(new pair(time,val));\\n        m1.put(time,val);\\n    }\\n    \\n    public String get(String key, int time) {\\n        if(!m.containsKey(key))return \"\";\\n        List<pair> l=m.get(key);\\n        \\n        int ind=upperbound(l,time);\\n        \\n        if(ind==-1)return \"\";\\n        return m1.get(ind);\\n    }\\n    public int upperbound(List<pair> l,int x1){\\n        int i=0;\\n        int j=l.size()-1;\\n        int ans=-1;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(l.get(mid).x<=x1){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else j=mid-1;\\n        }\\n        if(ans==-1)return -1;\\n        return l.get(ans).x;\\n    }\\n}\\n\\n  \\n    /**\\n     * Your TimeMap object will be instantiated and called as such:\\n     * TimeMap obj = new TimeMap();\\n     * obj.set(key,value,timestamp);\\n     * String param_2 = obj.get(key,timestamp);\\n     */",
                "codeTag": "Java"
            },
            {
                "id": 1701173,
                "title": "java-treemap-solution",
                "content": "```\\nclass TimeMap {\\n  Map<String, TreeMap<Integer, String>> map = new HashMap<>();\\n\\n  public void set(String key, String value, int timestamp) {\\n    map.putIfAbsent(key, new TreeMap<>());\\n    map.get(key).put(timestamp, value);\\n  }\\n\\n  public String get(String key, int timestamp) {\\n    if (!map.containsKey(key)) return \"\";\\n    Integer timestampPrev = map.get(key).floorKey(timestamp);\\n    return timestampPrev != null ? map.get(key).get(timestampPrev) : \"\";\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TimeMap {\\n  Map<String, TreeMap<Integer, String>> map = new HashMap<>();\\n\\n  public void set(String key, String value, int timestamp) {\\n    map.putIfAbsent(key, new TreeMap<>());\\n    map.get(key).put(timestamp, value);\\n  }\\n\\n  public String get(String key, int timestamp) {\\n    if (!map.containsKey(key)) return \"\";\\n    Integer timestampPrev = map.get(key).floorKey(timestamp);\\n    return timestampPrev != null ? map.get(key).get(timestampPrev) : \"\";\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514608,
                "title": "map-with-binary-search-approach-c-clean-code",
                "content": "# Code :\\n\\n```\\nclass TimeMap {\\n\\t// Map { key, vec[timestamp, value] }\\n    unordered_map<string,vector<pair<int, string>>> mp; \\npublic: \\n    \\n    static bool compare(const int& val, const pair<int, string>& a) {\\n        return a.first > val;\\n    }\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto& vec = mp[key];\\n        auto itr = upper_bound(vec.begin(), vec.end(), timestamp, compare);\\n        \\n        return itr == vec.begin() ? \"\" : prev(itr)->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\n\\t// Map { key, vec[timestamp, value] }\\n    unordered_map<string,vector<pair<int, string>>> mp; \\npublic: \\n    \\n    static bool compare(const int& val, const pair<int, string>& a) {\\n        return a.first > val;\\n    }\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto& vec = mp[key];\\n        auto itr = upper_bound(vec.begin(), vec.end(), timestamp, compare);\\n        \\n        return itr == vec.begin() ? \"\" : prev(itr)->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431761,
                "title": "python3-python-simple-solution-using-bisect-module",
                "content": "```\\nimport bisect\\nfrom collections import defaultdict\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.values = defaultdict(list)\\n        self.timestamps = defaultdict(list)\\n        return\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.values[key].append(value)\\n        self.timestamps[key].append(timestamp)\\n        # Note: All the timestamps are strictly increasing hence no sorting required.\\n        return\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        res = \"\"\\n        if key in self.timestamps:\\n            # NOTE: If there are multiple such values returns the value associated with the largest timestamp_prev\\n            pos = bisect.bisect_right(self.timestamps[key], timestamp)\\n            res = self.values[key][pos-1] if pos else res\\n        return res\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport bisect\\nfrom collections import defaultdict\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.values = defaultdict(list)\\n        self.timestamps = defaultdict(list)\\n        return\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.values[key].append(value)\\n        self.timestamps[key].append(timestamp)\\n        # Note: All the timestamps are strictly increasing hence no sorting required.\\n        return\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        res = \"\"\\n        if key in self.timestamps:\\n            # NOTE: If there are multiple such values returns the value associated with the largest timestamp_prev\\n            pos = bisect.bisect_right(self.timestamps[key], timestamp)\\n            res = self.values[key][pos-1] if pos else res\\n        return res\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133362,
                "title": "simple-python-solution-beat-99-9",
                "content": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dct = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        if key not in self.dct:\\n            self.dct[key] = [[timestamp], [value]]\\n        else:\\n            self.dct[key][0].append(timestamp)\\n            self.dct[key][1].append(value)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.dct: return \"\"\\n        time, val = self.dct[key]\\n        idx = bisect.bisect_right(time, timestamp)\\n        if idx == 0: return \"\"\\n        return val[idx - 1]\\n",
                "solutionTags": [],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dct = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        if key not in self.dct:\\n            self.dct[key] = [[timestamp], [value]]\\n        else:\\n            self.dct[key][0].append(timestamp)\\n            self.dct[key][1].append(value)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.dct: return \"\"\\n        time, val = self.dct[key]\\n        idx = bisect.bisect_right(time, timestamp)\\n        if idx == 0: return \"\"\\n        return val[idx - 1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 600333,
                "title": "java-solution-map-with-binary-search",
                "content": "```\\nclass TimeMap {\\n    class Tval{\\n        String val;\\n        int time;\\n        Tval(String x, int y){\\n            val = x; time = y; \\n        }\\n    }\\n    Map<String,ArrayList<Tval>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)) map.put(key,new ArrayList<>());\\n        map.get(key).add(new Tval(value,timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        int ind = binarySearch(map.getOrDefault(key,new ArrayList<Tval>()),timestamp);\\n        if(ind == -1) return \"\";\\n        return map.get(key).get(ind).val;\\n    }\\n    \\n    public int binarySearch(ArrayList<Tval> list,int t){\\n        int l = 0,r = list.size() - 1,ind = -1;\\n        if(r == -1) return r;\\n        while(l <= r){\\n            int mid = l + (r - l)/2;\\n            int x = list.get(mid).time;\\n            if(x == t) return mid;\\n            else if(x > t) r = mid - 1;\\n            else {\\n                l = mid + 1;\\n                ind = mid;\\n            }\\n        }\\n        return ind;\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass TimeMap {\\n    class Tval{\\n        String val;\\n        int time;\\n        Tval(String x, int y){\\n            val = x; time = y; \\n        }\\n    }\\n    Map<String,ArrayList<Tval>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)) map.put(key,new ArrayList<>());\\n        map.get(key).add(new Tval(value,timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        int ind = binarySearch(map.getOrDefault(key,new ArrayList<Tval>()),timestamp);\\n        if(ind == -1) return \"\";\\n        return map.get(key).get(ind).val;\\n    }\\n    \\n    public int binarySearch(ArrayList<Tval> list,int t){\\n        int l = 0,r = list.size() - 1,ind = -1;\\n        if(r == -1) return r;\\n        while(l <= r){\\n            int mid = l + (r - l)/2;\\n            int x = list.get(mid).time;\\n            if(x == t) return mid;\\n            else if(x > t) r = mid - 1;\\n            else {\\n                l = mid + 1;\\n                ind = mid;\\n            }\\n        }\\n        return ind;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521577,
                "title": "concise-hashmap-with-treemap-solution-in-java",
                "content": "```\\nclass TimeMap {\\n    HashMap<String, TreeMap<Integer, String>> timeMap;\\n\\n    public TimeMap() {\\n        timeMap = new HashMap<String, TreeMap<Integer, String>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        timeMap.putIfAbsent(key, new TreeMap<Integer, String>());\\n        timeMap.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(timeMap.get(key) == null) return \"\";\\n\\n        Map.Entry<Integer, String> res = timeMap.get(key).floorEntry(timestamp);\\n        return res == null ? \"\" : res.getValue();\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    HashMap<String, TreeMap<Integer, String>> timeMap;\\n\\n    public TimeMap() {\\n        timeMap = new HashMap<String, TreeMap<Integer, String>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        timeMap.putIfAbsent(key, new TreeMap<Integer, String>());\\n        timeMap.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(timeMap.get(key) == null) return \"\";\\n\\n        Map.Entry<Integer, String> res = timeMap.get(key).floorEntry(timestamp);\\n        return res == null ? \"\" : res.getValue();\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669539,
                "title": "c-vector-pair-solution-solution-389-ms",
                "content": "class TimeMap {\\npublic:\\n    vector<pair< string, pair<string, int>>> v;\\n   \\n    TimeMap() \\n    {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) \\n    {\\n        pair<string, int> p = {value, timestamp};\\n        pair<string, pair<string, int> > p1 = {key, p};\\n        v.push_back(p1);\\n       \\n        \\n    }\\n    \\n    string get(string key, int timestamp) \\n    {\\n        string ans=\"\";\\n        for(int i=v.size()-1; i>=0; i--)\\n        {\\n            if(v[i].first==key)\\n            {\\n                \\n                if(v[i].second.second==timestamp)\\n                {\\n                    return v[i].second.first;\\n                }\\n                else if(v[i].second.second<timestamp)\\n                {\\n                    return v[i].second.first;\\n                    // ans = v[i].second.first;\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */",
                "solutionTags": [],
                "code": "class TimeMap {\\npublic:\\n    vector<pair< string, pair<string, int>>> v;\\n   \\n    TimeMap() \\n    {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) \\n    {\\n        pair<string, int> p = {value, timestamp};\\n        pair<string, pair<string, int> > p1 = {key, p};\\n        v.push_back(p1);\\n       \\n        \\n    }\\n    \\n    string get(string key, int timestamp) \\n    {\\n        string ans=\"\";\\n        for(int i=v.size()-1; i>=0; i--)\\n        {\\n            if(v[i].first==key)\\n            {\\n                \\n                if(v[i].second.second==timestamp)\\n                {\\n                    return v[i].second.first;\\n                }\\n                else if(v[i].second.second<timestamp)\\n                {\\n                    return v[i].second.first;\\n                    // ans = v[i].second.first;\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2669226,
                "title": "python3-hashmap-and-binary-search-solution",
                "content": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.s_v = {}\\n        self.s_t = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.s_v.setdefault(key, []).append(value)\\n        self.s_t.setdefault(key, []).append(timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        lo, hi = 0, len(self.s_t.get(key, [])) - 1\\n        mid = 0\\n        while lo <= hi:\\n            mid = lo + (hi - lo) // 2\\n            if self.s_t[key][mid] == timestamp: break\\n            elif self.s_t[key][mid] > timestamp: hi = mid - 1\\n            else: lo = mid + 1\\n        else:\\n            mid = lo - 1\\n        return self.s_v[key][mid] if mid >= 0 else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.s_v = {}\\n        self.s_t = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.s_v.setdefault(key, []).append(value)\\n        self.s_t.setdefault(key, []).append(timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        lo, hi = 0, len(self.s_t.get(key, [])) - 1\\n        mid = 0\\n        while lo <= hi:\\n            mid = lo + (hi - lo) // 2\\n            if self.s_t[key][mid] == timestamp: break\\n            elif self.s_t[key][mid] > timestamp: hi = mid - 1\\n            else: lo = mid + 1\\n        else:\\n            mid = lo - 1\\n        return self.s_v[key][mid] if mid >= 0 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668848,
                "title": "using-binary-search-map-of-vector-of-pair",
                "content": "```\\nclass TimeMap {\\npublic:\\n    // Unordered Map of string, vector of pairs\\n    unordered_map<string,vector<pair<int,string>>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key) == mp.end()) return \"\";\\n        int low = 0, high = mp[key].size()-1;\\n        if(mp[key][0].first > timestamp) return \"\";\\n        string ans = \"\";\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            if(mp[key][mid].first == timestamp) return mp[key][mid].second;\\n            if(mp[key][mid].first > timestamp){\\n                high = mid-1;\\n            }\\n            else{\\n                ans = mp[key][mid].second;\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    // Unordered Map of string, vector of pairs\\n    unordered_map<string,vector<pair<int,string>>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key) == mp.end()) return \"\";\\n        int low = 0, high = mp[key].size()-1;\\n        if(mp[key][0].first > timestamp) return \"\";\\n        string ans = \"\";\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            if(mp[key][mid].first == timestamp) return mp[key][mid].second;\\n            if(mp[key][mid].first > timestamp){\\n                high = mid-1;\\n            }\\n            else{\\n                ans = mp[key][mid].second;\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667837,
                "title": "java-using-hashmap-treemap-easy-solution",
                "content": "IF YOU LIKE THE SOLUTION\\nPLEASE MAKE SURE TO UPVOTE IT !\\n\\n```\\nclass TimeMap {\\n    \\n    // HashMap of key(String) corresponding of TreeMap<TimeStamp,Value>>\\n    HashMap<String,TreeMap<Integer,String>> map;\\n    \\n    public TimeMap() {\\n        map = new HashMap<String,TreeMap<Integer,String>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n\\n        TreeMap<Integer,String> tmap;\\n        // if key is not present create a new instance otherwise get that treemap which is already there in hashmap corresponding to key.\\n        if(map.get(key) != null)\\n            tmap = map.get(key);  \\n        else\\n            tmap = new TreeMap<>(Collections.reverseOrder());  \\n        // finally put key value in treemap and then in hashmap.\\n        tmap.put(timestamp,value);\\n        map.put(key,tmap);\\n        \\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        // Iterate in hashmap first.\\n        for(Map.Entry m : map.entrySet()){\\n            // if key is equal to our hashmap key \\n            if(m.getKey().equals(key)){\\n                // get the value which is treemap correspond to given key.\\n                TreeMap<Integer,String> tmap = (TreeMap<Integer,String>)m.getValue();\\n                // Iterate in treemap\\n                for(Map.Entry tm : tmap.entrySet()){\\n                    if((int)tm.getKey() <= timestamp) return String.valueOf(tm.getValue());\\n                }\\n            }\\n        }\\n        return \"\";\\n        \\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    \\n    // HashMap of key(String) corresponding of TreeMap<TimeStamp,Value>>\\n    HashMap<String,TreeMap<Integer,String>> map;\\n    \\n    public TimeMap() {\\n        map = new HashMap<String,TreeMap<Integer,String>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n\\n        TreeMap<Integer,String> tmap;\\n        // if key is not present create a new instance otherwise get that treemap which is already there in hashmap corresponding to key.\\n        if(map.get(key) != null)\\n            tmap = map.get(key);  \\n        else\\n            tmap = new TreeMap<>(Collections.reverseOrder());  \\n        // finally put key value in treemap and then in hashmap.\\n        tmap.put(timestamp,value);\\n        map.put(key,tmap);\\n        \\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        // Iterate in hashmap first.\\n        for(Map.Entry m : map.entrySet()){\\n            // if key is equal to our hashmap key \\n            if(m.getKey().equals(key)){\\n                // get the value which is treemap correspond to given key.\\n                TreeMap<Integer,String> tmap = (TreeMap<Integer,String>)m.getValue();\\n                // Iterate in treemap\\n                for(Map.Entry tm : tmap.entrySet()){\\n                    if((int)tm.getKey() <= timestamp) return String.valueOf(tm.getValue());\\n                }\\n            }\\n        }\\n        return \"\";\\n        \\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667700,
                "title": "c-custom-binary-search-function-easy-to-understand",
                "content": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,vector<pair<int,string>>>mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp,value});\\n    }\\n    \\n    pair<int,string> searchEqualOrLesser(vector<pair<int,string>>&arr, int key){\\n        int n = arr.size();\\n        int low = 0, high = n-1,res = INT_MAX;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(arr[mid].first < key){\\n                res = mid;\\n                low = mid+1;\\n            }else if(arr[mid].first > key){\\n                high = mid - 1;\\n            }else{\\n                res = mid;\\n                break;\\n            }\\n        }\\n        if(res == INT_MAX){\\n            return {INT_MAX,\"\"};\\n        }\\n        return arr[res];\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        pair<int,string> p = searchEqualOrLesser(mp[key],timestamp);\\n        if(p.first == INT_MAX){\\n            return \"\";\\n        }\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,vector<pair<int,string>>>mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp,value});\\n    }\\n    \\n    pair<int,string> searchEqualOrLesser(vector<pair<int,string>>&arr, int key){\\n        int n = arr.size();\\n        int low = 0, high = n-1,res = INT_MAX;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(arr[mid].first < key){\\n                res = mid;\\n                low = mid+1;\\n            }else if(arr[mid].first > key){\\n                high = mid - 1;\\n            }else{\\n                res = mid;\\n                break;\\n            }\\n        }\\n        if(res == INT_MAX){\\n            return {INT_MAX,\"\"};\\n        }\\n        return arr[res];\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        pair<int,string> p = searchEqualOrLesser(mp[key],timestamp);\\n        if(p.first == INT_MAX){\\n            return \"\";\\n        }\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667392,
                "title": "unordered-map-and-upper-bound",
                "content": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,map<int,string> > um;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int ts) {\\n        um[key][ts]=value;\\n    }\\n    \\n    string get(string key, int ts) {\\n        if(um.find(key)==um.end())return \"\";\\n        auto it=um[key].upper_bound(ts);\\n        if(it==um[key].begin())return \"\";\\n        return (--it)->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,map<int,string> > um;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int ts) {\\n        um[key][ts]=value;\\n    }\\n    \\n    string get(string key, int ts) {\\n        if(um.find(key)==um.end())return \"\";\\n        auto it=um[key].upper_bound(ts);\\n        if(it==um[key].begin())return \"\";\\n        return (--it)->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054604,
                "title": "javascript-binary-search",
                "content": "```\\n\\nvar TimeMap = function () {\\n    this.map = new Map();\\n};\\n\\nTimeMap.prototype.set = function (key, value, timestamp) {\\n    const map = this.map;\\n    if (!map.has(key)) map.set(key, []);\\n    map.get(key).push([value, timestamp]);\\n};\\n\\nTimeMap.prototype.get = function (key, timestamp) {\\n    const arr = this.map.get(key) || [];\\n\\n    let [l, r] = [0, arr.length - 1];\\n    let res = \"\";\\n    while (l <= r) {\\n        const mid = Math.floor((l + r) / 2);\\n        const [v, t] = arr[mid];\\n        if (timestamp === t) return v;\\n        if (timestamp >= t) {\\n            l = mid + 1;\\n            res = v;\\n        } else r = mid - 1;\\n\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n\\nvar TimeMap = function () {\\n    this.map = new Map();\\n};\\n\\nTimeMap.prototype.set = function (key, value, timestamp) {\\n    const map = this.map;\\n    if (!map.has(key)) map.set(key, []);\\n    map.get(key).push([value, timestamp]);\\n};\\n\\nTimeMap.prototype.get = function (key, timestamp) {\\n    const arr = this.map.get(key) || [];\\n\\n    let [l, r] = [0, arr.length - 1];\\n    let res = \"\";\\n    while (l <= r) {\\n        const mid = Math.floor((l + r) / 2);\\n        const [v, t] = arr[mid];\\n        if (timestamp === t) return v;\\n        if (timestamp >= t) {\\n            l = mid + 1;\\n            res = v;\\n        } else r = mid - 1;\\n\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518467,
                "title": "c-built-in-binarysearch-method-for-lists-maps-97",
                "content": "Very good question! I learned alot about the ```BinarySearch``` method for ```Lists``` in C#. Very useful so you don\\'t have to imlpement binary search from scratch and risk error/debugging time.\\n\\nHighly recommend reading:                     https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.binarysearch?view=net-5.0#System_Collections_Generic_List_1_BinarySearch__0_System_Collections_Generic_IComparer__0__\\n\\nTo learn about the ```BinarySearch``` method.\\n\\n```\\npublic class TimeMap {\\n\\n    Dictionary<string, List<Tuple<int, string>>> cache;\\n    \\n    public TimeMap() \\n    {\\n        cache = new Dictionary<string, List<Tuple<int, string>>>();    \\n    }\\n    \\n    public void Set(string key, string value, int timestamp) \\n    {\\n        \\n        if(!cache.ContainsKey(key))\\n        {\\n            cache.Add(key, new List<Tuple<int, string>>());\\n        }\\n        \\n        cache[key].Add(new Tuple<int, string>(timestamp, value));\\n    }\\n    \\n    public string Get(string key, int timestamp) \\n    {\\n        var answer = \"\";\\n        \\n        if(cache.ContainsKey(key))\\n        {\\n            \\n            if(timestamp > cache[key][cache[key].Count - 1].Item1)\\n            {\\n                answer = cache[key][cache[key].Count - 1].Item2;    \\n            }\\n            else if(timestamp < cache[key][0].Item1)\\n            {\\n                return answer;\\n            }\\n            else\\n            {\\n\\n                var indexOfItem = cache[key].BinarySearch(new Tuple<int, string>(timestamp,key), new BinarySearchComparer());\\n\\n                if(indexOfItem < 0) //wasn\\'t found\\n                {\\n                    var complement = ~indexOfItem;\\n                                        \\n                    if(complement == cache[key].Count) //means that there\\'s no item bigger than what was searched for, return \"\"\\n                    {\\n                        return answer;\\n                    }\\n                    \\n                    answer = cache[key][complement - 1].Item2;  \\n                    //complement - 1 because of how BinarySearch works : \\n                    /* \\n                    The zero-based index of item in the sorted List<T>, if item is found; otherwise, \\n                    a negative number that is the bitwise complement of the index of the next element that is larger than item or, \\n                    if there is no larger element, the bitwise complement of Count.\\n                    */\\n                    \\n                    return answer;\\n                }\\n\\n                answer = cache[key][indexOfItem].Item2;    \\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n}\\n\\npublic class BinarySearchComparer : IComparer<Tuple<int, string>>\\n{\\n    public int Compare(Tuple<int, string> a, Tuple<int, string> b)\\n    {\\n        return a.Item1.CompareTo(b.Item1);\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.Set(key,value,timestamp);\\n * string param_2 = obj.Get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```BinarySearch```\n```Lists```\n```BinarySearch```\n```\\npublic class TimeMap {\\n\\n    Dictionary<string, List<Tuple<int, string>>> cache;\\n    \\n    public TimeMap() \\n    {\\n        cache = new Dictionary<string, List<Tuple<int, string>>>();    \\n    }\\n    \\n    public void Set(string key, string value, int timestamp) \\n    {\\n        \\n        if(!cache.ContainsKey(key))\\n        {\\n            cache.Add(key, new List<Tuple<int, string>>());\\n        }\\n        \\n        cache[key].Add(new Tuple<int, string>(timestamp, value));\\n    }\\n    \\n    public string Get(string key, int timestamp) \\n    {\\n        var answer = \"\";\\n        \\n        if(cache.ContainsKey(key))\\n        {\\n            \\n            if(timestamp > cache[key][cache[key].Count - 1].Item1)\\n            {\\n                answer = cache[key][cache[key].Count - 1].Item2;    \\n            }\\n            else if(timestamp < cache[key][0].Item1)\\n            {\\n                return answer;\\n            }\\n            else\\n            {\\n\\n                var indexOfItem = cache[key].BinarySearch(new Tuple<int, string>(timestamp,key), new BinarySearchComparer());\\n\\n                if(indexOfItem < 0) //wasn\\'t found\\n                {\\n                    var complement = ~indexOfItem;\\n                                        \\n                    if(complement == cache[key].Count) //means that there\\'s no item bigger than what was searched for, return \"\"\\n                    {\\n                        return answer;\\n                    }\\n                    \\n                    answer = cache[key][complement - 1].Item2;  \\n                    //complement - 1 because of how BinarySearch works : \\n                    /* \\n                    The zero-based index of item in the sorted List<T>, if item is found; otherwise, \\n                    a negative number that is the bitwise complement of the index of the next element that is larger than item or, \\n                    if there is no larger element, the bitwise complement of Count.\\n                    */\\n                    \\n                    return answer;\\n                }\\n\\n                answer = cache[key][indexOfItem].Item2;    \\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n}\\n\\npublic class BinarySearchComparer : IComparer<Tuple<int, string>>\\n{\\n    public int Compare(Tuple<int, string> a, Tuple<int, string> b)\\n    {\\n        return a.Item1.CompareTo(b.Item1);\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.Set(key,value,timestamp);\\n * string param_2 = obj.Get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215144,
                "title": "simple-java-solution-using-map-of-treemaps",
                "content": "```\\nclass TimeMap {\\n    \\n    Map<String, TreeMap<Integer, String>> map;\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        TreeMap<Integer, String> values = map.getOrDefault(key, new TreeMap<>());\\n        values.put(timestamp, value);\\n        map.put(key, values);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (!map.containsKey(key)) return \"\";\\n        Integer valueKey = map.get(key).floorKey(timestamp);\\n        if (valueKey == null) return \"\";\\n        return map.get(key).get(valueKey);\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\n    \\n    Map<String, TreeMap<Integer, String>> map;\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        TreeMap<Integer, String> values = map.getOrDefault(key, new TreeMap<>());\\n        values.put(timestamp, value);\\n        map.put(key, values);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (!map.containsKey(key)) return \"\";\\n        Integer valueKey = map.get(key).floorKey(timestamp);\\n        if (valueKey == null) return \"\";\\n        return map.get(key).get(valueKey);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 724892,
                "title": "python-bisect",
                "content": "\\tclass TimeMap:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tInitialize your data structure here.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.d = defaultdict(list)\\n\\n\\t\\tdef set(self, key: str, value: str, timestamp: int) -> None:\\n\\t\\t\\tself.d[key].append((timestamp, value))\\n\\n\\n\\t\\tdef get(self, key: str, timestamp: int) -> str:\\n\\t\\t\\tindex = bisect.bisect(self.d[key], (timestamp + 1, \\'\\'))\\n\\t\\t\\tif index == 0:\\n\\t\\t\\t\\treturn \\'\\'\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn self.d[key][index - 1][1]",
                "solutionTags": [],
                "code": "\\tclass TimeMap:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tInitialize your data structure here.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.d = defaultdict(list)\\n\\n\\t\\tdef set(self, key: str, value: str, timestamp: int) -> None:\\n\\t\\t\\tself.d[key].append((timestamp, value))\\n\\n\\n\\t\\tdef get(self, key: str, timestamp: int) -> str:\\n\\t\\t\\tindex = bisect.bisect(self.d[key], (timestamp + 1, \\'\\'))\\n\\t\\t\\tif index == 0:\\n\\t\\t\\t\\treturn \\'\\'\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn self.d[key][index - 1][1]",
                "codeTag": "Java"
            },
            {
                "id": 576539,
                "title": "c-solution-with-inline-code-explanation",
                "content": "```\\nclass TimeMap {\\npublic:\\nunordered_map<string, map<int, string>> time_map;\\n    \\n    /** Initialize your data structure here. */\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        // use hash map to lookup ordered {timestamp, value} pairs by key in O(1).\\n        time_map[key].insert({ timestamp, value });\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto exist = time_map.find(key) !=  time_map.end();\\n        if (!exist) {\\n            return \"\";\\n        }\\n                \\n        // use binary search to find the value with a timestamp greater the requested one.\\n        auto it = time_map[key].upper_bound(timestamp);\\n        auto minimum_it = time_map[key].begin();\\n        \\n        // if the first item with greater timestamp is equal to the first item in the time_map[key]\\n        // it means there is no value with a timestamp less than or equal to the requestd one \\n        if (it == minimum_it) {\\n            return \"\";\\n        }\\n        \\n        // return an item with the largest timestamp\\n        return prev(it)->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\npublic:\\nunordered_map<string, map<int, string>> time_map;\\n    \\n    /** Initialize your data structure here. */\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        // use hash map to lookup ordered {timestamp, value} pairs by key in O(1).\\n        time_map[key].insert({ timestamp, value });\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto exist = time_map.find(key) !=  time_map.end();\\n        if (!exist) {\\n            return \"\";\\n        }\\n                \\n        // use binary search to find the value with a timestamp greater the requested one.\\n        auto it = time_map[key].upper_bound(timestamp);\\n        auto minimum_it = time_map[key].begin();\\n        \\n        // if the first item with greater timestamp is equal to the first item in the time_map[key]\\n        // it means there is no value with a timestamp less than or equal to the requestd one \\n        if (it == minimum_it) {\\n            return \"\";\\n        }\\n        \\n        // return an item with the largest timestamp\\n        return prev(it)->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227968,
                "title": "rust-btreemap-hashmap",
                "content": "It turned out to be slightly faster (~170ms vs ~250ms) to use ```HashMap<String, BTreeMap<i32, String>>``` over a ```BTreeMap<i32, HashMap<String, String>>```.\\n```\\nuse std::collections::{BTreeMap, HashMap};\\n\\nstruct TimeMap {\\n    tm : HashMap<String, BTreeMap<i32, String>>,\\n}\\n\\nimpl TimeMap {\\n    fn new() -> Self {\\n        TimeMap {\\n            tm : HashMap::new(),\\n        }\\n    }\\n    \\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\\n        self.tm.entry(key).or_insert(BTreeMap::new()).insert(timestamp, value);\\n    }\\n    \\n    fn get(&self, key: String, timestamp: i32) -> String {\\n        if let Some((_,v)) = self.tm[&key].range(0..=timestamp).rev().next() {\\n            return v.clone();\\n        }\\n        String::new()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```HashMap<String, BTreeMap<i32, String>>```\n```BTreeMap<i32, HashMap<String, String>>```\n```\\nuse std::collections::{BTreeMap, HashMap};\\n\\nstruct TimeMap {\\n    tm : HashMap<String, BTreeMap<i32, String>>,\\n}\\n\\nimpl TimeMap {\\n    fn new() -> Self {\\n        TimeMap {\\n            tm : HashMap::new(),\\n        }\\n    }\\n    \\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\\n        self.tm.entry(key).or_insert(BTreeMap::new()).insert(timestamp, value);\\n    }\\n    \\n    fn get(&self, key: String, timestamp: i32) -> String {\\n        if let Some((_,v)) = self.tm[&key].range(0..=timestamp).rev().next() {\\n            return v.clone();\\n        }\\n        String::new()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900276,
                "title": "key-value-store-logn-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDesign Redis\\n# Approach\\nBasic set operations, the tricky part here is the get operation which hints at binary search (as it\\'s based on increasing timestamp values)\\nOther than that, use a simple hashmap to implement a KVS where key = key and value = list of values [val and timestamp]\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n# How to know when to use binary search -> Constraints\\n# O(logN)\\nclass TimeMap:\\n  # bin search soln\\n  def __init__(self):\\n    self.store = {} # hashmap, key = string, val = [list of [val, timestamp]] {foo -> [bar, 1]}\\n\\n  def set(self, key: str, value: str, timestamp: int) -> None:\\n    if key not in self.store:\\n      # insert\\n      self.store[key] = [] # set to empty list.\\n    self.store[key].append([value, timestamp]) # append val & times\\n\\n  def get(self, key: str, timestamp: int) -> str:\\n    res = \"\" # if not exist just return empty\\n    values = self.store.get(key, []) # find match it\\'ll return that list if doesn\\'t then returns empty list (by default) [values is a list]\\n    \\n    # binary  search\\n    low, high = 0, len(values) - 1\\n    while low <= high:\\n      mid = (low + high) // 2\\n      # values[mid] will be a pair of values and timestamps\\n      # we only need to check timestamps (which is in incr order) hence values[mid][1]\\n      if values[mid][1] <= timestamp:\\n        # if equal or less than timestamp -> ans found\\n        res = values[mid][0] # closest we\\'ve seen so far -> store in ans\\n        low = mid + 1 # check for closer values\\n      else:\\n        # not allowed (acc to question)\\n        high = mid - 1 # don\\'t assign any result here as this is an invalid val\\n    return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\n# How to know when to use binary search -> Constraints\\n# O(logN)\\nclass TimeMap:\\n  # bin search soln\\n  def __init__(self):\\n    self.store = {} # hashmap, key = string, val = [list of [val, timestamp]] {foo -> [bar, 1]}\\n\\n  def set(self, key: str, value: str, timestamp: int) -> None:\\n    if key not in self.store:\\n      # insert\\n      self.store[key] = [] # set to empty list.\\n    self.store[key].append([value, timestamp]) # append val & times\\n\\n  def get(self, key: str, timestamp: int) -> str:\\n    res = \"\" # if not exist just return empty\\n    values = self.store.get(key, []) # find match it\\'ll return that list if doesn\\'t then returns empty list (by default) [values is a list]\\n    \\n    # binary  search\\n    low, high = 0, len(values) - 1\\n    while low <= high:\\n      mid = (low + high) // 2\\n      # values[mid] will be a pair of values and timestamps\\n      # we only need to check timestamps (which is in incr order) hence values[mid][1]\\n      if values[mid][1] <= timestamp:\\n        # if equal or less than timestamp -> ans found\\n        res = values[mid][0] # closest we\\'ve seen so far -> store in ans\\n        low = mid + 1 # check for closer values\\n      else:\\n        # not allowed (acc to question)\\n        high = mid - 1 # don\\'t assign any result here as this is an invalid val\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667126,
                "title": "java-hash-map-and-binary-search-explained",
                "content": "# Intuition\\nWe need to search values by `key` and `timestamp`.\\nFirst of all let\\'s bucket all relevant entires together by key, we will do this with a `hash map`.\\n\\nNow every key has many timestamps with values, we can have an array to represent that. Because the timestamp come in `increasing` order, the insert to our list is going to be `O(1)` because no re-indexing is done, we only append to the end.\\n\\nWhenever we need to get an element, we first search the `key` in the hash map `O(1)`, and then binary search the timestamp values `O(logn)` because we know we have inserted them in linearly increasing order.\\n\\nThe code should be very readable. Just go through it.\\n\\n# Code\\n```\\nimport java.util.Optional;\\n\\nclass TimeStampedValue {\\n    public int timestamp;\\n    public String value;\\n    \\n    public TimeStampedValue(int timestamp, String value) {\\n        this.timestamp = timestamp;\\n        this.value = value;\\n    }\\n}\\n\\nclass TimeMap {\\n    Map<String, ArrayList<TimeStampedValue>> entriesByKey;\\n\\n    public TimeMap() {\\n       entriesByKey = new HashMap<>(); \\n    }\\n    \\n    // We know that timestmap is strictly increasing. Hence O(1) insertion\\n    public void set(String key, String value, int timestamp) {\\n        if(!entriesByKey.containsKey(key)) {\\n            entriesByKey.put(key, new ArrayList<TimeStampedValue>());\\n        }\\n        ArrayList<TimeStampedValue> timeStampedValues = entriesByKey.get(key);\\n        timeStampedValues.add(new TimeStampedValue(timestamp, value));\\n    }\\n    \\n    // O(logn) because of binary search\\n    public String get(String key, int timestamp) {\\n        if(!entriesByKey.containsKey(key)) return \"\";\\n        \\n        ArrayList<TimeStampedValue> timeStampedValues = entriesByKey.get(key);\\n        Optional<TimeStampedValue> timeStamp = binarySearchTimestamp(timeStampedValues, timestamp);\\n        if(timeStamp.isEmpty()) {\\n            return \"\";\\n        }\\n        \\n        return timeStamp.get().value;\\n    }\\n    \\n    private Optional<TimeStampedValue> binarySearchTimestamp(ArrayList<TimeStampedValue> arr, int target) {\\n        int left = 0, right = arr.size() - 1;\\n        int matchIndex = -1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            TimeStampedValue cur = arr.get(mid);\\n            if(cur.timestamp <= target) {\\n                matchIndex = mid;\\n                left = mid + 1;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        if(matchIndex == -1) {\\n            return Optional.empty();\\n        }\\n        return Optional.of(arr.get(matchIndex));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Optional;\\n\\nclass TimeStampedValue {\\n    public int timestamp;\\n    public String value;\\n    \\n    public TimeStampedValue(int timestamp, String value) {\\n        this.timestamp = timestamp;\\n        this.value = value;\\n    }\\n}\\n\\nclass TimeMap {\\n    Map<String, ArrayList<TimeStampedValue>> entriesByKey;\\n\\n    public TimeMap() {\\n       entriesByKey = new HashMap<>(); \\n    }\\n    \\n    // We know that timestmap is strictly increasing. Hence O(1) insertion\\n    public void set(String key, String value, int timestamp) {\\n        if(!entriesByKey.containsKey(key)) {\\n            entriesByKey.put(key, new ArrayList<TimeStampedValue>());\\n        }\\n        ArrayList<TimeStampedValue> timeStampedValues = entriesByKey.get(key);\\n        timeStampedValues.add(new TimeStampedValue(timestamp, value));\\n    }\\n    \\n    // O(logn) because of binary search\\n    public String get(String key, int timestamp) {\\n        if(!entriesByKey.containsKey(key)) return \"\";\\n        \\n        ArrayList<TimeStampedValue> timeStampedValues = entriesByKey.get(key);\\n        Optional<TimeStampedValue> timeStamp = binarySearchTimestamp(timeStampedValues, timestamp);\\n        if(timeStamp.isEmpty()) {\\n            return \"\";\\n        }\\n        \\n        return timeStamp.get().value;\\n    }\\n    \\n    private Optional<TimeStampedValue> binarySearchTimestamp(ArrayList<TimeStampedValue> arr, int target) {\\n        int left = 0, right = arr.size() - 1;\\n        int matchIndex = -1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            TimeStampedValue cur = arr.get(mid);\\n            if(cur.timestamp <= target) {\\n                matchIndex = mid;\\n                left = mid + 1;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        if(matchIndex == -1) {\\n            return Optional.empty();\\n        }\\n        return Optional.of(arr.get(matchIndex));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666801,
                "title": "c-hash-map",
                "content": "The idea is simple and straight forward. \\nstore the key,timestam,value in map \\nIn the get function use a loop from the asked time stamp till 1 and check if we find any value in the map[key] then return that one only. \\nif the loop does not return any value then return  empty string. \\n\\n\\n**c++ code**\\n```\\nclass TimeMap {\\n    unordered_map<string,unordered_map<int,string>>storage;\\n    \\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        storage[key][timestamp]=value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        for(int t=timestamp;t>0;t--){\\n            if(storage[key].find(t)!=storage[key].end())return storage[key][t];\\n        }\\n        return \"\";\\n    }\\n}; ```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass TimeMap {\\n    unordered_map<string,unordered_map<int,string>>storage;\\n    \\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        storage[key][timestamp]=value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        for(int t=timestamp;t>0;t--){\\n            if(storage[key].find(t)!=storage[key].end())return storage[key][t];\\n        }\\n        return \"\";\\n    }\\n}; ```",
                "codeTag": "Java"
            },
            {
                "id": 2666599,
                "title": "java-treemap-binary-search",
                "content": "# List + binary search\\n```\\n\\t//Runtime: 181 ms, faster than 87.71% of Java online submissions for Time Based Key-Value Store.\\n    //Memory Usage: 117.3 MB, less than 91.94% of Java online submissions for Time Based Key-Value Store.\\n    //List + binary search\\n    // If M is the number of set function calls\\n    // N is the number of get function calls\\n    // L is average length of key and value strings.\\n    class TimeMap{\\n\\n        //Space: O(M * L)\\n        Map<String, List<Pair<Integer, String>>> map;\\n        public TimeMap() {\\n            map = new HashMap<>();\\n        }\\n\\n        //Time: O(M * L) <<< M calls\\n        public void set(String key, String value, int timestamp) {\\n            map.computeIfAbsent(key, k -> new ArrayList<>()).add(new Pair<>(timestamp, value));\\n        }\\n\\n        //Time: O(N * L * LogM) <<< N calls\\n        public String get(String key, int timestamp) {\\n            if (!map.containsKey(key)) return \"\";\\n            List<Pair<Integer, String>> list = map.get(key);\\n            int idx = Collections.binarySearch(list, new Pair<>(timestamp, \"\"), Comparator.comparingInt(Pair::getKey));\\n            if (idx == -1) return \"\";\\n            if (idx < 0) idx = Math.abs(idx) - 2;\\n            return list.get(idx).getValue();\\n        }\\n    }\\n\\n```\\n# TreeMap\\n```\\n    //Runtime: 158 ms, faster than 96.18% of Java online submissions for Time Based Key-Value Store.\\n    //Memory Usage: 117.5 MB, less than 89.86% of Java online submissions for Time Based Key-Value Store.\\n    //TreeMap\\n    // If M is the number of set function calls\\n    // N is the number of get function calls\\n    // L is average length of key and value strings.\\n     class TimeMap_treeMap{\\n\\n        //Space: O(M * L)\\n        Map<String, TreeMap<Integer, String>> map;\\n        public TimeMap_treeMap() {\\n            map = new HashMap<>();\\n        }\\n\\n        //Time: O(M * L * LogM) <<< M calls\\n        public void set(String key, String value, int timestamp) {\\n            map.computeIfAbsent(key, k ->new TreeMap<>()).put(timestamp, value);\\n        }\\n\\n        //Time: O(N * L * LogM) <<< N calls\\n        public String get(String key, int timestamp) {\\n            if (!map.containsKey(key)) return \"\";\\n            Map.Entry<Integer, String> entry = map.get(key).floorEntry(timestamp);\\n            return entry == null ? \"\" : entry.getValue();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\n\\t//Runtime: 181 ms, faster than 87.71% of Java online submissions for Time Based Key-Value Store.\\n    //Memory Usage: 117.3 MB, less than 91.94% of Java online submissions for Time Based Key-Value Store.\\n    //List + binary search\\n    // If M is the number of set function calls\\n    // N is the number of get function calls\\n    // L is average length of key and value strings.\\n    class TimeMap{\\n\\n        //Space: O(M * L)\\n        Map<String, List<Pair<Integer, String>>> map;\\n        public TimeMap() {\\n            map = new HashMap<>();\\n        }\\n\\n        //Time: O(M * L) <<< M calls\\n        public void set(String key, String value, int timestamp) {\\n            map.computeIfAbsent(key, k -> new ArrayList<>()).add(new Pair<>(timestamp, value));\\n        }\\n\\n        //Time: O(N * L * LogM) <<< N calls\\n        public String get(String key, int timestamp) {\\n            if (!map.containsKey(key)) return \"\";\\n            List<Pair<Integer, String>> list = map.get(key);\\n            int idx = Collections.binarySearch(list, new Pair<>(timestamp, \"\"), Comparator.comparingInt(Pair::getKey));\\n            if (idx == -1) return \"\";\\n            if (idx < 0) idx = Math.abs(idx) - 2;\\n            return list.get(idx).getValue();\\n        }\\n    }\\n\\n```\n```\\n    //Runtime: 158 ms, faster than 96.18% of Java online submissions for Time Based Key-Value Store.\\n    //Memory Usage: 117.5 MB, less than 89.86% of Java online submissions for Time Based Key-Value Store.\\n    //TreeMap\\n    // If M is the number of set function calls\\n    // N is the number of get function calls\\n    // L is average length of key and value strings.\\n     class TimeMap_treeMap{\\n\\n        //Space: O(M * L)\\n        Map<String, TreeMap<Integer, String>> map;\\n        public TimeMap_treeMap() {\\n            map = new HashMap<>();\\n        }\\n\\n        //Time: O(M * L * LogM) <<< M calls\\n        public void set(String key, String value, int timestamp) {\\n            map.computeIfAbsent(key, k ->new TreeMap<>()).put(timestamp, value);\\n        }\\n\\n        //Time: O(N * L * LogM) <<< N calls\\n        public String get(String key, int timestamp) {\\n            if (!map.containsKey(key)) return \"\";\\n            Map.Entry<Integer, String> entry = map.get(key).floorEntry(timestamp);\\n            return entry == null ? \"\" : entry.getValue();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666518,
                "title": "python-3-binsearch-t-m-99-96-96",
                "content": "```\\nclass TimeMap:\\n    def __init__(self):\\n\\t\\n        self.values = defaultdict(list)\\n        self.stamps = defaultdict(list)\\n    \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n\\t\\n        self.values[key].append(value)\\n        self.stamps[key].append(timestamp)\\n        return\\n        \\n    def get(self, key: str, timestamp: int) -> str:\\n\\t\\n        i = bisect_right(self.stamps[key],timestamp)-1\\n        return \\'\\' if i == -1 else self.values[key][i]\\n```\\n[https://leetcode.com/submissions/detail/816108823/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass TimeMap:\\n    def __init__(self):\\n\\t\\n        self.values = defaultdict(list)\\n        self.stamps = defaultdict(list)\\n    \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n\\t\\n        self.values[key].append(value)\\n        self.stamps[key].append(timestamp)\\n        return\\n        \\n    def get(self, key: str, timestamp: int) -> str:\\n\\t\\n        i = bisect_right(self.stamps[key],timestamp)-1\\n        return \\'\\' if i == -1 else self.values[key][i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666502,
                "title": "daily-leetcoding-challenge-october-day-6",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/time-based-key-value-store/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/time-based-key-value-store/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2415322,
                "title": "c-using-hashmap-and-binary-search-approach-easy-understanding-code",
                "content": "```\\ntypedef pair<int, string> pis;\\nclass TimeMap {\\npublic:\\n    unordered_map<string, vector<pis>> m; \\n    TimeMap() {\\n        \\n    }\\n    \\n    string greatestValLessThan(int timestamp, vector<pis>& s){\\n        int start = 0;\\n        int end = s.size()-1;\\n        int ans = INT_MIN;\\n        string str = \"\";\\n        while(start <= end){\\n            int middle = start + ((end-start)/2);\\n            auto x = s[middle];\\n            int num = x.first;\\n            string str_temp = x.second;\\n            if(num > timestamp){\\n                end = middle -1;\\n            }\\n            else{\\n                if(num > ans){\\n                    str = str_temp;\\n                    ans = num;\\n                }\\n                start = middle+1;\\n            }\\n        }\\n        return str;\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key].push_back({timestamp,value});  \\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        string ans = \"\";\\n        ans = greatestValLessThan(timestamp,m[key]);\\n        return ans;\\n    }\\n    \\n};\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef pair<int, string> pis;\\nclass TimeMap {\\npublic:\\n    unordered_map<string, vector<pis>> m; \\n    TimeMap() {\\n        \\n    }\\n    \\n    string greatestValLessThan(int timestamp, vector<pis>& s){\\n        int start = 0;\\n        int end = s.size()-1;\\n        int ans = INT_MIN;\\n        string str = \"\";\\n        while(start <= end){\\n            int middle = start + ((end-start)/2);\\n            auto x = s[middle];\\n            int num = x.first;\\n            string str_temp = x.second;\\n            if(num > timestamp){\\n                end = middle -1;\\n            }\\n            else{\\n                if(num > ans){\\n                    str = str_temp;\\n                    ans = num;\\n                }\\n                start = middle+1;\\n            }\\n        }\\n        return str;\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key].push_back({timestamp,value});  \\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        string ans = \"\";\\n        ans = greatestValLessThan(timestamp,m[key]);\\n        return ans;\\n    }\\n    \\n};\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035774,
                "title": "binary-search-hashmap-solution-in-python-very-easy-to-understand",
                "content": "Read carefully and you will find that it is actually a **search question** combined with **hashmap**!\\n\\nUse **binary search**!\\nThe question actually asks us to find out **the largest number that is smaller or equal to some target value**.\\n\\nInitiate a **map**, storing (key, [(time1, value1), (time2, value2), ...]\\nWhen get, do the binary search based on timestamps, return the associated value.\\n\\n**Time:**\\nset: O(1)\\nget: O(lgn)\\n**Space:**\\nO(n)\\n\\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.mapping = collections.defaultdict(list)\\n        \\n    def set(self, key, value, timestamp):\\n        self.mapping[key].append((timestamp, value))\\n        \\n    def get(self, key, timestamp):\\n        \\n        values = self.mapping[key]\\n        if not values:\\n            return \\'\\'\\n        \\n        left, right = 0, len(values) - 1\\n        while left + 1 < right:\\n            mid = (left + right) // 2\\n            pre_time, value = values[mid]\\n            if pre_time == timestamp:\\n                return value\\n            if pre_time > timestamp:\\n                right = mid\\n            else:\\n                left = mid\\n        if values[right][0] <= timestamp:\\n            return values[right][1]\\n        if values[left][0] <= timestamp:\\n            return values[left][1]\\n        \\n        return \\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.mapping = collections.defaultdict(list)\\n        \\n    def set(self, key, value, timestamp):\\n        self.mapping[key].append((timestamp, value))\\n        \\n    def get(self, key, timestamp):\\n        \\n        values = self.mapping[key]\\n        if not values:\\n            return \\'\\'\\n        \\n        left, right = 0, len(values) - 1\\n        while left + 1 < right:\\n            mid = (left + right) // 2\\n            pre_time, value = values[mid]\\n            if pre_time == timestamp:\\n                return value\\n            if pre_time > timestamp:\\n                right = mid\\n            else:\\n                left = mid\\n        if values[right][0] <= timestamp:\\n            return values[right][1]\\n        if values[left][0] <= timestamp:\\n            return values[left][1]\\n        \\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959985,
                "title": "python-with-bisect-with-one-dict-easy-to-understand",
                "content": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_right\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.tm = defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.tm[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        # gives the index of the *next* element after the given timestamp\\n        idx = bisect_right(a=self.tm[key], x=timestamp, key=lambda x: x[0])\\n        \\n        # if index is zero then there is no kv pair within the given timestamp\\n        if idx > 0:\\n            return self.tm[key][idx-1][1]\\n        else:\\n            return \"\"\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_right\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.tm = defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.tm[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        # gives the index of the *next* element after the given timestamp\\n        idx = bisect_right(a=self.tm[key], x=timestamp, key=lambda x: x[0])\\n        \\n        # if index is zero then there is no kv pair within the given timestamp\\n        if idx > 0:\\n            return self.tm[key][idx-1][1]\\n        else:\\n            return \"\"\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643667,
                "title": "python-using-dict-and-binary-search",
                "content": "Create a dictionary of key => List of (timestamp, value)\\nFor e.g: \"foo\" => [(1,\"bar\"), (5,\"bar2\")]\\n\\n\"constantly increasing\" property of timestamps makes insertion in \"set\" operation easy by just appending the values in the list. \\n\\nAs the list is sorted, use binary search to get the value in O(logn) time. \\nTime taken for get: O(1) to find the key, O(logn) to get the value => O(logn)\\nTime taken for set: O(1) for insertion in a list\\n\\n```\\nfrom collections import defaultdict\\nfrom typing import Dict, List, Tuple\\nclass TimeMap:\\n\\n    def __init__(self):\\n       self.time_map: Dict[str,List[Tuple]] = defaultdict(list) \\n        \\n\\n    def get_value(self, key: str, timestamp: int):\\n        arr = self.time_map[key]\\n        low = 0\\n        high = len(arr) - 1\\n        while low <=high:\\n            mid = (low + high)//2\\n            if timestamp >= arr[mid][0] and timestamp < arr[mid+1][0]:\\n                return arr[mid][1]\\n            elif timestamp < arr[mid][0]:\\n                    high = mid - 1\\n            else:\\n                low = mid + 1\\n        return \"\"\\n            \\n    \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.time_map[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.time_map:\\n            return \"\"\\n        else:\\n            if timestamp < self.time_map[key][0][0]:\\n                return \"\"\\n            elif timestamp >= self.time_map[key][-1][0]:\\n                return self.time_map[key][-1][1]\\n            else:\\n                return self.get_value(key, timestamp)\\n        \\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import Dict, List, Tuple\\nclass TimeMap:\\n\\n    def __init__(self):\\n       self.time_map: Dict[str,List[Tuple]] = defaultdict(list) \\n        \\n\\n    def get_value(self, key: str, timestamp: int):\\n        arr = self.time_map[key]\\n        low = 0\\n        high = len(arr) - 1\\n        while low <=high:\\n            mid = (low + high)//2\\n            if timestamp >= arr[mid][0] and timestamp < arr[mid+1][0]:\\n                return arr[mid][1]\\n            elif timestamp < arr[mid][0]:\\n                    high = mid - 1\\n            else:\\n                low = mid + 1\\n        return \"\"\\n            \\n    \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.time_map[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.time_map:\\n            return \"\"\\n        else:\\n            if timestamp < self.time_map[key][0][0]:\\n                return \"\"\\n            elif timestamp >= self.time_map[key][-1][0]:\\n                return self.time_map[key][-1][1]\\n            else:\\n                return self.get_value(key, timestamp)\\n        \\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303684,
                "title": "python-binary-search-82-faster",
                "content": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here\\n        \"\"\"\\n        self.d = collections.defaultdict(list)\\n\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:  # O(1)\\n        self.d[key].append((timestamp, value))\\n    \\n\\n    def get(self, key: str, timestamp: int) -> str: # -- O(logN)\\n        # base case\\n        if key not in self.d or not self.d:\\n            return \"\"\\n        \\n        # key exists, check valid timestamps\\n        lst = self.d[key]\\n        if lst[-1][0] <= timestamp:\\n            return lst[-1][1]\\n        if lst[0][0] > timestamp:\\n            return \"\"\\n        \\n        # otherwise, we perform binary search to find the timestamp\\n        L, R = 0, len(lst) -1\\n        while L<R:\\n            mid=L+(R-L)//2\\n            t = lst[mid][0]\\n            if timestamp == t:\\n                return lst[mid][1]\\n            if timestamp > t:\\n                L = mid+1\\n            else:\\n                R = mid\\n\\n        return lst[L-1][1]  \\n```\\n### Complexity\\ntime: O(logN) where N is number of keys in `get` function. `set` only takes O(1)\\nspace: O(N) as we create data structure for all elements inserted\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here\\n        \"\"\"\\n        self.d = collections.defaultdict(list)\\n\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:  # O(1)\\n        self.d[key].append((timestamp, value))\\n    \\n\\n    def get(self, key: str, timestamp: int) -> str: # -- O(logN)\\n        # base case\\n        if key not in self.d or not self.d:\\n            return \"\"\\n        \\n        # key exists, check valid timestamps\\n        lst = self.d[key]\\n        if lst[-1][0] <= timestamp:\\n            return lst[-1][1]\\n        if lst[0][0] > timestamp:\\n            return \"\"\\n        \\n        # otherwise, we perform binary search to find the timestamp\\n        L, R = 0, len(lst) -1\\n        while L<R:\\n            mid=L+(R-L)//2\\n            t = lst[mid][0]\\n            if timestamp == t:\\n                return lst[mid][1]\\n            if timestamp > t:\\n                L = mid+1\\n            else:\\n                R = mid\\n\\n        return lst[L-1][1]  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095677,
                "title": "java-binary-search",
                "content": "```\\nclass TimeMap {\\n    Map<String, List<TimeValue>> map;\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.putIfAbsent(key, new ArrayList<>());\\n        map.get(key).add(new TimeValue(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        List<TimeValue> list = map.get(key);\\n        if(list == null || timestamp < list.get(0).timestamp) return \"\";\\n        int start =0, end =list.size() - 1 , mid;\\n        while (start < end) {\\n            mid = (start + end + 1) / 2;\\n            if(list.get(mid).timestamp > timestamp) end = mid-1;\\n            else start = mid;\\n        }\\n        return list.get(end).value;\\n    }\\n}\\n\\nclass TimeValue {\\n    int timestamp;\\n    String value;\\n    public TimeValue(String value, int timestamp) {\\n        this.timestamp = timestamp;\\n        this.value = value;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\n    Map<String, List<TimeValue>> map;\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.putIfAbsent(key, new ArrayList<>());\\n        map.get(key).add(new TimeValue(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        List<TimeValue> list = map.get(key);\\n        if(list == null || timestamp < list.get(0).timestamp) return \"\";\\n        int start =0, end =list.size() - 1 , mid;\\n        while (start < end) {\\n            mid = (start + end + 1) / 2;\\n            if(list.get(mid).timestamp > timestamp) end = mid-1;\\n            else start = mid;\\n        }\\n        return list.get(end).value;\\n    }\\n}\\n\\nclass TimeValue {\\n    int timestamp;\\n    String value;\\n    public TimeValue(String value, int timestamp) {\\n        this.timestamp = timestamp;\\n        this.value = value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 667192,
                "title": "c-std-unordered-map-std-upper-bound",
                "content": "```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, vector<pair<string, int>>> mp; // [key, vec[val, time]]\\n    TimeMap() {   \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n       mp[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto& v = mp[key];\\n        auto it = upper_bound(v.begin(), v.end(), timestamp, [](int val, auto& p){return val < p.second;});\\n        return it == v.begin() ? \"\" : prev(it)->first;\\n    }\\n};\\n```\\n\\nAlternatively, we can implement simple binary search without STL:\\n```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, vector<pair<string, int>>> mp; // [key, vec[val, time]]\\n    TimeMap() {   \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n       mp[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto& v = mp[key];\\n        int start = 0, end = (int)v.size()-1;\\n        while(start <= end)\\n        {\\n            int mid = start+(end-start)/2;\\n            v[mid].second > timestamp ? end = mid-1 : start = mid+1; // \\'end\\' will be equal or one less of TS\\n        }\\n        return end < 0 ? \"\" : v[end].first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, vector<pair<string, int>>> mp; // [key, vec[val, time]]\\n    TimeMap() {   \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n       mp[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto& v = mp[key];\\n        auto it = upper_bound(v.begin(), v.end(), timestamp, [](int val, auto& p){return val < p.second;});\\n        return it == v.begin() ? \"\" : prev(it)->first;\\n    }\\n};\\n```\n```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, vector<pair<string, int>>> mp; // [key, vec[val, time]]\\n    TimeMap() {   \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n       mp[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto& v = mp[key];\\n        int start = 0, end = (int)v.size()-1;\\n        while(start <= end)\\n        {\\n            int mid = start+(end-start)/2;\\n            v[mid].second > timestamp ? end = mid-1 : start = mid+1; // \\'end\\' will be equal or one less of TS\\n        }\\n        return end < 0 ? \"\" : v[end].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627298,
                "title": "java-maxheap-hashmap-100-memory-95-time-120-ms",
                "content": "The idea is to store a MaxHeap for every key. The Maxheap will work on the timestamp so as to get the max one on top. \\n\\n```\\nclass TimeMap {\\n\\n    Map<String, PriorityQueue<Entry>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        PriorityQueue<Entry> pq;\\n        if(!map.containsKey(key)){\\n            pq = new PriorityQueue<>(new Comparator<Entry>(){\\n                @Override\\n                public int compare(Entry e1, Entry e2){\\n                    return e2.timeStamp - e1.timeStamp;\\n                }\\n            });\\n            map.put(key, pq);\\n        }else{\\n            pq = map.get(key);\\n        }\\n        pq.add(new Entry(value, timestamp));\\n            \\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        String result = \"\";\\n        if(map.containsKey(key)){\\n            PriorityQueue<Entry> pq = map.get(key);\\n            Deque<Entry> dq = new ArrayDeque<>();\\n            \\n            if(pq.peek().timeStamp == timestamp) \\n                return pq.peek().value;\\n            while(!pq.isEmpty() && pq.peek().timeStamp > timestamp) \\n                dq.add(pq.poll());\\n            if(!pq.isEmpty())\\n                result = pq.peek().value;\\n            while(!dq.isEmpty()) pq.add(dq.remove());\\n        }\\n        return result;\\n    }\\n  \\n    class Entry{\\n        String value;\\n        int timeStamp;\\n        \\n        Entry(String value, int timeStamp){\\n            this.value = value;\\n            this.timeStamp = timeStamp;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\n\\n    Map<String, PriorityQueue<Entry>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        PriorityQueue<Entry> pq;\\n        if(!map.containsKey(key)){\\n            pq = new PriorityQueue<>(new Comparator<Entry>(){\\n                @Override\\n                public int compare(Entry e1, Entry e2){\\n                    return e2.timeStamp - e1.timeStamp;\\n                }\\n            });\\n            map.put(key, pq);\\n        }else{\\n            pq = map.get(key);\\n        }\\n        pq.add(new Entry(value, timestamp));\\n            \\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        String result = \"\";\\n        if(map.containsKey(key)){\\n            PriorityQueue<Entry> pq = map.get(key);\\n            Deque<Entry> dq = new ArrayDeque<>();\\n            \\n            if(pq.peek().timeStamp == timestamp) \\n                return pq.peek().value;\\n            while(!pq.isEmpty() && pq.peek().timeStamp > timestamp) \\n                dq.add(pq.poll());\\n            if(!pq.isEmpty())\\n                result = pq.peek().value;\\n            while(!dq.isEmpty()) pq.add(dq.remove());\\n        }\\n        return result;\\n    }\\n  \\n    class Entry{\\n        String value;\\n        int timeStamp;\\n        \\n        Entry(String value, int timeStamp){\\n            this.value = value;\\n            this.timeStamp = timeStamp;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410533,
                "title": "javasscrip-simple-solution-w-explanation",
                "content": "#### The idea\\nfor every key, its value is a series timestamp and a value corresponds to that timestamp, we can store these two information into a array where the array index is the timestamp. I know this is a bad idea but for this question it is accepected.\\n\\n``` javascript\\nvar TimeMap = function() {\\n    this.map = new Map();\\n};\\n\\n/** \\n * @param {string} key \\n * @param {string} value \\n * @param {number} timestamp\\n * @return {void}\\n */\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    if (!this.map.has(key)) this.map.set(key, []);\\n    let item = this.map.get(key);\\n    item[timestamp] = value;\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} timestamp\\n * @return {string}\\n */\\nTimeMap.prototype.get = function(key, timestamp) {\\n    if (!this.map.has(key)) return \"\";\\n    let item = this.map.get(key);\\n    for (let i = timestamp;i>=0;i--) {\\n        if(item[i] != null) {\\n            return item[i];\\n        }\\n    }\\n    return \"\";\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar TimeMap = function() {\\n    this.map = new Map();\\n};\\n\\n/** \\n * @param {string} key \\n * @param {string} value \\n * @param {number} timestamp\\n * @return {void}\\n */\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    if (!this.map.has(key)) this.map.set(key, []);\\n    let item = this.map.get(key);\\n    item[timestamp] = value;\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} timestamp\\n * @return {string}\\n */\\nTimeMap.prototype.get = function(key, timestamp) {\\n    if (!this.map.has(key)) return \"\";\\n    let item = this.map.get(key);\\n    for (let i = timestamp;i>=0;i--) {\\n        if(item[i] != null) {\\n            return item[i];\\n        }\\n    }\\n    return \"\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383525,
                "title": "cpp-a-clear-solution-using-stl-map-and-unordered-map",
                "content": "Here is a clear c++ solution for this problem, and this solution only use `map` and `unorder_map` data structure in STL.\\n\\nFirst, we use a `unordered_map` to save Key and \\'Value\\'(not truely value). And then, we use a `map` to save Time and turely value in map\\'s value, so that we can easy use the `lower_bound` api in `map` to finish search in time.\\n\\n```c++\\nclass TimeMap {\\npublic:\\n    \\n    TimeMap(){\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        data[key][timestamp] = value;\\n    } \\n    \\n    string get(string key, int timestamp) {\\n        auto it1 = data.find(key);\\n        if (it1 != data.end()) {\\n            auto it2 = it1->second.lower_bound(timestamp);    \\n            if (it2 != it1->second.end()) {\\n                return it2->second;\\n            }\\n        }\\n        return \"\";\\n    }\\n    \\n    unordered_map<string, map<int, string, greater<int> >> data;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass TimeMap {\\npublic:\\n    \\n    TimeMap(){\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        data[key][timestamp] = value;\\n    } \\n    \\n    string get(string key, int timestamp) {\\n        auto it1 = data.find(key);\\n        if (it1 != data.end()) {\\n            auto it2 = it1->second.lower_bound(timestamp);    \\n            if (it2 != it1->second.end()) {\\n                return it2->second;\\n            }\\n        }\\n        return \"\";\\n    }\\n    \\n    unordered_map<string, map<int, string, greater<int> >> data;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334289,
                "title": "simple-c-binary-search-solution",
                "content": "```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        map_[key].push_back(std::make_pair(value, timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        vector<pair<string, int>>& records = map_[key];\\n        if (records.size() == 0 ||\\n            timestamp < records[0].second) return \"\";\\n        int lo = 0;\\n        int hi = records.size() - 1;\\n        while (lo < hi - 1) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (records[mid].second < timestamp) {\\n                lo = mid;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        \\n        \\n        if (records[hi].second <= timestamp) {\\n            return records[hi].first;\\n        } else {\\n            return records[lo].first;\\n        }\\n    }\\nprivate:\\n    std::unordered_map<string, vector<pair<string, int>>> map_;\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        map_[key].push_back(std::make_pair(value, timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        vector<pair<string, int>>& records = map_[key];\\n        if (records.size() == 0 ||\\n            timestamp < records[0].second) return \"\";\\n        int lo = 0;\\n        int hi = records.size() - 1;\\n        while (lo < hi - 1) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (records[mid].second < timestamp) {\\n                lo = mid;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        \\n        \\n        if (records[hi].second <= timestamp) {\\n            return records[hi].first;\\n        } else {\\n            return records[lo].first;\\n        }\\n    }\\nprivate:\\n    std::unordered_map<string, vector<pair<string, int>>> map_;\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279215,
                "title": "c-solution",
                "content": "Here is the C# Solution.\\n\\n```\\npublic class TimeMap \\n{\\n    Dictionary<string, SortedList<int, string>> map = new Dictionary<string, SortedList<int, string>>();\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap()\\n    {\\n\\n    }\\n\\n    public void Set(string key, string value, int timestamp)\\n    {\\n        if (!map.ContainsKey(key))\\n            map.Add(key, new SortedList<int, string>());\\n\\n        SortedList<int, string> temp = map[key];\\n        temp.Add(timestamp, value);\\n    }\\n\\n    public string Get(string key, int timestamp)\\n    {\\n        if (!map.ContainsKey(key))\\n            return string.Empty;\\n\\n        IList<int> temp = map[key].Keys;\\n\\n        int left = 0;\\n        int right = temp.Count - 1;\\n        while (left < right)\\n        {\\n            int mid = (left + right + 1) / 2;\\n            if (temp[mid] == timestamp)\\n                return map[key].Values[mid];\\n\\n            if (temp[mid] < timestamp)\\n                left = mid;\\n            else\\n                right = mid - 1; \\n        }\\n        if(left == 0 && map[key].Keys[0] > timestamp)\\n            return string.Empty;\\n        return map[key].Values[left];\\n    }\\n}\\n\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.Set(key,value,timestamp);\\n * string param_2 = obj.Get(key,timestamp);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class TimeMap \\n{\\n    Dictionary<string, SortedList<int, string>> map = new Dictionary<string, SortedList<int, string>>();\\n\\n    /** Initialize your data structure here. */\\n    public TimeMap()\\n    {\\n\\n    }\\n\\n    public void Set(string key, string value, int timestamp)\\n    {\\n        if (!map.ContainsKey(key))\\n            map.Add(key, new SortedList<int, string>());\\n\\n        SortedList<int, string> temp = map[key];\\n        temp.Add(timestamp, value);\\n    }\\n\\n    public string Get(string key, int timestamp)\\n    {\\n        if (!map.ContainsKey(key))\\n            return string.Empty;\\n\\n        IList<int> temp = map[key].Keys;\\n\\n        int left = 0;\\n        int right = temp.Count - 1;\\n        while (left < right)\\n        {\\n            int mid = (left + right + 1) / 2;\\n            if (temp[mid] == timestamp)\\n                return map[key].Values[mid];\\n\\n            if (temp[mid] < timestamp)\\n                left = mid;\\n            else\\n                right = mid - 1; \\n        }\\n        if(left == 0 && map[key].Keys[0] > timestamp)\\n            return string.Empty;\\n        return map[key].Values[left];\\n    }\\n}\\n\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.Set(key,value,timestamp);\\n * string param_2 = obj.Get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272578,
                "title": "swift-two-dictionaries",
                "content": "Two dictionaries, one for ```(key: String, timestamp: Int)```, the other for ```(timeStamp: Int, value: String)```.\\n```\\nclass TimeMap {\\n\\n    /** Initialize your data structure here. */\\n\\tprivate var timestamps: [String: [Int]] = [:] \\n\\tprivate var values: [Int: String] = [:]\\n\\t\\n\\tinit() { }\\n\\t\\n\\tfunc set(_ key: String, _ value: String, _ timestamp: Int) {\\n\\t\\ttimestamps[key, default: []].append(timestamp)\\n\\t\\tvalues[timestamp] = value\\n\\t}\\n\\t\\n\\tfunc get(_ key: String, _ timestamp: Int) -> String {\\n\\t\\tguard let array = timestamps[key] else { return \"\" }\\n\\t\\tguard let first = array.first, timestamp >= first else { return \"\" }\\n\\t\\tlet timeKey = binarySearch(array, timestamp)\\n\\t\\treturn values[timeKey] ?? \"\"\\n\\t}\\n\\t\\n\\tprivate func binarySearch(_ array: [Int], _ target: Int) -> Int {\\n\\t\\t\\n\\t\\tvar L = 0, R = array.count - 1\\n\\t\\t\\n\\t\\twhile L < R {\\n\\t\\t\\tlet m = (L + R + 1) / 2\\n\\t\\t\\tif array[m] == target {\\n\\t\\t\\t\\treturn target\\n\\t\\t\\t} else if target < array[m] {\\n\\t\\t\\t\\tR = m - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tL = m\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn array[L]\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```(key: String, timestamp: Int)```\n```(timeStamp: Int, value: String)```\n```\\nclass TimeMap {\\n\\n    /** Initialize your data structure here. */\\n\\tprivate var timestamps: [String: [Int]] = [:] \\n\\tprivate var values: [Int: String] = [:]\\n\\t\\n\\tinit() { }\\n\\t\\n\\tfunc set(_ key: String, _ value: String, _ timestamp: Int) {\\n\\t\\ttimestamps[key, default: []].append(timestamp)\\n\\t\\tvalues[timestamp] = value\\n\\t}\\n\\t\\n\\tfunc get(_ key: String, _ timestamp: Int) -> String {\\n\\t\\tguard let array = timestamps[key] else { return \"\" }\\n\\t\\tguard let first = array.first, timestamp >= first else { return \"\" }\\n\\t\\tlet timeKey = binarySearch(array, timestamp)\\n\\t\\treturn values[timeKey] ?? \"\"\\n\\t}\\n\\t\\n\\tprivate func binarySearch(_ array: [Int], _ target: Int) -> Int {\\n\\t\\t\\n\\t\\tvar L = 0, R = array.count - 1\\n\\t\\t\\n\\t\\twhile L < R {\\n\\t\\t\\tlet m = (L + R + 1) / 2\\n\\t\\t\\tif array[m] == target {\\n\\t\\t\\t\\treturn target\\n\\t\\t\\t} else if target < array[m] {\\n\\t\\t\\t\\tR = m - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tL = m\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn array[L]\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235762,
                "title": "javascript-beat-100-solution",
                "content": "```\\nclass TimeMap{\\n    constructor(){\\n        this.map = {};\\n    }\\n\\n    set(key, value, timestamp){\\n        if(!this.map[key]) this.map[key]= [];\\n        this.map[key].push({timestamp:timestamp, value:value});\\n    }\\n\\n    get(key, timestamp){\\n        if(!this.map[key]) return undefined;\\n        return this.binarySearch(this.map[key],timestamp);\\n    }\\n\\n    binarySearch(list ,timeStamp){\\n        if(list.length === 1)return list[0].value;\\n        let l = 0 , r = list.length-1;\\n        let mid;\\n        while(l<=r){\\n            mid = Math.floor ((l+r)/2);\\n            if(list[mid].timestamp === timeStamp )return list[mid].value;\\n            if(timeStamp < list[mid].timestamp)  r = mid -1;\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return list[mid].timestamp < timeStamp ? list[mid].value : list[mid-1]? list[mid-1].value: \\'\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap{\\n    constructor(){\\n        this.map = {};\\n    }\\n\\n    set(key, value, timestamp){\\n        if(!this.map[key]) this.map[key]= [];\\n        this.map[key].push({timestamp:timestamp, value:value});\\n    }\\n\\n    get(key, timestamp){\\n        if(!this.map[key]) return undefined;\\n        return this.binarySearch(this.map[key],timestamp);\\n    }\\n\\n    binarySearch(list ,timeStamp){\\n        if(list.length === 1)return list[0].value;\\n        let l = 0 , r = list.length-1;\\n        let mid;\\n        while(l<=r){\\n            mid = Math.floor ((l+r)/2);\\n            if(list[mid].timestamp === timeStamp )return list[mid].value;\\n            if(timeStamp < list[mid].timestamp)  r = mid -1;\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return list[mid].timestamp < timeStamp ? list[mid].value : list[mid-1]? list[mid-1].value: \\'\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053411,
                "title": "simple-c-code-using-hash-map-faster-than-90-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeMap {\\npublic:\\n    map<string,map<int,string>>mp;\\n    TimeMap() {\\n        mp=map<string,map<int,string>>();\\n    }\\n    \\n    void set(string key, string value, int time) {\\n        mp[key].insert({-1*time,value});\\n    }\\n    \\n    string get(string key, int time) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n\\n        auto it=mp[key].lower_bound(-1*time);\\n\\n        if(it==mp[key].end()) return \"\";\\n\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    map<string,map<int,string>>mp;\\n    TimeMap() {\\n        mp=map<string,map<int,string>>();\\n    }\\n    \\n    void set(string key, string value, int time) {\\n        mp[key].insert({-1*time,value});\\n    }\\n    \\n    string get(string key, int time) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n\\n        auto it=mp[key].lower_bound(-1*time);\\n\\n        if(it==mp[key].end()) return \"\";\\n\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674765,
                "title": "python-simple-python-solution-using-hashmap-dictionary",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1654 ms, faster than 40.05% of Python3 online submissions for Time Based Key-Value Store.\\n# Memory Usage: 70 MB, less than 86.19% of Python3 online submissions for Time Based Key-Value Store.\\n\\n\\tclass TimeMap:\\n\\n\\t\\tdef __init__(self):\\n\\n\\t\\t\\tself.dict = {}\\n\\n\\t\\tdef set(self, key: str, value: str, timestamp: int) -> None:\\n\\n\\t\\t\\tif key not in self.dict:\\n\\t\\t\\t\\tself.dict[key] = {}\\n\\n\\t\\t\\tself.dict[key][timestamp] = value\\n\\n\\t\\tdef get(self, key: str, timestamp: int) -> str:\\n\\n\\t\\t\\tif key not in self.dict:\\n\\t\\t\\t\\treturn \\'\\'\\n\\n\\t\\t\\twhile timestamp > 0:\\n\\n\\t\\t\\t\\tif timestamp in self.dict[key]:\\n\\t\\t\\t\\t\\treturn self.dict[key][timestamp]\\n\\n\\t\\t\\t\\ttimestamp = timestamp - 1\\n\\n\\t\\t\\treturn \\'\\'\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1654 ms, faster than 40.05% of Python3 online submissions for Time Based Key-Value Store.\\n# Memory Usage: 70 MB, less than 86.19% of Python3 online submissions for Time Based Key-Value Store.\\n\\n\\tclass TimeMap:\\n\\n\\t\\tdef __init__(self):\\n\\n\\t\\t\\tself.dict = {}\\n\\n\\t\\tdef set(self, key: str, value: str, timestamp: int) -> None:\\n\\n\\t\\t\\tif key not in self.dict:\\n\\t\\t\\t\\tself.dict[key] = {}\\n\\n\\t\\t\\tself.dict[key][timestamp] = value\\n\\n\\t\\tdef get(self, key: str, timestamp: int) -> str:\\n\\n\\t\\t\\tif key not in self.dict:\\n\\t\\t\\t\\treturn \\'\\'\\n\\n\\t\\t\\twhile timestamp > 0:\\n\\n\\t\\t\\t\\tif timestamp in self.dict[key]:\\n\\t\\t\\t\\t\\treturn self.dict[key][timestamp]\\n\\n\\t\\t\\t\\ttimestamp = timestamp - 1\\n\\n\\t\\t\\treturn \\'\\'\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2670337,
                "title": "python3-the-most-efficient-and-shortest-algorithm",
                "content": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.d={}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.d[(key,timestamp)]=value\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        for i in range(timestamp,0,-1):\\n            if (key,i) in self.d:\\n                return self.d[(key,i)]\\n        return \"\"\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.d={}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.d[(key,timestamp)]=value\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        for i in range(timestamp,0,-1):\\n            if (key,i) in self.d:\\n                return self.d[(key,i)]\\n        return \"\"\\n",
                "codeTag": "Java"
            },
            {
                "id": 2669798,
                "title": "5-line-code-faster-than-96-95-of-cpp-online-submissions-hashmap-binary-search-map",
                "content": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,map<int,string>> umap;\\n    TimeMap() {}\\n    void set(string key, string value, int timestamp) {\\n        umap[key].insert({-1*timestamp,value});\\n    }\\n    string get(string key, int timestamp) {\\n        if(!umap.count(key)) return \"\";\\n        auto it=umap[key].lower_bound(-1*timestamp);\\n        return (*it).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,map<int,string>> umap;\\n    TimeMap() {}\\n    void set(string key, string value, int timestamp) {\\n        umap[key].insert({-1*timestamp,value});\\n    }\\n    string get(string key, int timestamp) {\\n        if(!umap.count(key)) return \"\";\\n        auto it=umap[key].lower_bound(-1*timestamp);\\n        return (*it).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669451,
                "title": "treemap-simple-85-faster",
                "content": "```java\\nclass TimeMap {\\n    Map <String, TreeMap<Integer, String>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n       if (map.get(key) == null)\\n           map.put(key, new TreeMap<>());\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (map.get(key) == null || map.get(key).floorKey(timestamp) == null)\\n            return \"\";\\n        Integer temp = map.get(key).floorKey(timestamp);\\n        return map.get(key).get(temp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```java\\nclass TimeMap {\\n    Map <String, TreeMap<Integer, String>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n       if (map.get(key) == null)\\n           map.put(key, new TreeMap<>());\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (map.get(key) == null || map.get(key).floorKey(timestamp) == null)\\n            return \"\";\\n        Integer temp = map.get(key).floorKey(timestamp);\\n        return map.get(key).get(temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668727,
                "title": "easiest-soln-java-treemap",
                "content": "```\\nclass TimeMap {\\n\\n    HashMap<String, TreeMap<Integer, String>> map;\\n    \\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        \\n        if(map.containsKey(key) == false){\\n            map.put(key, new TreeMap<>());\\n        }\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        \\n        if(map.containsKey(key) == false)   return \"\";\\n        \\n        TreeMap<Integer, String> t_map = map.get(key);\\n        \\n        Integer time = t_map.floorKey(timestamp);\\n        \\n        if(time != null)    return t_map.get(time);\\n        \\n        return \"\";\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n\\n    HashMap<String, TreeMap<Integer, String>> map;\\n    \\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        \\n        if(map.containsKey(key) == false){\\n            map.put(key, new TreeMap<>());\\n        }\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        \\n        if(map.containsKey(key) == false)   return \"\";\\n        \\n        TreeMap<Integer, String> t_map = map.get(key);\\n        \\n        Integer time = t_map.floorKey(timestamp);\\n        \\n        if(time != null)    return t_map.get(time);\\n        \\n        return \"\";\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668543,
                "title": "c-solution-using-map-simple-and-easy-to-understand",
                "content": "```\\nclass TimeMap {\\n    map<string, map<int, string, std::greater<int>>> dictionary;\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        dictionary[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto it  = dictionary[key].lower_bound(timestamp);\\n        if (it != dictionary[key].end()){\\n            return it->second;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\n    map<string, map<int, string, std::greater<int>>> dictionary;\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        dictionary[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto it  = dictionary[key].lower_bound(timestamp);\\n        if (it != dictionary[key].end()){\\n            return it->second;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668197,
                "title": "java-hashmap-treemap-searching-easy-to-understand",
                "content": "```\\nclass TimeMap {\\n    HashMap<String, TreeMap<Integer, String>> map;\\n    public TimeMap() {\\n        map = new HashMap<String, TreeMap<Integer, String>>();\\n    }\\n\\n    public void set(String key, String value, int timestamp) {\\n        if (!map.containsKey(key))   map.put(key, new TreeMap<Integer, String>());\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key))    return \"\";\\n        Integer value = map.get(key).floorKey(timestamp);\\n        if(value != null)    return map.get(key).get(value);\\n        return \"\";\\n    }\\n}\\n```\\n***Why floorKey()?***  \\n*`floorKey() is used to return the greatest key less than or equal to given key i.e. timestamp.`*\\n\\n*Kindly upvote if you find it helpful*",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    HashMap<String, TreeMap<Integer, String>> map;\\n    public TimeMap() {\\n        map = new HashMap<String, TreeMap<Integer, String>>();\\n    }\\n\\n    public void set(String key, String value, int timestamp) {\\n        if (!map.containsKey(key))   map.put(key, new TreeMap<Integer, String>());\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key))    return \"\";\\n        Integer value = map.get(key).floorKey(timestamp);\\n        if(value != null)    return map.get(key).get(value);\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667848,
                "title": "c-map-implementation-priority-queue",
                "content": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,string> mp;\\n    unordered_map<string,priority_queue<int>> mp2;\\n    \\n    TimeMap() {\\n        mp.clear();\\n        mp2.clear();\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        string s = key + \"_\" + to_string(timestamp);\\n        mp2[key].push(timestamp); // storing all the timestamps for same key in descending order\\n        mp[s] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        string s = key + \"_\" + to_string(timestamp);\\n        if(!mp.count(s)){ // if (key + timestamp) doesn\\'t found then find the largest timestamp which is less equal to the given timestamp \\n            vector<int> vec;\\n            \\n            while(!mp2[key].empty() && mp2[key].top() > timestamp){\\n                vec.push_back(mp2[key].top());\\n                mp2[key].pop();\\n            }\\n            if(mp2[key].empty()){\\n                for(auto it:vec){\\n                    mp2[key].push(it);\\n                }\\n                return \"\";  \\n            } \\n            string str = key + \"_\" + to_string(mp2[key].top());\\n            for(auto it:vec){\\n                mp2[key].push(it);\\n            }\\n            return mp[str];\\n        }\\n        return mp[s];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,string> mp;\\n    unordered_map<string,priority_queue<int>> mp2;\\n    \\n    TimeMap() {\\n        mp.clear();\\n        mp2.clear();\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        string s = key + \"_\" + to_string(timestamp);\\n        mp2[key].push(timestamp); // storing all the timestamps for same key in descending order\\n        mp[s] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        string s = key + \"_\" + to_string(timestamp);\\n        if(!mp.count(s)){ // if (key + timestamp) doesn\\'t found then find the largest timestamp which is less equal to the given timestamp \\n            vector<int> vec;\\n            \\n            while(!mp2[key].empty() && mp2[key].top() > timestamp){\\n                vec.push_back(mp2[key].top());\\n                mp2[key].pop();\\n            }\\n            if(mp2[key].empty()){\\n                for(auto it:vec){\\n                    mp2[key].push(it);\\n                }\\n                return \"\";  \\n            } \\n            string str = key + \"_\" + to_string(mp2[key].top());\\n            for(auto it:vec){\\n                mp2[key].push(it);\\n            }\\n            return mp[str];\\n        }\\n        return mp[s];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667624,
                "title": "java-treemap-implementation",
                "content": "##### Java\\n```java\\nprivate final Map<String, TreeMap<Integer, String>> store;\\n\\n    public TimeMap() {\\n        store = new HashMap<>();\\n    }\\n\\n    public void set(String key, String value, int timestamp) {\\n        if (!store.containsKey(key))\\n            store.put(key, new TreeMap<>());\\n\\n        store.get(key).put(timestamp, value);\\n    }\\n\\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer, String> treeMap = store.get(key);\\n        if (treeMap == null)\\n            return \"\";\\n\\n        Integer floorKey = treeMap.floorKey(timestamp);\\n        if (floorKey == null)\\n            return \"\";\\n\\n        return treeMap.get(floorKey);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nprivate final Map<String, TreeMap<Integer, String>> store;\\n\\n    public TimeMap() {\\n        store = new HashMap<>();\\n    }\\n\\n    public void set(String key, String value, int timestamp) {\\n        if (!store.containsKey(key))\\n            store.put(key, new TreeMap<>());\\n\\n        store.get(key).put(timestamp, value);\\n    }\\n\\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer, String> treeMap = store.get(key);\\n        if (treeMap == null)\\n            return \"\";\\n\\n        Integer floorKey = treeMap.floorKey(timestamp);\\n        if (floorKey == null)\\n            return \"\";\\n\\n        return treeMap.get(floorKey);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2667239,
                "title": "easy-understanding-hashmap-solution",
                "content": "class TimeMap {\\n\\n    HashMap<String,String>map;\\n    public TimeMap() {\\n        map=new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        String str=key+\" \"+timestamp;\\n        map.put(str,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        String str=key+\" \"+timestamp;\\n        \\n        if(map.containsKey(str)){\\n            return map.get(str);\\n        }\\n    \\n        while(!map.containsKey(str) && timestamp>0){\\n             timestamp-=1;\\n             str=key+\" \"+timestamp;\\n            }\\n         \\n        return map.getOrDefault(str,\"\");\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "class TimeMap {\\n\\n    HashMap<String,String>map;\\n    public TimeMap() {\\n        map=new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        String str=key+\" \"+timestamp;\\n        map.put(str,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        String str=key+\" \"+timestamp;\\n        \\n        if(map.containsKey(str)){\\n            return map.get(str);\\n        }\\n    \\n        while(!map.containsKey(str) && timestamp>0){\\n             timestamp-=1;\\n             str=key+\" \"+timestamp;\\n            }\\n         \\n        return map.getOrDefault(str,\"\");\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2666742,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap && Binary Search***\\n\\n* ***Time Complexity :- O(1) for Set operation && O(logN) for Get Operation***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass TimeMap {\\npublic:\\n    \\n    // declare a map\\n    \\n    unordered_map<string, map<int, string>> mp;\\n    \\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        mp[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        // take the upper bound of timestamp\\n        \\n        auto it = mp[key].upper_bound(timestamp);\\n        \\n        // if there is no. timestamp <= given timestamp\\n        \\n        if(it == mp[key].begin())\\n        {\\n            return \"\";\\n        }\\n        \\n        it--;\\n        \\n        // find the time\\n        \\n        int time = it -> first;\\n        \\n        return mp[key][time];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    \\n    // declare a map\\n    \\n    unordered_map<string, map<int, string>> mp;\\n    \\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        mp[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        // take the upper bound of timestamp\\n        \\n        auto it = mp[key].upper_bound(timestamp);\\n        \\n        // if there is no. timestamp <= given timestamp\\n        \\n        if(it == mp[key].begin())\\n        {\\n            return \"\";\\n        }\\n        \\n        it--;\\n        \\n        // find the time\\n        \\n        int time = it -> first;\\n        \\n        return mp[key][time];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666552,
                "title": "java-c-python3-hash-map-tree-map-binary-search-very-simple-approach",
                "content": "# Complexity\\n- Time complexity: **O(logn)**\\n\\n- Space complexity: **O(n)**\\n\\n# Code\\n```cpp []\\n// hash map\\nclass TimeMap {\\nprivate:\\n\\tunordered_map<string, vector<pair<int, string>>> hash;\\n\\npublic:\\n\\tTimeMap() {\\n\\n\\t}\\n\\n\\tvoid set(string key, string value, int timestamp) {\\n\\t\\thash[key].emplace_back(make_pair(timestamp, value));\\n\\t}\\n\\n\\tstring get(string key, int timestamp) {\\n\\t\\tvector<pair<int, string>>&vec = hash[key];\\n\\t\\tauto it = upper_bound(vec.begin(), vec.end(), make_pair(timestamp, string({127})));\\n\\t\\tif (it != vec.begin()) {\\n\\t\\t\\treturn (it - 1) -> second;\\n\\t\\t}\\n\\t\\treturn \"\";\\n\\t}\\n};\\n```\\n```java []\\n// tree map\\nclass TimeMap {\\n    Map<String, TreeMap<Integer, String>> data;\\n    public TimeMap() {\\n        data = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        TreeMap<Integer, String> v;\\n        if (!data.containsKey(key)) v = new TreeMap<>();\\n        else v = data.get(key);\\n        v.put(timestamp, value);\\n        data.put(key, v);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (!data.containsKey(key)) return \"\";\\n        Map.Entry<Integer, String> res = data.get(key).floorEntry(timestamp);\\n        return res == null ? \"\" : res.getValue();\\n    }\\n}\\n```\\n\\n```python []\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.dct = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.dct[key].append([timestamp, value])\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        a = bisect_right(self.dct[key], [timestamp, \"z\"*101]) #greater than the length of all key strings in the range [1, 100]\\n        if a - 1 == len(self.dct[key]) or a == 0:\\n            return \"\"\\n        return (self.dct[key])[a - 1][1]\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\n// hash map\\nclass TimeMap {\\nprivate:\\n\\tunordered_map<string, vector<pair<int, string>>> hash;\\n\\npublic:\\n\\tTimeMap() {\\n\\n\\t}\\n\\n\\tvoid set(string key, string value, int timestamp) {\\n\\t\\thash[key].emplace_back(make_pair(timestamp, value));\\n\\t}\\n\\n\\tstring get(string key, int timestamp) {\\n\\t\\tvector<pair<int, string>>&vec = hash[key];\\n\\t\\tauto it = upper_bound(vec.begin(), vec.end(), make_pair(timestamp, string({127})));\\n\\t\\tif (it != vec.begin()) {\\n\\t\\t\\treturn (it - 1) -> second;\\n\\t\\t}\\n\\t\\treturn \"\";\\n\\t}\\n};\\n```\n```java []\\n// tree map\\nclass TimeMap {\\n    Map<String, TreeMap<Integer, String>> data;\\n    public TimeMap() {\\n        data = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        TreeMap<Integer, String> v;\\n        if (!data.containsKey(key)) v = new TreeMap<>();\\n        else v = data.get(key);\\n        v.put(timestamp, value);\\n        data.put(key, v);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (!data.containsKey(key)) return \"\";\\n        Map.Entry<Integer, String> res = data.get(key).floorEntry(timestamp);\\n        return res == null ? \"\" : res.getValue();\\n    }\\n}\\n```\n```python []\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.dct = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.dct[key].append([timestamp, value])\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        a = bisect_right(self.dct[key], [timestamp, \"z\"*101]) #greater than the length of all key strings in the range [1, 100]\\n        if a - 1 == len(self.dct[key]) or a == 0:\\n            return \"\"\\n        return (self.dct[key])[a - 1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336966,
                "title": "java-map-binarysearch-easy-to-implement",
                "content": "I think it\\'s pretty clear with the note. However, leave the questions below if you had any questions. I\\'ll still answer them.\\n\\n```\\n class TimeMap \\n{\\n    HashMap<String, List<Pair<String, Integer>>> myMap;\\n    \\n    public TimeMap()\\n    {\\n        myMap = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) \\n    {\\n        // constraints: timestamp is strictly increasing as real world is\\n        if(!myMap.containsKey(key))\\n            myMap.put(key, new ArrayList<>());\\n        myMap.get(key).add(new Pair(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) \\n    {\\n        if(!myMap.containsKey(key)) return \"\";\\n        \\n        List<Pair<String, Integer>> myList = myMap.get(key);\\n        int idx = binarySearch(myList, timestamp);\\n        if(idx == -1)   return \"\";\\n        \\n        return myMap.get(key).get(idx).getKey();\\n    }\\n    \\n    private int binarySearch(List<Pair<String, Integer>> myList, int timestamp)\\n    {\\n        int left = 0, right = myList.size() - 1;\\n        int idx = -1;\\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            int time = myList.get(mid).getValue();\\n            \\n            if(time == timestamp)   return mid;\\n            \\n            // if all time in myList greater than timestamp, return -1 eventually.\\n            if(time > timestamp)\\n                right = mid - 1;\\n            else\\n            {\\n                // return largest time <= timestamp\\n                left = mid + 1;\\n                idx = mid;\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n class TimeMap \\n{\\n    HashMap<String, List<Pair<String, Integer>>> myMap;\\n    \\n    public TimeMap()\\n    {\\n        myMap = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) \\n    {\\n        // constraints: timestamp is strictly increasing as real world is\\n        if(!myMap.containsKey(key))\\n            myMap.put(key, new ArrayList<>());\\n        myMap.get(key).add(new Pair(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) \\n    {\\n        if(!myMap.containsKey(key)) return \"\";\\n        \\n        List<Pair<String, Integer>> myList = myMap.get(key);\\n        int idx = binarySearch(myList, timestamp);\\n        if(idx == -1)   return \"\";\\n        \\n        return myMap.get(key).get(idx).getKey();\\n    }\\n    \\n    private int binarySearch(List<Pair<String, Integer>> myList, int timestamp)\\n    {\\n        int left = 0, right = myList.size() - 1;\\n        int idx = -1;\\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            int time = myList.get(mid).getValue();\\n            \\n            if(time == timestamp)   return mid;\\n            \\n            // if all time in myList greater than timestamp, return -1 eventually.\\n            if(time > timestamp)\\n                right = mid - 1;\\n            else\\n            {\\n                // return largest time <= timestamp\\n                left = mid + 1;\\n                idx = mid;\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151486,
                "title": "java-simple-hashmap-binary-search-easy-to-understand",
                "content": "```\\nclass Pair{\\n    int time;\\n    String value;\\n    Pair(int time, String value) { this.time = time; this.value = value; }\\n}\\nclass TimeMap {\\n    HashMap<String, List<Pair>> mp = new HashMap();\\n    public TimeMap() {  }\\n    \\n    public void set(String key, String value, int timeStamp) {\\n        if (mp.get(key) == null) mp.put(key, new ArrayList<Pair>());\\n        List<Pair> list = mp.get(key);\\n        list.add(new Pair(timeStamp, value));\\n    }\\n    \\n    public String get(String key, int targetTime) \\n    {\\n        List<Pair> list = mp.get(key);\\n        if (list == null) return \"\";\\n        int low = 0, high = list.size() - 1;\\n        String ans = \"\";\\n        while(low <= high)\\n        {\\n            int mid  = low + (high - low) / 2;\\n            if (list.get(mid).time == targetTime) return list.get(mid).value;\\n            else if (list.get(mid).time < targetTime) { ans = list.get(mid).value; low = mid + 1; }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Pair{\\n    int time;\\n    String value;\\n    Pair(int time, String value) { this.time = time; this.value = value; }\\n}\\nclass TimeMap {\\n    HashMap<String, List<Pair>> mp = new HashMap();\\n    public TimeMap() {  }\\n    \\n    public void set(String key, String value, int timeStamp) {\\n        if (mp.get(key) == null) mp.put(key, new ArrayList<Pair>());\\n        List<Pair> list = mp.get(key);\\n        list.add(new Pair(timeStamp, value));\\n    }\\n    \\n    public String get(String key, int targetTime) \\n    {\\n        List<Pair> list = mp.get(key);\\n        if (list == null) return \"\";\\n        int low = 0, high = list.size() - 1;\\n        String ans = \"\";\\n        while(low <= high)\\n        {\\n            int mid  = low + (high - low) / 2;\\n            if (list.get(mid).time == targetTime) return list.get(mid).value;\\n            else if (list.get(mid).time < targetTime) { ans = list.get(mid).value; low = mid + 1; }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143926,
                "title": "python-3-simple-hash-map-binary-search-solution",
                "content": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.map = collections.defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.map[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        i = bisect.bisect_right(self.map[key], timestamp, key=lambda x: x[0])\\n        return self.map[key][i - 1][1] if i else \\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.map = collections.defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.map[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        i = bisect.bisect_right(self.map[key], timestamp, key=lambda x: x[0])\\n        return self.map[key][i - 1][1] if i else \\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1953556,
                "title": "typescript-javascript-binary-search-hashmap",
                "content": "Use map to store list of \\'datums\\' (value and timestamp).\\nDescription says timestamps are set in increasing order, so that is hint to use binary search.\\n\\nIn a list of timestamps, given a target timestamp, we want to find the \\'datum.timestamp\\' <= target. \\nOnce our mid <= target (within the correct range), we optimise the result by gradually increasing \\'left = mid + 1\\', until left > right, then we know \\'right\\' is the closest time we have.\\n\\n```\\ntype Datum = {\\n    value: string,\\n    timestamp: number\\n};\\n\\nclass TimeMap {\\n    data: Map<string, Datum[]>\\n\\n    constructor() {\\n        this.data = new Map<string, Datum[]>();\\n    }\\n\\n    set(key: string, value: string, timestamp: number): void {\\n        const datum: Datum = {value, timestamp}\\n        const found = this.data.get(key);\\n        if(found) {\\n            found.push(datum);\\n        } else {\\n            this.data.set(key, [datum]);   \\n        }\\n    }\\n\\n    // K keys. V values. V unsorted. o(1) lookup. o(logV) search\\n    get(key: string, timestamp: number): string {\\n        // find datum with key and timestamp\\n        // multiple values for the same key\\n        const found = this.data.get(key);\\n        if(found === undefined) {\\n            return \"\";\\n        }\\n\\n        // e.g. timestamp = 5 [1,3,4] if t <= timestamp, set \\n        // timestamps are increasing, use binary search. o(k*logV). k lookups. logV search\\n        const closestDatum = this.binarySearch(found, timestamp);\\n        if(closestDatum === -1) {\\n            return \"\";\\n        }\\n        \\n        return found[closestDatum].value;\\n    }\\n\\n    binarySearch(datums: Datum[], target: number) {\\n        let left = 0;\\n        let right = datums.length - 1;\\n        \\n        while(left <= right) {\\n            const mid = Math.floor(left + (right - left) / 2);\\n            const { value: midV, timestamp: midT } = datums[mid]\\n            // [1,3,4,5,8] target = 6. return largest t <= target - 5.\\n            if(midT <= target) {\\n                // increase left to find largest midT <= target\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        if(right < 0) {\\n            return -1;\\n        }\\n        return right;\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * var obj = new TimeMap()\\n * obj.set(key,value,timestamp)\\n * var param_2 = obj.get(key,timestamp)\\n */\\n ```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Binary Tree"
                ],
                "code": "```\\ntype Datum = {\\n    value: string,\\n    timestamp: number\\n};\\n\\nclass TimeMap {\\n    data: Map<string, Datum[]>\\n\\n    constructor() {\\n        this.data = new Map<string, Datum[]>();\\n    }\\n\\n    set(key: string, value: string, timestamp: number): void {\\n        const datum: Datum = {value, timestamp}\\n        const found = this.data.get(key);\\n        if(found) {\\n            found.push(datum);\\n        } else {\\n            this.data.set(key, [datum]);   \\n        }\\n    }\\n\\n    // K keys. V values. V unsorted. o(1) lookup. o(logV) search\\n    get(key: string, timestamp: number): string {\\n        // find datum with key and timestamp\\n        // multiple values for the same key\\n        const found = this.data.get(key);\\n        if(found === undefined) {\\n            return \"\";\\n        }\\n\\n        // e.g. timestamp = 5 [1,3,4] if t <= timestamp, set \\n        // timestamps are increasing, use binary search. o(k*logV). k lookups. logV search\\n        const closestDatum = this.binarySearch(found, timestamp);\\n        if(closestDatum === -1) {\\n            return \"\";\\n        }\\n        \\n        return found[closestDatum].value;\\n    }\\n\\n    binarySearch(datums: Datum[], target: number) {\\n        let left = 0;\\n        let right = datums.length - 1;\\n        \\n        while(left <= right) {\\n            const mid = Math.floor(left + (right - left) / 2);\\n            const { value: midV, timestamp: midT } = datums[mid]\\n            // [1,3,4,5,8] target = 6. return largest t <= target - 5.\\n            if(midT <= target) {\\n                // increase left to find largest midT <= target\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        if(right < 0) {\\n            return -1;\\n        }\\n        return right;\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * var obj = new TimeMap()\\n * obj.set(key,value,timestamp)\\n * var param_2 = obj.get(key,timestamp)\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1485025,
                "title": "python-two-clean-solutions-hashmap-linkedlist-or-binary-search",
                "content": "Solution No. 1: `LinkedList`. Super clean and self explanatory solution.\\n\\n```\\nclass LinkedList:\\n    def __init__(self, timestamp, value):\\n        self.timestamp = timestamp\\n        self.value = value\\n        self.next = None\\n\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.database = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        node = LinkedList(timestamp, value)\\n        node.next = self.database.get(key)\\n        self.database[key] = node\\n            \\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.database:\\n            return \"\"\\n        \\n        head = self.database[key]\\n        while head:\\n            if timestamp >= head.timestamp:\\n                return head.value\\n            head = head.next\\n\\n        return \"\"\\n```\\n\\nSolution No. 2: `Binary Search`. Fastest solution.\\n\\n```\\nfrom collections import defaultdict\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.data = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.data[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        entries = self.data.get(key)\\n        if not entries:\\n            return \"\"\\n\\n        latestTimestamp, latestValue = entries[-1]\\n        oldestTimestamp, oldestValue = entries[0]        \\n        if timestamp >= latestTimestamp:\\n            return latestValue\\n        if timestamp < oldestTimestamp:\\n            return \"\"\\n        \\n        left, right = 0, len(entries) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            currentTimestamp, currentValue = entries[mid]\\n            if currentTimestamp == timestamp:\\n                return currentValue\\n            elif currentTimestamp > timestamp:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return entries[left - 1][1]     # left is pointing to the next bigger\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Binary Tree"
                ],
                "code": "```\\nclass LinkedList:\\n    def __init__(self, timestamp, value):\\n        self.timestamp = timestamp\\n        self.value = value\\n        self.next = None\\n\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.database = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        node = LinkedList(timestamp, value)\\n        node.next = self.database.get(key)\\n        self.database[key] = node\\n            \\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.database:\\n            return \"\"\\n        \\n        head = self.database[key]\\n        while head:\\n            if timestamp >= head.timestamp:\\n                return head.value\\n            head = head.next\\n\\n        return \"\"\\n```\n```\\nfrom collections import defaultdict\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.data = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.data[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        entries = self.data.get(key)\\n        if not entries:\\n            return \"\"\\n\\n        latestTimestamp, latestValue = entries[-1]\\n        oldestTimestamp, oldestValue = entries[0]        \\n        if timestamp >= latestTimestamp:\\n            return latestValue\\n        if timestamp < oldestTimestamp:\\n            return \"\"\\n        \\n        left, right = 0, len(entries) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            currentTimestamp, currentValue = entries[mid]\\n            if currentTimestamp == timestamp:\\n                return currentValue\\n            elif currentTimestamp > timestamp:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return entries[left - 1][1]     # left is pointing to the next bigger\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186920,
                "title": "easy-to-understand-hash-map-priority-queue-beats-99-every-detail-commented",
                "content": "//Idea is to maintain a hashmap of the key value pairs, but each key has a max heap as its value. This takes care of both having multiple values \\n//mapped to a key and efficiently returning the one with the most recent timestamp. I use a \"timestamp\" object which stores both the actual value and the timestamp\\n//the object implements javas comparable interface (an alternative would be to use a custom comparator in the constructor of the heap - either works) so that they are\\n//automatically ordered by decreasing timestamp (highest timestamp at top). Then when we get a key, we keep popping from the heap while the value of the top element is \\n//strictly greater than the value of the timestamp were looking for. We need to keep these values in a temporary list to add back to the heap in case they are looked up \\n//in a later call. In the case that the timestamp is less than ALL values for the key, we return an empty string. \\n```\\nclass TimeMap {\\n     Map<String,Queue<TimeStamp>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        //instantiate a timestamp object with the time and the value.\\n        TimeStamp ts = new TimeStamp(timestamp,value);\\n        if(map.containsKey(key)){\\n            Queue<TimeStamp> current = map.get(key);\\n            //if we have seen this key before at to its queue.\\n            current.add(ts);\\n            map.put(key,current);\\n        }\\n        else{\\n            //if we havent seen it, add it and create a new queue with its value.\\n            //default ordering of priority queue in java is minheap, use collections to fix this.\\n            Queue<TimeStamp> current = new PriorityQueue<>(Collections.reverseOrder());\\n            current.add(ts);\\n            map.put(key, current);\\n        }\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        //this key is not found.\\n        if(!map.containsKey(key)){\\n            return \"\";\\n        }\\n        else{\\n            Queue<TimeStamp> current = map.get(key);\\n            List<TimeStamp> copy = new ArrayList<>();\\n            //search for greatest timestamp less than or equal to the one we are looking for.\\n            while(!current.isEmpty() && current.peek().time > timestamp){\\n                //copy the elements that we have popped to re add them later.\\n                copy.add(current.poll());\\n            }\\n            //while loop breaks at first time stamp less than or equal to our timestamp. return current.peek UNLESS the queue is empty which means every time stamp \\n            //was greater. In this case return empty string.\\n            String val = current.isEmpty() ? \"\" : current.peek().value;\\n            //add back values we popped in our search.\\n            current.addAll(copy);\\n            return val;\\n        }\\n        \\n    }\\n}\\nclass TimeStamp implements Comparable<TimeStamp>{\\n    //timestamp object maintains both time and value.\\n    public int time; \\n    public String value;\\n    TimeStamp(int time, String value){\\n      this.time=time;\\n      this.value=value;\\n    }\\n    //compare the nodes based on time so that the heap will be ordered correctly. This is an interface in Java, if not clear research comparable interface.\\n    public int compareTo(TimeStamp t ){\\n        if(this.time==t.time){\\n            return 0;\\n        }\\n        else{\\n            return this.time > t.time ? 1 : -1;\\n        }\\n    }\\n        \\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "//Idea is to maintain a hashmap of the key value pairs, but each key has a max heap as its value. This takes care of both having multiple values \\n//mapped to a key and efficiently returning the one with the most recent timestamp. I use a \"timestamp\" object which stores both the actual value and the timestamp\\n//the object implements javas comparable interface (an alternative would be to use a custom comparator in the constructor of the heap - either works) so that they are\\n//automatically ordered by decreasing timestamp (highest timestamp at top). Then when we get a key, we keep popping from the heap while the value of the top element is \\n//strictly greater than the value of the timestamp were looking for. We need to keep these values in a temporary list to add back to the heap in case they are looked up \\n//in a later call. In the case that the timestamp is less than ALL values for the key, we return an empty string. \\n```\\nclass TimeMap {\\n     Map<String,Queue<TimeStamp>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        //instantiate a timestamp object with the time and the value.\\n        TimeStamp ts = new TimeStamp(timestamp,value);\\n        if(map.containsKey(key)){\\n            Queue<TimeStamp> current = map.get(key);\\n            //if we have seen this key before at to its queue.\\n            current.add(ts);\\n            map.put(key,current);\\n        }\\n        else{\\n            //if we havent seen it, add it and create a new queue with its value.\\n            //default ordering of priority queue in java is minheap, use collections to fix this.\\n            Queue<TimeStamp> current = new PriorityQueue<>(Collections.reverseOrder());\\n            current.add(ts);\\n            map.put(key, current);\\n        }\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        //this key is not found.\\n        if(!map.containsKey(key)){\\n            return \"\";\\n        }\\n        else{\\n            Queue<TimeStamp> current = map.get(key);\\n            List<TimeStamp> copy = new ArrayList<>();\\n            //search for greatest timestamp less than or equal to the one we are looking for.\\n            while(!current.isEmpty() && current.peek().time > timestamp){\\n                //copy the elements that we have popped to re add them later.\\n                copy.add(current.poll());\\n            }\\n            //while loop breaks at first time stamp less than or equal to our timestamp. return current.peek UNLESS the queue is empty which means every time stamp \\n            //was greater. In this case return empty string.\\n            String val = current.isEmpty() ? \"\" : current.peek().value;\\n            //add back values we popped in our search.\\n            current.addAll(copy);\\n            return val;\\n        }\\n        \\n    }\\n}\\nclass TimeStamp implements Comparable<TimeStamp>{\\n    //timestamp object maintains both time and value.\\n    public int time; \\n    public String value;\\n    TimeStamp(int time, String value){\\n      this.time=time;\\n      this.value=value;\\n    }\\n    //compare the nodes based on time so that the heap will be ordered correctly. This is an interface in Java, if not clear research comparable interface.\\n    public int compareTo(TimeStamp t ){\\n        if(this.time==t.time){\\n            return 0;\\n        }\\n        else{\\n            return this.time > t.time ? 1 : -1;\\n        }\\n    }\\n        \\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1124750,
                "title": "javascript-solution-96-61-binary-search-clean",
                "content": "I spent more time writing binary search algorithm than anyting else. That\\'s where started to regret that JS misses binary search method on arrays.\\n\\nRuntime: 404 ms, faster than 96.55% of JavaScript online submissions for Time Based Key-Value Store.\\nMemory Usage: 79.4 MB, less than 61.49% of JavaScript online submissions for Time Based Key-Value Store.\\n\\n```\\nclass TimeMap {\\n  constructor() {\\n    this.map = new Map()\\n    this.searchTimestamp = (arr, timestamp) => {\\n      let l = 0, r = arr.length - 1\\n      while (l <= r) {\\n        const mid = Math.floor((l + r) / 2)\\n        if (arr[mid].timestamp === timestamp) return mid\\n        l = arr[mid].timestamp < timestamp ? mid + 1 : l\\n        r = arr[mid].timestamp > timestamp ? mid - 1 : r\\n      }\\n      return -l -1\\n    }\\n  }  \\n  \\n  set(key, value, timestamp) {\\n    const arr = this.map.get(key) || []\\n    arr.push({ value, timestamp })\\n    this.map.set(key, arr)\\n  }\\n  \\n  get(key, timestamp) {\\n    const arr = this.map.get(key)\\n    if (!arr) return \\'\\'\\n    const index = this.searchTimestamp(arr, timestamp)\\n    if (index === -1) return \\'\\'\\n    if (index >= 0) return arr[index].value\\n    // Use previous value from the collection\\n    return arr[-index-2].value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeMap {\\n  constructor() {\\n    this.map = new Map()\\n    this.searchTimestamp = (arr, timestamp) => {\\n      let l = 0, r = arr.length - 1\\n      while (l <= r) {\\n        const mid = Math.floor((l + r) / 2)\\n        if (arr[mid].timestamp === timestamp) return mid\\n        l = arr[mid].timestamp < timestamp ? mid + 1 : l\\n        r = arr[mid].timestamp > timestamp ? mid - 1 : r\\n      }\\n      return -l -1\\n    }\\n  }  \\n  \\n  set(key, value, timestamp) {\\n    const arr = this.map.get(key) || []\\n    arr.push({ value, timestamp })\\n    this.map.set(key, arr)\\n  }\\n  \\n  get(key, timestamp) {\\n    const arr = this.map.get(key)\\n    if (!arr) return \\'\\'\\n    const index = this.searchTimestamp(arr, timestamp)\\n    if (index === -1) return \\'\\'\\n    if (index >= 0) return arr[index].value\\n    // Use previous value from the collection\\n    return arr[-index-2].value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996290,
                "title": "python-without-bisect-library",
                "content": "Time Complexity: O(1) for each set operation, and O(logN) for each get operation, where N is the number of entries in the TimeMap\\nSpace Complexity: O(N)\\n```\\nclass TimeMap:\\n\\n    def binarySearch(self, a, key):\\n        if key < a[0][1]:\\n            return \\'\\'\\n        elif key >= a[-1][1]:\\n            return a[-1][0]\\n        \\n        low = 0\\n        high = len(a) - 1\\n        \\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if a[mid][1] == key:\\n                return a[mid][0]\\n            elif a[mid][1] > key:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return a[high][0]\\n    \\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.d = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.d[key].append((value, timestamp))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        return self.binarySearch(self.d[key], timestamp)\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def binarySearch(self, a, key):\\n        if key < a[0][1]:\\n            return \\'\\'\\n        elif key >= a[-1][1]:\\n            return a[-1][0]\\n        \\n        low = 0\\n        high = len(a) - 1\\n        \\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if a[mid][1] == key:\\n                return a[mid][0]\\n            elif a[mid][1] > key:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return a[high][0]\\n    \\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.d = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.d[key].append((value, timestamp))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        return self.binarySearch(self.d[key], timestamp)\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877115,
                "title": "java-two-solutions",
                "content": "If there is no contraint of \\'**strictly increasing insertion**\\' mentioned in the description:\\nthen we will use TreeMap to store the pair of value and timestamp\\n```\\nclass TimeMap {\\n    \\n    Map<String, Map<Integer,String>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int time) {\\n        map.computeIfAbsent(key, x -> new TreeMap<Integer, String>()).put(time, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer, String> child = (TreeMap<Integer, String>) map.getOrDefault(key, null);\\n        if(child == null)  return null;\\n        Map.Entry<Integer, String> entry = child.floorEntry(timestamp);\\n        if(entry == null) return \"\";\\n        return entry.getValue();\\n    }\\n}\\n```\\n\\n\\nWith the constraint:\\n**The timestamps for all TimeMap.set operations are strictly increasing.**\\nUse binary search for finding the answer\\n\\n```\\nclass TimeMap {\\n    \\n     Map<String, List<Pair>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void set(String key, String value, int time) {\\n        map.computeIfAbsent(key, x -> new ArrayList<Pair>()).add(new Pair(time, value));\\n    }\\n\\n    public String get(String key, int timestamp) {\\n        List<Pair> list = map.getOrDefault(key, null);\\n        if(list == null)  return null;\\n        return doBinarySearch(list, timestamp);\\n    }\\n\\n    public String doBinarySearch(List<Pair> list, int time){\\n        int start = 0;\\n        int end = list.size()-1;\\n        while(start < end){\\n            int mid = (start+end) >>1;\\n            int t1 = list.get(mid).time;\\n            if(t1 == time){\\n                return list.get(mid).val;\\n            }\\n            if(t1 > time){\\n                end = mid-1;\\n            } else{\\n                if(list.get(mid+1).time > time) return list.get(mid).val;\\n                start = mid+1;\\n            }\\n        }\\n        return (list.get(start).time <= time ? list.get(start).val : \"\");\\n    }\\n\\n    class Pair{\\n        int time;\\n        String val;\\n        Pair(int t, String v){\\n            this.time = t;\\n            this.val = v;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\n    \\n    Map<String, Map<Integer,String>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int time) {\\n        map.computeIfAbsent(key, x -> new TreeMap<Integer, String>()).put(time, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer, String> child = (TreeMap<Integer, String>) map.getOrDefault(key, null);\\n        if(child == null)  return null;\\n        Map.Entry<Integer, String> entry = child.floorEntry(timestamp);\\n        if(entry == null) return \"\";\\n        return entry.getValue();\\n    }\\n}\\n```\n```\\nclass TimeMap {\\n    \\n     Map<String, List<Pair>> map;\\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void set(String key, String value, int time) {\\n        map.computeIfAbsent(key, x -> new ArrayList<Pair>()).add(new Pair(time, value));\\n    }\\n\\n    public String get(String key, int timestamp) {\\n        List<Pair> list = map.getOrDefault(key, null);\\n        if(list == null)  return null;\\n        return doBinarySearch(list, timestamp);\\n    }\\n\\n    public String doBinarySearch(List<Pair> list, int time){\\n        int start = 0;\\n        int end = list.size()-1;\\n        while(start < end){\\n            int mid = (start+end) >>1;\\n            int t1 = list.get(mid).time;\\n            if(t1 == time){\\n                return list.get(mid).val;\\n            }\\n            if(t1 > time){\\n                end = mid-1;\\n            } else{\\n                if(list.get(mid+1).time > time) return list.get(mid).val;\\n                start = mid+1;\\n            }\\n        }\\n        return (list.get(start).time <= time ? list.get(start).val : \"\");\\n    }\\n\\n    class Pair{\\n        int time;\\n        String val;\\n        Pair(int t, String v){\\n            this.time = t;\\n            this.val = v;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698716,
                "title": "c",
                "content": "again, the description is poor.\\n```\\npublic class TimeMap {    \\n            private Dictionary<string, List<(int, string)>> dict = new Dictionary<string, List<(int, string)>>();\\n\\n            public void Set(string key, string value, int timestamp)\\n            {\\n                if (!dict.ContainsKey(key))\\n                    dict.Add(key, new List<(int, string)>());\\n\\n                dict[key].Add((timestamp, value));\\n            }\\n\\n            public string Get(string key, int timestamp)\\n            {\\n                if (!dict.ContainsKey(key))\\n                    return string.Empty;\\n                \\n                List<(int stamp, string val)> l = dict[key];\\n                int i = 0,\\n                    j = l.Count - 1,\\n                    k = 0;\\n                bool found = false;\\n                \\n                if (l[0].stamp > timestamp)\\n                    return string.Empty;\\n                else if (l[l.Count - 1].stamp < timestamp)\\n                    return l[l.Count - 1].val;\\n                else\\n                {\\n                    while (i <= j)\\n                    {\\n                        k = i + (j - i) / 2;\\n\\n                        if (l[k].stamp == timestamp)\\n                        {\\n                            found = true;\\n                            break;\\n                        }\\n                        else if (l[k].stamp > timestamp)\\n                            j = k - 1;\\n                        else\\n                            i = k + 1;\\n                    }\\n\\n                    if (!found)\\n                        k = k - 1 < 0 ? 0 : k - 1;\\n                }\\n\\n                return l[k].val;\\n            }\\n}",
                "solutionTags": [],
                "code": "again, the description is poor.\\n```\\npublic class TimeMap {    \\n            private Dictionary<string, List<(int, string)>> dict = new Dictionary<string, List<(int, string)>>();\\n\\n            public void Set(string key, string value, int timestamp)\\n            {\\n                if (!dict.ContainsKey(key))\\n                    dict.Add(key, new List<(int, string)>());\\n\\n                dict[key].Add((timestamp, value));\\n            }\\n\\n            public string Get(string key, int timestamp)\\n            {\\n                if (!dict.ContainsKey(key))\\n                    return string.Empty;\\n                \\n                List<(int stamp, string val)> l = dict[key];\\n                int i = 0,\\n                    j = l.Count - 1,\\n                    k = 0;\\n                bool found = false;\\n                \\n                if (l[0].stamp > timestamp)\\n                    return string.Empty;\\n                else if (l[l.Count - 1].stamp < timestamp)\\n                    return l[l.Count - 1].val;\\n                else\\n                {\\n                    while (i <= j)\\n                    {\\n                        k = i + (j - i) / 2;\\n\\n                        if (l[k].stamp == timestamp)\\n                        {\\n                            found = true;\\n                            break;\\n                        }\\n                        else if (l[k].stamp > timestamp)\\n                            j = k - 1;\\n                        else\\n                            i = k + 1;\\n                    }\\n\\n                    if (!found)\\n                        k = k - 1 < 0 ? 0 : k - 1;\\n                }\\n\\n                return l[k].val;\\n            }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 480842,
                "title": "easy-c-solution-with-binary-search",
                "content": "```\\n    public class TimeMap\\n    {\\n        private readonly IDictionary<string, IList<(int timestamp, string value)>> _data;\\n\\n        public TimeMap()\\n        {\\n            _data = new Dictionary<string, IList<(int timestamp, string value)>>();\\n        }\\n\\n        public void Set(string key, string value, int timestamp)\\n        {\\n            if (!_data.ContainsKey(key))\\n            {\\n                _data[key] = new List<(int timestamp, string value)>();\\n            }\\n\\n            _data[key].Add((timestamp, value));\\n        }\\n\\n        public string Get(string key, int timestamp)\\n        {\\n            if (!_data.ContainsKey(key))\\n            {\\n                return string.Empty;\\n            }\\n\\n            var list = _data[key];\\n\\n            int left = 0;\\n            int right = list.Count - 1;\\n\\n            while (left < right)\\n            {\\n                if (right - left == 1)\\n                {\\n                    break;\\n                }\\n\\n                int mid = left + (right - left) / 2;\\n\\n                var midItem = list[mid];\\n                if (midItem.timestamp == timestamp)\\n                {\\n                    return midItem.value;\\n                }\\n\\n                if (midItem.timestamp < timestamp)\\n                {\\n                    left = mid;\\n                    continue;\\n                }\\n\\n                right = mid;\\n            }\\n\\n            if (list[right].timestamp <= timestamp)\\n            {\\n                return list[right].value;\\n            }\\n\\n            if (list[left].timestamp <= timestamp)\\n            {\\n                return list[left].value;\\n            }\\n\\n            return string.Empty;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n    public class TimeMap\\n    {\\n        private readonly IDictionary<string, IList<(int timestamp, string value)>> _data;\\n\\n        public TimeMap()\\n        {\\n            _data = new Dictionary<string, IList<(int timestamp, string value)>>();\\n        }\\n\\n        public void Set(string key, string value, int timestamp)\\n        {\\n            if (!_data.ContainsKey(key))\\n            {\\n                _data[key] = new List<(int timestamp, string value)>();\\n            }\\n\\n            _data[key].Add((timestamp, value));\\n        }\\n\\n        public string Get(string key, int timestamp)\\n        {\\n            if (!_data.ContainsKey(key))\\n            {\\n                return string.Empty;\\n            }\\n\\n            var list = _data[key];\\n\\n            int left = 0;\\n            int right = list.Count - 1;\\n\\n            while (left < right)\\n            {\\n                if (right - left == 1)\\n                {\\n                    break;\\n                }\\n\\n                int mid = left + (right - left) / 2;\\n\\n                var midItem = list[mid];\\n                if (midItem.timestamp == timestamp)\\n                {\\n                    return midItem.value;\\n                }\\n\\n                if (midItem.timestamp < timestamp)\\n                {\\n                    left = mid;\\n                    continue;\\n                }\\n\\n                right = mid;\\n            }\\n\\n            if (list[right].timestamp <= timestamp)\\n            {\\n                return list[right].value;\\n            }\\n\\n            if (list[left].timestamp <= timestamp)\\n            {\\n                return list[left].value;\\n            }\\n\\n            return string.Empty;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401758,
                "title": "easy-c-solution-using-upper-bound",
                "content": "Runtime: 404 ms, faster than 62.79% of C++ online submissions for Time Based Key-Value Store.\\nMemory Usage: 136.7 MB, less than 100.00% of C++ online submissions for Time Based Key-Value Store.\\n\\n```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, map<int, string>> mp;\\n    TimeMap() {\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto find = mp[key].upper_bound(timestamp);\\n        if(find == mp[key].begin()) return \"\";\\n        find--;\\n        return find->second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "Runtime: 404 ms, faster than 62.79% of C++ online submissions for Time Based Key-Value Store.\\nMemory Usage: 136.7 MB, less than 100.00% of C++ online submissions for Time Based Key-Value Store.\\n\\n```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, map<int, string>> mp;\\n    TimeMap() {\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto find = mp[key].upper_bound(timestamp);\\n        if(find == mp[key].begin()) return \"\";\\n        find--;\\n        return find->second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 396345,
                "title": "c-99-57-100-with-binary-search",
                "content": "```\\npublic class TimeMap {\\n    Dictionary<string, List<(int, string)>> map = new Dictionary<string, List<(int, string)>>();\\n    \\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        \\n    }\\n    \\n    public void Set(string key, string value, int timestamp) {\\n        if (map.TryGetValue(key, out var list)) {\\n            list.Add((timestamp, value));\\n        } else {\\n            map[key] = new List<(int, string)>{(timestamp, value)};\\n        }\\n    }\\n    \\n    public string Get(string key, int timestamp) {\\n        if (map.TryGetValue(key, out var list)) \\n            return bs(list, timestamp);\\n        return \"\";\\n    }\\n    \\n    string bs(List<(int, string)> list, int target) {\\n        var start = 0;\\n        var end = list.Count - 1;\\n        \\n        while (start <= end) {\\n            var mid = (start + end) / 2;\\n            var (ts, val) = list[mid];\\n            if (ts == target) return val;\\n            if (ts > target) end = mid - 1;\\n            else start = mid + 1;\\n        }\\n        \\n        if (end >= 0) {\\n            var (_, res) =  list[end];\\n            return res;\\n        } else return \"\";\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\npublic class TimeMap {\\n    Dictionary<string, List<(int, string)>> map = new Dictionary<string, List<(int, string)>>();\\n    \\n    /** Initialize your data structure here. */\\n    public TimeMap() {\\n        \\n    }\\n    \\n    public void Set(string key, string value, int timestamp) {\\n        if (map.TryGetValue(key, out var list)) {\\n            list.Add((timestamp, value));\\n        } else {\\n            map[key] = new List<(int, string)>{(timestamp, value)};\\n        }\\n    }\\n    \\n    public string Get(string key, int timestamp) {\\n        if (map.TryGetValue(key, out var list)) \\n            return bs(list, timestamp);\\n        return \"\";\\n    }\\n    \\n    string bs(List<(int, string)> list, int target) {\\n        var start = 0;\\n        var end = list.Count - 1;\\n        \\n        while (start <= end) {\\n            var mid = (start + end) / 2;\\n            var (ts, val) = list[mid];\\n            if (ts == target) return val;\\n            if (ts > target) end = mid - 1;\\n            else start = mid + 1;\\n        }\\n        \\n        if (end >= 0) {\\n            var (_, res) =  list[end];\\n            return res;\\n        } else return \"\";\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307372,
                "title": "java-treemaps",
                "content": "```java\\nMap<String, TreeMap<Integer, String>> M = new HashMap<>();\\n\\npublic TimeMap() { }\\n\\npublic void set(String k, String v, int t) {\\n\\tif (!M.containsKey(k)) M.put(k, new TreeMap<>());\\n\\tM.get(k).put(t, v);\\n}\\n\\npublic String get(String k, int t) {\\n\\tif (!M.containsKey(k)) return \"\";\\n\\tMap.Entry<Integer, String> e = M.get(k).floorEntry(t);\\n\\treturn e == null ? \"\" : e.getValue();\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nMap<String, TreeMap<Integer, String>> M = new HashMap<>();\\n\\npublic TimeMap() { }\\n\\npublic void set(String k, String v, int t) {\\n\\tif (!M.containsKey(k)) M.put(k, new TreeMap<>());\\n\\tM.get(k).put(t, v);\\n}\\n\\npublic String get(String k, int t) {\\n\\tif (!M.containsKey(k)) return \"\";\\n\\tMap.Entry<Integer, String> e = M.get(k).floorEntry(t);\\n\\treturn e == null ? \"\" : e.getValue();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 297821,
                "title": "simple-c-solution-using-binary-search",
                "content": "```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m1[key][timestamp] = value;\\n        m2[key].push_back(timestamp);\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if (m1.find(key) == m1.end()) return \"\";\\n        \\n        auto it = upper_bound(m2[key].begin(), m2[key].end(), timestamp);\\n        if (it == m2[key].begin()) return \"\";\\n        return m1[key][*(--it)];\\n    }\\n    \\nprivate:\\n    unordered_map<string, map<int, string>> m1;\\n    unordered_map<string, vector<int>> m2;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\npublic:\\n    /** Initialize your data structure here. */\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m1[key][timestamp] = value;\\n        m2[key].push_back(timestamp);\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if (m1.find(key) == m1.end()) return \"\";\\n        \\n        auto it = upper_bound(m2[key].begin(), m2[key].end(), timestamp);\\n        if (it == m2[key].begin()) return \"\";\\n        return m1[key][*(--it)];\\n    }\\n    \\nprivate:\\n    unordered_map<string, map<int, string>> m1;\\n    unordered_map<string, vector<int>> m2;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256665,
                "title": "python-4-line-solution-using-bisect",
                "content": "```python\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.d = collections.defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.d[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        idx = bisect.bisect(self.d[key], (timestamp, chr(ord(\\'z\\') + 1))) - 1\\n        return \\'\\' if idx == -1 else self.d[key][idx][1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.d = collections.defaultdict(list)\\n        \\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.d[key].append((timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        idx = bisect.bisect(self.d[key], (timestamp, chr(ord(\\'z\\') + 1))) - 1\\n        return \\'\\' if idx == -1 else self.d[key][idx][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006693,
                "title": "time-based-key-value-store",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeMap {\\n    unordered_map<string,vector<pair<string, int>>> mTime;\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {        \\n        mTime[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {        \\n        int res = -1;\\n        if( mTime.find(key) != mTime.end()){            \\n            int start = 0, end = mTime[key].size()-1;\\n            \\n            while(start <= end){\\n                int mid = start + (end-start)/2;\\n                if(mTime[key][mid].second == timestamp){\\n                    return mTime[key][mid].first;\\n                }else if(mTime[key][mid].second < timestamp){\\n                    res = mid;\\n                    start = mid+1;\\n                }else\\n                    end = mid-1;\\n            }           \\n        }\\n        \\n        return (res != -1) ? mTime[key][res].first : \"\";\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TimeMap {\\n    unordered_map<string,vector<pair<string, int>>> mTime;\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {        \\n        mTime[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {        \\n        int res = -1;\\n        if( mTime.find(key) != mTime.end()){            \\n            int start = 0, end = mTime[key].size()-1;\\n            \\n            while(start <= end){\\n                int mid = start + (end-start)/2;\\n                if(mTime[key][mid].second == timestamp){\\n                    return mTime[key][mid].first;\\n                }else if(mTime[key][mid].second < timestamp){\\n                    res = mid;\\n                    start = mid+1;\\n                }else\\n                    end = mid-1;\\n            }           \\n        }\\n        \\n        return (res != -1) ? mTime[key][res].first : \"\";\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981521,
                "title": "verbose-python3-solution-beats-99-72",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou\\'re making a map of values and associating them with timestamps.\\n\\nSince the timestamp inputs are always increasing, we don\\'t have to worry about sorting or whatever.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo the same thing as others, but instead of using a tuple, for every value we insert into the map for a key, create an object that tracks the biggest timestamp seen for this value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$set()$$ is just insert into a map, so $$O(1)$$\\n$$get()$$ uses binary search in the event that the timestamp is less than $$max\\\\_timestamp$$, so overall $$O(log\\\\ n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe make $$n$$ objects in the map, each of those objects will have at most $$2n$$ timestamps in memory at any given time (call to $$get()$$ makes another list)\\nOverall $$O(n)$$\\n\\n# Code\\n```\\nclass TimeMapValue:\\n    def __init__(self, value: str, timestamp: int):\\n        self.values = {timestamp: value}\\n        self.max_timestamp = timestamp\\n    \\n    def set(self, value: str, timestamp: int) -> None:\\n        self.values[timestamp] = value\\n        if timestamp > self.max_timestamp:\\n            self.max_timestamp = timestamp\\n    \\n    def get(self, timestamp) -> str:\\n        if timestamp > self.max_timestamp:\\n            return self.values[self.max_timestamp]\\n        res = \"\"\\n        vals = list(self.values.keys())\\n        low, high = 0, len(vals) - 1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if vals[mid] <= timestamp:\\n                res = self.values[vals[mid]]\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        \\n        return res\\n\\n        if self.max_timestamp in self.values:\\n            return self.values[self.max_timestamp]\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.store = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        if key not in self.store:\\n            # Create it\\n            entry = TimeMapValue(value, timestamp)\\n            self.store[key] = entry\\n        else:\\n            # Update with additional key\\n            entry = self.store[key]\\n            entry.set(value, timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key in self.store:\\n            entry = self.store[key]\\n            return entry.get(timestamp)\\n\\n        return \"\"\\n        \\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TimeMapValue:\\n    def __init__(self, value: str, timestamp: int):\\n        self.values = {timestamp: value}\\n        self.max_timestamp = timestamp\\n    \\n    def set(self, value: str, timestamp: int) -> None:\\n        self.values[timestamp] = value\\n        if timestamp > self.max_timestamp:\\n            self.max_timestamp = timestamp\\n    \\n    def get(self, timestamp) -> str:\\n        if timestamp > self.max_timestamp:\\n            return self.values[self.max_timestamp]\\n        res = \"\"\\n        vals = list(self.values.keys())\\n        low, high = 0, len(vals) - 1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if vals[mid] <= timestamp:\\n                res = self.values[vals[mid]]\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        \\n        return res\\n\\n        if self.max_timestamp in self.values:\\n            return self.values[self.max_timestamp]\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.store = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        if key not in self.store:\\n            # Create it\\n            entry = TimeMapValue(value, timestamp)\\n            self.store[key] = entry\\n        else:\\n            # Update with additional key\\n            entry = self.store[key]\\n            entry.set(value, timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key in self.store:\\n            entry = self.store[key]\\n            return entry.get(timestamp)\\n\\n        return \"\"\\n        \\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849843,
                "title": "java-using-hashmap-and-binary-search-beats-98",
                "content": "\\n# Code\\n```\\nclass Node{\\n    int time;\\n    String value;\\n    Node(int time, String value){\\n        this.time = time;\\n        this.value = value;\\n    }\\n}\\nclass TimeMap {\\n    HashMap<String,List<Node>>timeMap;\\n    public TimeMap() {\\n        timeMap = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        Node newNode = new Node(timestamp,value);\\n        if(timeMap.containsKey(key)){\\n            timeMap.get(key).add(newNode);\\n        }\\n        else{\\n            List<Node>l = new ArrayList<>();\\n            l.add(newNode);\\n            timeMap.put(key,l);\\n        }\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!timeMap.containsKey(key))return \"\";\\n        List<Node>list = timeMap.get(key);\\n        return binarySearch(list,0,list.size()-1,timestamp);\\n    }\\n    String binarySearch(List<Node>list,int left, int right, int target){\\n        int mid = 0;\\n        while(left<right){\\n            mid = left+(right-left)/2+1;\\n            if(list.get(mid).time<target){\\n                left = mid;\\n            }\\n            else if(list.get(mid).time>target)right = mid-1;\\n            else return list.get(mid).value;\\n        }\\n        return list.get(left).time>target?\"\":list.get(left).value;\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node{\\n    int time;\\n    String value;\\n    Node(int time, String value){\\n        this.time = time;\\n        this.value = value;\\n    }\\n}\\nclass TimeMap {\\n    HashMap<String,List<Node>>timeMap;\\n    public TimeMap() {\\n        timeMap = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        Node newNode = new Node(timestamp,value);\\n        if(timeMap.containsKey(key)){\\n            timeMap.get(key).add(newNode);\\n        }\\n        else{\\n            List<Node>l = new ArrayList<>();\\n            l.add(newNode);\\n            timeMap.put(key,l);\\n        }\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!timeMap.containsKey(key))return \"\";\\n        List<Node>list = timeMap.get(key);\\n        return binarySearch(list,0,list.size()-1,timestamp);\\n    }\\n    String binarySearch(List<Node>list,int left, int right, int target){\\n        int mid = 0;\\n        while(left<right){\\n            mid = left+(right-left)/2+1;\\n            if(list.get(mid).time<target){\\n                left = mid;\\n            }\\n            else if(list.get(mid).time>target)right = mid-1;\\n            else return list.get(mid).value;\\n        }\\n        return list.get(left).time>target?\"\":list.get(left).value;\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848880,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Map\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass TimeMap {\\npublic:\\n    map<pair<string, int>, string> mp;\\n    map<string, string> mp2;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[{key, timestamp}] = value;\\n        mp2[key] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp2.find(key) == mp2.end()) return \"\";\\n        else {\\n            auto it = mp.upper_bound({key, timestamp});\\n            if (it == mp.begin()) return \"\";\\n            it--;\\n            return mp[it->first];\\n        }\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    map<pair<string, int>, string> mp;\\n    map<string, string> mp2;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[{key, timestamp}] = value;\\n        mp2[key] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp2.find(key) == mp2.end()) return \"\";\\n        else {\\n            auto it = mp.upper_bound({key, timestamp});\\n            if (it == mp.begin()) return \"\";\\n            it--;\\n            return mp[it->first];\\n        }\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837875,
                "title": "java-hashmap-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing HashMap+TreeMap\\n\\nhttps://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html#floorEntry-K-\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: log(n) to retrieve entry with timestamp which is greater and less than or equal to given key.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) No of keys, values and timestamps.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeMap {\\n    HashMap<String,TreeMap<Integer,String>> map;\\n    public TimeMap() {\\n        map==new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key,t->new TreeMap<>()).put(timestamp,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)) return \"\";\\n        Map.Entry<Integer,String> entry= map.get(key).floorEntry(timestamp);\\n        if(entry==null) return \"\";\\n\\n        return entry.getValue();\\n\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    HashMap<String,TreeMap<Integer,String>> map;\\n    public TimeMap() {\\n        map==new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key,t->new TreeMap<>()).put(timestamp,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)) return \"\";\\n        Map.Entry<Integer,String> entry= map.get(key).floorEntry(timestamp);\\n        if(entry==null) return \"\";\\n\\n        return entry.getValue();\\n\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643743,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code implements a time-based key-value store using the TimeMap class. The set function is used to store a key-value pair with a corresponding timestamp, and the get function is used to retrieve the value associated with a key at a specific timestamp.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe TimeMap class uses an unordered map m to store the key-value pairs. Each key in the map is associated with a vector of pairs, where each pair represents a timestamp-value pair. The pairs within the vector are sorted in ascending order of timestamps.\\n\\nThe set function takes a key, value, and timestamp as inputs. It inserts the pair {timestamp, value} into the vector associated with the key in the map m. If the key does not exist in the map, a new vector is created and inserted with the initial pair. The pairs within the vector are maintained in sorted order.\\n\\nThe get function takes a key and timestamp as inputs and returns the value associated with the key at the largest timestamp less than or equal to the given timestamp. If the key does not exist in the map, an empty string is returned.\\n\\nTo find the value associated with the given key and timestamp, the code performs a binary search on the vector associated with the key in the map. It compares the target timestamp with the timestamps in the vector using the binary search approach. The search continues until the target timestamp is found, or the search range is exhausted. If the target timestamp is found, the corresponding value is returned. Otherwise, if the target timestamp is not found, the value associated with the largest timestamp less than the target timestamp is returned. This is achieved by returning the value associated with the pair at the index high, where high is the largest index before the search range was exhausted.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe set function has a time complexity of O(1) as it performs constant time operations to insert a pair into the vector associated with the key in the map.\\nThe get function has a time complexity of O(log n), where n is the size of the vector associated with the key in the map. This is because it performs a binary search on the sorted vector to find the target timestamp or the largest timestamp less than the target timestamp.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), where n is the total number of key-value pairs stored in the map. This is because the map m stores all the key-value pairs, and the size of the map is proportional to the number of pairs.\\n# Code\\n```\\nclass TimeMap {\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(m.find(key)==m.end()){\\n            return \"\";\\n        }\\n        int low = 0;\\n        int high= m[key].size()-1;\\n        while(low<=high){\\n            int mid= low+ (high-low)/2;\\n            if(m[key][mid].first<timestamp){\\n                low=mid+1;\\n            }\\n            else if(m[key][mid].first>timestamp){\\n                high=mid-1;\\n            }\\n            else\\n            return m[key][mid].second;\\n        }\\n    \\n    if(high>=0)\\n    {\\n        return m[key][high].second;\\n    }\\n    \\n    return \"\";\\n    }\\n    private: \\n    unordered_map<string, vector<pair<int,string>>>m;\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        m[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(m.find(key)==m.end()){\\n            return \"\";\\n        }\\n        int low = 0;\\n        int high= m[key].size()-1;\\n        while(low<=high){\\n            int mid= low+ (high-low)/2;\\n            if(m[key][mid].first<timestamp){\\n                low=mid+1;\\n            }\\n            else if(m[key][mid].first>timestamp){\\n                high=mid-1;\\n            }\\n            else\\n            return m[key][mid].second;\\n        }\\n    \\n    if(high>=0)\\n    {\\n        return m[key][high].second;\\n    }\\n    \\n    return \"\";\\n    }\\n    private: \\n    unordered_map<string, vector<pair<int,string>>>m;\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534580,
                "title": "solution",
                "content": "```C++ []\\nclass TimeMap {\\npublic:\\n    TimeMap()\\n    {\\n    }\\n    void set(const string& key, const string& value, const int timestamp)\\n    {\\n        data_[key].emplace_back(timestamp, value);\\n    }\\n    string get(const string& key, const int timestamp)\\n    {\\n        const auto itData = data_.find(key);\\n        if (itData == data_.end())\\n        {\\n            return \"\";\\n        }\\n        const std::vector<std::pair<int, string>>& values = itData->second;\\n\\n        const auto it = std::lower_bound(values.rbegin(), values.rend(), timestamp, \\n        [&](const std::pair<int, string>& p, const int targeValue)\\n        {\\n            return p.first > targeValue;\\n        });\\n        if (it == values.rend())\\n        {\\n            return \"\";\\n        }\\n        return it->second;\\n    }\\nprivate:\\n    std::unordered_map<string, std::vector<std::pair<int, string>>> data_;\\n\\n};\\n```\\n\\n```Python3 []\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.values = collections.defaultdict(list)\\n        self.timestamps = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.values[key].append(value)\\n        self.timestamps[key].append(timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n\\n        if key not in self.values:\\n            return \"\"\\n        \\n        if timestamp >= self.timestamps[key][-1]:\\n            return self.values[key][-1]\\n\\n        timestamps = self.timestamps[key]\\n\\n        left = 0\\n        right = len(timestamps)-1\\n\\n        ans = -1\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if timestamps[mid] <= timestamp:\\n                ans = mid\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        \\n        return \"\" if ans < 0 else self.values[key][ans]\\n```\\n\\n```Java []\\n  class TimeMap extends TimeMap3<String, String> {\\n        protected String getDefaultValue() {\\n            return \"\";\\n        }\\n    }\\n     class TimeMap3<K, V> {\\n        private static class TimeMapNode<V> {\\n            V value;\\n            int timestamp;\\n\\n            public TimeMapNode(V value, int timestamp) {\\n                this.value = value;\\n                this.timestamp = timestamp;\\n            }\\n        }\\n        private final Map<K, ArrayList<TimeMapNode<V>>> timeMap = new HashMap<>();\\n\\n        public TimeMap3() { }\\n\\n        public void set(K key, V value, int timestamp) {\\n            timeMap.computeIfAbsent(key, (v) -> new ArrayList<>())\\n                    .add(new TimeMapNode<>(value, timestamp));\\n        }\\n        public V get(K key, int timestamp) {\\n            ArrayList<TimeMapNode<V>> values = timeMap.get(key);\\n            if (values == null || values.isEmpty()) {\\n                return getDefaultValue();\\n            }\\n            int start = 0;\\n            int end = values.size() - 1;\\n            if (timestamp < values.get(start).timestamp ) {\\n                return getDefaultValue();\\n            }\\n            if (timestamp >= values.get(end).timestamp) {\\n                return values.get(end).value;\\n            }\\n            while (start <= end) {\\n                int mid = (start + end)/2;\\n                TimeMapNode<V> midValue = values.get(mid);\\n                if (midValue.timestamp == timestamp) {\\n                    return midValue.value;\\n                } else if (midValue.timestamp > timestamp) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            }\\n            return values.get(end).value;\\n        }\\n        protected V getDefaultValue() {\\n            return null;\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass TimeMap {\\npublic:\\n    TimeMap()\\n    {\\n    }\\n    void set(const string& key, const string& value, const int timestamp)\\n    {\\n        data_[key].emplace_back(timestamp, value);\\n    }\\n    string get(const string& key, const int timestamp)\\n    {\\n        const auto itData = data_.find(key);\\n        if (itData == data_.end())\\n        {\\n            return \"\";\\n        }\\n        const std::vector<std::pair<int, string>>& values = itData->second;\\n\\n        const auto it = std::lower_bound(values.rbegin(), values.rend(), timestamp, \\n        [&](const std::pair<int, string>& p, const int targeValue)\\n        {\\n            return p.first > targeValue;\\n        });\\n        if (it == values.rend())\\n        {\\n            return \"\";\\n        }\\n        return it->second;\\n    }\\nprivate:\\n    std::unordered_map<string, std::vector<std::pair<int, string>>> data_;\\n\\n};\\n```\n```Python3 []\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.values = collections.defaultdict(list)\\n        self.timestamps = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.values[key].append(value)\\n        self.timestamps[key].append(timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n\\n        if key not in self.values:\\n            return \"\"\\n        \\n        if timestamp >= self.timestamps[key][-1]:\\n            return self.values[key][-1]\\n\\n        timestamps = self.timestamps[key]\\n\\n        left = 0\\n        right = len(timestamps)-1\\n\\n        ans = -1\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if timestamps[mid] <= timestamp:\\n                ans = mid\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        \\n        return \"\" if ans < 0 else self.values[key][ans]\\n```\n```Java []\\n  class TimeMap extends TimeMap3<String, String> {\\n        protected String getDefaultValue() {\\n            return \"\";\\n        }\\n    }\\n     class TimeMap3<K, V> {\\n        private static class TimeMapNode<V> {\\n            V value;\\n            int timestamp;\\n\\n            public TimeMapNode(V value, int timestamp) {\\n                this.value = value;\\n                this.timestamp = timestamp;\\n            }\\n        }\\n        private final Map<K, ArrayList<TimeMapNode<V>>> timeMap = new HashMap<>();\\n\\n        public TimeMap3() { }\\n\\n        public void set(K key, V value, int timestamp) {\\n            timeMap.computeIfAbsent(key, (v) -> new ArrayList<>())\\n                    .add(new TimeMapNode<>(value, timestamp));\\n        }\\n        public V get(K key, int timestamp) {\\n            ArrayList<TimeMapNode<V>> values = timeMap.get(key);\\n            if (values == null || values.isEmpty()) {\\n                return getDefaultValue();\\n            }\\n            int start = 0;\\n            int end = values.size() - 1;\\n            if (timestamp < values.get(start).timestamp ) {\\n                return getDefaultValue();\\n            }\\n            if (timestamp >= values.get(end).timestamp) {\\n                return values.get(end).value;\\n            }\\n            while (start <= end) {\\n                int mid = (start + end)/2;\\n                TimeMapNode<V> midValue = values.get(mid);\\n                if (midValue.timestamp == timestamp) {\\n                    return midValue.value;\\n                } else if (midValue.timestamp > timestamp) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            }\\n            return values.get(end).value;\\n        }\\n        protected V getDefaultValue() {\\n            return null;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395617,
                "title": "simple-and-easy-explanation-using-binary-search",
                "content": "We will use two maps:\\n1. **keyTimestampMap**: This map will have (key, timestamp) as key and value as value.\\n2. **timestampMap**: This map will have key as key and a list of timestamps when we encountered that key as values. These values will be sorted. \\n\\n**set()**: We will add (key, timestamp) as key and value as value in keyTimestampMap.\\n    We will also add the timestamp in timestampMap[key] list.\\n\\n**get()**: We will search (key, timestamp) in keyTimestampMap, if it is there then we \\n    return the value. \\n\\t\\nIf it is not there then in that case we will use timestampMap. \\nWe will use **binary search** to find the timestamp which is the greatest smaller timestamp than the given timestamp.\\nOnce found we will use that timestamp along with the key and return the value from \\nkeyTimestampMap.\\n\\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.keyTimestampMap = {}\\n        self.timestampMap = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.keyTimestampMap[(key, timestamp)] = value\\n        self.timestampMap[key].append(timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if (key, timestamp) in self.keyTimestampMap:\\n            return self.keyTimestampMap[(key, timestamp)]\\n        \\n        #If there is no values in timestampMap[key] or given timestamp is smaller than\\n        #first value of timestampMap[key] then required timestamp wont exist. \\n        #hence return \"\".\\n        if not self.timestampMap[key] or timestamp < self.timestampMap[key][0]:\\n            return \"\"\\n        \\n        left, right = 0, len(self.timestampMap[key])\\n        timestamps = self.timestampMap[key]\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if timestamp > timestamps[mid]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        # if left == 0: \\n        #     return \"\"\\n        return self.keyTimestampMap[(key, timestamps[left-1])]\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "We will use two maps:\\n1. **keyTimestampMap**: This map will have (key, timestamp) as key and value as value.\\n2. **timestampMap**: This map will have key as key and a list of timestamps when we encountered that key as values. These values will be sorted. \\n\\n**set()**: We will add (key, timestamp) as key and value as value in keyTimestampMap.\\n    We will also add the timestamp in timestampMap[key] list.\\n\\n**get()**: We will search (key, timestamp) in keyTimestampMap, if it is there then we \\n    return the value. \\n\\t\\nIf it is not there then in that case we will use timestampMap. \\nWe will use **binary search** to find the timestamp which is the greatest smaller timestamp than the given timestamp.\\nOnce found we will use that timestamp along with the key and return the value from \\nkeyTimestampMap.\\n\\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.keyTimestampMap = {}\\n        self.timestampMap = defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.keyTimestampMap[(key, timestamp)] = value\\n        self.timestampMap[key].append(timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if (key, timestamp) in self.keyTimestampMap:\\n            return self.keyTimestampMap[(key, timestamp)]\\n        \\n        #If there is no values in timestampMap[key] or given timestamp is smaller than\\n        #first value of timestampMap[key] then required timestamp wont exist. \\n        #hence return \"\".\\n        if not self.timestampMap[key] or timestamp < self.timestampMap[key][0]:\\n            return \"\"\\n        \\n        left, right = 0, len(self.timestampMap[key])\\n        timestamps = self.timestampMap[key]\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if timestamp > timestamps[mid]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        # if left == 0: \\n        #     return \"\"\\n        return self.keyTimestampMap[(key, timestamps[left-1])]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3359410,
                "title": "easiest-rust-solution",
                "content": "\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nstruct TimeMap \\n{\\n    // [1] a regular HashMap with timestamp-supplied value\\n    //     in the form of a tuple will do the job...\\n    time_map : HashMap<String, Vec<(i32, String)>>\\n}\\n\\nimpl TimeMap \\n{\\n    fn new() -> Self \\n    {\\n        TimeMap { time_map : HashMap::new() }\\n    }\\n    \\n    fn set(&mut self, key: String, value: String, timestamp: i32) \\n    {\\n        // [2] insert new key (if not present), then add timestamped value\\n        let mut entry = self.time_map.entry(key).or_insert(Vec::new());\\n        entry.push((timestamp, value));\\n    }\\n    \\n    fn get(&self, key: String, timestamp: i32) -> String \\n    {\\n        // [3] there are several cases that we need to handle;\\n        //     Rust\\'s binary_search is perfect for that;\\n        //     a special case for i == 0 is treated explicitly\\n        if let Some(tv) = self.time_map.get(&key)\\n        {\\n            return match tv.binary_search_by_key(&timestamp, |&(t, _)| t)\\n            {\\n                Ok(i)  => tv[i].1.clone(),\\n                Err(i) => if i > 0 { tv[i-1].1.clone() } else { String::from(\"\") }\\n            }\\n        }\\n        String::from(\"\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct TimeMap \\n{\\n    // [1] a regular HashMap with timestamp-supplied value\\n    //     in the form of a tuple will do the job...\\n    time_map : HashMap<String, Vec<(i32, String)>>\\n}\\n\\nimpl TimeMap \\n{\\n    fn new() -> Self \\n    {\\n        TimeMap { time_map : HashMap::new() }\\n    }\\n    \\n    fn set(&mut self, key: String, value: String, timestamp: i32) \\n    {\\n        // [2] insert new key (if not present), then add timestamped value\\n        let mut entry = self.time_map.entry(key).or_insert(Vec::new());\\n        entry.push((timestamp, value));\\n    }\\n    \\n    fn get(&self, key: String, timestamp: i32) -> String \\n    {\\n        // [3] there are several cases that we need to handle;\\n        //     Rust\\'s binary_search is perfect for that;\\n        //     a special case for i == 0 is treated explicitly\\n        if let Some(tv) = self.time_map.get(&key)\\n        {\\n            return match tv.binary_search_by_key(&timestamp, |&(t, _)| t)\\n            {\\n                Ok(i)  => tv[i].1.clone(),\\n                Err(i) => if i > 0 { tv[i-1].1.clone() } else { String::from(\"\") }\\n            }\\n        }\\n        String::from(\"\")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3303210,
                "title": "joke-question-easy-must-see",
                "content": "# Code\\n```\\nclass TimeMap \\n{\\npublic:\\n    unordered_map<string,vector<pair<string,int>>>mp;\\n    TimeMap() \\n    {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) \\n    {\\n        mp[key].push_back({value,timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) \\n    {\\n        int start = 0;\\n        int end = mp[key].size()-1;\\n\\n        while(start <= end)\\n        {\\n            int mid = (start + end)/2;\\n            int time = mp[key][mid].second;\\n\\n            if(time == timestamp)\\n            {\\n                return mp[key][mid].first;\\n            }  \\n            else if(timestamp < time)\\n            {\\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n        if(end >=0 and end<mp[key].size())\\n        {\\n            return mp[key][end].first;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass TimeMap \\n{\\npublic:\\n    unordered_map<string,vector<pair<string,int>>>mp;\\n    TimeMap() \\n    {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) \\n    {\\n        mp[key].push_back({value,timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) \\n    {\\n        int start = 0;\\n        int end = mp[key].size()-1;\\n\\n        while(start <= end)\\n        {\\n            int mid = (start + end)/2;\\n            int time = mp[key][mid].second;\\n\\n            if(time == timestamp)\\n            {\\n                return mp[key][mid].first;\\n            }  \\n            else if(timestamp < time)\\n            {\\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n        if(end >=0 and end<mp[key].size())\\n        {\\n            return mp[key][end].first;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163382,
                "title": "beats-99-java-code",
                "content": "# Code\\n```\\nclass TimeValue {\\n    String val;\\n    int timestamp;\\n    \\n    public TimeValue(String val, int time){\\n        this.val = val;\\n        timestamp = time;\\n    }\\n}\\nclass TimeMap {\\n    Map<String, List<TimeValue>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key, k-> new ArrayList<>()).add(new TimeValue(value, timestamp));\\n    }\\n    \\n        public String get(String key, int timestamp) {\\n        List<TimeValue> list = map.getOrDefault(key, null);\\n        if(list == null) return \"\";\\n        int start = 0, end = list.size()-1;\\n        if(list.get(start).timestamp > timestamp) return \"\";\\n        if(list.get(end).timestamp <= timestamp) return list.get(end).val;\\n        while(start < end){\\n           int mid = (start + end) / 2;\\n           if(list.get(mid).timestamp == timestamp) return list.get(mid).val;\\n           if(list.get(mid).timestamp < timestamp) start = mid + 1;\\n           else end = mid - 1;\\n            \\n        }\\n        return list.get(start - 1).val;\\n        \\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass TimeValue {\\n    String val;\\n    int timestamp;\\n    \\n    public TimeValue(String val, int time){\\n        this.val = val;\\n        timestamp = time;\\n    }\\n}\\nclass TimeMap {\\n    Map<String, List<TimeValue>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key, k-> new ArrayList<>()).add(new TimeValue(value, timestamp));\\n    }\\n    \\n        public String get(String key, int timestamp) {\\n        List<TimeValue> list = map.getOrDefault(key, null);\\n        if(list == null) return \"\";\\n        int start = 0, end = list.size()-1;\\n        if(list.get(start).timestamp > timestamp) return \"\";\\n        if(list.get(end).timestamp <= timestamp) return list.get(end).val;\\n        while(start < end){\\n           int mid = (start + end) / 2;\\n           if(list.get(mid).timestamp == timestamp) return list.get(mid).val;\\n           if(list.get(mid).timestamp < timestamp) start = mid + 1;\\n           else end = mid - 1;\\n            \\n        }\\n        return list.get(start - 1).val;\\n        \\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880857,
                "title": "pure-binarysearch-no-fancy-util-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- whenever we any data which is in sorted order we always need to think about binarySearch\\n- here we can see the data we are getting by timestamp, which will always be in increasing order, so that\\'s the click.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Set() - straight forward append the data\\n- Get() - pure binary serach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSet() - O(1)\\nGet() - O(logn) - binary search\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - array\\n\\n# Code\\n```\\ntype TimeMap struct {\\n    KeyMap map[string][]Pair\\n}\\n\\ntype Pair struct {\\n    val string\\n    timeStamp int\\n}\\n\\n\\nfunc Constructor() TimeMap {\\n    return TimeMap{\\n        KeyMap: make(map[string][]Pair),\\n    }\\n}\\n\\n\\nfunc (this *TimeMap) Set(key string, value string, timestamp int)  {\\n    pairObj := Pair{\\n        val: value,\\n        timeStamp: timestamp,\\n    }\\n\\n    if _, ok := this.KeyMap[key]; !ok {\\n        this.KeyMap[key] = make([]Pair, 0)\\n    }\\n    this.KeyMap[key] = append(this.KeyMap[key], pairObj)\\n}\\n\\n\\nfunc (this *TimeMap) Get(key string, timestamp int) string {\\n    if _, ok := this.KeyMap[key]; !ok {\\n        return \"\"\\n    }\\n    arr := this.KeyMap[key]\\n    if arr[0].timeStamp > timestamp {\\n        return \"\"\\n    }\\n\\n    left := 0\\n    right := len(arr)-1\\n\\n    for left < right {\\n        mid := left + (right-left)/2\\n        if arr[mid].timeStamp == timestamp  {\\n            return arr[mid].val\\n        } else if arr[mid].timeStamp > timestamp {\\n            right = mid - 1\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    if arr[left].timeStamp > timestamp {\\n        return arr[left-1].val\\n    }\\n    return arr[left].val\\n}\\n\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Set(key,value,timestamp);\\n * param_2 := obj.Get(key,timestamp);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "String",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\ntype TimeMap struct {\\n    KeyMap map[string][]Pair\\n}\\n\\ntype Pair struct {\\n    val string\\n    timeStamp int\\n}\\n\\n\\nfunc Constructor() TimeMap {\\n    return TimeMap{\\n        KeyMap: make(map[string][]Pair),\\n    }\\n}\\n\\n\\nfunc (this *TimeMap) Set(key string, value string, timestamp int)  {\\n    pairObj := Pair{\\n        val: value,\\n        timeStamp: timestamp,\\n    }\\n\\n    if _, ok := this.KeyMap[key]; !ok {\\n        this.KeyMap[key] = make([]Pair, 0)\\n    }\\n    this.KeyMap[key] = append(this.KeyMap[key], pairObj)\\n}\\n\\n\\nfunc (this *TimeMap) Get(key string, timestamp int) string {\\n    if _, ok := this.KeyMap[key]; !ok {\\n        return \"\"\\n    }\\n    arr := this.KeyMap[key]\\n    if arr[0].timeStamp > timestamp {\\n        return \"\"\\n    }\\n\\n    left := 0\\n    right := len(arr)-1\\n\\n    for left < right {\\n        mid := left + (right-left)/2\\n        if arr[mid].timeStamp == timestamp  {\\n            return arr[mid].val\\n        } else if arr[mid].timeStamp > timestamp {\\n            right = mid - 1\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    if arr[left].timeStamp > timestamp {\\n        return arr[left-1].val\\n    }\\n    return arr[left].val\\n}\\n\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Set(key,value,timestamp);\\n * param_2 := obj.Get(key,timestamp);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2760777,
                "title": "short-solution-biinary-search-lower-bound",
                "content": "class TimeMap\\n{\\n\\n\\tpublic:\\n    map<string,set<pair<int,string>>>mp;\\n    \\n    TimeMap() {\\n       \\n    }\\n    \\n    void set(string key, string value, int timestamp)\\n    {\\n        mp[key].insert({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) \\n    {\\n        string ans = \"\";\\n        if(mp.find(key) != mp.end())\\n        {\\n            auto ind = mp[key].lower_bound({timestamp+1, \"\"});\\n            if(ind != mp[key].begin())\\n            {\\n                ind--;\\n                return ind->second;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n};\\n\\n",
                "solutionTags": [],
                "code": "class TimeMap\\n{\\n\\n\\tpublic:\\n    map<string,set<pair<int,string>>>mp;\\n    \\n    TimeMap() {\\n       \\n    }\\n    \\n    void set(string key, string value, int timestamp)\\n    {\\n        mp[key].insert({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) \\n    {\\n        string ans = \"\";\\n        if(mp.find(key) != mp.end())\\n        {\\n            auto ind = mp[key].lower_bound({timestamp+1, \"\"});\\n            if(ind != mp[key].begin())\\n            {\\n                ind--;\\n                return ind->second;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2691663,
                "title": "python-solution-bisect-binary-search-o-logn-comments",
                "content": "```\\nclass TimeMap:\\n    def __init__(self):\\n        self.store = defaultdict(list)  # key : list of [val, time]\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.store[key].append((value, timestamp))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        lst = self.store[key]\\n        if not lst: return \"\"\\n        \\n        i = bisect.bisect(lst, timestamp, key=itemgetter(1)) # pos i just after ideal candidate\\n        if not i: return \"\"  # not found time s.t time <= timestamp\\n    \\n        return lst[i-1][0]  # ideal time_prev will reside at position i-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap:\\n    def __init__(self):\\n        self.store = defaultdict(list)  # key : list of [val, time]\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.store[key].append((value, timestamp))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        lst = self.store[key]\\n        if not lst: return \"\"\\n        \\n        i = bisect.bisect(lst, timestamp, key=itemgetter(1)) # pos i just after ideal candidate\\n        if not i: return \"\"  # not found time s.t time <= timestamp\\n    \\n        return lst[i-1][0]  # ideal time_prev will reside at position i-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670904,
                "title": "time-based-key-value-store-java-binarysearch",
                "content": "* Do like and upvote if you found my solution useful \\n* We could even use Java\\'s builtin TreeMap to implement this. However, i found this approach to be more intuitive.\\n\\n```\\n\\nclass TimeMap {\\n\\n    class ValueItem {\\n        String value;\\n        int time;\\n        public ValueItem(String value,int time) {\\n            this.value = value;\\n            this.time = time;\\n        }\\n    }\\n    \\n    HashMap<String,ArrayList<ValueItem>> dataStore;\\n    \\n    private String binSearch(ArrayList<ValueItem> arr,int reqTime) {\\n        \\n        int n = arr.size();\\n        int lo = 0,hi = n-1;\\n        String valueFound = \"\";\\n        while(lo<=hi) {\\n            \\n            int mid = lo+(hi-lo)/2;\\n            \\n            ValueItem currVal = arr.get(mid);\\n            \\n            if(reqTime==currVal.time) {\\n                return currVal.value;\\n            }\\n            else if(currVal.time<reqTime) {\\n                valueFound = currVal.value;\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        return valueFound;\\n    }\\n    \\n    public TimeMap() {\\n        dataStore = new HashMap<String,ArrayList<ValueItem>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!dataStore.containsKey(key)) {\\n            dataStore.put(key,new ArrayList<ValueItem>());\\n        }\\n        \\n        dataStore.get(key).add(new ValueItem(value,timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!dataStore.containsKey(key)) {\\n            return \"\";\\n        } \\n        return binSearch(dataStore.get(key),timestamp);\\n    }\\n}\\n\\n/*\\nTIme Complexities: \\nset : O(logn)\\nget : O(1)\\n\\nSince there will be atmost x = 2*1e5 calls made to get and set. \\n\\nset - O(xlogn)\\nget - O(x)\\n\\n*/\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass TimeMap {\\n\\n    class ValueItem {\\n        String value;\\n        int time;\\n        public ValueItem(String value,int time) {\\n            this.value = value;\\n            this.time = time;\\n        }\\n    }\\n    \\n    HashMap<String,ArrayList<ValueItem>> dataStore;\\n    \\n    private String binSearch(ArrayList<ValueItem> arr,int reqTime) {\\n        \\n        int n = arr.size();\\n        int lo = 0,hi = n-1;\\n        String valueFound = \"\";\\n        while(lo<=hi) {\\n            \\n            int mid = lo+(hi-lo)/2;\\n            \\n            ValueItem currVal = arr.get(mid);\\n            \\n            if(reqTime==currVal.time) {\\n                return currVal.value;\\n            }\\n            else if(currVal.time<reqTime) {\\n                valueFound = currVal.value;\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        return valueFound;\\n    }\\n    \\n    public TimeMap() {\\n        dataStore = new HashMap<String,ArrayList<ValueItem>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!dataStore.containsKey(key)) {\\n            dataStore.put(key,new ArrayList<ValueItem>());\\n        }\\n        \\n        dataStore.get(key).add(new ValueItem(value,timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!dataStore.containsKey(key)) {\\n            return \"\";\\n        } \\n        return binSearch(dataStore.get(key),timestamp);\\n    }\\n}\\n\\n/*\\nTIme Complexities: \\nset : O(logn)\\nget : O(1)\\n\\nSince there will be atmost x = 2*1e5 calls made to get and set. \\n\\nset - O(xlogn)\\nget - O(x)\\n\\n*/\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669483,
                "title": "c-hashmap-solution",
                "content": "```\\n#define pair pair<int,string>\\nclass TimeMap {\\npublic:\\n            map<pair,string> mp;\\n\\n    TimeMap() {\\n        \\n        // create a map to store key , value and timstamp\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        mp[{timestamp,key}] = value;\\n        \\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        while(1)\\n        {\\n            if(timestamp == 0)break;\\n            if(mp.find( {timestamp,key} ) != mp.end()) return mp[{timestamp,key}];\\n            timestamp--;\\n        }\\n        return \"\";\\n        \\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n#define pair pair<int,string>\\nclass TimeMap {\\npublic:\\n            map<pair,string> mp;\\n\\n    TimeMap() {\\n        \\n        // create a map to store key , value and timstamp\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        mp[{timestamp,key}] = value;\\n        \\n    }\\n    \\n    string get(string key, int timestamp) {\\n        \\n        while(1)\\n        {\\n            if(timestamp == 0)break;\\n            if(mp.find( {timestamp,key} ) != mp.end()) return mp[{timestamp,key}];\\n            timestamp--;\\n        }\\n        return \"\";\\n        \\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669405,
                "title": "c-using-map-hashing-and-set-using-previous-smaller-element-of-a-set",
                "content": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,set<int>>mp1;\\n    unordered_map<int,string>mp2;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp1[key].insert(timestamp);\\n        mp2[timestamp]=value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp1.find(key)!=mp1.end()){\\n            auto it=mp1[key].upper_bound(timestamp);\\n            if(it==mp1[key].begin()) return \"\";\\n            int left = *--it; //previous smaller element \\n            return mp2[left];\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,set<int>>mp1;\\n    unordered_map<int,string>mp2;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp1[key].insert(timestamp);\\n        mp2[timestamp]=value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp1.find(key)!=mp1.end()){\\n            auto it=mp1[key].upper_bound(timestamp);\\n            if(it==mp1[key].begin()) return \"\";\\n            int left = *--it; //previous smaller element \\n            return mp2[left];\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669186,
                "title": "java-hashmap-treemap-concise-solution",
                "content": "```\\nclass TimeMap {\\n\\n    Map<String, TreeMap<Integer, String>> map;\\n    \\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.putIfAbsent(key, new TreeMap<Integer, String>());\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)) return \"\";\\n        /* floorEntry(K key) : Returns a key-value mapping associated with \\n            the greatest key <= the given key, or null if there is no such key. */\\n        var tm = map.get(key).floorEntry(timestamp);\\n        return tm == null ? \"\" : tm.getValue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n\\n    Map<String, TreeMap<Integer, String>> map;\\n    \\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.putIfAbsent(key, new TreeMap<Integer, String>());\\n        map.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)) return \"\";\\n        /* floorEntry(K key) : Returns a key-value mapping associated with \\n            the greatest key <= the given key, or null if there is no such key. */\\n        var tm = map.get(key).floorEntry(timestamp);\\n        return tm == null ? \"\" : tm.getValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668678,
                "title": "c-easy-to-understand-easy-explanation",
                "content": "# Intuition\\n- As the question is framed from the view of storing key , value pairs then `map becomes the most obvious choice`.\\n\\n# Approach\\n- I have explained it in the code.\\n\\n\\n# Code\\n```\\nclass TimeMap\\n{\\npublic:\\n    map<string, vector<pair<int, string>>> storage;\\n    TimeMap()\\n    {\\n        storage.clear();\\n    }\\n    void set(string key, string value, int timestamp)\\n    {\\n        storage[key].push_back({timestamp, value});\\n        // Storage is a hasmap storing timestamp and value as vector of pairs\\n        // against a timestamp\\n    }\\n    string get(string key, int timestamp)\\n    {\\n        if (storage[key].size() == 0)\\n            return \"\";\\n        // If for that key no such pair is available then we cannot get\\n        // any value\\n        int arr_len = storage[key].size();\\n        // If there is vector of pairs then there will be size also\\n        int l = 0;\\n        int h = arr_len - 1;\\n        int mid = -1;\\n        // We are using binary search to find the value pair <= timestamp\\n        while (l <= h)\\n        {\\n            mid = (l + h) / 2;\\n            if (storage[key][mid].first <= timestamp)\\n                l = mid + 1;\\n            else\\n                h = mid - 1;\\n        }\\n        if (l == 0)\\n            return \"\";\\n        return storage[key][l - 1].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass TimeMap\\n{\\npublic:\\n    map<string, vector<pair<int, string>>> storage;\\n    TimeMap()\\n    {\\n        storage.clear();\\n    }\\n    void set(string key, string value, int timestamp)\\n    {\\n        storage[key].push_back({timestamp, value});\\n        // Storage is a hasmap storing timestamp and value as vector of pairs\\n        // against a timestamp\\n    }\\n    string get(string key, int timestamp)\\n    {\\n        if (storage[key].size() == 0)\\n            return \"\";\\n        // If for that key no such pair is available then we cannot get\\n        // any value\\n        int arr_len = storage[key].size();\\n        // If there is vector of pairs then there will be size also\\n        int l = 0;\\n        int h = arr_len - 1;\\n        int mid = -1;\\n        // We are using binary search to find the value pair <= timestamp\\n        while (l <= h)\\n        {\\n            mid = (l + h) / 2;\\n            if (storage[key][mid].first <= timestamp)\\n                l = mid + 1;\\n            else\\n                h = mid - 1;\\n        }\\n        if (l == 0)\\n            return \"\";\\n        return storage[key][l - 1].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668610,
                "title": "easy-java-4-5-lines-treemap",
                "content": "**Key point:**\\n1. TreeMap floorKey will do lowerBound binary search to find the key O(Log N)\\n\\n**Code:**\\n\\n```\\nclass TimeMap {\\n    \\n    Map<String, TreeMap<Integer, String>> store;\\n\\n    public TimeMap() {\\n        store = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        store.computeIfAbsent(key, x -> new TreeMap<>()).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        Integer tmp = (store.containsKey(key)) ? store.get(key).floorKey(timestamp) : null;\\n        return (tmp != null) ? store.get(key).get(tmp) : \"\";\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    \\n    Map<String, TreeMap<Integer, String>> store;\\n\\n    public TimeMap() {\\n        store = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        store.computeIfAbsent(key, x -> new TreeMap<>()).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        Integer tmp = (store.containsKey(key)) ? store.get(key).floorKey(timestamp) : null;\\n        return (tmp != null) ? store.get(key).get(tmp) : \"\";\\n    }\\n}\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap obj = new TimeMap();\\n * obj.set(key,value,timestamp);\\n * String param_2 = obj.get(key,timestamp);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2668442,
                "title": "c-unordered-map-easy-understanding",
                "content": "# Solution\\n\\n**TLE**\\n```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, string>ump;\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        ump[key + to_string(timestamp)] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        for(int i=timestamp;i>=0;i--){\\n            if(ump[key + to_string(i)] != \"\"){\\n                return ump[key + to_string(i)];\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```\\n\\n**ACCEPTED**\\n```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, vector<pair<int, string>>>m;\\npublic:\\n    TimeMap() {}\\n\\n    void set(string key, string value, int timestamp) {\\n        m[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto it = upper_bound(begin(m[key]), end(m[key]), pair<int, string>(timestamp, \"\"), [](\\n        const pair<int, string>& a, const pair<int, string>& b) { return a.first < b.first; });\\n        return it == m[key].begin() ? \"\" : prev(it)->second;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, string>ump;\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        ump[key + to_string(timestamp)] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        for(int i=timestamp;i>=0;i--){\\n            if(ump[key + to_string(i)] != \"\"){\\n                return ump[key + to_string(i)];\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```\n```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, vector<pair<int, string>>>m;\\npublic:\\n    TimeMap() {}\\n\\n    void set(string key, string value, int timestamp) {\\n        m[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto it = upper_bound(begin(m[key]), end(m[key]), pair<int, string>(timestamp, \"\"), [](\\n        const pair<int, string>& a, const pair<int, string>& b) { return a.first < b.first; });\\n        return it == m[key].begin() ? \"\" : prev(it)->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668411,
                "title": "three-solutions-hashmap-treemap-binary-search",
                "content": "Simplest Appraoch Using HashMap\\n```\\nclass TimeMap {\\n    HashMap <String, HashMap<Integer,String>> map;\\n    public TimeMap() {\\n         map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)){\\n            map.put(key,new HashMap<>());\\n        }\\n        map.get(key).put(timestamp,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)){\\n            return \"\";\\n        }\\n        while(true){\\n            if(timestamp==0){\\n                return \"\";\\n            }\\n            if(!map.get(key).containsKey(timestamp)){\\n                timestamp--;\\n            }\\n            else{\\n                String temp=map.get(key).getOrDefault(timestamp,\"\");\\n                return temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nSimplest Using TreeMap\\n```\\nclass TimeMap {\\n    TreeMap <String, TreeMap<Integer,String>> map;\\n    public TimeMap() {\\n         map = new TreeMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)){\\n            map.put(key,new TreeMap<>());\\n        }\\n        map.get(key).put(timestamp,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)){\\n            return \"\";\\n        }\\n        Integer floor = map.get(key).floorKey(timestamp);\\n        if(floor==null) {\\n            return \"\";\\n        }\\n        return map.get(key).get(floor);\\n    }\\n}\\n```\\nSimplest Using Binary Search\\n```\\nclass Pair {\\n    int key;\\n    String value;    \\n    public Pair(String value, int key) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n}\\nclass TimeMap {\\n    HashMap <String,List<Pair>> map;\\n    public TimeMap() {\\n         map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)){\\n            map.put(key,new ArrayList<>());\\n        }\\n        map.get(key).add(new Pair(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)){\\n            return \"\";\\n        }\\n        else{\\n            return binarySearch(map.get(key), timestamp);\\n        }\\n    }\\n    public String binarySearch(List<Pair> arr,int timestamp){\\n        int low = 0, high = arr.size()-1;\\n        String result = \"\";\\n        while(low <= high){\\n           int mid = (low + high) / 2;\\n           if(arr.get(mid).key <= timestamp){\\n               result=arr.get(mid).value;\\n               low=mid+1;\\n           }\\n           else{\\n               high=mid-1;\\n           } \\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n[https://www.youtube.com/watch?v=hjXvAirvEuc&ab_channel=PIRONOBCoding](http://)",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    HashMap <String, HashMap<Integer,String>> map;\\n    public TimeMap() {\\n         map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)){\\n            map.put(key,new HashMap<>());\\n        }\\n        map.get(key).put(timestamp,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)){\\n            return \"\";\\n        }\\n        while(true){\\n            if(timestamp==0){\\n                return \"\";\\n            }\\n            if(!map.get(key).containsKey(timestamp)){\\n                timestamp--;\\n            }\\n            else{\\n                String temp=map.get(key).getOrDefault(timestamp,\"\");\\n                return temp;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass TimeMap {\\n    TreeMap <String, TreeMap<Integer,String>> map;\\n    public TimeMap() {\\n         map = new TreeMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)){\\n            map.put(key,new TreeMap<>());\\n        }\\n        map.get(key).put(timestamp,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)){\\n            return \"\";\\n        }\\n        Integer floor = map.get(key).floorKey(timestamp);\\n        if(floor==null) {\\n            return \"\";\\n        }\\n        return map.get(key).get(floor);\\n    }\\n}\\n```\n```\\nclass Pair {\\n    int key;\\n    String value;    \\n    public Pair(String value, int key) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n}\\nclass TimeMap {\\n    HashMap <String,List<Pair>> map;\\n    public TimeMap() {\\n         map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key)){\\n            map.put(key,new ArrayList<>());\\n        }\\n        map.get(key).add(new Pair(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key)){\\n            return \"\";\\n        }\\n        else{\\n            return binarySearch(map.get(key), timestamp);\\n        }\\n    }\\n    public String binarySearch(List<Pair> arr,int timestamp){\\n        int low = 0, high = arr.size()-1;\\n        String result = \"\";\\n        while(low <= high){\\n           int mid = (low + high) / 2;\\n           if(arr.get(mid).key <= timestamp){\\n               result=arr.get(mid).value;\\n               low=mid+1;\\n           }\\n           else{\\n               high=mid-1;\\n           } \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668285,
                "title": "java-easy-solution-hashmap",
                "content": "```\\nclass TimeMap {\\n    \\n    Map<String, String> hmap;\\n\\n    public TimeMap() {\\n       hmap = new HashMap<String, String>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n       hmap.put(key+timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        while(timestamp > 0) {\\n        if(hmap.containsKey(key + timestamp)) return hmap.get(key + timestamp);\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TimeMap {\\n    \\n    Map<String, String> hmap;\\n\\n    public TimeMap() {\\n       hmap = new HashMap<String, String>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n       hmap.put(key+timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        while(timestamp > 0) {\\n        if(hmap.containsKey(key + timestamp)) return hmap.get(key + timestamp);\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668085,
                "title": "rust-87-ms-fastest-100-solution-using-binary-search-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/816399786/) employs binary search for fast access to values. It demonstrated **87 ms runtime (100.00%)** and used **89.5 MB memory (43.90%)**. Time complexity for search is logarithmic: **O(logN)**. Space complexity for search is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nuse std::collections::HashMap;\\n\\nstruct TimeMap \\n{\\n    // [1] a regular HashMap with timestamp-supplied value\\n    //     in the form of a tuple will do the job...\\n    time_map : HashMap<String, Vec<(i32, String)>>\\n}\\n\\nimpl TimeMap \\n{\\n    fn new() -> Self \\n    {\\n        TimeMap { time_map : HashMap::new() }\\n    }\\n    \\n    fn set(&mut self, key: String, value: String, timestamp: i32) \\n    {\\n        // [2] insert new key (if not present), then add timestamped value\\n        let mut entry = self.time_map.entry(key).or_insert(Vec::new());\\n        entry.push((timestamp, value));\\n    }\\n    \\n    fn get(&self, key: String, timestamp: i32) -> String \\n    {\\n        // [3] there are several cases that we need to handle;\\n        //     Rust\\'s binary_search is perfect for that;\\n        //     a special case for i == 0 is treated explicitly\\n        if let Some(tv) = self.time_map.get(&key)\\n        {\\n            return match tv.binary_search_by_key(&timestamp, |&(t, _)| t)\\n            {\\n                Ok(i)  => tv[i].1.clone(),\\n                Err(i) => if i > 0 { tv[i-1].1.clone() } else { String::from(\"\") }\\n            }\\n        }\\n        String::from(\"\")\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct TimeMap \\n{\\n    // [1] a regular HashMap with timestamp-supplied value\\n    //     in the form of a tuple will do the job...\\n    time_map : HashMap<String, Vec<(i32, String)>>\\n}\\n\\nimpl TimeMap \\n{\\n    fn new() -> Self \\n    {\\n        TimeMap { time_map : HashMap::new() }\\n    }\\n    \\n    fn set(&mut self, key: String, value: String, timestamp: i32) \\n    {\\n        // [2] insert new key (if not present), then add timestamped value\\n        let mut entry = self.time_map.entry(key).or_insert(Vec::new());\\n        entry.push((timestamp, value));\\n    }\\n    \\n    fn get(&self, key: String, timestamp: i32) -> String \\n    {\\n        // [3] there are several cases that we need to handle;\\n        //     Rust\\'s binary_search is perfect for that;\\n        //     a special case for i == 0 is treated explicitly\\n        if let Some(tv) = self.time_map.get(&key)\\n        {\\n            return match tv.binary_search_by_key(&timestamp, |&(t, _)| t)\\n            {\\n                Ok(i)  => tv[i].1.clone(),\\n                Err(i) => if i > 0 { tv[i-1].1.clone() } else { String::from(\"\") }\\n            }\\n        }\\n        String::from(\"\")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668079,
                "title": "js-very-easy-solution-with-hashmap-and-array",
                "content": "![image](https://assets.leetcode.com/users/images/91fc0b9e-15b6-4bad-938c-1e06e7059acd_1665050634.7139971.png)\\n```\\n\\nvar TimeMap = function() {\\n    this.hashmap = {};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {string} value \\n * @param {number} timestamp\\n * @return {void}\\n */\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    if (!this.hashmap[key]) {\\n        this.hashmap[key] =  []; \\n    }\\n    this.hashmap[key][timestamp] = {value, timestamp};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} timestamp\\n * @return {string}\\n */\\nTimeMap.prototype.get = function(key, timestamp) {\\n    const values = this.hashmap[key];\\n    if (!values) return \"\";\\n    for (let i = timestamp; i>=1; i--) {\\n        if (values[i]) return values[i].value\\n    }\\n\\n    return \"\";\\n};\\n\\n/** \\n * Your TimeMap object will be instantiated and called as such:\\n * var obj = new TimeMap()\\n * obj.set(key,value,timestamp)\\n * var param_2 = obj.get(key,timestamp)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeMap = function() {\\n    this.hashmap = {};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {string} value \\n * @param {number} timestamp\\n * @return {void}\\n */\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    if (!this.hashmap[key]) {\\n        this.hashmap[key] =  []; \\n    }\\n    this.hashmap[key][timestamp] = {value, timestamp};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} timestamp\\n * @return {string}\\n */\\nTimeMap.prototype.get = function(key, timestamp) {\\n    const values = this.hashmap[key];\\n    if (!values) return \"\";\\n    for (let i = timestamp; i>=1; i--) {\\n        if (values[i]) return values[i].value\\n    }\\n\\n    return \"\";\\n};\\n\\n/** \\n * Your TimeMap object will be instantiated and called as such:\\n * var obj = new TimeMap()\\n * obj.set(key,value,timestamp)\\n * var param_2 = obj.get(key,timestamp)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668014,
                "title": "python-simple-99-84-faster-runtime-531-ms",
                "content": "Runtime: 531 ms, faster than 99.84%\\nMemory Usage: 73.7 MB, less than 55.47%\\n\\n\\'\\'\\'\\n\\n\\tclass TimeMap(object):\\n    def __init__(self):\\n        self.dic = defaultdict(deque)\\n\\n    def set(self, key, value, timestamp):\\n        self.dic[key].appendleft((timestamp, value))\\t#O(1) time complexity\\n\\n    def get(self, key, timestamp):\\n        if self.dic[key]:\\n            for tv in self.dic[key]:\\t#O(N) time complexity, N = len(the key)\\n                if tv[0] <= timestamp:\\n                    return tv[1]\\n        return \\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "Runtime: 531 ms, faster than 99.84%\\nMemory Usage: 73.7 MB, less than 55.47%\\n\\n\\'\\'\\'\\n\\n\\tclass TimeMap(object):\\n    def __init__(self):\\n        self.dic = defaultdict(deque)\\n\\n    def set(self, key, value, timestamp):\\n        self.dic[key].appendleft((timestamp, value))\\t#O(1) time complexity\\n\\n    def get(self, key, timestamp):\\n        if self.dic[key]:\\n            for tv in self.dic[key]:\\t#O(N) time complexity, N = len(the key)\\n                if tv[0] <= timestamp:\\n                    return tv[1]\\n        return \\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2667668,
                "title": "small-code-two-maps",
                "content": "class TimeMap {\\npublic:\\n\\n    unordered_map<string,unordered_map<int,string>>mp;\\n    TimeMap() {\\n        \\n    }\\n    void set(string key, string value, int timestamp) {\\n        mp[key][timestamp]=value;\\n    }\\n    string get(string key, int timestamp) {\\n        for(int i=timestamp;i>=1;i--)\\n        {\\n            if(mp[key].find(i)!=mp[key].end())\\n                return mp[key][i];\\n        }\\n        return \"\";\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class TimeMap {\\npublic:\\n\\n    unordered_map<string,unordered_map<int,string>>mp;\\n    TimeMap() {\\n        \\n    }\\n    void set(string key, string value, int timestamp) {\\n        mp[key][timestamp]=value;\\n    }\\n    string get(string key, int timestamp) {\\n        for(int i=timestamp;i>=1;i--)\\n        {\\n            if(mp[key].find(i)!=mp[key].end())\\n                return mp[key][i];\\n        }\\n        return \"\";\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2667500,
                "title": "c-3-solutions-map-upper-bound-binary-search-easy-clean-code",
                "content": "**1. Single Map**\\n```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,map<int,string>> m;\\n    \\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int time) {\\n        m[key][time]=value;\\n    }\\n    \\n    string get(string key, int time) {\\n\\n        auto it=m[key].upper_bound(time);\\n        \\n        if(it==m[key].begin())\\n            return \"\";\\n        \\n        it--;\\n        return it->second;\\n    }\\n};\\n```\\n\\n**2. 2 Maps**\\n```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,vector<string>> m1;\\n    unordered_map<string,vector<int>> m2;\\n    \\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int time) {\\n        m1[key].push_back(value);\\n        m2[key].push_back(time);\\n    }\\n    \\n    string get(string key, int time) {\\n\\n        int in=upper_bound(m2[key].begin(),m2[key].end(),time)-m2[key].begin();\\n        \\n        if(in==0)\\n            return \"\";\\n        \\n        return m1[key][in-1];\\n    }\\n};\\n```\\n\\n**3. 2 Maps**\\n\\n```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,vector<int>> kt;  //key-timestamps\\n    unordered_map<string,unordered_map<int,string>> ktv;    //key-(timestamps,value)\\n    \\n    TimeMap() {}\\n    \\n    int bin_search(vector<int> &a,int t)\\n    {\\n        int l=0,h=a.size()-1;\\n        int ans=-1;\\n        \\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            \\n            if(a[mid]==t)\\n                return t;\\n            \\n            if(a[mid]<t)\\n            {\\n                ans=a[mid];\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        kt[key].push_back(timestamp);\\n        ktv[key][timestamp]=value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        int t=bin_search(kt[key],timestamp);\\n        return ktv[key][t];\\n    }\\n};\\n```\\n\\n**Do share your views & upvote if you like !!!** \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,map<int,string>> m;\\n    \\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int time) {\\n        m[key][time]=value;\\n    }\\n    \\n    string get(string key, int time) {\\n\\n        auto it=m[key].upper_bound(time);\\n        \\n        if(it==m[key].begin())\\n            return \"\";\\n        \\n        it--;\\n        return it->second;\\n    }\\n};\\n```\n```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,vector<string>> m1;\\n    unordered_map<string,vector<int>> m2;\\n    \\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int time) {\\n        m1[key].push_back(value);\\n        m2[key].push_back(time);\\n    }\\n    \\n    string get(string key, int time) {\\n\\n        int in=upper_bound(m2[key].begin(),m2[key].end(),time)-m2[key].begin();\\n        \\n        if(in==0)\\n            return \"\";\\n        \\n        return m1[key][in-1];\\n    }\\n};\\n```\n```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,vector<int>> kt;  //key-timestamps\\n    unordered_map<string,unordered_map<int,string>> ktv;    //key-(timestamps,value)\\n    \\n    TimeMap() {}\\n    \\n    int bin_search(vector<int> &a,int t)\\n    {\\n        int l=0,h=a.size()-1;\\n        int ans=-1;\\n        \\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            \\n            if(a[mid]==t)\\n                return t;\\n            \\n            if(a[mid]<t)\\n            {\\n                ans=a[mid];\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        kt[key].push_back(timestamp);\\n        ktv[key][timestamp]=value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        int t=bin_search(kt[key],timestamp);\\n        return ktv[key][t];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667357,
                "title": "java-100-125-ms-three-solutions-w-video-explanation",
                "content": "*Please **Upvote** if you find this explanation helpful*\\n\\n**Video Explanation**\\n[Time Based Key-Value Store | YouTube](https://www.youtube.com/watch?v=X7nSJYcBIMg&feature=youtu.be)\\n\\n**Java Solution**\\n```\\n//TreeMap Based\\npublic class TimeMap {\\n\\n    private static final String EMPTY_STR = \"\";\\n    Map<String, TreeMap<Integer, String>> map;\\n\\t\\n\\tpublic TimeMap() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key, k -> new TreeMap<>()).put(timestamp, value);\\n    }\\n\\n    public String get(String key, int timestamp) {\\n        if (!map.containsKey(key)) return EMPTY_STR;\\n        Map.Entry<Integer, String> e = map.get(key).floorEntry(timestamp);\\n        return e != null ? e.getValue() : EMPTY_STR;\\n    }\\n}\\n```\\n\\n```\\n//Using nested HashMap\\nclass TimeMap {\\n    HashMap<String, HashMap<Integer, String>> keyTimeMap;\\n    public TimeMap() {\\n        keyTimeMap = new HashMap<String, HashMap<Integer, String>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if (!keyTimeMap.containsKey(key)) {\\n            keyTimeMap.put(key, new HashMap<Integer, String>());\\n        }\\n        \\n        keyTimeMap.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (!keyTimeMap.containsKey(key)) {\\n            return \"\";\\n        }\\n        \\n        for (int currTime = timestamp; currTime >= 1; --currTime) {\\n            if (keyTimeMap.get(key).containsKey(currTime)) {\\n                return keyTimeMap.get(key).get(currTime);\\n            }\\n        }\\n        return \"\"; \\n    }\\n}\\n```\\n\\n\\n```\\n//125ms\\n//Unsing a different Class\\nclass TimeValue{\\n    String val;\\n    int timestamp;\\n    \\n    public TimeValue(String val, int time){\\n        this.val = val;\\n        timestamp = time;\\n    }\\n}\\n\\nclass TimeMap {\\n\\n    Map<String,List<TimeValue>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key,k->new ArrayList<>()).add(new TimeValue(value,timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        List<TimeValue> list = map.getOrDefault(key,null);\\n        if(list == null)\\n            return \"\";\\n        int low=0,high = list.size()-1;\\n        if(list.get(low).timestamp > timestamp)\\n            return \"\";\\n        if(list.get(high).timestamp <= timestamp)\\n            return list.get(high).val;\\n        \\n        while(low<high){\\n            int mid = (low + high)/2;\\n            if(list.get(mid).timestamp == timestamp)\\n                return list.get(mid).val;\\n            else if(list.get(mid).timestamp < timestamp)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        return list.get(low-1).val;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n//TreeMap Based\\npublic class TimeMap {\\n\\n    private static final String EMPTY_STR = \"\";\\n    Map<String, TreeMap<Integer, String>> map;\\n\\t\\n\\tpublic TimeMap() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key, k -> new TreeMap<>()).put(timestamp, value);\\n    }\\n\\n    public String get(String key, int timestamp) {\\n        if (!map.containsKey(key)) return EMPTY_STR;\\n        Map.Entry<Integer, String> e = map.get(key).floorEntry(timestamp);\\n        return e != null ? e.getValue() : EMPTY_STR;\\n    }\\n}\\n```\n```\\n//Using nested HashMap\\nclass TimeMap {\\n    HashMap<String, HashMap<Integer, String>> keyTimeMap;\\n    public TimeMap() {\\n        keyTimeMap = new HashMap<String, HashMap<Integer, String>>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if (!keyTimeMap.containsKey(key)) {\\n            keyTimeMap.put(key, new HashMap<Integer, String>());\\n        }\\n        \\n        keyTimeMap.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if (!keyTimeMap.containsKey(key)) {\\n            return \"\";\\n        }\\n        \\n        for (int currTime = timestamp; currTime >= 1; --currTime) {\\n            if (keyTimeMap.get(key).containsKey(currTime)) {\\n                return keyTimeMap.get(key).get(currTime);\\n            }\\n        }\\n        return \"\"; \\n    }\\n}\\n```\n```\\n//125ms\\n//Unsing a different Class\\nclass TimeValue{\\n    String val;\\n    int timestamp;\\n    \\n    public TimeValue(String val, int time){\\n        this.val = val;\\n        timestamp = time;\\n    }\\n}\\n\\nclass TimeMap {\\n\\n    Map<String,List<TimeValue>> map;\\n    public TimeMap() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        map.computeIfAbsent(key,k->new ArrayList<>()).add(new TimeValue(value,timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        List<TimeValue> list = map.getOrDefault(key,null);\\n        if(list == null)\\n            return \"\";\\n        int low=0,high = list.size()-1;\\n        if(list.get(low).timestamp > timestamp)\\n            return \"\";\\n        if(list.get(high).timestamp <= timestamp)\\n            return list.get(high).val;\\n        \\n        while(low<high){\\n            int mid = (low + high)/2;\\n            if(list.get(mid).timestamp == timestamp)\\n                return list.get(mid).val;\\n            else if(list.get(mid).timestamp < timestamp)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        return list.get(low-1).val;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667141,
                "title": "easy-c-unordered-map-binary-search-o-1-o-logn",
                "content": "# :)\\n**Time Complexity :**\\n* set() => O(1) ,  values can be inserted in unordered_map in O(1) time. + also, values can be appended in vector in O(1) time.\\n* get() => O(logn),  using binary-search to search for the timestamp in map[vector] which is equal to given targetted timestamp or just less than that.\\n\\n**Space Complexity :**\\n* O(n) : for storing all given data in unordered_map.\\n\\n```\\nclass TimeMap {\\npublic:\\n\\t\\tunordered_map<string, vector<pair<int,string>> > mp;  // mp[key] = {[timestamp, value]};\\n    \\n    TimeMap() {  }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key) == mp.end())    return \"\";\\n        else if(mp[key][0].first > timestamp)   return \"\";\\n        else{\\n            int n = mp[key].size();\\n            int low = 0, high = n-1;\\n            int resPos = -1;\\n            \\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                int ts = mp[key][mid].first;        // timestamp of mid position\\n\\n                if(ts>timestamp) high = mid-1;        // midVal > targetVal\\n                else resPos = mid, low = mid+1;        // midVal <= targetVal\\n            }\\n            \\n            return resPos == -1 ? \"\" : mp[key][resPos].second;\\n        }\\n    }\\n};\\n\\n```\\n\\n# :)\\n**If found useful, do upvote...**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n\\t\\tunordered_map<string, vector<pair<int,string>> > mp;  // mp[key] = {[timestamp, value]};\\n    \\n    TimeMap() {  }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp, value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key) == mp.end())    return \"\";\\n        else if(mp[key][0].first > timestamp)   return \"\";\\n        else{\\n            int n = mp[key].size();\\n            int low = 0, high = n-1;\\n            int resPos = -1;\\n            \\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                int ts = mp[key][mid].first;        // timestamp of mid position\\n\\n                if(ts>timestamp) high = mid-1;        // midVal > targetVal\\n                else resPos = mid, low = mid+1;        // midVal <= targetVal\\n            }\\n            \\n            return resPos == -1 ? \"\" : mp[key][resPos].second;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667116,
                "title": "simple-hashmap-solution",
                "content": "\\n\\n# Approach\\n HashMap\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Data{\\n    String val;\\n    int time;\\n    Data(String val,  int time){\\n        this.val= val;\\n        this.time=time;\\n    }\\n}\\n\\nclass TimeMap {\\n\\n    Map<String, List<Data>> map;\\n\\n    public TimeMap() {\\n        map=new HashMap<>();    \\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key))\\n            map.put(key, new ArrayList<Data>());\\n        map.get(key).add(new Data(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key))\\n            return \"\";\\n        return binarySearch(map.get(key), timestamp);\\n    }\\n\\n    public String binarySearch(List<Data> data, int timeStamp){\\n            int low=0,high= data.size() -1;\\n\\n            while(low<high){\\n                int mid=(low+high) >> 1;\\n                if(data.get(mid).time == timeStamp)\\n                    return data.get(mid).val;\\n                if(timeStamp< data.get(mid).time){\\n                    high=mid-1;\\n                }\\n                else{\\n                    if(data.get(mid+1).time > timeStamp)\\n                        return data.get(mid).val;\\n                    low=mid+1;\\n                }\\n            }\\n            //Returns a value such that set was called previously, with timestamp_prev <= timestamp\\n            return data.get(low).time <= timeStamp ? data.get(low).val : \"\" ;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "\\n\\n# Approach\\n HashMap\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Data{\\n    String val;\\n    int time;\\n    Data(String val,  int time){\\n        this.val= val;\\n        this.time=time;\\n    }\\n}\\n\\nclass TimeMap {\\n\\n    Map<String, List<Data>> map;\\n\\n    public TimeMap() {\\n        map=new HashMap<>();    \\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!map.containsKey(key))\\n            map.put(key, new ArrayList<Data>());\\n        map.get(key).add(new Data(value, timestamp));\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!map.containsKey(key))\\n            return \"\";\\n        return binarySearch(map.get(key), timestamp);\\n    }\\n\\n    public String binarySearch(List<Data> data, int timeStamp){\\n            int low=0,high= data.size() -1;\\n\\n            while(low<high){\\n                int mid=(low+high) >> 1;\\n                if(data.get(mid).time == timeStamp)\\n                    return data.get(mid).val;\\n                if(timeStamp< data.get(mid).time){\\n                    high=mid-1;\\n                }\\n                else{\\n                    if(data.get(mid+1).time > timeStamp)\\n                        return data.get(mid).val;\\n                    low=mid+1;\\n                }\\n            }\\n            //Returns a value such that set was called previously, with timestamp_prev <= timestamp\\n            return data.get(low).time <= timeStamp ? data.get(low).val : \"\" ;\\n    }\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2667067,
                "title": "python-solution-for-easy-understanding",
                "content": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.store=dict()\\n        \\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.store[(key,timestamp)]=value\\n        \\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        temp=timestamp\\n        while temp>0:\\n            if (key,temp) in self.store:\\n                return self.store[(key,temp)]\\n            temp-=1\\n        return \"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.store=dict()\\n        \\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.store[(key,timestamp)]=value\\n        \\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        temp=timestamp\\n        while temp>0:\\n            if (key,temp) in self.store:\\n                return self.store[(key,temp)]\\n            temp-=1\\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667052,
                "title": "solution-in-python-using-dictionary-and-tuples",
                "content": "# Intuition\\nSolution in Python using dictionary and tuples!\\n\\n# Approach\\nIn Dictionary, used key and timestamp tuple as key in and value as value\\n\\n# Complexity\\n- Time complexity:\\nO[timestamp] as I\\'m itterating from timestamp to 0\\n\\n\\n# Code\\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.head = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        llist = (key, timestamp)\\n        self.head[llist] = value\\n    def get(self, key: str, timestamp: int) -> str:\\n        while timestamp >= 0:\\n            llist = (key, timestamp)\\n            try:\\n                return self.head[llist]\\n            except:\\n                timestamp -= 1\\n        #print(self.head)\\n        #print(hhead)\\n        \\n        return \"\"\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.head = {}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        llist = (key, timestamp)\\n        self.head[llist] = value\\n    def get(self, key: str, timestamp: int) -> str:\\n        while timestamp >= 0:\\n            llist = (key, timestamp)\\n            try:\\n                return self.head[llist]\\n            except:\\n                timestamp -= 1\\n        #print(self.head)\\n        #print(hhead)\\n        \\n        return \"\"\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666866,
                "title": "easy-c-solution-hashing-binary-search",
                "content": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,vector<pair<int,string>>> mb;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mb[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        string ans = \"\";\\n        pair<int, string> p = make_pair(timestamp, \"\");\\n\\t\\tauto it = lower_bound(mb[key].begin(), mb[key].end(), p);\\n        if(it-mb[key].begin()<mb[key].size()){\\n            if(it==mb[key].begin() and (*it).first == timestamp){\\n                ans = (*it).second;\\n            }\\n            else if(it-mb[key].begin()>0){\\n                if((*it).first == timestamp){\\n                    ans=(*it).second;\\n                }\\n                else{\\n                   it--;\\n                    ans = (*it).second; \\n                }\\n                \\n            }\\n        }\\n        else{\\n            if(mb[key].size()){\\n                it--;\\n                ans = (*it).second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string,vector<pair<int,string>>> mb;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mb[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        string ans = \"\";\\n        pair<int, string> p = make_pair(timestamp, \"\");\\n\\t\\tauto it = lower_bound(mb[key].begin(), mb[key].end(), p);\\n        if(it-mb[key].begin()<mb[key].size()){\\n            if(it==mb[key].begin() and (*it).first == timestamp){\\n                ans = (*it).second;\\n            }\\n            else if(it-mb[key].begin()>0){\\n                if((*it).first == timestamp){\\n                    ans=(*it).second;\\n                }\\n                else{\\n                   it--;\\n                    ans = (*it).second; \\n                }\\n                \\n            }\\n        }\\n        else{\\n            if(mb[key].size()){\\n                it--;\\n                ans = (*it).second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666856,
                "title": "javascript",
                "content": "# Code\\n```\\nvar TimeMap = function() {\\n    this.map = {};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {string} value \\n * @param {number} timestamp\\n * @return {void}\\n */\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    var combinedKey = `${key}${timestamp}`;\\n    this.map[combinedKey] = value;\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} timestamp\\n * @return {string}\\n */\\nTimeMap.prototype.get = function(key, timestamp) {\\n    while (timestamp > 0) {\\n        var combinedKey = `${key}${timestamp}`;\\n        if (combinedKey in this.map) return this.map[combinedKey];\\n        timestamp -= 1;\\n    }\\n    return \\'\\';\\n};\\n\\n/** \\n * Your TimeMap object will be instantiated and called as such:\\n * var obj = new TimeMap()\\n * obj.set(key,value,timestamp)\\n * var param_2 = obj.get(key,timestamp)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeMap = function() {\\n    this.map = {};\\n};\\n\\n/** \\n * @param {string} key \\n * @param {string} value \\n * @param {number} timestamp\\n * @return {void}\\n */\\nTimeMap.prototype.set = function(key, value, timestamp) {\\n    var combinedKey = `${key}${timestamp}`;\\n    this.map[combinedKey] = value;\\n};\\n\\n/** \\n * @param {string} key \\n * @param {number} timestamp\\n * @return {string}\\n */\\nTimeMap.prototype.get = function(key, timestamp) {\\n    while (timestamp > 0) {\\n        var combinedKey = `${key}${timestamp}`;\\n        if (combinedKey in this.map) return this.map[combinedKey];\\n        timestamp -= 1;\\n    }\\n    return \\'\\';\\n};\\n\\n/** \\n * Your TimeMap object will be instantiated and called as such:\\n * var obj = new TimeMap()\\n * obj.set(key,value,timestamp)\\n * var param_2 = obj.get(key,timestamp)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2666787,
                "title": "python-accepted",
                "content": "Screenshot :\\n![image](https://assets.leetcode.com/users/images/50c6bcfd-6522-4fac-b476-a3de18322bb6_1665026101.9689121.png)\\n\\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.cur_dict={}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        if not key in self.cur_dict:\\n            self.cur_dict[key]=[\"\"]\\n        self.cur_dict[key].append([value,timestamp])\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.cur_dict:\\n            return \"\"\\n        for i in range(len(self.cur_dict[key])-1,-1,-1):\\n            if self.cur_dict[key][i]==\"\":\\n                return \"\"\\n            x,y = self.cur_dict[key][i]\\n            if y<=timestamp:\\n                return x\\n        \\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```\\n\\nRuntime: 693 ms, faster than 97.24% of Python3 online submissions for Time Based Key-Value Store.\\nMemory Usage: 71.9 MB, less than 52.27% of Python3 online submissions for Time Based Key-Value Store.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.cur_dict={}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        if not key in self.cur_dict:\\n            self.cur_dict[key]=[\"\"]\\n        self.cur_dict[key].append([value,timestamp])\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.cur_dict:\\n            return \"\"\\n        for i in range(len(self.cur_dict[key])-1,-1,-1):\\n            if self.cur_dict[key][i]==\"\":\\n                return \"\"\\n            x,y = self.cur_dict[key][i]\\n            if y<=timestamp:\\n                return x\\n        \\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666683,
                "title": "easy-python-solution-faster-than-92",
                "content": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.dict = defaultdict(list)\\n        \\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.dict[key].append([value,timestamp])\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.dict:\\n            return \"\"\\n        result = \"\"\\n        values = self.dict.get(key)\\n        left,right=0,len(values)-1\\n        while(left<=right):\\n            mid = (left+right)//2\\n            if values[mid][1] <= timestamp:\\n                result = values[mid][0]\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return result\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.dict = defaultdict(list)\\n        \\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.dict[key].append([value,timestamp])\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.dict:\\n            return \"\"\\n        result = \"\"\\n        values = self.dict.get(key)\\n        left,right=0,len(values)-1\\n        while(left<=right):\\n            mid = (left+right)//2\\n            if values[mid][1] <= timestamp:\\n                result = values[mid][0]\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666634,
                "title": "c-binary-search-and-map-solution",
                "content": "**Binary search:**\\n```\\nclass TimeMap {\\npublic:\\n    map<string,vector<pair<int,string>>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        int len = mp[key].size();\\n        int low = 0,high = len-1;\\n        string ans;\\n        while(low <=high){\\n            int mid = low + (high-low)/2;\\n            if(mp[key][mid].first == timestamp){\\n                return mp[key][mid].second;\\n            }else if(mp[key][mid].first < timestamp){\\n                ans = mp[key][mid].second;\\n                low = mid+1;\\n            }else high = mid-1;\\n        };\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```\\n\\n**Map:**\\n```\\nclass TimeMap {\\npublic:\\n     map<string, map<int, string>> mp;\\n    TimeMap(){}\\n    void set(string key, string value, int timestamp) {\\n        mp[key].insert({timestamp,value});\\n    }\\n    string get(string key, int timestamp) {\\n        auto ptr = mp[key].upper_bound(timestamp);\\n        return ptr == mp[key].begin()? \"\":prev(ptr)->second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n ```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    map<string,vector<pair<int,string>>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back({timestamp,value});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        int len = mp[key].size();\\n        int low = 0,high = len-1;\\n        string ans;\\n        while(low <=high){\\n            int mid = low + (high-low)/2;\\n            if(mp[key][mid].first == timestamp){\\n                return mp[key][mid].second;\\n            }else if(mp[key][mid].first < timestamp){\\n                ans = mp[key][mid].second;\\n                low = mid+1;\\n            }else high = mid-1;\\n        };\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```\n```\\nclass TimeMap {\\npublic:\\n     map<string, map<int, string>> mp;\\n    TimeMap(){}\\n    void set(string key, string value, int timestamp) {\\n        mp[key].insert({timestamp,value});\\n    }\\n    string get(string key, int timestamp) {\\n        auto ptr = mp[key].upper_bound(timestamp);\\n        return ptr == mp[key].begin()? \"\":prev(ptr)->second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2666551,
                "title": "easiest-java-solution-using-treemap",
                "content": "```\\nclass TimeMap {\\n    HashMap<String, TreeMap<Integer, String>> map;\\n    public TimeMap() {\\n        map = new HashMap();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        TreeMap<Integer, String> temp = map.getOrDefault(key, new TreeMap<Integer, String>());\\n        temp.put(timestamp, value);\\n        map.put(key, temp);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer, String> keyMap = map.get(key);\\n        if (keyMap == null) return \"\";\\n        Map.Entry<Integer,String> entry = keyMap.floorEntry(timestamp);\\n        if (entry == null) return \"\";\\n        return entry.getValue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    HashMap<String, TreeMap<Integer, String>> map;\\n    public TimeMap() {\\n        map = new HashMap();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        TreeMap<Integer, String> temp = map.getOrDefault(key, new TreeMap<Integer, String>());\\n        temp.put(timestamp, value);\\n        map.put(key, temp);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        TreeMap<Integer, String> keyMap = map.get(key);\\n        if (keyMap == null) return \"\";\\n        Map.Entry<Integer,String> entry = keyMap.floorEntry(timestamp);\\n        if (entry == null) return \"\";\\n        return entry.getValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666535,
                "title": "java-3-liner-hash-and-tree-maps",
                "content": "**Idea:** Use a hashmap of key to a sorted map, of timestamp to value, to store the values in ascending order of timestamps\\n>T/S: O(m lg m)/O(m), where m = size(timemap)\\n>*constructor:* O(1)/O(1)\\n>*set:* O(lg n)/O(1), where n = size of timemap at this call\\n>*get:* O(lg n)/O(1)\\n```\\nclass TimeMap {\\n\\n\\tprivate final Map<String, TreeMap<Integer, String>> timemap = new HashMap<>();\\n\\n\\t/**\\n\\t * Initializes the object of the data structure.\\n\\t */\\n\\tpublic TimeMap() {}\\n\\n\\t/**\\n\\t * Stores the key = key with the value = value at the given time timestamp.\\n\\t */\\n\\tpublic void set(String key, String value, int timestamp) {\\n\\t\\ttimemap.computeIfAbsent(key, k -> new TreeMap<>())\\n\\t\\t\\t   .put(timestamp, value);\\n\\t}\\n\\n\\t/**\\n\\t * @return a value such that set was called previously, with timestamp_prev <= timestamp.\\n\\t * If there are multiple such values, it returns the value associated with the largest timestamp_prev.\\n\\t * If there are no values, it returns \"\"\\n\\t */\\n\\tpublic String get(String key, int timestamp) {\\n\\t\\treturn timemap.containsKey(key) && timemap.get(key).floorEntry(timestamp) != null \\n\\t\\t\\t ? timemap.get(key).floorEntry(timestamp).getValue() \\n\\t\\t\\t : \"\";\\n\\t}\\n}\\n```\\nAnother way of writing the *get* method\\n```\\npublic String get(String key, int timestamp) {\\n\\tvar values = timemap.get(key);\\n\\tif (values == null)\\n\\t\\treturn \"\";\\n\\n\\tvar floorKey = values.floorKey(timestamp);\\n\\tif (floorKey == null)\\n\\t\\treturn \"\";\\n\\n\\treturn values.get(floorKey);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TimeMap {\\n\\n\\tprivate final Map<String, TreeMap<Integer, String>> timemap = new HashMap<>();\\n\\n\\t/**\\n\\t * Initializes the object of the data structure.\\n\\t */\\n\\tpublic TimeMap() {}\\n\\n\\t/**\\n\\t * Stores the key = key with the value = value at the given time timestamp.\\n\\t */\\n\\tpublic void set(String key, String value, int timestamp) {\\n\\t\\ttimemap.computeIfAbsent(key, k -> new TreeMap<>())\\n\\t\\t\\t   .put(timestamp, value);\\n\\t}\\n\\n\\t/**\\n\\t * @return a value such that set was called previously, with timestamp_prev <= timestamp.\\n\\t * If there are multiple such values, it returns the value associated with the largest timestamp_prev.\\n\\t * If there are no values, it returns \"\"\\n\\t */\\n\\tpublic String get(String key, int timestamp) {\\n\\t\\treturn timemap.containsKey(key) && timemap.get(key).floorEntry(timestamp) != null \\n\\t\\t\\t ? timemap.get(key).floorEntry(timestamp).getValue() \\n\\t\\t\\t : \"\";\\n\\t}\\n}\\n```\n```\\npublic String get(String key, int timestamp) {\\n\\tvar values = timemap.get(key);\\n\\tif (values == null)\\n\\t\\treturn \"\";\\n\\n\\tvar floorKey = values.floorKey(timestamp);\\n\\tif (floorKey == null)\\n\\t\\treturn \"\";\\n\\n\\treturn values.get(floorKey);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610682,
                "title": "rust-three-solutions-hashmap-btreemap-hashmap-binarysearch-btreemap-only",
                "content": "If you like my solutions, you should check out [my github repo](https://github.com/SvetlinZarev/coding-challenges/tree/main/leetcode)\\n\\n\\n### HashMap + BTreeMap\\n\\n```rust\\nuse std::collections::{BTreeMap, HashMap};\\n\\n#[derive(Default)]\\nstruct TimeMap {\\n    map: HashMap<String, BTreeMap<i32, String>>,\\n}\\n\\nimpl TimeMap {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\\n        self.map.entry(key).or_default().insert(timestamp, value);\\n    }\\n\\n    fn get(&self, key: String, timestamp: i32) -> String {\\n        self.map\\n            .get(&key)\\n            .and_then(|tree| {\\n                tree.range(0..=timestamp)\\n                    .next_back()\\n                    .map(|(_, v)| v.clone())\\n            })\\n            .unwrap_or_else(|| String::new())\\n    }\\n}\\n```\\n\\n### HashMap + Vec & BinarySearch\\n\\nWe can take advantage that all timestamps are strictly increasing (i.e. no equal\\ntimestamps). This will allow us to use an ordinary vector to store them, and\\nthen we can just do a binary search to find the correct one.\\n\\n```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Default)]\\nstruct TimeMap {\\n    map: HashMap<String, Vec<(i32, String)>>,\\n}\\n\\nimpl TimeMap {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\\n        self.map.entry(key).or_default().push((timestamp, value));\\n    }\\n\\n    fn get(&self, key: String, timestamp: i32) -> String {\\n        self.map\\n            .get(&key)\\n            .and_then(\\n                |values| match values.binary_search_by_key(&timestamp, |x| x.0) {\\n                    // we have an exact match fo the timestamp\\n                    Ok(idx) => Some(values[idx].1.as_str()),\\n                    // There is no smaller timestamp than ours, thus there is no value to return\\n                    Err(idx) if idx == 0 => Some(\"\"),\\n                    // Return thr largest timestamp smaller than ours\\n                    Err(idx) => Some(values[idx - 1].1.as_str()),\\n                },\\n            )\\n            .map(|val| val.to_owned())\\n            .unwrap_or_else(|| String::new())\\n    }\\n}\\n```\\n\\n### BTreeMap only\\n\\nWe can implement a custom key for the tree-map and directly access the element\\nwe need\\n\\n```rust\\nuse std::borrow::Cow;\\nuse std::collections::BTreeMap;\\nuse std::ops::{Bound, RangeInclusive};\\n\\n#[derive(Eq, PartialEq, Ord, PartialOrd)]\\nstruct Key<\\'l> {\\n    key: Cow<\\'l, str>,\\n    time: i32,\\n}\\n\\nimpl<\\'l> Key<\\'l> {\\n    pub fn owned(key: String, timestamp: i32) -> Self {\\n        Self {\\n            key: Cow::Owned(key),\\n            time: timestamp,\\n        }\\n    }\\n\\n    pub fn borrowed(key: &\\'l str, timestamp: i32) -> Self {\\n        Self {\\n            key: Cow::Borrowed(key),\\n            time: timestamp,\\n        }\\n    }\\n}\\n\\nstruct TimeMap<\\'l> {\\n    inner: BTreeMap<Key<\\'l>, String>,\\n}\\n\\nimpl<\\'l> TimeMap<\\'l> {\\n    fn new() -> Self {\\n        Self {\\n            inner: BTreeMap::new(),\\n        }\\n    }\\n\\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\\n        self.inner.insert(Key::owned(key, timestamp), value);\\n    }\\n\\n    fn get(&self, key: String, timestamp: i32) -> String {\\n        let r = (\\n            Bound::Included(Key::borrowed(key.as_str(), 0)),\\n            Bound::Included(Key::borrowed(key.as_str(), timestamp)),\\n        );\\n\\n        self.inner\\n            .range(r)\\n            .next_back()\\n            .map(|(_, val)| val.clone())\\n            .unwrap_or_else(|| String::new())\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rust\\nuse std::collections::{BTreeMap, HashMap};\\n\\n#[derive(Default)]\\nstruct TimeMap {\\n    map: HashMap<String, BTreeMap<i32, String>>,\\n}\\n\\nimpl TimeMap {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\\n        self.map.entry(key).or_default().insert(timestamp, value);\\n    }\\n\\n    fn get(&self, key: String, timestamp: i32) -> String {\\n        self.map\\n            .get(&key)\\n            .and_then(|tree| {\\n                tree.range(0..=timestamp)\\n                    .next_back()\\n                    .map(|(_, v)| v.clone())\\n            })\\n            .unwrap_or_else(|| String::new())\\n    }\\n}\\n```\n```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Default)]\\nstruct TimeMap {\\n    map: HashMap<String, Vec<(i32, String)>>,\\n}\\n\\nimpl TimeMap {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\\n        self.map.entry(key).or_default().push((timestamp, value));\\n    }\\n\\n    fn get(&self, key: String, timestamp: i32) -> String {\\n        self.map\\n            .get(&key)\\n            .and_then(\\n                |values| match values.binary_search_by_key(&timestamp, |x| x.0) {\\n                    // we have an exact match fo the timestamp\\n                    Ok(idx) => Some(values[idx].1.as_str()),\\n                    // There is no smaller timestamp than ours, thus there is no value to return\\n                    Err(idx) if idx == 0 => Some(\"\"),\\n                    // Return thr largest timestamp smaller than ours\\n                    Err(idx) => Some(values[idx - 1].1.as_str()),\\n                },\\n            )\\n            .map(|val| val.to_owned())\\n            .unwrap_or_else(|| String::new())\\n    }\\n}\\n```\n```rust\\nuse std::borrow::Cow;\\nuse std::collections::BTreeMap;\\nuse std::ops::{Bound, RangeInclusive};\\n\\n#[derive(Eq, PartialEq, Ord, PartialOrd)]\\nstruct Key<\\'l> {\\n    key: Cow<\\'l, str>,\\n    time: i32,\\n}\\n\\nimpl<\\'l> Key<\\'l> {\\n    pub fn owned(key: String, timestamp: i32) -> Self {\\n        Self {\\n            key: Cow::Owned(key),\\n            time: timestamp,\\n        }\\n    }\\n\\n    pub fn borrowed(key: &\\'l str, timestamp: i32) -> Self {\\n        Self {\\n            key: Cow::Borrowed(key),\\n            time: timestamp,\\n        }\\n    }\\n}\\n\\nstruct TimeMap<\\'l> {\\n    inner: BTreeMap<Key<\\'l>, String>,\\n}\\n\\nimpl<\\'l> TimeMap<\\'l> {\\n    fn new() -> Self {\\n        Self {\\n            inner: BTreeMap::new(),\\n        }\\n    }\\n\\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\\n        self.inner.insert(Key::owned(key, timestamp), value);\\n    }\\n\\n    fn get(&self, key: String, timestamp: i32) -> String {\\n        let r = (\\n            Bound::Included(Key::borrowed(key.as_str(), 0)),\\n            Bound::Included(Key::borrowed(key.as_str(), timestamp)),\\n        );\\n\\n        self.inner\\n            .range(r)\\n            .next_back()\\n            .map(|(_, val)| val.clone())\\n            .unwrap_or_else(|| String::new())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488840,
                "title": "java-clean-readable-hashmap-and-treemap-based-solution",
                "content": "```\\nclass TimeMap {\\n    HashMap<String, TreeMap<Integer, String>> hm=new HashMap<>();\\n    public TimeMap() {\\n        hm=new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!hm.containsKey(key))\\n            hm.put(key, new TreeMap<>());\\n        hm.get(key).put(timestamp,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!hm.containsKey(key)) return \"\";\\n        var v=hm.get(key).floorKey(timestamp);\\n        if(v==null) return \"\";\\n        return hm.get(key).get(v);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    HashMap<String, TreeMap<Integer, String>> hm=new HashMap<>();\\n    public TimeMap() {\\n        hm=new HashMap<>();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        if(!hm.containsKey(key))\\n            hm.put(key, new TreeMap<>());\\n        hm.get(key).put(timestamp,value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        if(!hm.containsKey(key)) return \"\";\\n        var v=hm.get(key).floorKey(timestamp);\\n        if(v==null) return \"\";\\n        return hm.get(key).get(v);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464374,
                "title": "python-binary-search-solution-o-1-set-o-logn-get-time-o-n-space",
                "content": "```\\n# * Binary Search Based On Search Insert Position Solution | O(1) Set, O(logn) Get Time | O(n) Space\\n# * n -> The number of values per key\\n\\n\\nclass TimeMap:\\n    def __init__(self):\\n        # * Stores an array of a pair of value and timestamp per key.\\n        # * Pair -> (value, timestamp)\\n        self.key_value_map = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.key_value_map[key].append((value, timestamp))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        values = self.key_value_map[key]\\n        left, right = 0, len(values) - 1\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if values[mid][1] == timestamp:\\n                return values[mid][0]\\n            elif values[mid][1] < timestamp:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        left -= 1\\n        return values[left][0] if left >= 0 else \"\"\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Binary Tree"
                ],
                "code": "```\\n# * Binary Search Based On Search Insert Position Solution | O(1) Set, O(logn) Get Time | O(n) Space\\n# * n -> The number of values per key\\n\\n\\nclass TimeMap:\\n    def __init__(self):\\n        # * Stores an array of a pair of value and timestamp per key.\\n        # * Pair -> (value, timestamp)\\n        self.key_value_map = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.key_value_map[key].append((value, timestamp))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        values = self.key_value_map[key]\\n        left, right = 0, len(values) - 1\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if values[mid][1] == timestamp:\\n                return values[mid][0]\\n            elif values[mid][1] < timestamp:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        left -= 1\\n        return values[left][0] if left >= 0 else \"\"\\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445051,
                "title": "simple-python-solution-using-two-dictionaries-and-binary-search",
                "content": "We will simply create two dictionaries of key and value list type. One will hold the key and values(list of values) and other one will hold the key and timestamps(list of timestamps). \\n\\nNow, when we want to set, we will simply append in these dictionaries at appropriate places. \\n\\nWhen we want to get, we will first fetch the list of timestamps for that perticular key. Once we have that list of times, we will simply apply binary search to find the timestamp, if we do find it we will return the corresponding value in the value list for that key. if we dont, the Binary search code is written in such a way that if we dont find the timestamp then we will end up at the previoud timestamp. \\n\\nWe can also use bisects code to find the correct timestamp without using the binary search but it is good to use binary search for interview purposes. \\n\\t\\t\\n\\n```class TimeMap:\\n    def __init__(self):\\n        self.keyvalue = collections.defaultdict(list)\\n        self.keytime = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.keyvalue[key].append(value)\\n        self.keytime[key].append(timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        # idx = bisect.bisect(self.keytime[key], timestamp)\\n        # if idx == 0:\\n        #     return \\'\\'\\n        # return self.keyvalue[key][idx - 1]\\n        times = self.keytime[key]\\n        if not times:\\n            return \"\"\\n        left, right = 0, len(times)-1\\n        \\n        mid = (left+right)//2\\n        while left<=right:\\n            \\n            if times[mid] == timestamp:\\n                return self.keyvalue[key][mid]\\n            if times[mid] > timestamp:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            mid = (left+right)//2    \\n            \\n        return  self.keyvalue[key][mid] if self.keytime[key][mid] <= timestamp else \"\"\\n    \\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "We will simply create two dictionaries of key and value list type. One will hold the key and values(list of values) and other one will hold the key and timestamps(list of timestamps). \\n\\nNow, when we want to set, we will simply append in these dictionaries at appropriate places. \\n\\nWhen we want to get, we will first fetch the list of timestamps for that perticular key. Once we have that list of times, we will simply apply binary search to find the timestamp, if we do find it we will return the corresponding value in the value list for that key. if we dont, the Binary search code is written in such a way that if we dont find the timestamp then we will end up at the previoud timestamp. \\n\\nWe can also use bisects code to find the correct timestamp without using the binary search but it is good to use binary search for interview purposes. \\n\\t\\t\\n\\n```class TimeMap:\\n    def __init__(self):\\n        self.keyvalue = collections.defaultdict(list)\\n        self.keytime = collections.defaultdict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.keyvalue[key].append(value)\\n        self.keytime[key].append(timestamp)\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        # idx = bisect.bisect(self.keytime[key], timestamp)\\n        # if idx == 0:\\n        #     return \\'\\'\\n        # return self.keyvalue[key][idx - 1]\\n        times = self.keytime[key]\\n        if not times:\\n            return \"\"\\n        left, right = 0, len(times)-1\\n        \\n        mid = (left+right)//2\\n        while left<=right:\\n            \\n            if times[mid] == timestamp:\\n                return self.keyvalue[key][mid]\\n            if times[mid] > timestamp:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            mid = (left+right)//2    \\n            \\n        return  self.keyvalue[key][mid] if self.keytime[key][mid] <= timestamp else \"\"\\n    \\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)",
                "codeTag": "Java"
            },
            {
                "id": 2431465,
                "title": "python-intuition-faster-than-96",
                "content": "Python Brute Force:\\n\\nSince timestamp is always in increasing order, we can just search from the last element of array and return after edge cases.\\n\\n\\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.cur_dict={}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        if not key in self.cur_dict:\\n            self.cur_dict[key]=[\"\"]\\n        self.cur_dict[key].append([value,timestamp])\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.cur_dict:\\n            return \"\"\\n        for i in range(len(self.cur_dict[key])-1,-1,-1):\\n            if self.cur_dict[key][i]==\"\":\\n                return \"\"\\n            x,y = self.cur_dict[key][i]\\n            if y<=timestamp:\\n                return x\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.cur_dict={}\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        if not key in self.cur_dict:\\n            self.cur_dict[key]=[\"\"]\\n        self.cur_dict[key].append([value,timestamp])\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        if key not in self.cur_dict:\\n            return \"\"\\n        for i in range(len(self.cur_dict[key])-1,-1,-1):\\n            if self.cur_dict[key][i]==\"\":\\n                return \"\"\\n            x,y = self.cur_dict[key][i]\\n            if y<=timestamp:\\n                return x\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333022,
                "title": "map-based-solution-using-lower-bound",
                "content": "Before we look at solution ,let\\'s look at this .\\n```\\nint main(){\\n    map < int, string, greater < int >> m2; // LOOK AT THIS\\n    m2[2] = \"ab\";\\n    m2[3] = \"abc\";\\n    m2[4] = \"abcd\";\\n\\n    for(auto &it:m2){\\n        cout << it.first << \" \"<< it.second << endl;\\n    }\\n}\\noutput is \\n4 abcd\\n3 abc\\n2 ab\\n```\\nWhat do you observe ?\\nJust because we used the greater than in our map , our key is sorted in decreasing order .\\nNow in our solution ,we created a map where key is string and for each key , we store another map that stores the timestamp and value but our timestamps is stored in decreasing order .We will learn why only decreasing a bit later .\\nNext in our set operation , we just did the usual stuff of setting the key with value .\\n ```\\n void set(string key, string value, int timestamp) {\\n        store[key][timestamp] = value;\\n    }\\n```\\nNow ,while retreiving the value of key at a particular timestamp , you will see that we use a lower bound on the second map which reisdes inside the outer map .\\nWhy ?\\nIf we look at sorted array ,lower bound will give you the element that is equal to the element you are searching or element greater than that but if the same operation is performed on a reversed array, it will give you the element or element smaller than that and that\\'s what we are looking for .\\nRead this line from test case \\n```\\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\\n```\\n\\nCounter questions ?\\nHey dude why didn\\'t you keep your array sorted and instead use upper bound ?\\nME : If you use upper bound on a sorted array ,it will tell you the next element that is greater than the element you are looking for but in our problem what if there is a value for key at timestamp 3 and we do upper_bound of 3 , we won\\'t get value at 3 .\\nHope this helps.\\nComplete code \\n```\\nclass TimeMap {\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    unordered_map<string ,map <int ,string ,greater <int>> > store;\\n    \\n    void set(string key, string value, int timestamp) {\\n        store[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto mit = store.find(key);\\n        if(mit == store.end()){\\n            return \"\";\\n        }\\n        auto mit2 = mit->second.lower_bound(timestamp);\\n        if(mit2 == mit->second.end()){\\n            return \"\";\\n        }\\n        return mit2->second;\\n        \\n        \\n    }\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint main(){\\n    map < int, string, greater < int >> m2; // LOOK AT THIS\\n    m2[2] = \"ab\";\\n    m2[3] = \"abc\";\\n    m2[4] = \"abcd\";\\n\\n    for(auto &it:m2){\\n        cout << it.first << \" \"<< it.second << endl;\\n    }\\n}\\noutput is \\n4 abcd\\n3 abc\\n2 ab\\n```\n```\\n void set(string key, string value, int timestamp) {\\n        store[key][timestamp] = value;\\n    }\\n```\n```\\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\\n```\n```\\nclass TimeMap {\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    unordered_map<string ,map <int ,string ,greater <int>> > store;\\n    \\n    void set(string key, string value, int timestamp) {\\n        store[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto mit = store.find(key);\\n        if(mit == store.end()){\\n            return \"\";\\n        }\\n        auto mit2 = mit->second.lower_bound(timestamp);\\n        if(mit2 == mit->second.end()){\\n            return \"\";\\n        }\\n        return mit2->second;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2055350,
                "title": "java-treemap",
                "content": "```\\nclass TimeMap {\\n    Map<String, TreeMap<Integer, String>> tm;\\n\\n    public TimeMap() {\\n        tm = new HashMap();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        tm.putIfAbsent(key, new TreeMap());\\n        tm.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        return java.util.Optional.ofNullable(tm.get(key))\\n            .map(tp -> tp.floorEntry(timestamp))\\n            .map(entry->entry.getValue())\\n            .orElse(\"\");\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    Map<String, TreeMap<Integer, String>> tm;\\n\\n    public TimeMap() {\\n        tm = new HashMap();\\n    }\\n    \\n    public void set(String key, String value, int timestamp) {\\n        tm.putIfAbsent(key, new TreeMap());\\n        tm.get(key).put(timestamp, value);\\n    }\\n    \\n    public String get(String key, int timestamp) {\\n        return java.util.Optional.ofNullable(tm.get(key))\\n            .map(tp -> tp.floorEntry(timestamp))\\n            .map(entry->entry.getValue())\\n            .orElse(\"\");\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040976,
                "title": "python-hashmap-and-heap-runtime-faster-than-100-and-memory-less-than-99-97",
                "content": "![image](https://assets.leetcode.com/users/images/18e9aeb7-3c9d-4197-ba4f-273b1754ddf3_1652602812.6493857.png)\\n\\n```\\nfrom collections import defaultdict as ddict\\nfrom heapq import heappush, heappop\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.hashmap = ddict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        heappush(self.hashmap[key], (-timestamp, timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        ls = self.hashmap[key]\\n        tmp = []\\n        result = \"\"\\n        while ls:\\n            _, stamp, value = heappop(ls)\\n            heappush(tmp, (-stamp, stamp, value))\\n            if stamp <= timestamp:\\n                result = value\\n                break\\n        self.hashmap[key] = tmp\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict as ddict\\nfrom heapq import heappush, heappop\\n\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.hashmap = ddict(list)\\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        heappush(self.hashmap[key], (-timestamp, timestamp, value))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        ls = self.hashmap[key]\\n        tmp = []\\n        result = \"\"\\n        while ls:\\n            _, stamp, value = heappop(ls)\\n            heappush(tmp, (-stamp, stamp, value))\\n            if stamp <= timestamp:\\n                result = value\\n                break\\n        self.hashmap[key] = tmp\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981167,
                "title": "python-binary-search-concise-solution",
                "content": "The main idea is to use binary search when you are searching for the timestamp, leading to a O(log(n)) get operation.\\n```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.hmap = defaultdict(list)       \\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.hmap[key].append((value,timestamp))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        values = self.hmap[key]\\n        \\n        l = 0\\n        h = len(values) - 1\\n        \\n        while l<=h:\\n            mid = (l+h) // 2\\n            \\n            if values[mid][1] == timestamp:\\n                return values[mid][0]\\n            elif values[mid][1]>timestamp:\\n                h = mid-1\\n            else:\\n                l = mid+1\\n        # If h < 0, it means that there are no entries with a smaller timestamp       \\n        return \"\" if h < 0 else values[h][0]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass TimeMap:\\n\\n    def __init__(self):\\n        self.hmap = defaultdict(list)       \\n\\n    def set(self, key: str, value: str, timestamp: int) -> None:\\n        self.hmap[key].append((value,timestamp))\\n\\n    def get(self, key: str, timestamp: int) -> str:\\n        values = self.hmap[key]\\n        \\n        l = 0\\n        h = len(values) - 1\\n        \\n        while l<=h:\\n            mid = (l+h) // 2\\n            \\n            if values[mid][1] == timestamp:\\n                return values[mid][0]\\n            elif values[mid][1]>timestamp:\\n                h = mid-1\\n            else:\\n                l = mid+1\\n        # If h < 0, it means that there are no entries with a smaller timestamp       \\n        return \"\" if h < 0 else values[h][0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953579,
                "title": "cpp-with-lower-bound-clean-solution",
                "content": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string, map<int, string>> kv;\\n    TimeMap() {\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        kv[key][-timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto ele = kv[key].lower_bound(-timestamp);\\n        if (ele == kv[key].end()) {\\n            return \"\";\\n        }\\n        return (*ele).second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\npublic:\\n    unordered_map<string, map<int, string>> kv;\\n    TimeMap() {\\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        kv[key][-timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        auto ele = kv[key].lower_bound(-timestamp);\\n        if (ele == kv[key].end()) {\\n            return \"\";\\n        }\\n        return (*ele).second;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760859,
                "title": "c-easy-and-concise-2-approaches",
                "content": "# 1. Approach \\n```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, vector<pair<string, int>>>mp;\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        string ans=\"\";\\n        int low = 0, end = mp[key].size();\\n        while(low < end)\\n        {\\n            int mid = low + (end-low)/2;\\n            if(mp[key][mid].second > timestamp){\\n                end = mid;\\n            }\\n            else{\\n                ans = mp[key][mid].first;\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n ```\\n \\n ```\\n` 2. Approach `\\n\\t unordered_map<string, map<int, string>> m;\\n\\tvoid set(string key, string value, int timestamp) {\\n\\t  m[key].insert({ timestamp, value });\\n\\t}\\n\\tstring get(string key, int timestamp) {\\n\\t  auto it = m[key].upper_bound(timestamp);\\n\\t  return it == m[key].begin() ? \"\" : prev(it)->second;\\n\\t}\\n ```\\n",
                "solutionTags": [],
                "code": "```\\nclass TimeMap {\\nprivate:\\n    unordered_map<string, vector<pair<string, int>>>mp;\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        mp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        string ans=\"\";\\n        int low = 0, end = mp[key].size();\\n        while(low < end)\\n        {\\n            int mid = low + (end-low)/2;\\n            if(mp[key][mid].second > timestamp){\\n                end = mid;\\n            }\\n            else{\\n                ans = mp[key][mid].first;\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n ```\n```\\n` 2. Approach `\\n\\t unordered_map<string, map<int, string>> m;\\n\\tvoid set(string key, string value, int timestamp) {\\n\\t  m[key].insert({ timestamp, value });\\n\\t}\\n\\tstring get(string key, int timestamp) {\\n\\t  auto it = m[key].upper_bound(timestamp);\\n\\t  return it == m[key].begin() ? \"\" : prev(it)->second;\\n\\t}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1700879,
                "title": "c-clear-concise-unordered-map-map-upper-bound",
                "content": "```\\nclass TimeMap {\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) \\n    {\\n        store[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) \\n    {\\n        if (store.find(key) == store.end())\\n            return \"\";\\n        \\n        map<int, string>& snaps = store[key];\\n        auto itr = snaps.upper_bound(timestamp);\\n\\n        return itr == snaps.begin() ? \"\" : (--itr)->second;\\n    }\\n    \\nprivate:\\n    unordered_map<string, map<int, string>> store;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass TimeMap {\\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) \\n    {\\n        store[key][timestamp] = value;\\n    }\\n    \\n    string get(string key, int timestamp) \\n    {\\n        if (store.find(key) == store.end())\\n            return \"\";\\n        \\n        map<int, string>& snaps = store[key];\\n        auto itr = snaps.upper_bound(timestamp);\\n\\n        return itr == snaps.begin() ? \"\" : (--itr)->second;\\n    }\\n    \\nprivate:\\n    unordered_map<string, map<int, string>> store;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690549,
                "title": "c-solution",
                "content": "```\\nclass TimeMap {\\n    unordered_map<string, vector<pair<string, int>>> ump; \\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        ump[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(ump.find(key) == ump.end()) return \"\";\\n        // Please notice the \\'&\\' in the next line, you will hit TLE if no \\'&\\' in there.\\n        vector<pair<string, int>>& temp = ump[key]; \\n        int low = 0, high = temp.size() - 1;\\n        if(temp[high].second <= timestamp) return temp[high].first;\\n        if(temp[low].second > timestamp) return \"\";\\n        while(low < high){\\n            if(low + 1 == high) return temp[low].first;\\n            int mid = low + (high - low) / 2;\\n            if(temp[mid].second == timestamp) return temp[mid].first;\\n            else if(temp[mid].second > timestamp)\\n                high = mid;\\n            else\\n                low = mid;\\n        }\\n        return \"\";\\n    }\\n};\\n```\\n\\n`Have to use binary search, otherwise it will hit TLE`",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Binary Tree"
                ],
                "code": "```\\nclass TimeMap {\\n    unordered_map<string, vector<pair<string, int>>> ump; \\npublic:\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        ump[key].push_back({value, timestamp});\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(ump.find(key) == ump.end()) return \"\";\\n        // Please notice the \\'&\\' in the next line, you will hit TLE if no \\'&\\' in there.\\n        vector<pair<string, int>>& temp = ump[key]; \\n        int low = 0, high = temp.size() - 1;\\n        if(temp[high].second <= timestamp) return temp[high].first;\\n        if(temp[low].second > timestamp) return \"\";\\n        while(low < high){\\n            if(low + 1 == high) return temp[low].first;\\n            int mid = low + (high - low) / 2;\\n            if(temp[mid].second == timestamp) return temp[mid].first;\\n            else if(temp[mid].second > timestamp)\\n                high = mid;\\n            else\\n                low = mid;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568416,
                "title": "my-kotlin-solution",
                "content": "- Runtime: 896 ms, faster than 100.00% of Kotlin online submissions for Time Based Key-Value Store.\\n- Memory Usage: 135.3 MB, less than 89.85% of Kotlin online submissions for Time Based Key-Value Store.\\n\\n```kotlin\\nclass TimeMap {\\n\\n    private val dataSet = mutableMapOf<String, MutableList<TimeNode>>()\\n\\n\\t// Time complexity: O(1)\\n\\t// Space complexity: O(1)\\n    fun set(key: String, value: String, timestamp: Int) {\\n        val nodes = dataSet.getOrPut(key) { mutableListOf() }\\n\\n\\t\\t// We do not allow entries that are in the past.\\n        val lastTimestamp: Int = nodes.lastOrNull()?.timestamp ?: Int.MIN_VALUE\\n        if (lastTimestamp < timestamp) {\\n            nodes += TimeNode(value, timestamp)\\n        }\\n    }\\n\\n\\t// Time complexity: O(logn)\\n\\t// Space complexity: O(1)\\n    fun get(key: String, timestamp: Int): String {\\n        val nodes = dataSet.getOrPut(key) { mutableListOf() }\\n\\n\\t\\t// Short circuit: If nodes are empty, there is no message to verify.\\n        if (nodes.isEmpty()) return \"\"\\n\\n\\t\\t// We will need to keep track of the \"most close\" entry (see below).\\n        var node: TimeNode? = null\\n\\t\\t\\n        var left = 0\\n        var right = nodes.size\\n\\n\\t\\t// Binary Search.\\n        while (left < right) {\\n            val mid = left + (right - left) / 2\\n            node = nodes[mid]\\n\\n\\t\\t\\t// If we find a perfect match, return it.\\n            if (node.timestamp == timestamp) {\\n                return node.text\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Otherwise, continue the binary search.\\n            if (node.timestamp < timestamp) {\\n                left = mid + 1\\n            } else if (node.timestamp >= timestamp) {\\n                right = mid\\n            }\\n        }\\n\\n\\t\\t// If no match is found, we verify if the \"most close\" node is before the requested timestamp.\\n\\t\\t// If yes, we can result it as that is the first message before the requested timestamp.\\n        if (node != null && node.timestamp <= timestamp) {\\n            return node.text\\n        }\\n\\n\\t\\t// If nothing is found, return empty string.\\n        return \"\"\\n    }\\n}\\n\\n// Helper class, to keep the text/timestamp combination in our dataSet map.\\nprivate class TimeNode(\\n    val text: String,\\n    val timestamp: Int\\n)\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nclass TimeMap {\\n\\n    private val dataSet = mutableMapOf<String, MutableList<TimeNode>>()\\n\\n\\t// Time complexity: O(1)\\n\\t// Space complexity: O(1)\\n    fun set(key: String, value: String, timestamp: Int) {\\n        val nodes = dataSet.getOrPut(key) { mutableListOf() }\\n\\n\\t\\t// We do not allow entries that are in the past.\\n        val lastTimestamp: Int = nodes.lastOrNull()?.timestamp ?: Int.MIN_VALUE\\n        if (lastTimestamp < timestamp) {\\n            nodes += TimeNode(value, timestamp)\\n        }\\n    }\\n\\n\\t// Time complexity: O(logn)\\n\\t// Space complexity: O(1)\\n    fun get(key: String, timestamp: Int): String {\\n        val nodes = dataSet.getOrPut(key) { mutableListOf() }\\n\\n\\t\\t// Short circuit: If nodes are empty, there is no message to verify.\\n        if (nodes.isEmpty()) return \"\"\\n\\n\\t\\t// We will need to keep track of the \"most close\" entry (see below).\\n        var node: TimeNode? = null\\n\\t\\t\\n        var left = 0\\n        var right = nodes.size\\n\\n\\t\\t// Binary Search.\\n        while (left < right) {\\n            val mid = left + (right - left) / 2\\n            node = nodes[mid]\\n\\n\\t\\t\\t// If we find a perfect match, return it.\\n            if (node.timestamp == timestamp) {\\n                return node.text\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Otherwise, continue the binary search.\\n            if (node.timestamp < timestamp) {\\n                left = mid + 1\\n            } else if (node.timestamp >= timestamp) {\\n                right = mid\\n            }\\n        }\\n\\n\\t\\t// If no match is found, we verify if the \"most close\" node is before the requested timestamp.\\n\\t\\t// If yes, we can result it as that is the first message before the requested timestamp.\\n        if (node != null && node.timestamp <= timestamp) {\\n            return node.text\\n        }\\n\\n\\t\\t// If nothing is found, return empty string.\\n        return \"\"\\n    }\\n}\\n\\n// Helper class, to keep the text/timestamp combination in our dataSet map.\\nprivate class TimeNode(\\n    val text: String,\\n    val timestamp: Int\\n)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565049,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1949698,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1633938,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1890817,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1567087,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1934766,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1575240,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1569414,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1841946,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1634016,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1565049,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1949698,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1633938,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1890817,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1567087,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1934766,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1575240,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1569414,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1841946,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 1634016,
                "content": [
                    {
                        "username": "beginner_7",
                        "content": "What does this mean? \"Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\" The examples seem contradictory to this statement"
                    },
                    {
                        "username": "szcwleowang",
                        "content": "I am also confused for the description of \"String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\". Does test case 45, [\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5], meet this rule?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "To put it simply, it means \"Returns a value associated with the given `key` such that the value\\'s timestamp *doesn\\'t exceed* the given `timestamp`.\""
                    },
                    {
                        "username": "Neeraj00",
                        "content": "They are tryin to say that if you don\\'t have any value at that time stamp then, return the value of the timestamp which is either equal to the given time stamp or just less than. \\n"
                    },
                    {
                        "username": "xqcow",
                        "content": "it's kinda confusing but it makes sense imo. it's like \"if given a `timestamp` that's too far in the future, then return a value that was _before_ that time\""
                    },
                    {
                        "username": "raghav_puri",
                        "content": "This problem statement is really badly written"
                    },
                    {
                        "username": "akshar_",
                        "content": "The time limit for C++ must be relaxed. Stuck at 44/48 test cases even though the same code translated to Java passes every time."
                    },
                    {
                        "username": "anasrabhi0",
                        "content": "i literally translated log(n) c++ code (TLE) to java , it beated 94%"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Same here with c#"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "same here with JS"
                    },
                    {
                        "username": "xeniawann",
                        "content": "***Hint:*** \nTake advantage of the fact that \"timestamp is strictly increasing\", so you can do binary search based on `timestamp` variable. A linear search will exceed time limit, so it's probably better to start from linear search but write code based on binary search. \n\nA hashmap of `key` will get you started, think what its associating value could be, maybe another hashmap (but then it's unsorted)? or maybe just an array of tuples?"
                    },
                    {
                        "username": "lylyjenny",
                        "content": "Shall we move this constraint to the main problem description? This matters a lot when people trying to design the solution. Thanks!"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "[@xeniawann](/xeniawann) > All the timestamps timestamp of set are strictly increasing\\n\\nI missed this line and my original solution used a priority queue."
                    },
                    {
                        "username": "xeniawann",
                        "content": "sry but what constraint?"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "very true"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "FIXED !!! : GETTING TLE IN C++ EVEN ON CORRECT SOLUTION ???\n\n`Remember one thing : that when you access the container inside your hashmap... access it using reference \n instead of directly assigning bcoz it will cause copying of the container so more time complexity`"
                    },
                    {
                        "username": "aftabmk",
                        "content": "from getting TLE to beat 80% just by add \"&\"."
                    },
                    {
                        "username": "jpla83",
                        "content": "I would like to know why the performance of C# solutions are always that bad. For example I solved this exercise using C# and I got Time Exceeeded, after that I translated the same code to java and it was accepted. Do anybody here knows what this happens?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Discrimination"
                    },
                    {
                        "username": "Madmag77",
                        "content": "Always shows time-limit even if I just return empty string in `get` :)\\nHow to get to admins in order to fix that?"
                    },
                    {
                        "username": "syavawow97",
                        "content": "Try to rework your set method.  In my case, I was doing iteration over the whole list instead of just appending / iterating from the end. After fixing that, I was able to pass the time limit"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Here is a testcase that is more comprehensive than the provided example:\\n[\"TimeMap\",\"set\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\"]\\n[[],[\"robb\",\"talisa\",2],[\"robb\",3],[\"sansa\", \"tyrion\",3],[\"sansa\",\"ramsay\",5],[\"sansa\",5],[\"sansa\",1],[\"bran\",7]]"
                    },
                    {
                        "username": "touchstone",
                        "content": "Let Bran rest now :P "
                    },
                    {
                        "username": "Stroller_15",
                        "content": "any body can tell me what is  -> TimeMap() {    }\\nis doing in this class??\\n\\n        \\n  "
                    },
                    {
                        "username": "MightyZeus",
                        "content": "It is called as constructor , it is used to instantiate the class i.e to create an object of a class . You should read some basics of OOPs."
                    }
                ]
            },
            {
                "id": 2011031,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 1633753,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 1935033,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 1874376,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 1766973,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 1728345,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 1794548,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 1572423,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 2071233,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 2063980,
                "content": [
                    {
                        "username": "SaAwAL_Ag",
                        "content": "this question is really hard to understand :("
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "I\\'m pretty sure Javascript\\'s UT has bug starting 44/48, coz every single time the case impl triggers the time exceeds limit, so my code is hashmap+binary search never has a chance to be validated"
                    },
                    {
                        "username": "pyush98",
                        "content": "map each key to a list of lists where the nested lists are of length two with (timestamp, value)\\n\\nconsider whether the timestamps can ever be inserted out of sorted order\\n\\nthen think of a way to retrieve the target timestamp in logN time"
                    },
                    {
                        "username": "Minatokun",
                        "content": "Can we return any timestamp<=currentTimestamp if the given timestamp isnt present or we have to return the timestamp just before(less than) the given timestamp??"
                    },
                    {
                        "username": "mlivingston",
                        "content": "seems to be a bug with class attributes persisting once object is instantiated "
                    },
                    {
                        "username": "grilam14",
                        "content": "If you see values persisting between test cases, you\\'re init is probably not written correctly. There is a bug, but there is a workaround if you need it. "
                    },
                    {
                        "username": "mitrjain96",
                        "content": "A test case which is not checked  for during submission is:\\n[\"TimeMap\",\"set\",\"set\",\"set\",\"get\"]\\n[[],[\"love\",\"high\",10],[\"love\",\"mid\",14],[\"love\",\"low\",20],[\"love\",15]]\\n\\nMy code fails at this test case, but I have a successful submission. "
                    },
                    {
                        "username": "Vengeance_",
                        "content": "why is it giving tle at 44th testcase? it's a simple binary search which should have passed .. some of the solutions in solution section is in linear time but passed.\n\n```class TimeMap {\npublic:\nunordered_map<string,vector<pair<string,int>>> m;\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        m[key].push_back({value,timestamp});\n    }\n    \n    string get(string key, int timestamp) {\n        if(m.find(key) != m.end()){\n            vector<pair<string,int>> arr = m[key];\n            int l=0,r = arr.size()-1;\n            if(timestamp < arr[0].second)return \"\";\n            while(l<=r){\n                int mid = (l+r)/2;\n                if(arr[mid].second == timestamp)return arr[mid].first;\n                else if(arr[mid].second > timestamp)r = mid-1;\n                else l = mid+1;\n            }\n\n            return arr[r].first;\n\n        }\n\n        return \"\";\n    }\n\n    \n\n};\n\n```"
                    },
                    {
                        "username": "kdplant205",
                        "content": "Is there a bug in the test program of C version?\\nI got the error when the input data is very large.\\n\"Error in `sandbox run\\': realloc(): invalid next size: 0x0000000003a27a30\""
                    },
                    {
                        "username": "mochiball",
                        "content": "TLE on test case 44/50? "
                    },
                    {
                        "username": "qhdud3100",
                        "content": "why should it be binary search?  \\uD83D\\uDC40 \\nBecause timestamp always increase. \\nI think it has to be noticed even though it\\'s not written on description. "
                    }
                ]
            },
            {
                "id": 2063851,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 2061510,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 2055454,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 2038723,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 2018520,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 1994349,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 1990750,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 1987976,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 1986023,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 1985227,
                "content": [
                    {
                        "username": "qhdud3100",
                        "content": "Apparently, it can only get the value with prev_timestamp( -> which means timestamp of previously stored data) that is smaller or equal than timestamp of requested one. \n\nI think this example is more intuitive. \ncopied form other website. \nInput: \ninputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"],\ninputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\n\nOutput: \n[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] \n\n\nin below case, \n5-> can't get value \n10, 15 -> 10 \n20, 25 -> 20 \n\nI hope this make it clear. "
                    },
                    {
                        "username": "percy_98",
                        "content": "I really want such type of question to show up in my interviews !! I find far more intuitive  solving design problems   and It is more likely I could face something similar in my  job ."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "It is important to take note that \"All the timestamps timestamp of set are strictly increasing.\""
                    },
                    {
                        "username": "nadabao",
                        "content": "This is awesome question and I\\'ve seen this in Apple interview in 2021."
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "I am quite confused about which form of binary search should I choose? There are different forms in almost every problem. Some don't work with start = mid + 1 or end = mid - 1 so you gotta change them to be equal to mid and then some change require changing the if condition. Does anyone have a good technique to figure out which one to apply where?"
                    },
                    {
                        "username": "liorbm1",
                        "content": "Lol, I implemented a dictionary of Binary Search Trees..."
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is really good for interviews. \nText is readable, intuition is not hidden and is evaluated as medium correctly.\nSome can argue is easy... "
                    },
                    {
                        "username": "cc2002",
                        "content": "This problem statement is poorly written."
                    },
                    {
                        "username": "user5429Wl",
                        "content": "I think this problem needs another version for the O(N * logN), to practice binary search)"
                    },
                    {
                        "username": "sri_datta",
                        "content": "Python TLE with binary search and hashmap could be due to using nested dics. Using dic for timestamp and value would require you to do list(timestamp_value_dic.keys()) Which seems to be quite slow in some stress test cases where too many get operations are performed. Instead storing them as list of tuples solved the issue"
                    }
                ]
            },
            {
                "id": 1932734,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            },
            {
                "id": 1928259,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            },
            {
                "id": 1911087,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            },
            {
                "id": 1910511,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            },
            {
                "id": 1908334,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            },
            {
                "id": 1826982,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            },
            {
                "id": 1789759,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            },
            {
                "id": 1769908,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            },
            {
                "id": 1755486,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            },
            {
                "id": 1633338,
                "content": [
                    {
                        "username": "rahulsah6003",
                        "content": "My code is giving TLE even though i have applied binary search anyone please check ?\\n\\nclass TimeMap {\\npublic:\\n\\n    unordered_map <string ,vector <pair<string,int>>> mpp;\\n\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        \\n        // set into the map \\n        mpp[key].push_back(make_pair(value,timestamp));\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        // auto vec = mpp[key];\\n        vector <pair <string,int>> vec = mpp[key];\\n\\n        string val=\"\";\\n        // for(auto it : vec)\\n        // {\\n        //     if(it.second <= timestamp)\\n        //     {\\n        //         val = it.first;\\n        //     }\\n        // }\\n\\n        // applying binary search \\n\\n        int low=0,high = vec.size()-1;\\n\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(vec[mid].second <= timestamp)\\n            {   val = vec[mid].first;\\n                low = mid+1;\\n            }\\n\\n            else \\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return val;\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Question description is not clear."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Key is definitely that all timestamps are given to be strictly increasing. Otherwise we would have to perform n operations to readjust and create a sorted array. \\n\\nIf the problem did allow for timestamps to be inserted that are less than the current max, would it be better to implement a binary heap?"
                    },
                    {
                        "username": "Rookie_WangLingxiao",
                        "content": "44/48 test case\\u2018s Data volume is too extreme"
                    },
                    {
                        "username": "Neeraj00",
                        "content": "maybe you are missing some optimization step."
                    },
                    {
                        "username": "lu284918171",
                        "content": "damn!!!!!!!!!!even Editorial\\'s python solution can only pass 48/50 test case ! and rest two will be Time limit exceeded!"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Getting Internal Error while submitting my code (C++). Anyone facing the same?"
                    },
                    {
                        "username": "grilam14",
                        "content": "I think this question is bugged. My class values are persisting between test cases"
                    },
                    {
                        "username": "quentinbalin",
                        "content": "Same as other above, Time Limit Exceeded in JS, I don\\'t think my solution was too terrible though. "
                    },
                    {
                        "username": "bhavanababu32",
                        "content": "Time limit for c++ is stuck at 44/49. Same code passes in python!!"
                    },
                    {
                        "username": "MohanChhabaria",
                        "content": "Using Map inside Map \\n`\\n\\nclass TimeMap {\\npublic:\\n    unordered_map<string, unordered_map<int,string>> mp;\\n    TimeMap() {\\n        \\n    }\\n    \\n    void set(string key, string value, int timestamp) {\\n        if(mp.find(key)==mp.end()){\\n            unordered_map<int,string> temp;\\n            mp[key] = temp;\\n        }\\n        // unordered_map<int,string> tem = mp[key];\\n        mp[key][timestamp] = value;\\n        \\n        // for(auto it : mp){\\n        //     unordered_map<int,string> t = it.second;\\n        //     for(auto i : t){\\n        //         cout<<i.first<<\"  \"<<i.second;\\n        //         cout<<\"\\\\n\";\\n        //     }\\n        // }\\n    }\\n    \\n    string get(string key, int timestamp) {\\n        if(mp.find(key)==mp.end()) return \"\";\\n        // unordered_map<int,string> temp = mp[key];\\n        while(timestamp>0){\\n            if(mp[key].find(timestamp)!=mp[key].end()){\\n                return mp[key][timestamp];\\n            }\\n            timestamp--;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your TimeMap object will be instantiated and called as such:\\n * TimeMap* obj = new TimeMap();\\n * obj->set(key,value,timestamp);\\n * string param_2 = obj->get(key,timestamp);\\n */\\n`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Triples with Bitwise AND Equal To Zero",
        "question_content": "<p>Given an integer array nums, return <em>the number of <strong>AND triples</strong></em>.</p>\n\n<p>An <strong>AND triple</strong> is a triple of indices <code>(i, j, k)</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; nums.length</code></li>\n\t<li><code>0 &lt;= j &lt; nums.length</code></li>\n\t<li><code>0 &lt;= k &lt; nums.length</code></li>\n\t<li><code>nums[i] &amp; nums[j] &amp; nums[k] == 0</code>, where <code>&amp;</code> represents the bitwise-AND operator.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,3]\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> We could choose the following i, j, k triples:\n(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1\n(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2\n(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1\n(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3\n(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1\n(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2\n(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1\n(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3\n(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2\n(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2\n(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1\n(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0]\n<strong>Output:</strong> 27\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 227309,
                "title": "c-naive-o-n-n",
                "content": "First, we process all tuples ```A[i]``` and ```A[j]```, and store the result of ```A[i] & A[j]``` in the hash map ```tuples```. We also count there how many times each result was produced.\\n\\nThen, we go through the array again, and check each element against all tuples. If it produces zero, we add the tuple counter to the result.\\n```\\nint countTriplets(vector<int>& A, int cnt = 0) {\\n  unordered_map<int, int> tuples;\\n  for (auto a : A)\\n    for (auto b : A) ++tuples[a & b];\\n  for (auto a : A)\\n    for (auto t : tuples)\\n      if ((t.first & a) == 0) cnt += t.second;\\n  return cnt;\\n}\\n```\\nIf we know that the input is large, we could use an array instead of hash set. The size of this array will be ```1 << 16```. This will speed up things quite a bit.\\n```\\nint countTriplets(vector<int>& A, int cnt = 0) {\\n  int tuples[1 << 16] = {};\\n  for (auto a : A)\\n    for (auto b : A) ++tuples[a & b];\\n  for (auto a : A)\\n    for (auto i = 0; i < (1 << 16); ++i)\\n      if ((i & a) == 0) cnt += tuples[i];\\n  return cnt;\\n}\\n```\\n## Complexity Analysis\\nTime: *O(n * n)*. We can have 2^16 tuples at most. When n is large, n * n will dominate n * 2^16. So it is O(n * n) in the big O notation.\\nMemory: *O(n)* for the first solution; *O(2 ^ 16)*, or, stricter, *O(1)* for the second one.",
                "solutionTags": [],
                "code": "```A[i]```\n```A[j]```\n```A[i] & A[j]```\n```tuples```\n```\\nint countTriplets(vector<int>& A, int cnt = 0) {\\n  unordered_map<int, int> tuples;\\n  for (auto a : A)\\n    for (auto b : A) ++tuples[a & b];\\n  for (auto a : A)\\n    for (auto t : tuples)\\n      if ((t.first & a) == 0) cnt += t.second;\\n  return cnt;\\n}\\n```\n```1 << 16```\n```\\nint countTriplets(vector<int>& A, int cnt = 0) {\\n  int tuples[1 << 16] = {};\\n  for (auto a : A)\\n    for (auto b : A) ++tuples[a & b];\\n  for (auto a : A)\\n    for (auto i = 0; i < (1 << 16); ++i)\\n      if ((i & a) == 0) cnt += tuples[i];\\n  return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226721,
                "title": "java-dp-o-3-2-16-n-time-o-2-16-space",
                "content": "**Update:**\\n\\nThanks for the inspiring solutions in the comments using `HashMap` which runs `O(n^2)` time. I didn\\'t come up with such solutions in the contest. That\\'s really efficient for this problem specifically. However, I think my solution is more scalable in terms of **the number of indices to be picked** is very large. Say it\\'s `M` instead of `3`, the runtime is `O(M * 2^16 * n)`.\\n\\nHere I updated an `O(M * 2^16)` space version to help understanding, where `dp[i][j]` represents the number of combinations if we pick `i` numbers where the `AND` of these numbers is `j`:\\n\\n```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int N = 1 << 16, M = 3;\\n        int[][] dp = new int[M + 1][N];\\n        dp[0][N - 1] = 1;\\n        for (int i = 0; i < M; i++) {\\n            for (int k = 0; k < N; k++) {\\n                for (int a : A) {\\n                    dp[i + 1][k & a] += dp[i][k];\\n                }\\n            }\\n        }\\n        return dp[M][0];\\n    }\\n}\\n```\\n\\nAppreciate for other solutions again!\\n\\n**Original Post:**\\n\\nFor each `i`, assume that if we pick `i` numbers from `A` array(allow duplicates), the `AND` of these `i` numbers is `k`.\\nThen `dp[k]` represents the number of combinations for such `i` and `k`. We update this `dp` array for 3 times.\\n\\nExample:\\n`i=2` means we pick `2` numbers.\\n`dp[10] = 5` means when we pick `2` numbers, the count of combinations is `5`, where the `AND` result of such numbers is `10`.\\n\\nTricky:\\nWe initialize the `dp[(1<<16) - 1]` to 1 because the AND result of every number with `(1<<16) - 1` is the number itself.\\n\\nTime complexity:\\n`O(3 * 2^16 * n)`\\n\\nSpace:\\n`O(2^16)`\\n\\n```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int N = 1 << 16;\\n        int[] dp = new int[N];\\n        dp[N - 1] = 1;\\n        for (int i = 0; i < 3; i++) {\\n            int[] temp = new int[N];\\n            for (int k = 0; k < N; k++) {\\n                for (int a : A) {\\n                    temp[k & a] += dp[k];\\n                }\\n            }\\n            dp = temp;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int N = 1 << 16, M = 3;\\n        int[][] dp = new int[M + 1][N];\\n        dp[0][N - 1] = 1;\\n        for (int i = 0; i < M; i++) {\\n            for (int k = 0; k < N; k++) {\\n                for (int a : A) {\\n                    dp[i + 1][k & a] += dp[i][k];\\n                }\\n            }\\n        }\\n        return dp[M][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int N = 1 << 16;\\n        int[] dp = new int[N];\\n        dp[N - 1] = 1;\\n        for (int i = 0; i < 3; i++) {\\n            int[] temp = new int[N];\\n            for (int k = 0; k < N; k++) {\\n                for (int a : A) {\\n                    temp[k & a] += dp[k];\\n                }\\n            }\\n            dp = temp;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988061,
                "title": "java-5-approaches-with-explanation-and-clean-codes",
                "content": "**Approach 1: Count pairs using array - Naive**\\nSince we\\'re only dealing with 16 bit numbers, ```A[i]```, ```A[i] & A[j]``` or ```A[i] & A[j] & A[k]``` everything lies within 16 bits only. 2<sup>16</sup> = 65,536 which is not a very big number so we can consider generating all ```A[i] & A[j]``` pairs and counting their frequencies using a HashMap or an array. After that, we can check for each ```A[i]```, which of these pairs yield 0 when taken AND with ```A[i]```.\\n\\n```\\n// 147 ms. 70%\\npublic int countTriplets(int[] A) {\\n    int[] count = new int[1 << 16];\\n    for(int a: A) for(int b: A) count[a & b]++;\\n    int res = 0;\\n    for(int a: A) for(int i = 0; i < count.length; i++) if((a & i) == 0) res += count[i];\\n    return res;\\n}\\n```\\n\\n**Approach 2: Count pairs using Trie**\\nWe can build a trie of depth 16 and insert all ```A[i] & A[j]``` values into it. Leaf of the trie node stores the count of the number represented by that path. Then, for each ```A[i]```, we can find how many pairs when taken AND with ```A[i]``` give 0 by traversing the trie bit by bit. If at any time, bit of ```A[i]``` is 1, then we traverse bit 0 child only whereas if bit of ```A[i]``` is 0, we traverse both bit 0 and 1 children.\\n\\n```\\n// 196 ms. 65.56%\\nclass Trie {\\n    private int count = 0;\\n    private Trie[] child = new Trie[2];\\n    public void add(int num) {\\n        Trie node = this;\\n        for(int i = 15; i >= 0; i--) {\\n            int b = (num >> i) & 1;\\n            if(node.child[b] == null) node.child[b] = new Trie();\\n            node = node.child[b];\\n        }\\n        node.count++;\\n    }\\n    private int find(Trie node, int num, int i) {\\n        return node == null ? 0 : (i == -1 ? node.count : (find(node.child[0], num, i - 1) + (((num >> i) & 1) == 0 ? find(node.child[1], num, i - 1) : 0)));\\n    }\\n    public int countZeroAND(int num) {\\n        return find(this, num, 15);\\n    }\\n}\\npublic int countTriplets(int[] A) {\\n    Trie trie = new Trie();\\n    for(int a: A) for(int b: A) trie.add(a & b);\\n    int res = 0;\\n    for(int a: A) res += trie.countZeroAND(a);\\n    return res;\\n}\\n```\\n\\n**Approach 3: Count pairs using array - Trie based search**\\nWe can optimize previous approach by noting that we\\'re only dealing with 2<sup>16</sup> = 65,536 possible values so we should consider using an array instead of a Trie to speed things up. But this does not mean that we\\'re back to naive search of approach 1, we leverage the trie based bit by bit search technique and apply it using a recursive search method. Idea is that search starts with the whole range ```[L, R]``` and based on bit of ```A[i]``` gets split into calls of ```[L, M]``` and ```[M + 1, R]``` where ```M = (L + R) / 2```.\\n```\\n// 29 ms. 97.78%\\nprivate int find(int[] count, int a, int i, int p) {\\n    return i == -1 ? count[p] : find(count, a, i - 1, p) + (((a >> i) & 1) == 0 ? find(count, a, i - 1, p + (1 << i)) : 0);\\n}\\npublic int countTriplets(int[] A) {\\n    int[] count = new int[1 << 16];\\n    for(int a: A) for(int b: A) count[a & b]++;\\n    int res = 0;\\n    for(int a: A) res += find(count, a, 15, 0);\\n    return res;\\n}\\n```\\n\\n**Approach 4: Count pairs using array - Skip useless numbers**\\nIn naive approach 1, we\\'re iterating over all the values from 0 to 2<sup>16</sup>-1 for each ```A[i]```. But we can make this loop faster by skipping over numbers that we can be sure wouldn\\'t give 0 when taken AND with ```A[i]```. Let\\'s say, ```a``` (from ```A```) = xxxx1000 and ```i``` (from loop) = 1000 so that ```a & i``` = 00001000 which is != 0. At this point, we can be sure that subsequent values after ```i``` i.e. 1001, 1010, 1011, 1100, ..., 1111  when taken AND with ```a``` won\\'t give 0 either because all of these have a 1 at bit position 3 so we can directly skip ahead to ```i``` = 10000. Note that this is essentially the same as previous approach in spirit.\\n\\n```\\n// 13 ms. 100%\\npublic int countTriplets(int[] A) {\\n    int[] count = new int[1 << 16];\\n    for(int a: A) for(int b: A) count[a & b]++;\\n    int res = 0;\\n    for(int a: A) for(int i = 0; i < count.length; i++) {\\n    \\tif((a & i) == 0) res += count[i];\\n    \\telse i += (a & i) - 1;\\n    }\\n    return res;\\n}\\n```\\n\\n**Approach 5: Dynamic Programming**\\nWe can count combinations of indices using DP. Specifically, let ```dp[i][j]``` = number of tuples of length ```i``` of indices of ```A``` that give AND as ```j```.\\nAnswer that we\\'re looking for would be in ```dp[3][0]```. We can initialize length 1 tuples by directly using each ```A[i]```. After that, to calculate next level, we can use the logic: ```dp[i + 1][j & A[k]] += dp[i][j]```.\\n\\n**Optimization:** Since next level depends only on the values of previous level, we can just maintain previous level everytime and use it to calculate next level thereby reducing space.\\n\\n```\\n// 357 ms. 52.22%\\npublic int countTriplets(int[] A) {\\n    int[] dp = new int[1 << 16];\\n    for(int a: A) dp[a]++;\\n    for(int i = 0; i < 2; i++) {\\n        int[] next = new int[dp.length];\\n        for(int a: A) for(int j = 0; j < dp.length; j++) next[a & j] += dp[j];\\n        dp = next;\\n    }\\n    return dp[0];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```A[i]```\n```A[i] & A[j]```\n```A[i] & A[j] & A[k]```\n```A[i] & A[j]```\n```A[i]```\n```A[i]```\n```\\n// 147 ms. 70%\\npublic int countTriplets(int[] A) {\\n    int[] count = new int[1 << 16];\\n    for(int a: A) for(int b: A) count[a & b]++;\\n    int res = 0;\\n    for(int a: A) for(int i = 0; i < count.length; i++) if((a & i) == 0) res += count[i];\\n    return res;\\n}\\n```\n```A[i] & A[j]```\n```A[i]```\n```A[i]```\n```A[i]```\n```A[i]```\n```\\n// 196 ms. 65.56%\\nclass Trie {\\n    private int count = 0;\\n    private Trie[] child = new Trie[2];\\n    public void add(int num) {\\n        Trie node = this;\\n        for(int i = 15; i >= 0; i--) {\\n            int b = (num >> i) & 1;\\n            if(node.child[b] == null) node.child[b] = new Trie();\\n            node = node.child[b];\\n        }\\n        node.count++;\\n    }\\n    private int find(Trie node, int num, int i) {\\n        return node == null ? 0 : (i == -1 ? node.count : (find(node.child[0], num, i - 1) + (((num >> i) & 1) == 0 ? find(node.child[1], num, i - 1) : 0)));\\n    }\\n    public int countZeroAND(int num) {\\n        return find(this, num, 15);\\n    }\\n}\\npublic int countTriplets(int[] A) {\\n    Trie trie = new Trie();\\n    for(int a: A) for(int b: A) trie.add(a & b);\\n    int res = 0;\\n    for(int a: A) res += trie.countZeroAND(a);\\n    return res;\\n}\\n```\n```[L, R]```\n```A[i]```\n```[L, M]```\n```[M + 1, R]```\n```M = (L + R) / 2```\n```\\n// 29 ms. 97.78%\\nprivate int find(int[] count, int a, int i, int p) {\\n    return i == -1 ? count[p] : find(count, a, i - 1, p) + (((a >> i) & 1) == 0 ? find(count, a, i - 1, p + (1 << i)) : 0);\\n}\\npublic int countTriplets(int[] A) {\\n    int[] count = new int[1 << 16];\\n    for(int a: A) for(int b: A) count[a & b]++;\\n    int res = 0;\\n    for(int a: A) res += find(count, a, 15, 0);\\n    return res;\\n}\\n```\n```A[i]```\n```A[i]```\n```a```\n```A```\n```i```\n```a & i```\n```i```\n```a```\n```i```\n```\\n// 13 ms. 100%\\npublic int countTriplets(int[] A) {\\n    int[] count = new int[1 << 16];\\n    for(int a: A) for(int b: A) count[a & b]++;\\n    int res = 0;\\n    for(int a: A) for(int i = 0; i < count.length; i++) {\\n    \\tif((a & i) == 0) res += count[i];\\n    \\telse i += (a & i) - 1;\\n    }\\n    return res;\\n}\\n```\n```dp[i][j]```\n```i```\n```A```\n```j```\n```dp[3][0]```\n```A[i]```\n```dp[i + 1][j & A[k]] += dp[i][j]```\n```\\n// 357 ms. 52.22%\\npublic int countTriplets(int[] A) {\\n    int[] dp = new int[1 << 16];\\n    for(int a: A) dp[a]++;\\n    for(int i = 0; i < 2; i++) {\\n        int[] next = new int[dp.length];\\n        for(int a: A) for(int j = 0; j < dp.length; j++) next[a & j] += dp[j];\\n        dp = next;\\n    }\\n    return dp[0];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226832,
                "title": "fastest-solution-using-fast-walsh-hadamard-transform-32ms",
                "content": "*`O(n log n)`* where ***`n`*** is number of masks = *`2^16`*\\n\\nThe best part is that you can edit:\\n```cpp\\nfor(auto& x : b) x = x * x * x;\\n```\\nto\\n```cpp\\nfor(auto& x : b) x = pow(x, k);\\n```\\nif you want to choose ***`k`*** numbers\\n```cpp\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& a) {\\n        int n = a.size();\\n        vector<int> b(1 << 16); \\n        for(auto x : a) b[x]++;\\n        fwht(b, false);\\n        for(auto& x : b) x = x * x * x;\\n        fwht(b, true);\\n        return b[0];\\n    }\\n    \\n    void fwht(vector<int>& a, bool inv) {\\n        int n = a.size();\\n        for(int m = 1; 2 * m <= n; m *= 2) {\\n            for(int i = 0; i < n; i += 2 * m) {\\n                for(int j = 0; j < m; ++j) {\\n                    auto x = a[i + j];\\n                    auto y = a[i + j + m];\\n                    if(not inv) {\\n                        a[i + j] = y;\\n                        a[i + j + m] = x + y;\\n                    } else {                        \\n                        a[i + j] = -x + y;\\n                        a[i + j + m] = x;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nfor(auto& x : b) x = x * x * x;\\n```\n```cpp\\nfor(auto& x : b) x = pow(x, k);\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& a) {\\n        int n = a.size();\\n        vector<int> b(1 << 16); \\n        for(auto x : a) b[x]++;\\n        fwht(b, false);\\n        for(auto& x : b) x = x * x * x;\\n        fwht(b, true);\\n        return b[0];\\n    }\\n    \\n    void fwht(vector<int>& a, bool inv) {\\n        int n = a.size();\\n        for(int m = 1; 2 * m <= n; m *= 2) {\\n            for(int i = 0; i < n; i += 2 * m) {\\n                for(int j = 0; j < m; ++j) {\\n                    auto x = a[i + j];\\n                    auto y = a[i + j + m];\\n                    if(not inv) {\\n                        a[i + j] = y;\\n                        a[i + j + m] = x + y;\\n                    } else {                        \\n                        a[i + j] = -x + y;\\n                        a[i + j + m] = x;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227053,
                "title": "python3-solution-by-the-idea-of-venn-diagram-552-ms",
                "content": "I didn\\'t figure this problem out during contest and solved it after contest ends.\\nAfter went through discussion, it seems there is no similar solution, so here is the code.\\nIt might be not the fastest, hope you can find it helpful.\\n\\nbasic idea is:\\nsince our goal requires you to select three numbers and make sure there is at least one \"0\" in each bit\\'s three digits pool ( under binary form ). \\nthus we can convert this problem to be:  find the total count of combinations where each bit\\'s three digits pool is all \"1\".\\nfinally return N^3 - count\\n\\nsteps are as follows:\\n1. convert each number into binary\\n2. loop each column and collect row index in set once you meet a \"1\"\\n3. loop each column again and update Venn diagram, here I put an example here:\\n\\nsuppose input = [2, 4, 7, 3]\\nwe know that pool = [\"010\", \"100\", \"111\", \"011\"]\\nand one = {0: {1,2}, 1: {0,2,3}, 2: {2,3}}\\nVenn is initialized as defaultdict(list), and cnt = 0\\nnow we start to update Venn diagram:\\n\\nfirstly we are at j = 0\\ncnt becomes 2^3\\nVenn[1] = [ {1,2} ]\\n\\nthen we are at j = 1\\ncnt change from 2^3 to be 2^3 + 3^3 \\n(since we have three number with 1-th bit is \"1\", there is 3^3 combinations to fill three \"box\", however the intersection of 2^3 and 3^3 are counted twice, so we need to vanish the effect of intersection: one[0] & one[1] = {2} )\\ncnt change from 2^3 + 3^3 to be 2^3 + 3^3 - ( len( {2} ) )^3, it is 34\\nVenn[2] = [ {2} ] and Venn[1] = [ {1, 2}, {0,2,3} ]\\n\\nlastly, we are at j = 2\\ncnt change from 34 to 34 + 2^3 = 42\\nnext we remove the effect of intersecion between one[2] and each earlier set in Venn\\nfor Venn[1]: one[2] & {1,2} = {2} and one[2] & {0,2,3} = {2,3}, so cnt updates to be 42-1-8 = 33\\nfor Venn[2]: one[2] & {2} = {2}, so cnt updates to be 33 + 1 = 34 (pay attention to the \"+\" sign)\\nso finally, we return 4^3 - 34 = 30, that is what this problem requires.\\n\\nlast note:\\n1. for the sign problem above, for odd-th operation it is \"-\", for even-th operation it is \"+\", which follows the Venn Diagram rule. \\n2. for the order of updating, we can NOT update in ascending order, because when we are looping Venn[i], we are appending new results into Venn[i+1]. therefore we should use descending order when updating Venn dictionary.\\n\\ncode is here.\\nfor clear, I didn\\'t make it concise for example combining \"for\" loops etc.\\nthanks for your time, everyone.\\n```\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n\\t\\n        tmp = []\\n        maxlen = 0\\n        for a in A:\\n            tmp.append(bin(a)[2:])\\n            maxlen = max(maxlen, len(tmp[-1]))\\n        pool = []\\n        for s in tmp:\\n            extra = maxlen - len(s)\\n            pool.append(\\'0\\'*extra + s)\\n        \\n        row, col = len(pool), len(pool[0])\\n        one = collections.defaultdict(set)\\n        for j in range(col):\\n            for i in range(row):\\n                if pool[i][j] == \\'1\\':\\n                    one[j].add(i)\\n        \\n        Venn = collections.defaultdict(list)\\n        cnt = 0\\n        for j in range(col):\\n            if len(one[j]) != 0:\\n                cnt += (len(one[j]))**3\\n                for i in range(j, 0, -1):\\n                    for prv in Venn[i]:\\n                        intersec = prv & one[j]\\n                        if len(intersec) != 0:\\n                            cnt += ((-1)**i)*(len(intersec))**3\\n                            Venn[i+1].append(intersec)\\n                Venn[1].append(one[j])\\n        \\n        return row**3 - cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n\\t\\n        tmp = []\\n        maxlen = 0\\n        for a in A:\\n            tmp.append(bin(a)[2:])\\n            maxlen = max(maxlen, len(tmp[-1]))\\n        pool = []\\n        for s in tmp:\\n            extra = maxlen - len(s)\\n            pool.append(\\'0\\'*extra + s)\\n        \\n        row, col = len(pool), len(pool[0])\\n        one = collections.defaultdict(set)\\n        for j in range(col):\\n            for i in range(row):\\n                if pool[i][j] == \\'1\\':\\n                    one[j].add(i)\\n        \\n        Venn = collections.defaultdict(list)\\n        cnt = 0\\n        for j in range(col):\\n            if len(one[j]) != 0:\\n                cnt += (len(one[j]))**3\\n                for i in range(j, 0, -1):\\n                    for prv in Venn[i]:\\n                        intersec = prv & one[j]\\n                        if len(intersec) != 0:\\n                            cnt += ((-1)**i)*(len(intersec))**3\\n                            Venn[i+1].append(intersec)\\n                Venn[1].append(one[j])\\n        \\n        return row**3 - cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226942,
                "title": "c-28ms-beat-100",
                "content": "Steps:\\n1. Using vector to store the occurrence of the first 2 value\\'s AND result (A[i] & A[j]).\\n2. For all A[k], check all values between 0 and (1 << 16).\\n3. If the value AND A[k] is equal to 0, then add the occurrence of this value from step 1 to result.\\n\\nTrick:\\nWe don\\'t have to go through (0 ~ 1 << 16) to find the answer.\\nIf (A[k] & X) != 0, we can skip next (A[i] & X) -1 values and still get correct result.\\n\\nFor example: Assume A[k] is 0x11000 and X is 0x1000. Obviously, the next (0x1000 - 1) values (0x1001 to 0x1111) will not meet the requirement.\\n\\nThanks [firejox](https://leetcode.com/firejox/), he made an improevement to reduce the time to 12ms.\\n\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int i, j;\\n        int N = A.size();\\n        int Result = 0;\\n        \\n        vector<int> Map(1 << 16);\\n        \\n        for(i = 0; i < N; i++)\\n        {\\n            for(j = 0; j < N; j++)\\n            {\\n                Map[(A[i] & A[j])]++;\\n            }\\n        }\\n        \\n        for(i = 0; i < N; i++)\\n        {\\n            for(j = 0; j < (1 << 16); j++)\\n            {\\n                if((A[i] & j) == 0)\\n                {\\n                    Result += Map[j];\\n                }\\n                else\\n                {\\n                    j += (A[i] & j) - 1;\\n                }\\n            }\\n        }\\n        \\n        return Result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int i, j;\\n        int N = A.size();\\n        int Result = 0;\\n        \\n        vector<int> Map(1 << 16);\\n        \\n        for(i = 0; i < N; i++)\\n        {\\n            for(j = 0; j < N; j++)\\n            {\\n                Map[(A[i] & A[j])]++;\\n            }\\n        }\\n        \\n        for(i = 0; i < N; i++)\\n        {\\n            for(j = 0; j < (1 << 16); j++)\\n            {\\n                if((A[i] & j) == 0)\\n                {\\n                    Result += Map[j];\\n                }\\n                else\\n                {\\n                    j += (A[i] & j) - 1;\\n                }\\n            }\\n        }\\n        \\n        return Result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274752,
                "title": "java-solution-using-map",
                "content": "```java\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i : A) {\\n            for(int j : A) {\\n                map.put(i&j, map.getOrDefault(i&j, 0)+1);\\n            }\\n        }\\n        int res = 0;\\n        for(int k : A) {\\n            for(int key : map.keySet()) {\\n                if((key & k) == 0) {\\n                    res+= map.get(key);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i : A) {\\n            for(int j : A) {\\n                map.put(i&j, map.getOrDefault(i&j, 0)+1);\\n            }\\n        }\\n        int res = 0;\\n        for(int k : A) {\\n            for(int key : map.keySet()) {\\n                if((key & k) == 0) {\\n                    res+= map.get(key);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829812,
                "title": "c-inclusion-exclusion-100-12ms-o-2-16-n",
                "content": "Idea: Instead of finding {i, j, k} with (a[i] & a[j] & a[k]) = 0, try to find {i, j, k} with (a[i] & a[j] & a[k]) != 0 and subtract it from total number of triplets.\\n\\nReferences: \\nInclusion Exclusion: https://cp-algorithms.com/combinatorics/inclusion-exclusion.html\\nSubmask Enumeration: https://cp-algorithms.com/algebra/all-submasks.html\\n\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& a) {\\n        int n = a.size(), ans = 0, c[1 << 16];\\n        memset(c, 0, sizeof(c));\\n        for (int i = 0; i < n; i++)\\n            for (int j = a[i]; j > 0; j = (j - 1) & a[i])\\n                c[j]++;\\n        for (int i = 1; i < (1 << 16); i++)\\n            if (__builtin_popcount(i) & 1)\\n                ans += c[i] * c[i] * c[i];\\n            else\\n                ans -= c[i] * c[i] * c[i];\\n        ans = n * n * n - ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& a) {\\n        int n = a.size(), ans = 0, c[1 << 16];\\n        memset(c, 0, sizeof(c));\\n        for (int i = 0; i < n; i++)\\n            for (int j = a[i]; j > 0; j = (j - 1) & a[i])\\n                c[j]++;\\n        for (int i = 1; i < (1 << 16); i++)\\n            if (__builtin_popcount(i) & 1)\\n                ans += c[i] * c[i] * c[i];\\n            else\\n                ans -= c[i] * c[i] * c[i];\\n        ans = n * n * n - ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226655,
                "title": "this-is-too-easy",
                "content": "```\\nclass Solution {\\n    //tc : n cubed\\n    public int countTriplets(int[] A) {\\n        int count = 0;\\n        Arrays.sort(A);\\n        for (int i = 0 ; i < A.length; i++) {\\n            for (int j = i; j < A.length; j++) {\\n                int tmp = A[i] & A[j];\\n                for (int k = j; k < A.length; k++) {\\n                    int re = tmp & A[k];\\n                    if (re == 0) {\\n                        if (i == j && j == k) {\\n                            count += 1;\\n                        } else if (i == j || i == k || j == k) {\\n                            count += 3;\\n                        } else {\\n                            count += 6;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //tc : n cubed\\n    public int countTriplets(int[] A) {\\n        int count = 0;\\n        Arrays.sort(A);\\n        for (int i = 0 ; i < A.length; i++) {\\n            for (int j = i; j < A.length; j++) {\\n                int tmp = A[i] & A[j];\\n                for (int k = j; k < A.length; k++) {\\n                    int re = tmp & A[k];\\n                    if (re == 0) {\\n                        if (i == j && j == k) {\\n                            count += 1;\\n                        } else if (i == j || i == k || j == k) {\\n                            count += 3;\\n                        } else {\\n                            count += 6;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227198,
                "title": "n-2-dp-c-solution-beats-100-0-of-all-submissions-28ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n\\t\\n        int n = A.size();\\n            \\n        vector<int> cnt(1 << 16, 0);\\n        for(int i = 0; i < n; ++i) cnt[A[i]]++; //inital counts of supermasks of (i)\\n        \\n\\t\\t//counting all the submasks for a given supermask (i) by removing one bit at a time\\n        int mx = 1 << 16;\\n        for(int bit = 0; bit < 16; ++bit){\\n            int bit_to_remove = 1 << bit;\\n            for(int i = bit_to_remove; i < mx; i++){\\n                if((i >> bit) & 1) // if (i) has this bit set to 1\\n                    cnt[i] += cnt[i ^ bit_to_remove]; // try removing this set bit and adding the number of ALREADY CALCULATED submasks to the current supermask (i)\\n            }\\n        }\\n        \\n\\t\\t//just collecting up the answer after deciding on the first two elements (i, j) from their calculated complementary mask.\\n        int res = 0;\\n        for(int i = 0; i < n; ++i){\\n            for(int j = 0; j < n; ++j){\\n                int mask = A[i] & A[j];\\n                // int req_msk = (~mask) & ((1 << 16) - 1);  //or use this\\n                int req_msk = mask ^ ((1 << 16) - 1);\\n                res += cnt[req_msk];        \\n            }\\n        }\\n        \\n        return res; // result ^_^\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n\\t\\n        int n = A.size();\\n            \\n        vector<int> cnt(1 << 16, 0);\\n        for(int i = 0; i < n; ++i) cnt[A[i]]++; //inital counts of supermasks of (i)\\n        \\n\\t\\t//counting all the submasks for a given supermask (i) by removing one bit at a time\\n        int mx = 1 << 16;\\n        for(int bit = 0; bit < 16; ++bit){\\n            int bit_to_remove = 1 << bit;\\n            for(int i = bit_to_remove; i < mx; i++){\\n                if((i >> bit) & 1) // if (i) has this bit set to 1\\n                    cnt[i] += cnt[i ^ bit_to_remove]; // try removing this set bit and adding the number of ALREADY CALCULATED submasks to the current supermask (i)\\n            }\\n        }\\n        \\n\\t\\t//just collecting up the answer after deciding on the first two elements (i, j) from their calculated complementary mask.\\n        int res = 0;\\n        for(int i = 0; i < n; ++i){\\n            for(int j = 0; j < n; ++j){\\n                int mask = A[i] & A[j];\\n                // int req_msk = (~mask) & ((1 << 16) - 1);  //or use this\\n                int req_msk = mask ^ ((1 << 16) - 1);\\n                res += cnt[req_msk];        \\n            }\\n        }\\n        \\n        return res; // result ^_^\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226977,
                "title": "leetcode-weekly-contest-121-screencast",
                "content": "https://www.youtube.com/watch?v=_yWUAJ0LmZE&t=966s\\n\\nNot doing good this time. Made some stupid mistake on Problem 2. I break down a get method for nested data structure into two statements, but used copy instead of reference. It took me some time to realize that. Hope you can learn something from my lessons.",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=_yWUAJ0LmZE&t=966s\\n\\nNot doing good this time. Made some stupid mistake on Problem 2. I break down a get method for nested data structure into two statements, but used copy instead of reference. It took me some time to realize that. Hope you can learn something from my lessons.",
                "codeTag": "Unknown"
            },
            {
                "id": 226700,
                "title": "succinct-c-dp-solution-with-explanation",
                "content": "dp[0][j] means the number of **single numbers** whose result is j\\ndp[1][j] means the number of **pairs** whose result is j\\ndp[2][j] means the number of **triples** whose result is j\\nthus the final answer = dp[2][0].\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        vector<vector<int>> dp(3, vector<int>(1<<16, 0));\\n        for (const int a: A) {\\n            dp[0][a]++;\\n        }\\n        for (int i = 1; i < 3; ++i) {\\n            for (const int a: A) {\\n                for (int b = 0; b < 1<<16; ++b) {\\n                    dp[i][a&b] += dp[i-1][b];\\n                }\\n            }\\n        }\\n        return dp[2][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        vector<vector<int>> dp(3, vector<int>(1<<16, 0));\\n        for (const int a: A) {\\n            dp[0][a]++;\\n        }\\n        for (int i = 1; i < 3; ++i) {\\n            for (const int a: A) {\\n                for (int b = 0; b < 1<<16; ++b) {\\n                    dp[i][a&b] += dp[i-1][b];\\n                }\\n            }\\n        }\\n        return dp[2][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866848,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxChunksToSorted(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n       vector<int>filled(arr.size(),0);\\n        for(int i=0;i<n;i++){\\n            filled[arr[i]]++;\\n                    int cnt=0;\\n                for(int j=0;j<=i;j++){\\n                    cnt+=filled[j];\\n                }\\n                if(cnt==i+1)ans++;\\n            \\n        }\\n\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxChunksToSorted(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n       vector<int>filled(arr.size(),0);\\n        for(int i=0;i<n;i++){\\n            filled[arr[i]]++;\\n                    int cnt=0;\\n                for(int j=0;j<=i;j++){\\n                    cnt+=filled[j];\\n                }\\n                if(cnt==i+1)ans++;\\n            \\n        }\\n\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226671,
                "title": "straightforward-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        const int n = nums.size();\\n        int count = 0;\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                ++m[nums[i] & nums[j]];\\n            }\\n        }\\n        for (int k = 0; k < n; ++k) {\\n            for (auto& mm : m) {\\n                if ((nums[k] & mm.first) == 0) count += mm.second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        const int n = nums.size();\\n        int count = 0;\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                ++m[nums[i] & nums[j]];\\n            }\\n        }\\n        for (int k = 0; k < n; ++k) {\\n            for (auto& mm : m) {\\n                if ((nums[k] & mm.first) == 0) count += mm.second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347809,
                "title": "c-map-time-o-n-n-easy-to-understand-short-sweet-code",
                "content": "````\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums){\\n            for(auto &j: nums){\\n                mp[i&j]++;\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &i: nums){\\n            for(auto &j: mp){\\n                if((i&j.first)==0)ans += j.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums){\\n            for(auto &j: nums){\\n                mp[i&j]++;\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &i: nums){\\n            for(auto &j: mp){\\n                if((i&j.first)==0)ans += j.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257470,
                "title": "python3-hash-table",
                "content": "\\n```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        freq = defaultdict(int)\\n        for x in nums: \\n            for y in nums: \\n                freq[x&y] += 1\\n        \\n        ans = 0\\n        for x in nums: \\n            mask = x = x ^ 0xffff\\n            while x: \\n                ans += freq[x]\\n                x = mask & (x-1)\\n            ans += freq[0]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        freq = defaultdict(int)\\n        for x in nums: \\n            for y in nums: \\n                freq[x&y] += 1\\n        \\n        ans = 0\\n        for x in nums: \\n            mask = x = x ^ 0xffff\\n            while x: \\n                ans += freq[x]\\n                x = mask & (x-1)\\n            ans += freq[0]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 228384,
                "title": "java-trie-solution-o-n-2",
                "content": "First compute every a & b and store it in Trie. Then for each element of array do the DFS on the Trie comparing bits - if 0 you can go both 1 and 0 paths in the Trie, if 1 you can go only 0 path.\\n```\\npublic int countTriplets(int[] A) {\\n        Node root = new Node();\\n        int count = 0;\\n        for(int a1: A) {\\n            for(int a2: A) {\\n                Node.add(a1 & a2, root);\\n            }\\n        }\\n        for(int a: A) {\\n            count += Node.sum(a, root, 0);\\n        }\\n        return count;\\n    }\\n\\n    static class Node {\\n        Node zero;\\n        Node one;\\n        int count;\\n\\t\\t\\n        public static void add(int n, Node root) {\\n            Node curr = root;\\n            for(int i = 0; i < 16; i++) {\\n                if(n % 2 == 0) { //curr bit is zero\\n                    if(curr.zero == null) {\\n                        curr.zero = new Node();\\n                    }\\n                    curr = curr.zero;\\n                } else {\\n                    if(curr.one == null) {\\n                        curr.one = new Node();\\n                    }\\n                    curr = curr.one;\\n                }\\n                n >>>= 1;\\n            }\\n            curr.count++;\\n        }\\n\\n        public static int sum(int n, Node node, int depth) {\\n            if(depth == 16) {\\n                return node.count;\\n            }\\n            int res = 0;\\n            if(n % 2 == 0) {\\n                if(node.zero != null) {\\n                    res += sum(n >>> 1, node.zero, depth + 1);\\n                }\\n                if(node.one != null) {\\n                    res += sum(n >>> 1, node.one, depth + 1);\\n                }\\n            } else {\\n                if(node.zero != null) {\\n                    res += sum(n >>> 1, node.zero, depth + 1);\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\npublic int countTriplets(int[] A) {\\n        Node root = new Node();\\n        int count = 0;\\n        for(int a1: A) {\\n            for(int a2: A) {\\n                Node.add(a1 & a2, root);\\n            }\\n        }\\n        for(int a: A) {\\n            count += Node.sum(a, root, 0);\\n        }\\n        return count;\\n    }\\n\\n    static class Node {\\n        Node zero;\\n        Node one;\\n        int count;\\n\\t\\t\\n        public static void add(int n, Node root) {\\n            Node curr = root;\\n            for(int i = 0; i < 16; i++) {\\n                if(n % 2 == 0) { //curr bit is zero\\n                    if(curr.zero == null) {\\n                        curr.zero = new Node();\\n                    }\\n                    curr = curr.zero;\\n                } else {\\n                    if(curr.one == null) {\\n                        curr.one = new Node();\\n                    }\\n                    curr = curr.one;\\n                }\\n                n >>>= 1;\\n            }\\n            curr.count++;\\n        }\\n\\n        public static int sum(int n, Node node, int depth) {\\n            if(depth == 16) {\\n                return node.count;\\n            }\\n            int res = 0;\\n            if(n % 2 == 0) {\\n                if(node.zero != null) {\\n                    res += sum(n >>> 1, node.zero, depth + 1);\\n                }\\n                if(node.one != null) {\\n                    res += sum(n >>> 1, node.one, depth + 1);\\n                }\\n            } else {\\n                if(node.zero != null) {\\n                    res += sum(n >>> 1, node.zero, depth + 1);\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217427,
                "title": "top-down-dp-2-improvized-iterative-solution-with-map-dp",
                "content": "**Top-Down(Recursive+Memo-Dp):**\\n# \\n```\\nclass Solution {\\n    Integer dp[][]=new Integer[3][1<<16];\\n    int find(int nums[],int num,int count){\\n        if(count==2)return num==0 ? 1 : 0;\\n        if(count>2)return 0;\\n        if(dp[count][num]!=null)return dp[count][num];\\n        int res=0;\\n        for(int i=0;i<nums.length;i++)\\n            res+=find(nums,num&nums[i],count+1);\\n         return dp[count][num]=res;        \\n    }\\n    \\n    public int countTriplets(int[] nums) {\\n        int count=0;\\n        for(int num : nums)count+=find(nums,num,0);\\n        return count;        \\n    }\\n}\\n```\\n\\n**1st-Iterative-Solution:** Time: O(n^3) Space : O(1) \\n                                             TLE at leetcode:\\n# \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n```\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n            for(int j=0;j<nums.length;j++)\\n                for(int k=0;k<nums.length;k++)if((nums[i]&nums[j]&nums[k])==0)count++;\\n        return count;\\n    }\\n}\\n```\\n**2nd-improvized-Solution:** Time : O(n^2)\\n                                                    Space : O(n)\\n# \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int count=0;\\n        Map<Integer,Integer>dp=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n            for(int j=0;j<nums.length;j++)\\n                dp.put(nums[i]&nums[j],dp.getOrDefault(nums[i]&nums[j],0)+1);\\n        for(Map.Entry<Integer,Integer>m : dp.entrySet())\\n            for(int num :  nums) if(((int)(m.getKey()&num))==0)count+=m.getValue();\\n        return count;\\n                \\n    }\\n}\\n```\\n***Please,Upvote if this is helpful***\\n**Please,Upvote or comment if u like this trick of conversion O(n^3) to O(n^2)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer dp[][]=new Integer[3][1<<16];\\n    int find(int nums[],int num,int count){\\n        if(count==2)return num==0 ? 1 : 0;\\n        if(count>2)return 0;\\n        if(dp[count][num]!=null)return dp[count][num];\\n        int res=0;\\n        for(int i=0;i<nums.length;i++)\\n            res+=find(nums,num&nums[i],count+1);\\n         return dp[count][num]=res;        \\n    }\\n    \\n    public int countTriplets(int[] nums) {\\n        int count=0;\\n        for(int num : nums)count+=find(nums,num,0);\\n        return count;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n            for(int j=0;j<nums.length;j++)\\n                for(int k=0;k<nums.length;k++)if((nums[i]&nums[j]&nums[k])==0)count++;\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int count=0;\\n        Map<Integer,Integer>dp=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n            for(int j=0;j<nums.length;j++)\\n                dp.put(nums[i]&nums[j],dp.getOrDefault(nums[i]&nums[j],0)+1);\\n        for(Map.Entry<Integer,Integer>m : dp.entrySet())\\n            for(int num :  nums) if(((int)(m.getKey()&num))==0)count+=m.getValue();\\n        return count;\\n                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603568,
                "title": "greedy-solution-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        unordered_map<int,int> mp;\\n        for(auto a:A){\\n            for(auto b:A){\\n                mp[a&b]++;\\n            }\\n        }\\n        int res=0;\\n        for(auto a:A){\\n            for(auto t:mp){\\n                if((a&t.first)==0){\\n                    res+=t.second;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        unordered_map<int,int> mp;\\n        for(auto a:A){\\n            for(auto b:A){\\n                mp[a&b]++;\\n            }\\n        }\\n        int res=0;\\n        for(auto a:A){\\n            for(auto t:mp){\\n                if((a&t.first)==0){\\n                    res+=t.second;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226745,
                "title": "python-o-n-3-with-counter",
                "content": "```\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n        N = len(A)\\n        ans = 0\\n        count = collections.Counter()\\n\\n        for i in range(N):\\n            for j in range(N):\\n                count[A[i]&A[j]] += 1\\n                \\n        for k in range(N):\\n            for v in count:\\n                if A[k] & v == 0:\\n                    ans += count[v]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n        N = len(A)\\n        ans = 0\\n        count = collections.Counter()\\n\\n        for i in range(N):\\n            for j in range(N):\\n                count[A[i]&A[j]] += 1\\n                \\n        for k in range(N):\\n            for v in count:\\n                if A[k] & v == 0:\\n                    ans += count[v]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066364,
                "title": "fast-java-solution-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this problem is to count the number of triplets in an array of integers that satisfy a certain condition. My first thought would be to use nested loops to iterate through all possible triplets and check if they satisfy the condition, but this would have a high time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne approach to solve this problem could be to use a counting array to count the number of pairs of integers in the array that satisfy a certain condition, and then use another nested loop to iterate through the array again and check for the presence of a third element that, when combined with a pair from the counting array, satisfies the condition.\\n# Complexity\\n- Time complexity:  $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we are using 2 nested loops to check all possible pairs of integers in the array and also using another nested loop to check the presence of a third element that, when combined with a pair from the counting array, satisfies the condition.\\n- Space complexity: $$O(2^16)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(2^16) because we are using a counting array of size 2^16 to count the number of pairs of integers in the array that satisfy a certain condition.\\n# Code\\n```\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int[] count = new int[1 << 16];\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                count[nums[i] & nums[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < 1 << 16; j++) {\\n                if ((nums[i] & j) == 0) {\\n                    ans += count[j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int[] count = new int[1 << 16];\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                count[nums[i] & nums[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < 1 << 16; j++) {\\n                if ((nums[i] & j) == 0) {\\n                    ans += count[j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011874,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTriplets(self, nums):\\n        n, total, dict1 = len(nums), 0, collections.Counter(x&y for x in nums for y in nums)\\n\\n        for i in nums:\\n            for j in dict1:\\n                if i&j == 0:\\n                    total += dict1[j]\\n\\n        return total\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, nums):\\n        n, total, dict1 = len(nums), 0, collections.Counter(x&y for x in nums for y in nums)\\n\\n        for i in nums:\\n            for j in dict1:\\n                if i&j == 0:\\n                    total += dict1[j]\\n\\n        return total\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608414,
                "title": "java-solution-brute-force-to-optimized-three-approaches",
                "content": "```\\n// Brute Force Approach \\n\\n\\n\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        \\n        int res = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j =0;j<nums.length;j++){\\n                for(int k = 0;k<nums.length;k++){\\n                    if((nums[i]&nums[j]&nums[k])==0) res++;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n\\n// some little optimization \\n\\n\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        \\n        int res = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j =i;j<nums.length;j++){\\n                for(int k = j;k<nums.length;k++){\\n                    if((nums[i]&nums[j]&nums[k])==0)\\n                    {\\n                        \\n                        if(i == j && j ==k)\\n                            res++;\\n                        else if(i==j || i==k || j==k)\\n                            res+=3;\\n                        else\\n                            res+=6;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n\\n// more optimization \\n\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        \\n        int res = 0;\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i =0;i<nums.length;i++){\\n            for(int j = 0;j<nums.length;j++){\\n                int and  =  nums[i]&nums[j] ;\\n                map.put(and,map.getOrDefault(and,0)+1);\\n            }\\n        }\\n        \\n        \\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            for(int i :nums){\\n                if((key&i)==0)\\n                    res+=value;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Brute Force Approach \\n\\n\\n\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        \\n        int res = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j =0;j<nums.length;j++){\\n                for(int k = 0;k<nums.length;k++){\\n                    if((nums[i]&nums[j]&nums[k])==0) res++;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n\\n// some little optimization \\n\\n\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        \\n        int res = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j =i;j<nums.length;j++){\\n                for(int k = j;k<nums.length;k++){\\n                    if((nums[i]&nums[j]&nums[k])==0)\\n                    {\\n                        \\n                        if(i == j && j ==k)\\n                            res++;\\n                        else if(i==j || i==k || j==k)\\n                            res+=3;\\n                        else\\n                            res+=6;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n\\n// more optimization \\n\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        \\n        int res = 0;\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i =0;i<nums.length;i++){\\n            for(int j = 0;j<nums.length;j++){\\n                int and  =  nums[i]&nums[j] ;\\n                map.put(and,map.getOrDefault(and,0)+1);\\n            }\\n        }\\n        \\n        \\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            for(int i :nums){\\n                if((key&i)==0)\\n                    res+=value;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060295,
                "title": "easy-cpp-solution-explained",
                "content": "**O(2^16*N)**\\n\\n**Here we choosen 16 beacause in question they had given 2^16 as maximum number. First we store bit and operation for first two numbers nums[i]&nums[j] then later in second for loop we are going to check for number nums[k] if it returns zero then we store number of times that operation taken place by storing it in Vector of bits**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        \\n        int mem[1<<16]={};\\n        \\n        int n(nums.size());\\n        \\n        for( int i=0;i<n;i++ ){\\n            for( int j=0;j<n;j++){\\n                mem[ nums[i]&nums[j] ]++;\\n            }\\n        }\\n         \\n        int ans(0);\\n        \\n        for( int k=0;k<n;k++ ){\\n            for( int ij=0;ij<(1<<16);ij++){\\n                \\n                if( (nums[k]&ij)==0 ){\\n                    ans+=mem[ij];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n\\n        \\n    }\\n};\\n```\\n\\n\\n```\\nIf you dont understand any thing feel free to leave comments and please upvote\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        \\n        int mem[1<<16]={};\\n        \\n        int n(nums.size());\\n        \\n        for( int i=0;i<n;i++ ){\\n            for( int j=0;j<n;j++){\\n                mem[ nums[i]&nums[j] ]++;\\n            }\\n        }\\n         \\n        int ans(0);\\n        \\n        for( int k=0;k<n;k++ ){\\n            for( int ij=0;ij<(1<<16);ij++){\\n                \\n                if( (nums[k]&ij)==0 ){\\n                    ans+=mem[ij];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n\\n        \\n    }\\n};\\n```\n```\\nIf you dont understand any thing feel free to leave comments and please upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836004,
                "title": "c-dp-top-down-easy",
                "content": "Bottom-up DP is always faster but for those who prefer top-down DP:\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t int v[4][1000000];                                     //v[level][calculated value till this level]\\n\\t\\tint recur(vector<int>&n,int lev,int cur){ \\n\\t\\t\\t// base cases\\n\\t\\t\\t if(lev>3){return 0;}\\n\\t\\t\\t if(lev==3 && cur==0){return 1;}                    //if AND triplet value is 0 at level 3\\n\\t\\t\\tif(v[lev][cur]!=-1){return v[lev][cur];}  \\n\\t\\t\\tif(lev<3 && cur==0){return v[lev][cur]=pow(n.size(),3-lev);} //if at any point AND triplet value equals 0,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //all substrees return constant value\\n\\n\\t\\t\\t//explore possible routes\\n\\t\\t\\tint i,sum=0;       \\n\\t\\t\\tfor(i=0;i<n.size();i++){\\n\\t\\t\\t\\tif(lev==0){sum+=recur(n,lev+1,n[i]);}\\n\\t\\t\\t\\telse {sum+=recur(n,lev+1,cur&n[i]);}\\n\\t\\t\\t}        \\n\\t\\t\\treturn v[lev][cur]=sum; //memoize        \\n\\t\\t}  \\n\\n\\t\\tint countTriplets(vector<int>& n) { \\t\\t\\n\\t\\t\\tmemset(v,-1,sizeof(v));      \\n\\t\\t\\treturn recur(n,0,1);        \\n\\t\\t}\\n\\t};\\n\\n![image](https://assets.leetcode.com/users/images/b89ace8d-8391-428f-95d2-c6fe973421de_1646895707.567185.png)\\n\\n__________________________________________________________________________________________________________________________\\nPlease upvote if you liked it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t int v[4][1000000];                                     //v[level][calculated value till this level]\\n\\t\\tint recur(vector<int>&n,int lev,int cur){ \\n\\t\\t\\t// base cases\\n\\t\\t\\t if(lev>3){return 0;}",
                "codeTag": "Java"
            },
            {
                "id": 1750934,
                "title": "this-should-be-an-easy-easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& a) {\\n        int  n = a.size();\\n        unordered_map<int,int> mp;\\n        for(int  i= 0;i<n;i++)\\n        {\\n            for(int  j= 0;j<n;j++)\\n            {\\n               mp[(a[i] & a[j])]++;\\n            }\\n        }\\n        int ans  = 0;\\n        for(auto &op : mp)\\n        {\\n            for(int  i = 0;i<n;i++)\\n            {\\n                if(op.first & a[i])\\n                {}\\n                else\\n                {ans+=op.second;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& a) {\\n        int  n = a.size();\\n        unordered_map<int,int> mp;\\n        for(int  i= 0;i<n;i++)\\n        {\\n            for(int  j= 0;j<n;j++)\\n            {\\n               mp[(a[i] & a[j])]++;\\n            }\\n        }\\n        int ans  = 0;\\n        for(auto &op : mp)\\n        {\\n            for(int  i = 0;i<n;i++)\\n            {\\n                if(op.first & a[i])\\n                {}\\n                else\\n                {ans+=op.second;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251000,
                "title": "easy-c-soln-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[(1<<16)+1][4];\\n    int sol(vector<int>& nums, int count, int cur){\\n        if(count==4){return cur==0;}\\n        if(dp[cur][count]!=-1)return dp[cur][count];\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans+=sol(nums,count+1,(cur&nums[i]));\\n        }\\n                     return dp[cur][count]=ans;\\n    }\\n    int countTriplets(vector<int>& nums) {\\n        memset(dp,-1,sizeof dp);\\n        return sol(nums,1,pow(2,16)-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[(1<<16)+1][4];\\n    int sol(vector<int>& nums, int count, int cur){\\n        if(count==4){return cur==0;}\\n        if(dp[cur][count]!=-1)return dp[cur][count];\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans+=sol(nums,count+1,(cur&nums[i]));\\n        }\\n                     return dp[cur][count]=ans;\\n    }\\n    int countTriplets(vector<int>& nums) {\\n        memset(dp,-1,sizeof dp);\\n        return sol(nums,1,pow(2,16)-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687358,
                "title": "c-well-commented-naive-solution-o-n-n-n-2-16",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        \\n        //mp array stores the frequency of andValue of pairs of the array A\\n        int mp[1<<16];\\n        \\n        //initializing the array by zero\\n        memset(mp,0,sizeof(mp));\\n        \\n        //two nested loops to find andValue of all the pairs\\n        for(int i=0;i<A.size();i++){\\n            for(int j=0;j<A.size();j++){\\n                mp[A[i]&A[j]]++;\\n            }\\n        }\\n        \\n        long long ans=0;\\n        \\n        //For all the values of the array check its and with all possible andValues (which are 0 to 1<<16) if the and is zero add the frequency of that particular value to answer\\n        for(int n=0;n<A.size();n++){\\n            for(int i=0;i<(1<<16);i++){\\n                if((A[n]&i)==0){\\n                        ans=ans+mp[i];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        \\n        //mp array stores the frequency of andValue of pairs of the array A\\n        int mp[1<<16];\\n        \\n        //initializing the array by zero\\n        memset(mp,0,sizeof(mp));\\n        \\n        //two nested loops to find andValue of all the pairs\\n        for(int i=0;i<A.size();i++){\\n            for(int j=0;j<A.size();j++){\\n                mp[A[i]&A[j]]++;\\n            }\\n        }\\n        \\n        long long ans=0;\\n        \\n        //For all the values of the array check its and with all possible andValues (which are 0 to 1<<16) if the and is zero add the frequency of that particular value to answer\\n        for(int n=0;n<A.size();n++){\\n            for(int i=0;i<(1<<16);i++){\\n                if((A[n]&i)==0){\\n                        ans=ans+mp[i];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650023,
                "title": "sum-over-subsets-dp-o-n-n-2-16-16",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int MAX=(1<<16)-1;\\n        int dp[MAX+1];\\n        memset(dp,0,sizeof(dp));\\n        for(auto i:A){\\n            dp[i]++;\\n        }\\n        for(int i=0;i<16;i++){\\n            for(int j=0;j<=MAX;j++){\\n                if((1<<i)&j){\\n                    dp[j]+=dp[j^(1<<i)];\\n                }\\n            }\\n        }\\n        int tot=0;\\n        int n=(int)A.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int num=A[i]&A[j];\\n                num=num^MAX;\\n                tot+=dp[num];\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int MAX=(1<<16)-1;\\n        int dp[MAX+1];\\n        memset(dp,0,sizeof(dp));\\n        for(auto i:A){\\n            dp[i]++;\\n        }\\n        for(int i=0;i<16;i++){\\n            for(int j=0;j<=MAX;j++){\\n                if((1<<i)&j){\\n                    dp[j]+=dp[j^(1<<i)];\\n                }\\n            }\\n        }\\n        int tot=0;\\n        int n=(int)A.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int num=A[i]&A[j];\\n                num=num^MAX;\\n                tot+=dp[num];\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243036,
                "title": "2-line-python-solution",
                "content": "```python\\ndef countTriplets(self, A):\\n\\tcombo = collections.Counter(x&y for x in A for y in A)\\n\\treturn sum(combo[k] for z in A for k in combo if z&k == 0)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef countTriplets(self, A):\\n\\tcombo = collections.Counter(x&y for x in A for y in A)\\n\\treturn sum(combo[k] for z in A for k in combo if z&k == 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3534582,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        int table[1<<16] = {0};\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            ++table[nums[i]];\\n            for (int j = i+1; j < n; ++j) {\\n                table[nums[i]&nums[j]]+= 2;\\n            }\\n        }\\n        int res = 0;\\n        for (int i: nums) {\\n            i = i ^ 0xffff;\\n            for (int j = i; j; j = (j-1)&i) {\\n                res += table[j];\\n            }\\n            res += table[0];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n\\t\\n        tmp = []\\n        maxlen = 0\\n        for a in A:\\n            tmp.append(bin(a)[2:])\\n            maxlen = max(maxlen, len(tmp[-1]))\\n        pool = []\\n        for s in tmp:\\n            extra = maxlen - len(s)\\n            pool.append(\\'0\\'*extra + s)\\n        \\n        row, col = len(pool), len(pool[0])\\n        one = collections.defaultdict(set)\\n        for j in range(col):\\n            for i in range(row):\\n                if pool[i][j] == \\'1\\':\\n                    one[j].add(i)\\n        \\n        Venn = collections.defaultdict(list)\\n        cnt = 0\\n        for j in range(col):\\n            if len(one[j]) != 0:\\n                cnt += (len(one[j]))**3\\n                for i in range(j, 0, -1):\\n                    for prv in Venn[i]:\\n                        intersec = prv & one[j]\\n                        if len(intersec) != 0:\\n                            cnt += ((-1)**i)*(len(intersec))**3\\n                            Venn[i+1].append(intersec)\\n                Venn[1].append(one[j])\\n        \\n        return row**3 - cnt\\n```\\n\\n```Java []\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        int N = 1;\\n        while (N <= max) {\\n            N <<= 1;\\n        }\\n        int[] cnt = new int[N];\\n        for (int x : nums) {\\n            for (int y : nums) {\\n                cnt[x & y]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int num : nums) {\\n            int subset = num ^ (N - 1);\\n            ans += cnt[0];\\n            for (int i = subset; i > 0; i = subset & (i - 1)) {\\n                ans += cnt[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        int table[1<<16] = {0};\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            ++table[nums[i]];\\n            for (int j = i+1; j < n; ++j) {\\n                table[nums[i]&nums[j]]+= 2;\\n            }\\n        }\\n        int res = 0;\\n        for (int i: nums) {\\n            i = i ^ 0xffff;\\n            for (int j = i; j; j = (j-1)&i) {\\n                res += table[j];\\n            }\\n            res += table[0];\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n\\t\\n        tmp = []\\n        maxlen = 0\\n        for a in A:\\n            tmp.append(bin(a)[2:])\\n            maxlen = max(maxlen, len(tmp[-1]))\\n        pool = []\\n        for s in tmp:\\n            extra = maxlen - len(s)\\n            pool.append(\\'0\\'*extra + s)\\n        \\n        row, col = len(pool), len(pool[0])\\n        one = collections.defaultdict(set)\\n        for j in range(col):\\n            for i in range(row):\\n                if pool[i][j] == \\'1\\':\\n                    one[j].add(i)\\n        \\n        Venn = collections.defaultdict(list)\\n        cnt = 0\\n        for j in range(col):\\n            if len(one[j]) != 0:\\n                cnt += (len(one[j]))**3\\n                for i in range(j, 0, -1):\\n                    for prv in Venn[i]:\\n                        intersec = prv & one[j]\\n                        if len(intersec) != 0:\\n                            cnt += ((-1)**i)*(len(intersec))**3\\n                            Venn[i+1].append(intersec)\\n                Venn[1].append(one[j])\\n        \\n        return row**3 - cnt\\n```\n```Java []\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        int N = 1;\\n        while (N <= max) {\\n            N <<= 1;\\n        }\\n        int[] cnt = new int[N];\\n        for (int x : nums) {\\n            for (int y : nums) {\\n                cnt[x & y]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int num : nums) {\\n            int subset = num ^ (N - 1);\\n            ans += cnt[0];\\n            for (int i = subset; i > 0; i = subset & (i - 1)) {\\n                ans += cnt[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625960,
                "title": "triples-with-bitwise-and-equal-to-zero-solution-java",
                "content": "class Solution {\\n  public int countTriplets(int[] A) {\\n    final int kMax = 1 << 16;\\n    int ans = 0;\\n    int[] count = new int[kMax]; // {A[i] & A[j]: times}\\n\\n    for (final int a : A)\\n      for (final int b : A)\\n        ++count[a & b];\\n\\n    for (final int a : A)\\n      for (int i = 0; i < kMax; ++i)\\n        if ((a & i) == 0)\\n          ans += count[i];\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n  public int countTriplets(int[] A) {\\n    final int kMax = 1 << 16;\\n    int ans = 0;\\n    int[] count = new int[kMax]; // {A[i] & A[j]: times}",
                "codeTag": "Java"
            },
            {
                "id": 1568044,
                "title": "python-hard-math-with-explanations",
                "content": "I solved this problem in a very complex way, not yet know if exist simpler solutions. I first divided our numbers into two subarrays `x` that has less or equal than eight `1`s in a binary form and `y` that has greater than eight `1`s in a binary form. \\n\\nFirst) I count number of triplets where each triplet is from `x`. We recall inclusion exclusion principle. Consider `A1` set of numbers which has first bit equal to `1`, similarly `A2, A3, .. A16`. Question, how many triplets share common first bit, it is `|A1| ^ 3`, how many triplets share common first and second bit, it is `|A1 intersection A2| ^ 3`.\\nFrom inclusion exclusion principle how many triplets share at least one common value bit, it is `sum of |Ai odd number of intersections| ^ 3 - sum of |Aj even number of intersections| ^ 3`. Thus, to get number of triples which doesnt share common point we have to substract from overall number of triplets the expression we got.\\nHow do we compute `|intersections of some Ai|`, we loop through every number in `x` and consider all subsets it represents, since number of ones in binary form of these numbers is less than or equal eight we get `2 ^ 8 = 256` number of possible subsets at most. Thus we perform at most 1000 * 256 operations to compute all this (`|x| <= 1000`).\\n\\nSecond) If just now we computed triplets of form `(x, x, x)`, now we need to compute triplets which has at least one element from `y`, let\\'s name these triplets `(s1, s2, y)`, where `si = x or y`.\\nWe first compute all intersections (bitwise AND) of numbers from `s1` and `s2`. Say we have numbers `a` and `b` from `s1` and `s2`. Compute `c = a & b` and now increase counter for `c` (number of times pair `a` and `b` intersected at value `c`). This double loop will take 10 ^ 6 time.\\nNow loop through each number `k` from `y`. `c & k == 0` iff all ones in `c` correspond to zeros in `k`. Otherwise they will share common one in a binary form. But how many subset of zeros do we have in `k`? Magically we chose `y` to have not greater than eight zeros. Thus, we check for all zero subsets of `k` and see how many `c`s have ones exactly in this subset of zeros, but recall that we precomputed these values. So for each `k` we can get number of triplets that do not intersect. Looping for all k is `1000 operations` and considering all zero subsets is `2 ^ 8 = 256`. So, all operations are done in allowed time boundary.\\n\\nI initially knew that this problem should be solved in some sort of division of some sets into two, and then when looping through second one, just using precomputed values of first sets. But, I considered many approaches for this problem, and eventually came up with this very complex one, multistep approach, where each step is by itself a problem! I am satisfied.\\n\\n\\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def countTriplets(self, nums):\\n        x = [k for k in nums if bin(k).count(\\'1\\') <= 8]\\n        y = [k for k in nums if bin(k).count(\\'1\\') > 8]\\n        \\n        # first solve for (x, x, x) triplets\\n        bits2ct = defaultdict(int)\\n        for k in x:\\n            ones = [w for w in range(16) if k & (1 << w)]\\n            n_ones = len(ones)\\n            for b in range(1, 2 ** n_ones):\\n                bits = sum(1 << ones[t] for t in range(n_ones) if b & (1 << t))\\n                bits2ct[bits] += 1\\n        # inclusion exclusion principle\\n        n_intersection = 0\\n        for bits in bits2ct:\\n            if bin(bits).count(\\'1\\') % 2 == 1:\\n                n_intersection += bits2ct[bits] ** 3\\n            else:\\n                n_intersection -= bits2ct[bits] ** 3\\n        total = len(x) ** 3 - n_intersection\\n        \\n        # solve for triplets for which third is from y\\n        def solve(s1, s2, y):\\n            ct = defaultdict(int)\\n            for n1 in s1:\\n                for n2 in s2:\\n                    key = n1 & n2\\n                    ct[key] += 1\\n\\n            summ = 0\\n            for k in y:\\n                zeros = [w for w in range(16) if (k & (1 << w)) == 0]\\n                n_zeros = len(zeros)\\n\\n                n_disjoint = 0\\n                for b in range(2 ** n_zeros):\\n                    bits = sum(1 << zeros[t] for t in range(n_zeros) if b & (1 << t))\\n                    n_disjoint += ct[bits]\\n                summ += n_disjoint\\n            return summ\\n\\n        total += solve(x, x, y) * 3 + solve(x, y, y) * 3 + solve(y, y, y)\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def countTriplets(self, nums):\\n        x = [k for k in nums if bin(k).count(\\'1\\') <= 8]\\n        y = [k for k in nums if bin(k).count(\\'1\\') > 8]\\n        \\n        # first solve for (x, x, x) triplets\\n        bits2ct = defaultdict(int)\\n        for k in x:\\n            ones = [w for w in range(16) if k & (1 << w)]\\n            n_ones = len(ones)\\n            for b in range(1, 2 ** n_ones):\\n                bits = sum(1 << ones[t] for t in range(n_ones) if b & (1 << t))\\n                bits2ct[bits] += 1\\n        # inclusion exclusion principle\\n        n_intersection = 0\\n        for bits in bits2ct:\\n            if bin(bits).count(\\'1\\') % 2 == 1:\\n                n_intersection += bits2ct[bits] ** 3\\n            else:\\n                n_intersection -= bits2ct[bits] ** 3\\n        total = len(x) ** 3 - n_intersection\\n        \\n        # solve for triplets for which third is from y\\n        def solve(s1, s2, y):\\n            ct = defaultdict(int)\\n            for n1 in s1:\\n                for n2 in s2:\\n                    key = n1 & n2\\n                    ct[key] += 1\\n\\n            summ = 0\\n            for k in y:\\n                zeros = [w for w in range(16) if (k & (1 << w)) == 0]\\n                n_zeros = len(zeros)\\n\\n                n_disjoint = 0\\n                for b in range(2 ** n_zeros):\\n                    bits = sum(1 << zeros[t] for t in range(n_zeros) if b & (1 << t))\\n                    n_disjoint += ct[bits]\\n                summ += n_disjoint\\n            return summ\\n\\n        total += solve(x, x, y) * 3 + solve(x, y, y) * 3 + solve(y, y, y)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257466,
                "title": "c-982-triples-with-bitwise-and-equal-to-zero",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int, int> freq; \\n        for (auto& x : nums) \\n            for (auto& y : nums) \\n                ++freq[x&y]; \\n        \\n        int ans = 0; \\n        for (auto& x : nums) {\\n            x ^= 0xffff; \\n            for (int mask = x; x; x = mask & (x-1)) \\n                ans += freq[x]; \\n        }\\n        return ans + size(nums)*freq[0]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int, int> freq; \\n        for (auto& x : nums) \\n            for (auto& y : nums) \\n                ++freq[x&y]; \\n        \\n        int ans = 0; \\n        for (auto& x : nums) {\\n            x ^= 0xffff; \\n            for (int mask = x; x; x = mask & (x-1)) \\n                ans += freq[x]; \\n        }\\n        return ans + size(nums)*freq[0]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191642,
                "title": "java-clean-concise-optimal-code-counting-array-100-beats-java-solution",
                "content": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        \\n        int max = 0;\\n        \\n        for (int num : A) {\\n            max = Math.max (max, num);\\n        }\\n        \\n        int[] count = new int[max + 1];\\n        \\n        for (int a : A) {\\n            for (int b : A) {\\n                ++count[a & b];\\n            }\\n        }\\n        \\n        int answer = 0;\\n        \\n        for (int a : A) {\\n            for (int i = 0; i <= max; i++) {\\n                if ((a & i) == 0) {\\n                    answer += count[i];\\n                }\\n                else {\\n                    i += (a & i) - 1;  // skip the unused numbers\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        \\n        int max = 0;\\n        \\n        for (int num : A) {\\n            max = Math.max (max, num);\\n        }\\n        \\n        int[] count = new int[max + 1];\\n        \\n        for (int a : A) {\\n            for (int b : A) {\\n                ++count[a & b];\\n            }\\n        }\\n        \\n        int answer = 0;\\n        \\n        for (int a : A) {\\n            for (int i = 0; i <= max; i++) {\\n                if ((a & i) == 0) {\\n                    answer += count[i];\\n                }\\n                else {\\n                    i += (a & i) - 1;  // skip the unused numbers\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154502,
                "title": "java-dp-o-n-max-a-n-n",
                "content": "```\\n// Find number of ordered triplets (i,j,k) in array A such that   A[i] & A[j] & A[k] = 0\\n// any of i,j,k may be used once or more than once in the same triplet.\\n// (0,0,0)   (0,0,1)   (1,0,2)  are valid triplets.\\n//  (0,0,1)   and    (0,1,0)     and     (1,0,0)    count as different triplets.\\nclass Solution\\n{\\n    public int countTriplets(int[] A)\\n    {\\n        int ans = 0, n=A.length;\\n        int[][] dp = new int[n][n];\\n        Map<Integer, Integer> pairs = new HashMap<>(); // Keys -> each possible pairwise AND\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                dp[i][j] = A[i] & A[j];\\n                pairs.put(dp[i][j], 0);\\n            }\\n        }\\n        for(int i : pairs.keySet())   // Length of key set <= max(A) because all pairwise AND will give result <= max(A)\\n        {\\n            for(int k=0; k<n; k++)\\n            {\\n                if((i&A[k])==0)\\n                {\\n                    pairs.put(i, pairs.getOrDefault(i,0)+1); // Count for each possible pairwise AND,\\n                                                             // how many numbers in A can make it 0 on AND operation\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                ans += pairs.getOrDefault(dp[i][j],0);  // Just add the pre-computed result, i.e. number of i,j,k e [0,n) such that,\\n                                                        // A[i] & A[j] & A[k]  =  0\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Find number of ordered triplets (i,j,k) in array A such that   A[i] & A[j] & A[k] = 0\\n// any of i,j,k may be used once or more than once in the same triplet.\\n// (0,0,0)   (0,0,1)   (1,0,2)  are valid triplets.\\n//  (0,0,1)   and    (0,1,0)     and     (1,0,0)    count as different triplets.\\nclass Solution\\n{\\n    public int countTriplets(int[] A)\\n    {\\n        int ans = 0, n=A.length;\\n        int[][] dp = new int[n][n];\\n        Map<Integer, Integer> pairs = new HashMap<>(); // Keys -> each possible pairwise AND\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                dp[i][j] = A[i] & A[j];\\n                pairs.put(dp[i][j], 0);\\n            }\\n        }\\n        for(int i : pairs.keySet())   // Length of key set <= max(A) because all pairwise AND will give result <= max(A)\\n        {\\n            for(int k=0; k<n; k++)\\n            {\\n                if((i&A[k])==0)\\n                {\\n                    pairs.put(i, pairs.getOrDefault(i,0)+1); // Count for each possible pairwise AND,\\n                                                             // how many numbers in A can make it 0 on AND operation\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                ans += pairs.getOrDefault(dp[i][j],0);  // Just add the pre-computed result, i.e. number of i,j,k e [0,n) such that,\\n                                                        // A[i] & A[j] & A[k]  =  0\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928415,
                "title": "c-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        // using map\\n        int n = A.size();\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                m[A[i]&A[j]]++;\\n        int ans = 0;\\n        for (auto x: m){\\n            for (int i = 0; i < n; i++)\\n                if ((x.first & A[i])==0)\\n                    ans += x.second;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        // using map\\n        int n = A.size();\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                m[A[i]&A[j]]++;\\n        int ans = 0;\\n        for (auto x: m){\\n            for (int i = 0; i < n; i++)\\n                if ((x.first & A[i])==0)\\n                    ans += x.second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 856601,
                "title": "java-dp-solution-in-o-n",
                "content": "Time O(2\\xB9\\u2076 + N\\xB2). N\\xB2 dominates here and 2\\xB9\\u2076 is constant, so time complexity is O(N\\xB2)\\n\\n```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int answer = 0;\\n        int mx = (1 << 16);\\n        int[] dp = new int[mx];\\n        \\n        for (int num : A) {\\n            for (int bit = 0; bit < mx; bit++) {\\n                if ((num & bit) == 0) dp[bit]++;\\n            }\\n        }\\n        \\n        for (int i : A) {\\n            for (int j : A) {\\n                answer += dp[i & j];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int answer = 0;\\n        int mx = (1 << 16);\\n        int[] dp = new int[mx];\\n        \\n        for (int num : A) {\\n            for (int bit = 0; bit < mx; bit++) {\\n                if ((num & bit) == 0) dp[bit]++;\\n            }\\n        }\\n        \\n        for (int i : A) {\\n            for (int j : A) {\\n                answer += dp[i & j];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747736,
                "title": "java-dfs-memo-o-n-2-16",
                "content": "```\\nclass Solution {\\n    int dp[][];\\n    public int countTriplets(int[] A) {\\n        int M=0;\\n        for(int i : A)M=Math.max(M,i);\\n        dp=new int[M+1][3];\\n        for(int i=0;i<dp.length;i++)Arrays.fill(dp[i],-1);\\n        int res=0;\\n        for(int i:A){\\n            res+=dfs(A,i,0);\\n        }\\n        return res;\\n    }\\n    \\n    public int dfs(int A[],int cur,int level){\\n        if(level==2){\\n            if(cur!=0)return 0;\\n            return 1;\\n        }\\n        if(dp[cur][level]!=-1)return dp[cur][level];\\n        int res=0;\\n        for(int n:A){\\n            res+=dfs(A,cur&n,level+1);\\n        }\\n        \\n        dp[cur][level]=res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    public int countTriplets(int[] A) {\\n        int M=0;\\n        for(int i : A)M=Math.max(M,i);\\n        dp=new int[M+1][3];\\n        for(int i=0;i<dp.length;i++)Arrays.fill(dp[i],-1);\\n        int res=0;\\n        for(int i:A){\\n            res+=dfs(A,i,0);\\n        }\\n        return res;\\n    }\\n    \\n    public int dfs(int A[],int cur,int level){\\n        if(level==2){\\n            if(cur!=0)return 0;\\n            return 1;\\n        }\\n        if(dp[cur][level]!=-1)return dp[cur][level];\\n        int res=0;\\n        for(int n:A){\\n            res+=dfs(A,cur&n,level+1);\\n        }\\n        \\n        dp[cur][level]=res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725501,
                "title": "o-n-2-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        unordered_map<int,int>f;\\n        int n=A.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                f[A[i]&A[j]]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto v:f){\\n            for(int i=0;i<n;i++){\\n                if((v.first&A[i])==0){\\n                    ans+=v.second;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        unordered_map<int,int>f;\\n        int n=A.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                f[A[i]&A[j]]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto v:f){\\n            for(int i=0;i<n;i++){\\n                if((v.first&A[i])==0){\\n                    ans+=v.second;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674954,
                "title": "a-simple-python-solution-accepted",
                "content": "```\\nclass Solution:\\n    def countTriplets(self, A: List[int]) -> int:\\n        memo=dict()\\n        for i in range(len(A)):\\n            for j in range(i,len(A)):\\n                r=A[i]&A[j]\\n                memo[r]=memo.get(r,0)+(1 if i==j else 2) \\n        ret=0\\n        for i in range(len(A)):\\n            for k in memo:\\n                if A[i]&k==0:\\n                    ret+=memo[k]\\n        return ret\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, A: List[int]) -> int:\\n        memo=dict()\\n        for i in range(len(A)):\\n            for j in range(i,len(A)):\\n                r=A[i]&A[j]\\n                memo[r]=memo.get(r,0)+(1 if i==j else 2) \\n        ret=0\\n        for i in range(len(A)):\\n            for k in memo:\\n                if A[i]&k==0:\\n                    ret+=memo[k]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595204,
                "title": "fast-c-8-ms-smart-bit-manipulation",
                "content": "```\\nint countTriplets(int* A, int ASize){\\n    int cnt[1 << 16] = { 0 };\\n    for (int i = 0; i < ASize; i++) {\\n        cnt[A[i]]++;\\n        for (int j = i + 1; j < ASize; j++) {\\n            cnt[A[i] & A[j]] += 2;\\n        }\\n    } \\n\\n    int res = cnt[0] * ASize;\\n    for (int i = 0; i < ASize; ++i) {\\n        const int t = (~A[i]) & 0xFFFF;\\n        for (int j = t; j != 0; j = (j - 1) & t)\\n            res += cnt[j];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint countTriplets(int* A, int ASize){\\n    int cnt[1 << 16] = { 0 };\\n    for (int i = 0; i < ASize; i++) {\\n        cnt[A[i]]++;\\n        for (int j = i + 1; j < ASize; j++) {\\n            cnt[A[i] & A[j]] += 2;\\n        }\\n    } \\n\\n    int res = cnt[0] * ASize;\\n    for (int i = 0; i < ASize; ++i) {\\n        const int t = (~A[i]) & 0xFFFF;\\n        for (int j = t; j != 0; j = (j - 1) & t)\\n            res += cnt[j];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 542096,
                "title": "simple-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int CountTriplets(int[] nums)\\n        {\\n            int res = 0;\\n\\n            IDictionary<int, int> val2Count = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                for (int j = 0; j < nums.Length; j++)\\n                {\\n                    var t = nums[i] & nums[j];\\n\\n                    if (!val2Count.ContainsKey(t))\\n                    {\\n                        val2Count[t] = 0;\\n                    }\\n\\n                    val2Count[t]++;\\n                }\\n            }\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                foreach (var v2c in val2Count)\\n                {\\n                    if ((v2c.Key & nums[i]) == 0)\\n                    {\\n                        res += v2c.Value;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int CountTriplets(int[] nums)\\n        {\\n            int res = 0;\\n\\n            IDictionary<int, int> val2Count = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                for (int j = 0; j < nums.Length; j++)\\n                {\\n                    var t = nums[i] & nums[j];\\n\\n                    if (!val2Count.ContainsKey(t))\\n                    {\\n                        val2Count[t] = 0;\\n                    }\\n\\n                    val2Count[t]++;\\n                }\\n            }\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                foreach (var v2c in val2Count)\\n                {\\n                    if ((v2c.Key & nums[i]) == 0)\\n                    {\\n                        res += v2c.Value;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289589,
                "title": "polynomial-algorithm-using-symmetry",
                "content": "Using the fact that solutions may reoccur, so we do not need to rediscover them. This means we can start each inner loop from the current iterator from the enclosing loop. \\n\\nWhen a solution is discovered we can use the following to add the correct number of solutions to the total.\\n\\nIf the indices are all the same then we only need to count the solution once as there is no way to permute the indices, if any 2 of the indices are repeated then there are 3 ways to get that solution (3 choose 2), if they are all different then the solution can be counted 6 times (3 choose 3).\\n\\n```class Solution {\\n    public int countTriplets(int[] A) {\\n        int count = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i; j < A.length; j++) {\\n                for (int k = j; k < A.length; k++) {\\n                    if (((A[i] & A[j]) & A[k]) == 0) {\\n                        if (i == j && i ==k) {\\n                            count++;\\n                        }\\n                        else if (i == j || i == k || j == k) {\\n                            count +=3;\\n                        }\\n                        else count +=6;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int countTriplets(int[] A) {\\n        int count = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i; j < A.length; j++) {\\n                for (int k = j; k < A.length; k++) {\\n                    if (((A[i] & A[j]) & A[k]) == 0) {\\n                        if (i == j && i ==k) {\\n                            count++;\\n                        }\\n                        else if (i == j || i == k || j == k) {\\n                            count +=3;\\n                        }\\n                        else count +=6;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239459,
                "title": "java-complete-search-easy-to-explain-remember-and-impl-in-5mins-cheers",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        int n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int k = A[i] & A[j];\\n                cnt.put(k, cnt.getOrDefault(k, 0) + 1);\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (Integer key : cnt.keySet()) {\\n                if ((key & A[i]) == 0) {\\n                    res += cnt.get(key);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        int n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int k = A[i] & A[j];\\n                cnt.put(k, cnt.getOrDefault(k, 0) + 1);\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (Integer key : cnt.keySet()) {\\n                if ((key & A[i]) == 0) {\\n                    res += cnt.get(key);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237522,
                "title": "python-memory-usage-16-3-mb-less-than-100-00-of-python-online",
                "content": "1. Run throught arrays with two nested loops A[i] and A[j]\\n2. Store A[i]&A[j] into dict  alongside with number of occurrence.\\n3. Run through array one more time and check if dict key and array element  gives result of 0\\n\\n```\\n    def countTriplets2(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"        \\n        d={}\\n        res=0\\n        for a in A:\\n            for b in A:\\n                t=a&b\\n                if t in d:\\n                    d[t]+=1\\n                else:\\n                    d[t]=1\\n        for a in A:\\n            for k,v in d.items():\\n                if a&k==0:\\n                    res+=v\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def countTriplets2(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"        \\n        d={}\\n        res=0\\n        for a in A:\\n            for b in A:\\n                t=a&b\\n                if t in d:\\n                    d[t]+=1\\n                else:\\n                    d[t]=1\\n        for a in A:\\n            for k,v in d.items():\\n                if a&k==0:\\n                    res+=v\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 227332,
                "title": "math-exclusive-set",
                "content": "Looks like no post is talking about the math way, so the proposal.\\n\\nCode could be better, while basically, total - that_for(odd_sets) + that_for(even_sets),  where odd/even for the ~~size of the sets~~ parity of the set key.\\n\\nThe calculation per set is ```k * k * k``` based on the number of ways of picking repeatable items in the set.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& a) {\\n      unordered_map<int, int> c;\\n      for (int x : a) {\\n        for (int i = x; i > 0; i = (i - 1) & x) ++c[i];\\n      }\\n      int n = a.size();\\n      int ret = n * n * n;\\n      for (const auto& p : c) {\\n        bool o = false;\\n        for (int x = p.first; x > 0; x -= x & -x) o = !o;\\n        if (o) ret -= p.second * p.second * p.second;\\n        else ret += p.second * p.second * p.second;\\n      }\\n      return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```k * k * k```\n```c++\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& a) {\\n      unordered_map<int, int> c;\\n      for (int x : a) {\\n        for (int i = x; i > 0; i = (i - 1) & x) ++c[i];\\n      }\\n      int n = a.size();\\n      int ret = n * n * n;\\n      for (const auto& p : c) {\\n        bool o = false;\\n        for (int x = p.first; x > 0; x -= x & -x) o = !o;\\n        if (o) ret -= p.second * p.second * p.second;\\n        else ret += p.second * p.second * p.second;\\n      }\\n      return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227186,
                "title": "c-o-n-2-dp-solution-with-detailed-explanation",
                "content": "Given array `A` and any triplet `(i, j, k)`, if `A[i] & A[j] & A[k] == 0` and `A[i] & A[j]` has non-zero bits `b1`, `b2`, ..., `bt`, then `A[k]` must have value `0` on all these bits. Therefore, if we can pre-caculate `zeroOnBits(b1, b2, ..., bt)`, which is the set of indices `idx` such that `A[idx]` has value `0` on the bit combination {`b1`, `b2`, ..., `bt`}, then it just takes `O(1)` time to obtain the number of valid `(i, j, *)` triplets.\\n\\nSince the values in `A` are within a mild range `[0, 65535]`, we can map each bit combination to a single number within that range. For example, for a bit combination `{2, 5, 8}`, which means the second, fifth, and eighth lowest bits, we can map it to number `(1 << 2) + (1 << 5) + (1 << 8) = 4 + 32 + 256 = 292`. Due to this observation we can use a top-down dp routine `f(mask)` to get `zeroOnBits(b1, b2, ..., bt)`, as defined above, where `mask` is the single number that `{b1, b2, ..., bt}` maps to.\\n\\nHow does the dp work? Well, before it begins, we first get a 2-d table `zeroOnSingleBit`, where `zeroOnSingleBit[b]` is the set of indices `idx` such that `A[idx]` has value `0` on the `b`-th lowest bit. Then for any bit combination `{b1, b2, ..., bt}` mapped to a single number `mask`, if `t == 1`, then we can directly return `zeroOnSingleBit[b1]`; otherwise, let\\'s say the numbers corresponding to the first half and second half bits are `mask1` and `mask2` respectively, then we can have a recursive call to obtain `f(mask1)` and `f(mask2)`, obviously `f(mask)` should be the intersection of `f(mask1)` and `f(mask2)`, which can be done using two-point approach in `O(n)` time. Since in a dp algorithm each distinct value will be evaluated only once, the total time complexity for dp will be `O(numMasks*n) = O(65536*n) = O(n)`. Once the dp is done, we can loop for index `i` and `j`, then the number of `k`\\'s such that `A[i] & A[j] & A[k] == 0` will be `f(A[i] & A[j])`, which takes `O(1)` time, and the complexity of the two-level loop is `O(n^2)`. Therefore, the total time complexity of the algorithm is `O(n^2)`.\\n\\nActually, we do not need to seperate dp and the two-level for-loop. Instead, we only need to explicitly evaluate those values `f(A[i] & A[j])` for all `(i, j)` pairs. Please see the code implementation below.\\n\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int n = A.size();\\n        \\n        // Set of idx\\'s such that `A[idx]` has value 0 on a single bit b\\n        vector<vector<int>> zeroOnBit(16);\\n        for (int i = 0; i < n; ++i) {\\n            for (int b = 0; b < 16; ++b) {\\n                int mask = (1 << b);\\n                if ((A[i] & mask) == 0) {\\n                    zeroOnBit[b].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        // Set of idx\\'s such that `A[idx]` has value 0 on a bit combination mask within `[0, 65535]`\\n        intersect.resize(65536);\\n        \\n        // Size of the set defined above\\n        table.resize(65536, -1);\\n        \\n        int count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int bitAnd = (A[i] & A[j]);\\n                if (!bitAnd) {\\n                    count += n;\\n                    continue;\\n                }\\n                getIntersect(bitAnd, zeroOnBit);\\n                count += table[bitAnd];\\n            }    \\n        }\\n        return count;\\n    }\\n    \\n    // DP to obtain set of idx\\'s such that `A[idx]` has value 0 on a given bit mask`\\n    // indices: set of idx\\'s such that `A[idx]` has value 0 on a single bit b\\n    vector<int>& getIntersect(int mask, vector<vector<int>>& indices) {\\n        if (table[mask] >= 0)\\n            return intersect[mask];\\n        \\n        if (!mask) {\\n            table[mask] = 0;\\n            return intersect[mask];\\n        }\\n        vector<int> nonZeroBits;\\n        for (int b = 0; b < 16; ++b) {\\n            if (mask & (1 << b)) {\\n                nonZeroBits.push_back(b);\\n            }\\n        }\\n        \\n        if (nonZeroBits.size() == 1) {\\n            intersect[mask] = indices[nonZeroBits[0]];\\n            table[mask] = intersect[mask].size();\\n            return intersect[mask];\\n        }\\n        \\n        int m1 = 0, m2 = 0;\\n        int total = nonZeroBits.size();\\n        for (int i = 0; i < total; ++i) {\\n            int b = nonZeroBits[i];\\n            if (i <= (total - 1)/2) {\\n                m1 = (m1 | (1 << b));\\n            } else {\\n                m2 = (m2 | (1 << b));\\n            }\\n        }\\n        \\n        // Recursive call for masks m1 and m2\\n        vector<int>& v1 = getIntersect(m1, indices);\\n        vector<int>& v2 = getIntersect(m2, indices);\\n        \\n        // Two pointer approach to get the intersection\\n        int p1 = 0, p2 = 0;\\n        while (p1 < table[m1] && p2 < table[m2]) {\\n            if (v1[p1] < v2[p2]) {\\n                ++p1;\\n            } else if (v1[p1] > v2[p2]) {\\n                ++p2;\\n            } else {\\n                intersect[mask].push_back(v1[p1]);\\n                ++p1;\\n                ++p2;\\n            }\\n        }\\n        \\n        table[mask] = intersect[mask].size();\\n        return intersect[mask];\\n    }\\nprivate:\\n    vector<vector<int>> intersect;\\n    vector<int> table;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int n = A.size();\\n        \\n        // Set of idx\\'s such that `A[idx]` has value 0 on a single bit b\\n        vector<vector<int>> zeroOnBit(16);\\n        for (int i = 0; i < n; ++i) {\\n            for (int b = 0; b < 16; ++b) {\\n                int mask = (1 << b);\\n                if ((A[i] & mask) == 0) {\\n                    zeroOnBit[b].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        // Set of idx\\'s such that `A[idx]` has value 0 on a bit combination mask within `[0, 65535]`\\n        intersect.resize(65536);\\n        \\n        // Size of the set defined above\\n        table.resize(65536, -1);\\n        \\n        int count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int bitAnd = (A[i] & A[j]);\\n                if (!bitAnd) {\\n                    count += n;\\n                    continue;\\n                }\\n                getIntersect(bitAnd, zeroOnBit);\\n                count += table[bitAnd];\\n            }    \\n        }\\n        return count;\\n    }\\n    \\n    // DP to obtain set of idx\\'s such that `A[idx]` has value 0 on a given bit mask`\\n    // indices: set of idx\\'s such that `A[idx]` has value 0 on a single bit b\\n    vector<int>& getIntersect(int mask, vector<vector<int>>& indices) {\\n        if (table[mask] >= 0)\\n            return intersect[mask];\\n        \\n        if (!mask) {\\n            table[mask] = 0;\\n            return intersect[mask];\\n        }\\n        vector<int> nonZeroBits;\\n        for (int b = 0; b < 16; ++b) {\\n            if (mask & (1 << b)) {\\n                nonZeroBits.push_back(b);\\n            }\\n        }\\n        \\n        if (nonZeroBits.size() == 1) {\\n            intersect[mask] = indices[nonZeroBits[0]];\\n            table[mask] = intersect[mask].size();\\n            return intersect[mask];\\n        }\\n        \\n        int m1 = 0, m2 = 0;\\n        int total = nonZeroBits.size();\\n        for (int i = 0; i < total; ++i) {\\n            int b = nonZeroBits[i];\\n            if (i <= (total - 1)/2) {\\n                m1 = (m1 | (1 << b));\\n            } else {\\n                m2 = (m2 | (1 << b));\\n            }\\n        }\\n        \\n        // Recursive call for masks m1 and m2\\n        vector<int>& v1 = getIntersect(m1, indices);\\n        vector<int>& v2 = getIntersect(m2, indices);\\n        \\n        // Two pointer approach to get the intersection\\n        int p1 = 0, p2 = 0;\\n        while (p1 < table[m1] && p2 < table[m2]) {\\n            if (v1[p1] < v2[p2]) {\\n                ++p1;\\n            } else if (v1[p1] > v2[p2]) {\\n                ++p2;\\n            } else {\\n                intersect[mask].push_back(v1[p1]);\\n                ++p1;\\n                ++p2;\\n            }\\n        }\\n        \\n        table[mask] = intersect[mask].size();\\n        return intersect[mask];\\n    }\\nprivate:\\n    vector<vector<int>> intersect;\\n    vector<int> table;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227168,
                "title": "c-7-line",
                "content": "```\\n    int countTriplets(vector<int>& A) {\\n        unordered_map<int,int> m;\\n        for(int x:A)\\n            for(int y:A) ++m[x&y];\\n        int sum = 0;\\n        for(auto x:A)\\n            for(auto [y, cnt]:m) if((x&y)==0) sum += cnt;\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int countTriplets(vector<int>& A) {\\n        unordered_map<int,int> m;\\n        for(int x:A)\\n            for(int y:A) ++m[x&y];\\n        int sum = 0;\\n        for(auto x:A)\\n            for(auto [y, cnt]:m) if((x&y)==0) sum += cnt;\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 226820,
                "title": "easiest-solution-so-far-after-looking-at-most-posts-i-don-t-feel-shame-at-my-solution",
                "content": "Most DP Solution is bounded by O (3 * (2^ 16) * n), almost O(2^28) due to `n <= 1000`\\n\\nHowever, this one is boundy by O (n ^ 3 /2) = O (2^ 29) ...\\n\\n```\\npublic int countTriplets(int[] A) {\\n    final Set<Integer> all = new HashSet<>();\\n    for (int a : A) {\\n      all.add(a);\\n    }\\n    int count = 0;\\n    for (int i = 0; i < A.length; i++) {\\n      for (int j = i; j < A.length; j++) {\\n        for (int k = j; k < A.length; k++) {\\n          if ((A[i] & A[j] & A[k]) == 0) {\\n            if (i == j && j == k) count++;\\n            else if (i == j || j == k || k == i) count += 3;\\n            else {\\n              count += 6;\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return count;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countTriplets(int[] A) {\\n    final Set<Integer> all = new HashSet<>();\\n    for (int a : A) {\\n      all.add(a);\\n    }\\n    int count = 0;\\n    for (int i = 0; i < A.length; i++) {\\n      for (int j = i; j < A.length; j++) {\\n        for (int k = j; k < A.length; k++) {\\n          if ((A[i] & A[j] & A[k]) == 0) {\\n            if (i == j && j == k) count++;\\n            else if (i == j || j == k || k == i) count += 3;\\n            else {\\n              count += 6;\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return count;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226780,
                "title": "c-132ms-o-n-2-14-lines",
                "content": "The basic idea is that the question limited the values of A[i] to <= 2^16 so that means any bitwise & of two nums in the array will be <= 2^16 as well. So allocate an array of size 2^16 then  we can simply iterate in a nested loop accumualting a count of all A[i]&A[j] pairs. Since A.size() <= 1000 that costs us 1000 * 1000 = 1,000,000 operations at most. \\n\\nThen we iterate over A again this time seeing if the bitwise A[i] & index of v == 0, if it does add the count of pairs to the answer. Since a triplet in this question allows replacement, that is, i can equal j or k and j can equal k we can just simply add the pairwise count to the answer. \\n\\nSince in the second loop our count vector is 2^16 that is 1000 * 65536 = 65,536,000 operations at most, which can comfortably fit into one second of computation time.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        vector<int> v((1<<16),0);\\n        for(int i=0;i<A.size();i++)\\n            for(int j=0;j<A.size();j++)\\n                v[A[i] & A[j]]++;\\n        int ans = 0;\\n        for(int i=0;i<A.size();i++)\\n            for(int j=0;j<v.size();j++)\\n                if((A[i] & j) == 0) ans += v[j];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        vector<int> v((1<<16),0);\\n        for(int i=0;i<A.size();i++)\\n            for(int j=0;j<A.size();j++)\\n                v[A[i] & A[j]]++;\\n        int ans = 0;\\n        for(int i=0;i<A.size();i++)\\n            for(int j=0;j<v.size();j++)\\n                if((A[i] & j) == 0) ans += v[j];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054872,
                "title": "o-n-2-solution-with-detailed-explanation",
                "content": "# Intuition\\nCreate an array cnt of size 2^16 to store counts of all possible bitwise AND results between pairs of numbers in nums. This array is used to count how many times each AND result occurs in the input array.\\n\\nNow, iterate through each element \\'num\\' in the input array nums and check if the `num & i` is equal to 0. If yes, increment the count.\\n\\nNow, this solution has a complexity of `max(n*n, (2^16))`, to optimize it we are going to do the following.\\n\\nInstead of iterating on all 2^16 numbers, we are going to skip ranges that can never be our answer.\\n\\nIf the above said AND result is not 0, move \\'i\\' to the next position with a 0 in its binary representation. This is done to skip positions where the AND result can never be 0, optimizing the loop.\\n\\nIn such case we are goint to shift `i`,  `(i & num) - 1` times.\\n\\nThis simply means that we have set bits in some places in the AND result. Now these set bits will turn off after `num&i` iterations.  so we subtract 1 as loop incriment is there. \\n\\n# Complexity\\n- Time complexity: O(n*n)\\n\\n- Space complexity: (2^16)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int countTriplets(vector<int> &nums)\\n    {\\n        int ans = 0;\\n        int cnt[1 << 16] = {0};\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                cnt[nums[i] & nums[j]]++;\\n            }\\n        }\\n\\n        for (int &num : nums)\\n        {\\n            for (int i = 0; i < (1 << 16); i++)\\n            {\\n                if ((num & i) == 0)\\n                    ans += cnt[i];\\n                else\\n                {\\n                    // core optimization\\n                    // we are going to shift i that many places in which and of numbers and num can\\'t be zero\\n                    i += (num & i) - 1;\\n\\n                    // this simply means that we have set bits in some places\\n                    // now these set bits will turn off after num&i iterations \\n                    // so we subtract 1 as loop incriment is there  \\n                    // so we effectivly skip large ranges \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int countTriplets(vector<int> &nums)\\n    {\\n        int ans = 0;\\n        int cnt[1 << 16] = {0};\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                cnt[nums[i] & nums[j]]++;\\n            }\\n        }\\n\\n        for (int &num : nums)\\n        {\\n            for (int i = 0; i < (1 << 16); i++)\\n            {\\n                if ((num & i) == 0)\\n                    ans += cnt[i];\\n                else\\n                {\\n                    // core optimization\\n                    // we are going to shift i that many places in which and of numbers and num can\\'t be zero\\n                    i += (num & i) - 1;\\n\\n                    // this simply means that we have set bits in some places\\n                    // now these set bits will turn off after num&i iterations \\n                    // so we subtract 1 as loop incriment is there  \\n                    // so we effectivly skip large ranges \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982568,
                "title": "something-like-3sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        res = 0\\n        freq = {}\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(n):\\n                t = nums[i]&nums[j]\\n                if t not in freq:\\n                    freq[t] = 0\\n                freq[t] += 1\\n        \\n        for n in nums:\\n            for t in freq:\\n                if n&t == 0:\\n                    res += freq[t]\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        res = 0\\n        freq = {}\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(n):\\n                t = nums[i]&nums[j]\\n                if t not in freq:\\n                    freq[t] = 0\\n                freq[t] += 1\\n        \\n        for n in nums:\\n            for t in freq:\\n                if n&t == 0:\\n                    res += freq[t]\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962929,
                "title": "naive-c-just-brute-forces",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(auto a:nums) {\\n            for(auto b:nums) {\\n                mp[a&b]++;\\n            }\\n        }\\n        int res = 0;\\n        for(auto a: nums) {\\n            for(auto it = mp.begin(); it != mp.end(); it++) {\\n                if(!(a&(it->first))) {\\n                    res += it->second;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(auto a:nums) {\\n            for(auto b:nums) {\\n                mp[a&b]++;\\n            }\\n        }\\n        int res = 0;\\n        for(auto a: nums) {\\n            for(auto it = mp.begin(); it != mp.end(); it++) {\\n                if(!(a&(it->first))) {\\n                    res += it->second;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956637,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    int f[1<<16];\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        for (int& x : nums)\\n            for (int& y : nums)\\n                ++f[x & y];\\n        int ans = 0;\\n        for (int& x : nums)\\n            for (int i = 0; i < (1<<16); ++i)\\n                if ((i & x) == 0)\\n                    ans += f[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int f[1<<16];\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        for (int& x : nums)\\n            for (int& y : nums)\\n                ++f[x & y];\\n        int ans = 0;\\n        for (int& x : nums)\\n            for (int i = 0; i < (1<<16); ++i)\\n                if ((i & x) == 0)\\n                    ans += f[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729238,
                "title": "js-solution-using-map",
                "content": "# Approach\\nWe count frequencies of each pair of numbers and then for each of the number we check if there is any value in the nums array whose bitwise and is 0 with the current bitwise and of the pair, let\\'s say we have bitwise and of pair (1,2) , then we iterate whole nums array for checking if there is any element whose bitwise and with and of this pair (1,2) is zero then we add the count of occurence of this pair(1,2) to the answer. One must be wondering while storing and of each pair we would get n^2 pairs but there will be numbers in the range of 0 to 2^16 and since we are using map and storing the count so even in the worst case we will be having no more than 2^16 entries in the map. \\n\\n# Complexity\\n- Time complexity:\\n    O(n2^(number with most no. of bits)) => we can say as per the constraints it will be O(n2^16) in the case where we have 16 bit large numbers.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countTriplets = function(nums) {\\n    let ans = new Map() , count = 0 ; \\n    for(i of nums)\\n      for(j of nums)\\n        ans.set(i&j,[i&j,(ans.get(i&j)||[i&j,0])[1]+1])\\n    \\n    for(val of ans)\\n      for(num of nums)\\n        if((val[0]&num) === 0) count+=val[1][1];\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countTriplets = function(nums) {\\n    let ans = new Map() , count = 0 ; \\n    for(i of nums)\\n      for(j of nums)\\n        ans.set(i&j,[i&j,(ans.get(i&j)||[i&j,0])[1]+1])\\n    \\n    for(val of ans)\\n      for(num of nums)\\n        if((val[0]&num) === 0) count+=val[1][1];\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3648880,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2 + 2^16 * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^16 * n) ?\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def countTriplets(nums: Array[Int]): Int = {\\n        val counts = nums.flatMap(i => nums.map(j => i & j)).groupBy(identity).view.mapValues(_.length)\\n        nums.foldLeft(0)((res, i) => res + counts.filterKeys(x => (x & i) == 0).values.sum)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def countTriplets(nums: Array[Int]): Int = {\\n        val counts = nums.flatMap(i => nums.map(j => i & j)).groupBy(identity).view.mapValues(_.length)\\n        nums.foldLeft(0)((res, i) => res + counts.filterKeys(x => (x & i) == 0).values.sum)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3556898,
                "title": "linear-algebra-and-dimensional-reduction-commented-and-explained-o-n-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo get this problem would really suck if you don\\'t have linear algebra background. This is because you can take the problem, which naively runs in O(N^3), and reduce to O(N) if you are clever about it. To pull this off we need to realize that we can consider this problem as the determinant of the submatrices of a bit masked version of the binary values of our nums array. This is not a simple insight! I only came to it intuitively after setting up the problem in a different fashion and from there realized the striking symmetry of the problem; I leave in references to some others work with the venn diagram approach, who may or may not have realized the matrix space they were working in as a nod to other approaches as well. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo set this up, start by first getting the binary form of all values in nums and storing them, along with the longest length you encounter on the way. \\n\\nFrom there, loop through your binary value strings and find the extension needed at each point as the difference of max length and this length. \\nAppend to extra bits this extension as another row in our overall extra bits matrix. \\n\\nAt the end of this, we will have a matrix not well seen but implicitly defined as the length of our extra bits and the length of the first item in our extra bits array. \\n\\nWe know make a cols to rows activated mapping where we will store which rows by index are activated by which columns in our extra bits matrix. We will find these in col major order so we progress in the fashion of linear algebra over the space, left to right and top to bottom. \\n\\nAs we do so, if we find that we have a \\'1\\' in our extra bits for this row and this column, we are to add this row to our mapping for this column. \\n\\nFinally, we can set up a venn diagram intersection, as stated in other posts (this is really a listing of the determinant based findings of the sub matrices in our overall matrix of size row by row from above, but that\\'s a separate post entirely) \\n\\nSet a count equal to 0. We are technically counting the over counting of the total size of our row by row matrix of extension of bits. \\n\\nLoop in col major order and as you do \\n- If you have rows activated for this column \\n    - we\\'ve definitely overcounted by any here on 3 times occassions \\n    - Increment count by the number of rows cubed \\n    - then for prior column in range of this column up to but not at 0 \\n        - consider each previous calculation we have made of the determinant (each prior entry in the venn diagram at prior column)\\n        - calculate the number of intersections of the previous entry with the current entry of cols to rows activated at col as the bitwise and operation \\n        - if this intersection is not 0 \\n            - we also overcount here, we\\'ll need to increase count \\n            - but! this is a determinant, and submatrix considerations must come into play. This was a positive value if the prior column is even, otherwise it is a negative value. The value of the increment is as expected, the length of the intersection cubed for our 3 loop consideration normally \\n            - Afterwards, whatever the intersection was, we will want to account for it on the next loop, so add it to the prior columns successor (prior column + 1) in the determinant calculations (venn diagram) \\n    - after considering all prior columns, the determinant calculation at index 1 will need to also have the rows activated here appeneded as well since we considered them as well \\n\\nWhen the loop finishes, take the size of our matrix cubed and subtract from it the amount we overcount in the processing. This is our final answer. \\n\\n# Complexity\\n- Time complexity : O(N) \\n    - Take O(N) to build all binary nums \\n    - Take O(N) to build your extra bits \\n    - The largest size possible for the matrix dimensions col major order outer loop must be max length - 0 -> aka max length\\n    - The max length considerable in the problem is 16, based on 2^16 \\n    - So the max we can have on our first extension is when it is 2^8\\n    - This would have us add 16 and 8 to get a size of 24 \\n    - Row unfortunately can run all the way to 1000, so we have at worst a matrix of size 1000 by 1000, aka O(N)  \\n    - Similarly we loop over cols, at worst 24 \\n        - and then do a sub loop of at worst 23 \\n            - but then have an inner loop of at worst N \\n                - which sets our max at O(N) \\n    - All told then, we have a run time of O(N) \\n\\n- Space complexity : O(N) \\n    - Store N binary values\\n    - Store N extra bits \\n    - Store 24 * N items in our cols activated \\n    - Store 24 * N items in our venn diagram intersection perhaps \\n    - All O(N)  \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countTriplets(self, nums: \\'List[int]\\') -> \\'int\\' :\\n        # get binary string forms of the values \\n        binary_values = [] \\n        # and the maximal length possible \\n        max_length = 0 \\n        # by looping over nums and building as you go \\n        for num in nums : \\n            binary_values.append(bin(num)[2:])\\n            max_length = max(max_length, len(binary_values[-1]))\\n        \\n        # figure out how many extra bits you\\'ll need for a bit masked matrix \\n        extra_bits = [] \\n        # by looping over your binary values \\n        for binary_value in binary_values : \\n            # determining any needed extensions \\n            extension = max_length - len(binary_value)\\n            # and extending it as needed  \\n            extra_bits.append(\\'0\\'*extension + binary_value)\\n        \\n        # the length of the set up is your number of rows, and your initial is the number of cols \\n        matrix_dimensions = [len(extra_bits), len(extra_bits[0])]\\n        # use this to determine mapping of column to rows activated in the matrix \\n        cols_to_rows_activated = collections.defaultdict(set) \\n        # by looping in col major order \\n        for col in range(matrix_dimensions[1]) : \\n            for row in range(matrix_dimensions[0]) :\\n                # and if you have a value there  \\n                if extra_bits[row][col] == \"1\" :\\n                    # updating appropriately  \\n                    cols_to_rows_activated[col].add(row)\\n        # we could do the above since all cells will go up to at least cols positioning \\n        # as everything after that is longer overall. This lets us update without worries \\n        # we now build a venn diagram intersectioni using some linear algebra in the work \\n        venn_diagram_intersection = collections.defaultdict(list) \\n        # where we are going to use determinant basically in our evaluation \\n        count = 0 \\n        # col major order looping \\n        for col in range(matrix_dimensions[1]) :\\n            # if we have a length here that is not 0 -> some rows activated  \\n            if len(cols_to_rows_activated[col]) != 0 : \\n                # update count by this amount cubed \\n                count += len(cols_to_rows_activated[col])**3\\n                # consider prior column entries up to the first but not including it  \\n                for prior_col in range(col, 0, -1) : \\n                    # get the previous entries there at prior column \\n                    for previous_entry in venn_diagram_intersection[prior_col] : \\n                        # find value of intersection. If not zero \\n                        intersection = previous_entry & cols_to_rows_activated[col]\\n                        if len(intersection) != 0 : \\n                            # based on corresponding matrix position, you add or subtract \\n                            # the appropriate valuation of the length of intersection cubed \\n                            count += ((-1)**prior_col)*(len(intersection)) ** 3 \\n                            # and be sure to update the priors successor based on this  \\n                            venn_diagram_intersection[prior_col + 1].append(intersection)\\n                # after considering all prior columns, be sure to note that for the final \\n                # entry we now must add the valuation of the cols to rows activated at col \\n                venn_diagram_intersection[1].append(cols_to_rows_activated[col])\\n        # return you matrix dimensions of the row cubed - count of total \\n        # this reduces us to the proper amount of values based on the cubing process \\n        # where we would normally consider num for num in nums 3 separate times \\n        return matrix_dimensions[0]**3 - count  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, nums: \\'List[int]\\') -> \\'int\\' :\\n        # get binary string forms of the values \\n        binary_values = [] \\n        # and the maximal length possible \\n        max_length = 0 \\n        # by looping over nums and building as you go \\n        for num in nums : \\n            binary_values.append(bin(num)[2:])\\n            max_length = max(max_length, len(binary_values[-1]))\\n        \\n        # figure out how many extra bits you\\'ll need for a bit masked matrix \\n        extra_bits = [] \\n        # by looping over your binary values \\n        for binary_value in binary_values : \\n            # determining any needed extensions \\n            extension = max_length - len(binary_value)\\n            # and extending it as needed  \\n            extra_bits.append(\\'0\\'*extension + binary_value)\\n        \\n        # the length of the set up is your number of rows, and your initial is the number of cols \\n        matrix_dimensions = [len(extra_bits), len(extra_bits[0])]\\n        # use this to determine mapping of column to rows activated in the matrix \\n        cols_to_rows_activated = collections.defaultdict(set) \\n        # by looping in col major order \\n        for col in range(matrix_dimensions[1]) : \\n            for row in range(matrix_dimensions[0]) :\\n                # and if you have a value there  \\n                if extra_bits[row][col] == \"1\" :\\n                    # updating appropriately  \\n                    cols_to_rows_activated[col].add(row)\\n        # we could do the above since all cells will go up to at least cols positioning \\n        # as everything after that is longer overall. This lets us update without worries \\n        # we now build a venn diagram intersectioni using some linear algebra in the work \\n        venn_diagram_intersection = collections.defaultdict(list) \\n        # where we are going to use determinant basically in our evaluation \\n        count = 0 \\n        # col major order looping \\n        for col in range(matrix_dimensions[1]) :\\n            # if we have a length here that is not 0 -> some rows activated  \\n            if len(cols_to_rows_activated[col]) != 0 : \\n                # update count by this amount cubed \\n                count += len(cols_to_rows_activated[col])**3\\n                # consider prior column entries up to the first but not including it  \\n                for prior_col in range(col, 0, -1) : \\n                    # get the previous entries there at prior column \\n                    for previous_entry in venn_diagram_intersection[prior_col] : \\n                        # find value of intersection. If not zero \\n                        intersection = previous_entry & cols_to_rows_activated[col]\\n                        if len(intersection) != 0 : \\n                            # based on corresponding matrix position, you add or subtract \\n                            # the appropriate valuation of the length of intersection cubed \\n                            count += ((-1)**prior_col)*(len(intersection)) ** 3 \\n                            # and be sure to update the priors successor based on this  \\n                            venn_diagram_intersection[prior_col + 1].append(intersection)\\n                # after considering all prior columns, be sure to note that for the final \\n                # entry we now must add the valuation of the cols to rows activated at col \\n                venn_diagram_intersection[1].append(cols_to_rows_activated[col])\\n        # return you matrix dimensions of the row cubed - count of total \\n        # this reduces us to the proper amount of values based on the cubing process \\n        # where we would normally consider num for num in nums 3 separate times \\n        return matrix_dimensions[0]**3 - count  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394894,
                "title": "using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[66000][5];\\n    int fun(int val,int size,vector<int>&nums){\\n        if(size>3)return 0;\\n        if(val==0&&size==3)return 1;\\n        if(dp[val][size]!=-1)return dp[val][size];\\n        int ans=0;\\n        for(auto it:nums){\\n            if(size==0) ans+=  fun(it,size+1,nums);\\n           \\n            else  ans+= dp[val][size]=  fun(val&it,size+1,nums);\\n            \\n        }\\n        return dp[val][size]=ans;\\n    }\\n    int countTriplets(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[66000][5];\\n    int fun(int val,int size,vector<int>&nums){\\n        if(size>3)return 0;\\n        if(val==0&&size==3)return 1;\\n        if(dp[val][size]!=-1)return dp[val][size];\\n        int ans=0;\\n        for(auto it:nums){\\n            if(size==0) ans+=  fun(it,size+1,nums);\\n           \\n            else  ans+= dp[val][size]=  fun(val&it,size+1,nums);\\n            \\n        }\\n        return dp[val][size]=ans;\\n    }\\n    int countTriplets(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265348,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countTriplets = function(nums) {\\n    let count = 0;\\n    let size = nums.length;\\n     for (let i = 0; i < size; ++i) {\\n        for (let j = 0; j < size; ++j) {\\n            for (let k = 0; k < size; ++k) {\\n                if (!(nums[i] & nums[j] & nums[k])) {++count;}\\n            }\\n        }\\n     }\\n     return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countTriplets = function(nums) {\\n    let count = 0;\\n    let size = nums.length;\\n     for (let i = 0; i < size; ++i) {\\n        for (let j = 0; j < size; ++j) {\\n            for (let k = 0; k < size; ++k) {\\n                if (!(nums[i] & nums[j] & nums[k])) {++count;}\\n            }\\n        }\\n     }\\n     return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162322,
                "title": "rust-optimized-o-n-2",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_triplets(nums: Vec<i32>) -> i32 {\\n        let mut map = HashMap::with_capacity(10000);\\n        let mut res = 0;\\n        for i in 0..nums.len() {\\n            for j in 0..nums.len() {\\n                let x = nums[i] & nums[j];\\n                map.entry(x).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n        }\\n        for i in nums {\\n            for (k ,v) in &map {\\n                if i & k == 0 {\\n                    res += v;\\n                }\\n            } \\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_triplets(nums: Vec<i32>) -> i32 {\\n        let mut map = HashMap::with_capacity(10000);\\n        let mut res = 0;\\n        for i in 0..nums.len() {\\n            for j in 0..nums.len() {\\n                let x = nums[i] & nums[j];\\n                map.entry(x).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n        }\\n        for i in nums {\\n            for (k ,v) in &map {\\n                if i & k == 0 {\\n                    res += v;\\n                }\\n            } \\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3073917,
                "title": "java-clean-code-beats-100-explaination",
                "content": "we\\'re iterating over all the values from 0 to 216-1 for each A[i]. But we can make this loop faster by skipping over numbers that we can be sure wouldn\\'t give 0 when taken AND with A[i]. Let\\'s say, a (from A) = xxxx1000 and i (from loop) = 1000 so that a & i = 00001000 which is != 0. At this point, we can be sure that subsequent values after i i.e. 1001, 1010, 1011, 1100, ..., 1111 when taken AND with a won\\'t give 0 either because all of these have a 1 at bit position 3 so we can directly skip ahead to i = 10000. Note that this is essentially the same as previous approach in spirit.\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int countTriplets(int[] A) {\\n    int[] count = new int[1 << 16];\\n    for(int a: A) for(int b: A) count[a & b]++;\\n    int res = 0;\\n    for(int a: A) for(int i = 0; i < count.length; i++) {\\n    \\tif((a & i) == 0) res += count[i];\\n    \\telse i += (a & i) - 1;\\n    }\\n    return res;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int countTriplets(int[] A) {\\n    int[] count = new int[1 << 16];\\n    for(int a: A) for(int b: A) count[a & b]++;\\n    int res = 0;\\n    for(int a: A) for(int i = 0; i < count.length; i++) {\\n    \\tif((a & i) == 0) res += count[i];\\n    \\telse i += (a & i) - 1;\\n    }\\n    return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024507,
                "title": "python-5-lines-3-sum-variation-o-n-2",
                "content": "# Intuition\\nStore pairs of indices AND results and then compare each index value with stored values, storing should record number of repeats per AND value\\n\\n# Approach\\nNested loop everything with everything (quadratic), count how many times each and sum repeats, then run again loop for every value check if there is stored AND sum that combines to 0, if so increase result with number of repeats of that AND sum.\\n\\n# Complexity\\n- Time complexity:\\nO(N**2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countTriplets(self, A: List[int]) -> int:\\n        pairs, N = defaultdict(int), len(A)\\n        for i in range(N):\\n            for j in range(N):\\n                pairs[A[i]&A[j]] += 1\\n        return sum(pairs[k] if A[i] & k == 0 else 0 for k in pairs for i in range(N))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Function"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countTriplets(self, A: List[int]) -> int:\\n        pairs, N = defaultdict(int), len(A)\\n        for i in range(N):\\n            for j in range(N):\\n                pairs[A[i]&A[j]] += 1\\n        return sum(pairs[k] if A[i] & k == 0 else 0 for k in pairs for i in range(N))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002510,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_triplets(nums: Vec<i32>) -> i32 {\\n        let mut mp = std::collections::HashMap::new();\\n        for x in &nums {\\n            for y in &nums {\\n                *mp.entry(x & y).or_insert(0) += 1;\\n            }\\n        }\\n        let mut ans = 0;\\n        for (x, count) in mp {\\n            for y in &nums {\\n                if (x & y) == 0 {\\n                    ans += count;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_triplets(nums: Vec<i32>) -> i32 {\\n        let mut mp = std::collections::HashMap::new();\\n        for x in &nums {\\n            for y in &nums {\\n                *mp.entry(x & y).or_insert(0) += 1;\\n            }\\n        }\\n        let mut ans = 0;\\n        for (x, count) in mp {\\n            for y in &nums {\\n                if (x & y) == 0 {\\n                    ans += count;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998556,
                "title": "easy-brute-force-o-n-n-solution-c",
                "content": "\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        vector<int> freq(1<<16,0);\\n        for (auto a : nums)\\n            for (auto b : nums)\\n                freq[a & b]++;\\n        int cnt = 0;\\n        for (auto a : nums)\\n            for (auto mask = 0; mask < (1 << 16); mask++)\\n                if ((mask & a) == 0)\\n                    cnt += freq[mask];\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        vector<int> freq(1<<16,0);\\n        for (auto a : nums)\\n            for (auto b : nums)\\n                freq[a & b]++;\\n        int cnt = 0;\\n        for (auto a : nums)\\n            for (auto mask = 0; mask < (1 << 16); mask++)\\n                if ((mask & a) == 0)\\n                    cnt += freq[mask];\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974813,
                "title": "bit-manipulation-hashmap-c",
                "content": "*Pls do upvote if it helps \\uD83D\\uDE04*\\n\\n>*Code:*\\n\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int, int>mpp;\\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.size(); ++i)\\n        {\\n            for(int j=0; j<nums.size(); ++j)\\n            {\\n                int and_ = nums[i] & nums[j];\\n                mpp[and_]++;\\n            }\\n        }\\n        \\n        for(int i=0; i<nums.size(); ++i)\\n        {\\n            for(auto it : mpp)\\n            {\\n                if(!(it.first&nums[i]))\\n                {\\n                    ans += it.second;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n***\\uD83E\\uDD17***",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int, int>mpp;\\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.size(); ++i)\\n        {\\n            for(int j=0; j<nums.size(); ++j)\\n            {\\n                int and_ = nums[i] & nums[j];\\n                mpp[and_]++;\\n            }\\n        }\\n        \\n        for(int i=0; i<nums.size(); ++i)\\n        {\\n            for(auto it : mpp)\\n            {\\n                if(!(it.first&nums[i]))\\n                {\\n                    ans += it.second;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965193,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        freq = defaultdict(int)\\n        for x in nums: \\n            for y in nums: \\n                freq[x&y] += 1\\n        \\n        ans = 0\\n        for x in nums: \\n            mask = x = x ^ 0xffff\\n            while x: \\n                ans += freq[x]\\n                x = mask & (x-1)\\n            ans += freq[0]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        freq = defaultdict(int)\\n        for x in nums: \\n            for y in nums: \\n                freq[x&y] += 1\\n        \\n        ans = 0\\n        for x in nums: \\n            mask = x = x ^ 0xffff\\n            while x: \\n                ans += freq[x]\\n                x = mask & (x-1)\\n            ans += freq[0]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883181,
                "title": "c-solution-using-map",
                "content": "\\n\\n# Approach\\n-> Seeing the constraints, we know that n^2 solution will pass. \\n-> So, we first store the frequency of every (a[i]&a[j]) pair we can get inside an unordered_map.\\n-> Then we need to find the kth index, for which we again iterate through the array and check for every index.\\n-> Finally, if the condition is satisified we add it to the answer.\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countTriplets(vector<int>& nums) \\n    {\\n        unordered_map <int,int> mp;\\n        for(auto x:nums)\\n        {\\n            for(auto y:nums)\\n            {\\n                mp[(x&y)]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto x:mp)\\n        {\\n            for(auto y:nums)\\n            {\\n                if((x.first&y)==0)\\n                ans+=x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countTriplets(vector<int>& nums) \\n    {\\n        unordered_map <int,int> mp;\\n        for(auto x:nums)\\n        {\\n            for(auto y:nums)\\n            {\\n                mp[(x&y)]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto x:mp)\\n        {\\n            for(auto y:nums)\\n            {\\n                if((x.first&y)==0)\\n                ans+=x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867107,
                "title": "ts-use-hash-map-to-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Calculate the count of ``nums[i] & nums[j] & nums[k] === 0``, ``i !== j && i !== k && j !== k``\\n2. Calculate the count of ``nums[i] & nums[j] & nums[k] === 0``, ``i !== j``\\n    1. k is equal to i or equal to j.\\n3. Calculate the count of ``nums[i] & nums[j] & nums[k] === 0``, ``i === j && i === k``\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^3)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nfunction countTriplets(nums: number[]): number {\\n    let res = 0\\n    // (key, value) = (nums[i] & nums[j], count), i !== j\\n    const map = new Map<number, number>()\\n    const n = nums.length\\n    \\n    for (let i = 0; i < n; i++) {\\n        for (const entry of Array.from(map.entries())) {\\n            if ((nums[i] & entry[0]) === 0) {\\n                // (i, j, k), i !== j && i !== k && j !== k\\n                // 3! = 6\\n                // 3: the ways pick i into three slot.\\n                // 2: the ways pick j into two slot.\\n                // 1: the ways pick k into one slot.\\n                res += entry[1] * 6\\n            }\\n        }\\n\\n        for (let j = 0; j < i; j++) {\\n            // record the different ways that nums[i] & nums[j]\\n            map.set(nums[i] & nums[j], (map.get(nums[i] & nums[j]) ?? 0) + 1)\\n\\n            // (i, j, k), i !== j && (i === k || j === k)\\n            // i: C(3, 2) + C(3, 1) = 6\\n            // i: C(3, 2), the ways pick two i into three slot\\n            // i: C(3, 1), the ways pick one i into three slot \\n            if ((nums[i] & nums[j]) === 0)\\n                res += 6\\n        }\\n\\n        // (i, i, i)\\n        if (nums[i] === 0)\\n            res += 1\\n    }\\n\\n\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction countTriplets(nums: number[]): number {\\n    let res = 0\\n    // (key, value) = (nums[i] & nums[j], count), i !== j\\n    const map = new Map<number, number>()\\n    const n = nums.length\\n    \\n    for (let i = 0; i < n; i++) {\\n        for (const entry of Array.from(map.entries())) {\\n            if ((nums[i] & entry[0]) === 0) {\\n                // (i, j, k), i !== j && i !== k && j !== k\\n                // 3! = 6\\n                // 3: the ways pick i into three slot.\\n                // 2: the ways pick j into two slot.\\n                // 1: the ways pick k into one slot.\\n                res += entry[1] * 6\\n            }\\n        }\\n\\n        for (let j = 0; j < i; j++) {\\n            // record the different ways that nums[i] & nums[j]\\n            map.set(nums[i] & nums[j], (map.get(nums[i] & nums[j]) ?? 0) + 1)\\n\\n            // (i, j, k), i !== j && (i === k || j === k)\\n            // i: C(3, 2) + C(3, 1) = 6\\n            // i: C(3, 2), the ways pick two i into three slot\\n            // i: C(3, 1), the ways pick one i into three slot \\n            if ((nums[i] & nums[j]) === 0)\\n                res += 6\\n        }\\n\\n        // (i, i, i)\\n        if (nums[i] === 0)\\n            res += 1\\n    }\\n\\n\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2762964,
                "title": "c-solutions-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int i, j;\\n        int N = A.size();\\n        int Result = 0;\\n        \\n        vector<int> Map(1 << 16);\\n        \\n        for(i = 0; i < N; i++)\\n        {\\n            for(j = 0; j < N; j++)\\n            {\\n                Map[(A[i] & A[j])]++;\\n            }\\n        }\\n        \\n        for(i = 0; i < N; i++)\\n        {\\n            for(j = 0; j < (1 << 16); j++)\\n            {\\n                if((A[i] & j) == 0)\\n                {\\n                    Result += Map[j];\\n                }\\n                else\\n                {\\n                    j += (A[i] & j) - 1;\\n                }\\n            }\\n        }\\n        \\n        return Result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int i, j;\\n        int N = A.size();\\n        int Result = 0;\\n        \\n        vector<int> Map(1 << 16);\\n        \\n        for(i = 0; i < N; i++)\\n        {\\n            for(j = 0; j < N; j++)\\n            {\\n                Map[(A[i] & A[j])]++;\\n            }\\n        }\\n        \\n        for(i = 0; i < N; i++)\\n        {\\n            for(j = 0; j < (1 << 16); j++)\\n            {\\n                if((A[i] & j) == 0)\\n                {\\n                    Result += Map[j];\\n                }\\n                else\\n                {\\n                    j += (A[i] & j) - 1;\\n                }\\n            }\\n        }\\n        \\n        return Result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697136,
                "title": "c-o-n-n-n-2-16-easy-approach",
                "content": "\\n\\n# Approach\\nFirst calculate bitwise AND of every pair of array and store the frequency of that result in a vector. Now iterate the given array once again and do bitwise AND of every element with every index of previously calculated vector. If the result is 0 then add the frequency of the index to the answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n + n*(pow(2,16)))$$\\n\\n- Space complexity:\\n$$O(pow(2,16))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        int ans=0;\\n        int n = nums.size();\\n        vector<int> tmp(pow(2,16)+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                tmp[nums[i]&nums[j]]++;\\n            }\\n        }\\n        for(int i=0;i<tmp.size();i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&nums[j])==0)\\n                ans+=tmp[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        int ans=0;\\n        int n = nums.size();\\n        vector<int> tmp(pow(2,16)+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                tmp[nums[i]&nums[j]]++;\\n            }\\n        }\\n        for(int i=0;i<tmp.size();i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&nums[j])==0)\\n                ans+=tmp[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677112,
                "title": "c-ad-hoc",
                "content": "```\\nclass Solution {\\n    int count[65536];\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        int ans = 0,n = nums.size();\\n        vector<int> prods;\\n        memset(count,0,sizeof(count));\\n        for(int i=n-1;i>=0;i--){\\n            ans += (nums[i]==0);\\n            for(auto p:prods){\\n                if((nums[i]&p) == 0)\\n                    ans += 6*count[p];\\n            }\\n            for(int j=i+1;j<n;j++){\\n                if((nums[j]&nums[i]) == 0)\\n                    ans += 6;\\n                if(!(count[nums[j] & nums[i]]))\\n                    prods.push_back(nums[j] & nums[i]);\\n                count[nums[j] & nums[i]]++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int count[65536];\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        int ans = 0,n = nums.size();\\n        vector<int> prods;\\n        memset(count,0,sizeof(count));\\n        for(int i=n-1;i>=0;i--){\\n            ans += (nums[i]==0);\\n            for(auto p:prods){\\n                if((nums[i]&p) == 0)\\n                    ans += 6*count[p];\\n            }\\n            for(int j=i+1;j<n;j++){\\n                if((nums[j]&nums[i]) == 0)\\n                    ans += 6;\\n                if(!(count[nums[j] & nums[i]]))\\n                    prods.push_back(nums[j] & nums[i]);\\n                count[nums[j] & nums[i]]++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667308,
                "title": "python-easy-solution-beats-69-73",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        freq = defaultdict(int)\\n        for x in nums: \\n            for y in nums: \\n                freq[x&y] += 1\\n        \\n        ans = 0\\n        for x in nums: \\n            mask = x = x ^ 0xffff\\n            while x: \\n                ans += freq[x]\\n                x = mask & (x-1)\\n            ans += freq[0]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        freq = defaultdict(int)\\n        for x in nums: \\n            for y in nums: \\n                freq[x&y] += 1\\n        \\n        ans = 0\\n        for x in nums: \\n            mask = x = x ^ 0xffff\\n            while x: \\n                ans += freq[x]\\n                x = mask & (x-1)\\n            ans += freq[0]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632891,
                "title": "python-simple-solution-o-n-2",
                "content": "```\\ndef countTriplets(self, nums: List[int]) -> int:\\n\\td = Counter(a & b for a in nums for b in nums)\\n\\treturn sum(d[k] for n in nums for k in d if n&k==0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countTriplets(self, nums: List[int]) -> int:\\n\\td = Counter(a & b for a in nums for b in nums)\\n\\treturn sum(d[k] for n in nums for k in d if n&k==0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2512786,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int countTriplets(vector<int>& v) {\\n        vi(ll)ump(1 << 16, 0); // max possible size, as the b.w. & of {x,y} can never be greater than max(x,y) \\n        for (ll it : v) {\\n            for (ll ti : v) {\\n                ++ump[it & ti]; // ump[i]=j =>  j pairs {x,y} in total such that x&y==i\\n            }\\n        }\\n        ll ans = 0;\\n        for (ll it : v) {\\n            for (ll in = 0;in < ump.size();++in) {\\n                if ((in & it) == 0) {\\n                    ans += ump[in]; // here goes nothing\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int countTriplets(vector<int>& v) {\\n        vi(ll)ump(1 << 16, 0); // max possible size, as the b.w. & of {x,y} can never be greater than max(x,y) \\n        for (ll it : v) {\\n            for (ll ti : v) {\\n                ++ump[it & ti]; // ump[i]=j =>  j pairs {x,y} in total such that x&y==i\\n            }\\n        }\\n        ll ans = 0;\\n        for (ll it : v) {\\n            for (ll in = 0;in < ump.size();++in) {\\n                if ((in & it) == 0) {\\n                    ans += ump[in]; // here goes nothing\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460307,
                "title": "python3-2-lines-o-n-2",
                "content": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        dct=collections.Counter(a&b for a in nums for b in nums)\\n        return sum(dct[b] if a&b==0 else 0 for a in nums for b in dct)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        dct=collections.Counter(a&b for a in nums for b in nums)\\n        return sum(dct[b] if a&b==0 else 0 for a in nums for b in dct)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423117,
                "title": "count-pairs-and-then-triplets",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ctr = defaultdict(int)\\n        for i in range(n):\\n            for j in range(n):\\n                ctr[nums[i] & nums[j]] += 1\\n        res = 0\\n        for i in range(n):\\n            for val in ctr:\\n                if nums[i] & val == 0:\\n                    res += ctr[val]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ctr = defaultdict(int)\\n        for i in range(n):\\n            for j in range(n):\\n                ctr[nums[i] & nums[j]] += 1\\n        res = 0\\n        for i in range(n):\\n            for val in ctr:\\n                if nums[i] & val == 0:\\n                    res += ctr[val]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410071,
                "title": "python-solution-hash-table",
                "content": "I prefer using the hash table instead of array in this case to avoid checking the zeros\\nI am not sure why the question is tagged bit-manipulation though, doesn\\'t seem we can do much with considering the individual bits\\n\\n```\\n# Hash table solution\\nclass Solution:\\n    # i, j, k can repeat\\n    # 0 <= nums[i] < 2^(16)\\n    # 2^16 isn\\'t too big, and nums[i] & nums[j] would not go out of the range!\\n    # We can use an array to keep track of count of nums[i] & nums[j] first\\n    # Then for each nums[i], we & it against the current dp table\\n    def countTriplets(self, nums: List[int]) -> int:\\n        hash_table = {}\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(i,n):\\n                if nums[i] & nums[j] not in hash_table:\\n                    hash_table[nums[i] & nums[j]] = 0\\n                if i == j:\\n                    hash_table[nums[i]&nums[j]] += 1\\n                else:\\n                    hash_table[nums[i]&nums[j]] += 2\\n\\n        result = 0\\n        for key in list(hash_table.keys()):\\n            for num in nums:\\n                if num & key == 0:\\n                    result += hash_table[key]\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n# Hash table solution\\nclass Solution:\\n    # i, j, k can repeat\\n    # 0 <= nums[i] < 2^(16)\\n    # 2^16 isn\\'t too big, and nums[i] & nums[j] would not go out of the range!\\n    # We can use an array to keep track of count of nums[i] & nums[j] first\\n    # Then for each nums[i], we & it against the current dp table\\n    def countTriplets(self, nums: List[int]) -> int:\\n        hash_table = {}\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(i,n):\\n                if nums[i] & nums[j] not in hash_table:\\n                    hash_table[nums[i] & nums[j]] = 0\\n                if i == j:\\n                    hash_table[nums[i]&nums[j]] += 1\\n                else:\\n                    hash_table[nums[i]&nums[j]] += 2\\n\\n        result = 0\\n        for key in list(hash_table.keys()):\\n            for num in nums:\\n                if num & key == 0:\\n                    result += hash_table[key]\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407456,
                "title": "c-brute-force-beats-100",
                "content": "```\\n  public int CountTriplets(int[] nums) { \\n        int count=0;\\n        for(int i=0;i<nums.Length;i++){\\n            for(int j=i;j<nums.Length;j++){\\n                for(int k=j;k<nums.Length;k++){\\n                    if((nums[i]&nums[j]&nums[k])==0){ \\n                        if(!(j==k && i==j)){ \\n                            if(i==j || i==k || j==k){\\n                                count+=3;\\n                            }\\n                            else{\\n                                count+=6;\\n                            }\\n                        }\\n                        else{\\n                            count+=1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    } \\n```",
                "solutionTags": [],
                "code": "```\\n  public int CountTriplets(int[] nums) { \\n        int count=0;\\n        for(int i=0;i<nums.Length;i++){\\n            for(int j=i;j<nums.Length;j++){\\n                for(int k=j;k<nums.Length;k++){\\n                    if((nums[i]&nums[j]&nums[k])==0){ \\n                        if(!(j==k && i==j)){ \\n                            if(i==j || i==k || j==k){\\n                                count+=3;\\n                            }\\n                            else{\\n                                count+=6;\\n                            }\\n                        }\\n                        else{\\n                            count+=1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2387176,
                "title": "c-concise-code-using-hash-map",
                "content": "```\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int n = nums.size();\\n        for (int i = 0; i< n; i++)\\n            for (int j = 0; j < n; j++)\\n                m[(nums[i] & nums[j])]++;\\n        int c = 0;\\n        for (auto it: m)\\n            for (int i = 0; i < n; i++)\\n                if (!(it.first & nums[i]))\\n                    c += it.second;\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int n = nums.size();\\n        for (int i = 0; i< n; i++)\\n            for (int j = 0; j < n; j++)\\n                m[(nums[i] & nums[j])]++;\\n        int c = 0;\\n        for (auto it: m)\\n            for (int i = 0; i < n; i++)\\n                if (!(it.first & nums[i]))\\n                    c += it.second;\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228588,
                "title": "easy-python3-solution-explained",
                "content": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        ans = 0\\n        mem = [0] * (1 << 16)\\n        size = len(nums)\\n\\n        for i in range(size):\\n            for j in range(i, size):\\n                mem[nums[i]&nums[j]] += 2 if i != j else 1\\n        \\n        for ij in range(1 << 16):\\n            if mem[ij] > 0:\\n                for k in nums:\\n                    if k & ij == 0:\\n                        ans += mem[ij]\\n        return ans\\n```\\n\\t\\t\\n-- Success --\\nRuntime: 3169 ms, faster than 76.32% of Python3 online submissions for Triples with Bitwise AND Equal To Zero.\\nMemory Usage: 14.4 MB, less than 100.00% of Python3 online submissions for Triples with Bitwise AND Equal To Zero.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        ans = 0\\n        mem = [0] * (1 << 16)\\n        size = len(nums)\\n\\n        for i in range(size):\\n            for j in range(i, size):\\n                mem[nums[i]&nums[j]] += 2 if i != j else 1\\n        \\n        for ij in range(1 << 16):\\n            if mem[ij] > 0:\\n                for k in nums:\\n                    if k & ij == 0:\\n                        ans += mem[ij]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197953,
                "title": "hashtable-set-intersection-python-o-16-n-2",
                "content": "class Solution(object):\\n    def countTriplets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n    \\n        self.zeroTable = [set() for i in range(16)] #Create a zeroTable for checking; zeroTable[i] is set include all the numbers has 0 in bit i\\n\\n     \\n        self.biDict = {}\\n        nLen = len(nums)\\n\\n\\n        for n in range(nLen): #Step1. create the checking table\\n            for i in range(16):\\n                if((nums[n] & (1 << i)) == 0):\\n                    self.zeroTable[i].add(n)  \\n    \\n        results = 0 #Step 2. Go through all the possible combination of i,j.  Note: here can reduce some time, since (i, j) get same result as (j, i)\\n\\n        for i in range(nLen):         \\n            for j in range(nLen):\\n             \\n                tmp = nums[i] & nums[j] #For each possible combination i,j, check the number of possible k by function self.findSet() \\n                if(tmp == 0):   #If tmp is 0, then k can be any number\\n                    results += nLen \\n                else:   #If tmp is not 0, then check how many k satisify\\n                    results += self.findSet(tmp) \\n    \\n        return  results\\n    \\n    def findSet(self, num):   \\n        \\n        if(num in self.biDict): #hash mem\\n            return self.biDict[num]\\n        \\n        set1 = None\\n        for i in range(16): #Check the zero bit table, we want the intersections\\n            if((num & (1 << i)) != 0):\\n                if(set1 is None):\\n                   set1 = self.zeroTable[i]\\n                else:\\n                   set1 = set1 & self.zeroTable[i]\\n                \\n        if(set1 == None):\\n            self.biDict[num] = 0\\n            return 0\\n        \\n        self.biDict[num] = len(list(set1))\\n        return self.biDict[num] \\n",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "class Solution(object):\\n    def countTriplets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n    \\n        self.zeroTable = [set() for i in range(16)] #Create a zeroTable for checking; zeroTable[i] is set include all the numbers has 0 in bit i\\n\\n     \\n        self.biDict = {}",
                "codeTag": "Java"
            },
            {
                "id": 2186059,
                "title": "c-solution-hash-map-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //we can make an O(n**3) algorithm by simply iterating 3 times across the array and \\n    //taking the bitwise AND. That would involve a lot of duplicate AND calculation.\\n    //Instead we can iterate using two counters i and j, and store the count of every \\n    //bitwise AND we encounter in a hashmap. Then we will iterate the array and for every\\n    //value in the hashmap, if it\\'s bitwise AND with the current element is zero, then we\\n    //add the number of times that AND appears in our array to our answer.\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                mp[nums[i]&nums[j]]++;\\n            }\\n        }\\n        int ans=0;\\n        for(int k=0;k<nums.size();k++){\\n            for(unordered_map<int,int>::iterator it=mp.begin();it!=mp.end();it++){\\n                if(!(nums[k]&it->first)){\\n                    ans+=it->second;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    //we can make an O(n**3) algorithm by simply iterating 3 times across the array and \\n    //taking the bitwise AND. That would involve a lot of duplicate AND calculation.\\n    //Instead we can iterate using two counters i and j, and store the count of every \\n    //bitwise AND we encounter in a hashmap. Then we will iterate the array and for every\\n    //value in the hashmap, if it\\'s bitwise AND with the current element is zero, then we\\n    //add the number of times that AND appears in our array to our answer.\\n    int countTriplets(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                mp[nums[i]&nums[j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2058372,
                "title": "simple-javascript-solution-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countTriplets = function (nums) {\\n    let n = 1 << 16; // 65536\\n    let dp = create(n)\\n    \\n    // set end bit to 1\\n    dp[n - 1] = 1;\\n    \\n    // just compare 3 times\\n    let i = 3;\\n\\n    while (i--) {\\n        // set template for calculate\\n        const t = create(n)\\n\\n        // set value if not 0\\n        for (let k = 0; k < n; k++) {\\n            for (let a of nums) {\\n                t[k & a] += dp[k];\\n            }\\n        }\\n\\n        // assign to dp\\n        dp = t;\\n    }\\n\\n    // return first of dp\\n    return dp.shift();\\n\\n    // create array as filling\\n    function create(n) {\\n        return new Array(n).fill(0)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countTriplets = function (nums) {\\n    let n = 1 << 16; // 65536\\n    let dp = create(n)\\n    \\n    // set end bit to 1\\n    dp[n - 1] = 1;\\n    \\n    // just compare 3 times\\n    let i = 3;\\n\\n    while (i--) {\\n        // set template for calculate\\n        const t = create(n)\\n\\n        // set value if not 0\\n        for (let k = 0; k < n; k++) {\\n            for (let a of nums) {\\n                t[k & a] += dp[k];\\n            }\\n        }\\n\\n        // assign to dp\\n        dp = t;\\n    }\\n\\n    // return first of dp\\n    return dp.shift();\\n\\n    // create array as filling\\n    function create(n) {\\n        return new Array(n).fill(0)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2001390,
                "title": "c-o-2-16-n-time-o-2-16-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        map<int,int> mp;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                mp[nums[i] & nums[j]]++;\\n            }\\n        }\\n        for(auto it: mp) {\\n            int k = it.first;\\n            int cnt = it.second;\\n            for (int i = 0; i < n; ++i) {\\n                int num = nums[i];\\n                if((k&num)==0) {\\n                    res += (cnt);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        map<int,int> mp;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                mp[nums[i] & nums[j]]++;\\n            }\\n        }\\n        for(auto it: mp) {\\n            int k = it.first;\\n            int cnt = it.second;\\n            for (int i = 0; i < n; ++i) {\\n                int num = nums[i];\\n                if((k&num)==0) {\\n                    res += (cnt);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987130,
                "title": "scala-dp",
                "content": "```scala\\ndef countTriplets(nums: Array[Int]): Int = {\\n  val max = nums.max\\n  val dp = Array.fill(3)(new Array[Int](max + 1))\\n  nums.foreach(i => dp(0)(i) += 1)\\n  (0 until 2).foreach { i =>\\n    dp(i).indices.foreach { j =>\\n      nums.foreach { n =>\\n        dp(i+1)(j & n) += dp(i)(j)\\n      }\\n    }\\n  }\\n  dp(2)(0)\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```scala\\ndef countTriplets(nums: Array[Int]): Int = {\\n  val max = nums.max\\n  val dp = Array.fill(3)(new Array[Int](max + 1))\\n  nums.foreach(i => dp(0)(i) += 1)\\n  (0 until 2).foreach { i =>\\n    dp(i).indices.foreach { j =>\\n      nums.foreach { n =>\\n        dp(i+1)(j & n) += dp(i)(j)\\n      }\\n    }\\n  }\\n  dp(2)(0)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1797826,
                "title": "c-simple-recursion-approach-o-n-2-16-time-o-2-16-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void traverse(int i, unsigned curNum, unsigned num, int cnt[], int& res) {\\n        if (i == 16) {\\n            res += cnt[curNum];\\n            return;\\n        }\\n        \\n        if (((num >> i) & 1) == 0) {\\n            traverse(i+1, curNum, num, cnt, res);\\n            traverse(i+1, curNum + (1 << i), num, cnt, res);\\n        } else {\\n            traverse(i+1, curNum, num, cnt, res);\\n        }\\n    }\\n    \\n    int countTriplets(vector<int>& nums) {\\n        int res = 0;\\n        int cnt[1 << 16] = {0};\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = 0; j < nums.size(); ++j) {\\n                cnt[nums[i] & nums[j]]++;\\n            }\\n        }\\n        \\n        for (auto num: nums) {            \\n            traverse(0, 0, num, cnt, res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverse(int i, unsigned curNum, unsigned num, int cnt[], int& res) {\\n        if (i == 16) {\\n            res += cnt[curNum];\\n            return;\\n        }\\n        \\n        if (((num >> i) & 1) == 0) {\\n            traverse(i+1, curNum, num, cnt, res);\\n            traverse(i+1, curNum + (1 << i), num, cnt, res);\\n        } else {\\n            traverse(i+1, curNum, num, cnt, res);\\n        }\\n    }\\n    \\n    int countTriplets(vector<int>& nums) {\\n        int res = 0;\\n        int cnt[1 << 16] = {0};\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = 0; j < nums.size(); ++j) {\\n                cnt[nums[i] & nums[j]]++;\\n            }\\n        }\\n        \\n        for (auto num: nums) {            \\n            traverse(0, 0, num, cnt, res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726642,
                "title": "c-all-possible-solutions",
                "content": "Approach 1: Brute force. O(n^3)\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n     \\n        int result = 0;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                for(int k = 0; k < n; k++) {\\n                    if((nums[i] & nums[j] & nums[k]) == 0)\\n                        result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nApproach 2: **T.C -> O(n^2) S.C -> O(n)**\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n     \\n        // Find AND of all nums[i] & nums[j]. Store the rsult withh there count somewhere\\n        // Then loop again to find third number which makes i&j zero\\n        // Since, n has a max value of (2^16) - 1. So, make a table of 2^16\\n        // (A & B) will never result in a number greater than A and B both.\\n        \\n        vector<int> count(1 << 16, 0);        // Stores the count of a[i] & a[j]\\n        \\n        for(int a: nums) {\\n            for(int b: nums) {\\n                count[a & b]++;\\n            }\\n        }\\n        \\n        // (a & b) for any number will lie between [a, b]\\n        \\n        int triplets = 0;\\n        for(int val: nums) {\\n            for(int i = 0; i < count.size(); i++) {\\n                int aANDb = i;\\n                if((val & aANDb) == 0)\\n                    triplets += count[i];\\n            }\\n        }\\n        \\n        return triplets;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n     \\n        int result = 0;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                for(int k = 0; k < n; k++) {\\n                    if((nums[i] & nums[j] & nums[k]) == 0)\\n                        result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n     \\n        // Find AND of all nums[i] & nums[j]. Store the rsult withh there count somewhere\\n        // Then loop again to find third number which makes i&j zero\\n        // Since, n has a max value of (2^16) - 1. So, make a table of 2^16\\n        // (A & B) will never result in a number greater than A and B both.\\n        \\n        vector<int> count(1 << 16, 0);        // Stores the count of a[i] & a[j]\\n        \\n        for(int a: nums) {\\n            for(int b: nums) {\\n                count[a & b]++;\\n            }\\n        }\\n        \\n        // (a & b) for any number will lie between [a, b]\\n        \\n        int triplets = 0;\\n        for(int val: nums) {\\n            for(int i = 0; i < count.size(); i++) {\\n                int aANDb = i;\\n                if((val & aANDb) == 0)\\n                    triplets += count[i];\\n            }\\n        }\\n        \\n        return triplets;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723041,
                "title": "concise-cpp-solution-2-approaches-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) \\n    {\\n        /*\\n            1st we calculate the and of 2 elements from the \\n            given input and store the result in map \\n            \\n            then after we loop back again with nums with map element \\n            and check if ith element with map element of ans is zero of not \\n             if zero add the count of map ,\\n        */\\n        // ONE APPROACH USING MAP TAKES MORE RUN TIME \\n        // unordered_map<int,int>mp;\\n        // for(auto i:nums)\\n        // {\\n        //     for(auto j:nums)\\n        //     {\\n        //         mp[i&j]++;\\n        //     }\\n        // }\\n        // int cnt=0;\\n        // for(auto i:nums)\\n        // {\\n        //     for(auto j:mp)\\n        //     {\\n        //         if((i&j.first)== 0)\\n        //         {\\n        //                 cnt+=j.second;\\n        //         }\\n        //     }\\n        // }\\n        // return cnt;\\n        \\n        // USING VECTOR \\n        int mp[1<<16]={};\\n        for(auto i:nums)\\n        {\\n            for(auto j:nums)\\n            {\\n                mp[i&j]++;\\n            }\\n        }\\n        int cnt=0;\\n        for(auto i:nums)\\n        {\\n            for(int j=0;j<(1<<16) ;j++)\\n            {\\n                if((i&j) == 0)\\n                {\\n                    cnt+=mp[j];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) \\n    {\\n        /*\\n            1st we calculate the and of 2 elements from the \\n            given input and store the result in map \\n            \\n            then after we loop back again with nums with map element \\n            and check if ith element with map element of ans is zero of not \\n             if zero add the count of map ,\\n        */\\n        // ONE APPROACH USING MAP TAKES MORE RUN TIME \\n        // unordered_map<int,int>mp;\\n        // for(auto i:nums)\\n        // {\\n        //     for(auto j:nums)\\n        //     {\\n        //         mp[i&j]++;\\n        //     }\\n        // }\\n        // int cnt=0;\\n        // for(auto i:nums)\\n        // {\\n        //     for(auto j:mp)\\n        //     {\\n        //         if((i&j.first)== 0)\\n        //         {\\n        //                 cnt+=j.second;\\n        //         }\\n        //     }\\n        // }\\n        // return cnt;\\n        \\n        // USING VECTOR \\n        int mp[1<<16]={};\\n        for(auto i:nums)\\n        {\\n            for(auto j:nums)\\n            {\\n                mp[i&j]++;\\n            }\\n        }\\n        int cnt=0;\\n        for(auto i:nums)\\n        {\\n            for(int j=0;j<(1<<16) ;j++)\\n            {\\n                if((i&j) == 0)\\n                {\\n                    cnt+=mp[j];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697761,
                "title": "c-easy-hashing-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mp[(nums[i]&nums[j])]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto it: mp)\\n        {\\n            int k = it.first;\\n            for(int i=0;i<n;i++)\\n            {\\n                if((k&nums[i])==0)\\n                {\\n                    ans+=(it.second);\\n                }\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mp[(nums[i]&nums[j])]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto it: mp)\\n        {\\n            int k = it.first;\\n            for(int i=0;i<n;i++)\\n            {\\n                if((k&nums[i])==0)\\n                {\\n                    ans+=(it.second);\\n                }\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648792,
                "title": "java-bitmask-submask-enumeration",
                "content": "```\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int[] arr = new int[1<<17];\\n        HashMap<Integer, Integer> maskMap = new HashMap<>();\\n        for (int num : nums) {\\n            int mask = 0;\\n            for (int i = 0; i < 16; i++) {\\n                if ((num & (1 << i)) == 0) {\\n                    mask |= (1 << i);\\n                }\\n            }\\n            int s = mask;\\n            while (s > 0) {\\n               // maskMap.put(s, maskMap.getOrDefault(s, 0) + 1);\\n                arr[s]++;\\n                s = (s - 1) & mask;\\n            }\\n        }\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                int val = nums[i] & nums[j];\\n                if (val == 0) {\\n                    count += nums.length;\\n                } else {\\n                    int mask = 0;\\n                    for (int k = 0; k < 16; k++) {\\n                        if ((val & (1 << k)) > 0) {\\n                            mask |= (1 << k);\\n                        }\\n                    }\\n                    count += arr[mask];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] nums) {\\n        int[] arr = new int[1<<17];\\n        HashMap<Integer, Integer> maskMap = new HashMap<>();\\n        for (int num : nums) {\\n            int mask = 0;\\n            for (int i = 0; i < 16; i++) {\\n                if ((num & (1 << i)) == 0) {\\n                    mask |= (1 << i);\\n                }\\n            }\\n            int s = mask;\\n            while (s > 0) {\\n               // maskMap.put(s, maskMap.getOrDefault(s, 0) + 1);\\n                arr[s]++;\\n                s = (s - 1) & mask;\\n            }\\n        }\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                int val = nums[i] & nums[j];\\n                if (val == 0) {\\n                    count += nums.length;\\n                } else {\\n                    int mask = 0;\\n                    for (int k = 0; k < 16; k++) {\\n                        if ((val & (1 << k)) > 0) {\\n                            mask |= (1 << k);\\n                        }\\n                    }\\n                    count += arr[mask];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585522,
                "title": "python-trie-solution",
                "content": "This solution was inspired by [this solution](https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/discuss/228384/Java-Trie-Solution-O(n2)). \\n\\nBasically, get the result of & operations between any two numbers in the nums array and put the result in the trie. For each number, we can do a dfs to count how many of two-value-pair-&-result are eligible. \\n\\nDuring the process of tree traversing, whenever our bit is 0, we can go to both zero subtree and one subtree; when our bit is 1, we can only go to the zero subtree.\\n\\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.count = 0\\n        self.zero = None\\n        self.one = None\\n\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        size = len(nums)\\n        bitLen = max(map(int.bit_length, nums))\\n        trie = TrieNode()\\n\\t\\t# compute & result for pairs\\n        for num1 in nums:\\n            for num2 in nums:\\n                andVal = num1 & num2 \\n                curr = trie\\n                for _ in range(bitLen):\\n                    andVal, bit = divmod(andVal, 2) # get bit then shift\\n                    if bit == 1:\\n                        if not curr.one:\\n                            curr.one = TrieNode()\\n                        curr = curr.one\\n                    else:\\n                        if not curr.zero:\\n                            curr.zero = TrieNode()\\n                        curr = curr.zero\\n                curr.count += 1\\n\\t\\t\\t\\t\\n        def dfs(num, trie, level):\\n            if not trie: return 0\\n            if level == bitLen: return trie.count\\n            nextNum, bit = divmod(num, 2)\\n            if bit == 0:\\n                return dfs(nextNum, trie.zero, level + 1)\\\\\\n                    + dfs(nextNum, trie.one, level + 1)\\n            else:\\n                return dfs(nextNum, trie.zero, level + 1)\\n        from collections import Counter\\n        return sum(dfs(num, trie, 0) * count\\n            for num, count in Counter(nums).items()\\n        )\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.count = 0\\n        self.zero = None\\n        self.one = None\\n\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        size = len(nums)\\n        bitLen = max(map(int.bit_length, nums))\\n        trie = TrieNode()\\n\\t\\t# compute & result for pairs\\n        for num1 in nums:\\n            for num2 in nums:\\n                andVal = num1 & num2 \\n                curr = trie\\n                for _ in range(bitLen):\\n                    andVal, bit = divmod(andVal, 2) # get bit then shift\\n                    if bit == 1:\\n                        if not curr.one:\\n                            curr.one = TrieNode()\\n                        curr = curr.one\\n                    else:\\n                        if not curr.zero:\\n                            curr.zero = TrieNode()\\n                        curr = curr.zero\\n                curr.count += 1\\n\\t\\t\\t\\t\\n        def dfs(num, trie, level):\\n            if not trie: return 0\\n            if level == bitLen: return trie.count\\n            nextNum, bit = divmod(num, 2)\\n            if bit == 0:\\n                return dfs(nextNum, trie.zero, level + 1)\\\\\\n                    + dfs(nextNum, trie.one, level + 1)\\n            else:\\n                return dfs(nextNum, trie.zero, level + 1)\\n        from collections import Counter\\n        return sum(dfs(num, trie, 0) * count\\n            for num, count in Counter(nums).items()\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548836,
                "title": "using-hashmaps",
                "content": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        d = {}\\n        for i in nums:\\n            for j in nums:\\n                if (i & j) not in d:\\n                    d[i & j] = 0\\n                d[i & j] = d[i & j] + 1\\n        c = 0\\n        for i in d:\\n            for j in nums:\\n                if i & j == 0:\\n                    c = c + d[i]\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTriplets(self, nums: List[int]) -> int:\\n        d = {}\\n        for i in nums:\\n            for j in nums:\\n                if (i & j) not in d:\\n                    d[i & j] = 0\\n                d[i & j] = d[i & j] + 1\\n        c = 0\\n        for i in d:\\n            for j in nums:\\n                if i & j == 0:\\n                    c = c + d[i]\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471722,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n      \\n        int n=nums.size(),count=0;\\n        unordered_map<int,int>mp;\\n        for(auto k:nums){\\n            for(auto l:nums){\\n                mp[k&l]++;//mapping first two pair & frequency\\n            }\\n        }\\n         for(auto k:nums){\\n            for(auto l:mp){\\n                if((k&l.first)==0)//now (it is like 1&(2,3) where 1 comes from k and(2,3)comes from l for example)\\n                    count+=l.second;\\n            }\\n        }\\n       return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& nums) {\\n      \\n        int n=nums.size(),count=0;\\n        unordered_map<int,int>mp;\\n        for(auto k:nums){\\n            for(auto l:nums){\\n                mp[k&l]++;//mapping first two pair & frequency\\n            }\\n        }\\n         for(auto k:nums){\\n            for(auto l:mp){\\n                if((k&l.first)==0)//now (it is like 1&(2,3) where 1 comes from k and(2,3)comes from l for example)\\n                    count+=l.second;\\n            }\\n        }\\n       return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410246,
                "title": "javascript-dp",
                "content": "```\\nvar countTriplets = function (nums) {\\n    let N = 1 << 16;\\n        let dp = new Array(N).fill(0);\\n        dp[N - 1] = 1;\\n        for (let i = 0; i < 3; i++) {\\n            const temp = new Array(N).fill(0);\\n            for (let k = 0; k < N; k++) {\\n                for (let a of nums) {\\n                    temp[k & a] += dp[k];\\n                }\\n            }\\n            dp = temp;\\n        }\\n        return dp[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countTriplets = function (nums) {\\n    let N = 1 << 16;\\n        let dp = new Array(N).fill(0);\\n        dp[N - 1] = 1;\\n        for (let i = 0; i < 3; i++) {\\n            const temp = new Array(N).fill(0);\\n            for (let k = 0; k < N; k++) {\\n                for (let a of nums) {\\n                    temp[k & a] += dp[k];\\n                }\\n            }\\n            dp = temp;\\n        }\\n        return dp[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1376560,
                "title": "c-o-n-2-basic-maths",
                "content": "```\\n\\tint countTriplets(vector<int>& nums) {\\n        vector<int>count(1<<16,0);\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                ans++;\\n            }\\n            ans+=count[nums[i]]*3;\\n            for(int j=i+1;j<n;j++){\\n                ans+=count[nums[i]&nums[j]]*6;\\n                if((nums[i]&nums[j])==0){\\n                    ans+=3;\\n                }\\n            }\\n            for(int j=0;j<(1<<16);j++){\\n                if((nums[i]&j)==0){\\n                    count[j]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint countTriplets(vector<int>& nums) {\\n        vector<int>count(1<<16,0);\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                ans++;\\n            }\\n            ans+=count[nums[i]]*3;\\n            for(int j=i+1;j<n;j++){\\n                ans+=count[nums[i]&nums[j]]*6;\\n                if((nums[i]&nums[j])==0){\\n                    ans+=3;\\n                }\\n            }\\n            for(int j=0;j<(1<<16);j++){\\n                if((nums[i]&j)==0){\\n                    count[j]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038114,
                "title": "my-c-solution-using-bit-manipulation-faster-than-97-of-other-c-submissions",
                "content": "```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int n = A.size();\\n        int cnt[1<<16] = {};\\n        REP(i, n) REP(j, n) cnt[A[i] & A[j]]++;\\n        int ans = 0;\\n        REP(k, n){\\n            int cA = (1<<16) - 1 - A[k];\\n            for(int now = cA; now >= 1; now = (now - 1) & cA) ans += cnt[now];\\n            ans += cnt[0];\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int n = A.size();\\n        int cnt[1<<16] = {};\\n        REP(i, n) REP(j, n) cnt[A[i] & A[j]]++;\\n        int ans = 0;\\n        REP(k, n){\\n            int cA = (1<<16) - 1 - A[k];\\n            for(int now = cA; now >= 1; now = (now - 1) & cA) ans += cnt[now];\\n            ans += cnt[0];\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956944,
                "title": "kotlin",
                "content": "```\\nimport kotlin.collections.HashMap\\n\\nclass Solution {\\n    fun countTriplets(A: IntArray): Int {\\n             val map = HashMap<Int, Int>()\\n        var ret = 0\\n        val n = A.size\\n         for (i in A.indices) {\\n            for (j in A.indices) {\\n                val twoAnd = A[i] and A[j]\\n                if (map.containsKey(twoAnd)) {\\n                    map[twoAnd] = (map[twoAnd] ?: 0) + 1\\n                } else {\\n                    map[twoAnd] = 1\\n                }\\n            }\\n        \\n        }\\n        \\n       A.forEach { a ->\\n            map.keys.forEach { b ->\\n                if ((a and b) == 0) {\\n                    map[b]?.let {\\n                        ret += it\\n                    }\\n                }\\n\\n            }\\n        }\\n        return ret\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport kotlin.collections.HashMap\\n\\nclass Solution {\\n    fun countTriplets(A: IntArray): Int {\\n             val map = HashMap<Int, Int>()\\n        var ret = 0\\n        val n = A.size\\n         for (i in A.indices) {\\n            for (j in A.indices) {\\n                val twoAnd = A[i] and A[j]\\n                if (map.containsKey(twoAnd)) {\\n                    map[twoAnd] = (map[twoAnd] ?: 0) + 1\\n                } else {\\n                    map[twoAnd] = 1\\n                }\\n            }\\n        \\n        }\\n        \\n       A.forEach { a ->\\n            map.keys.forEach { b ->\\n                if ((a and b) == 0) {\\n                    map[b]?.let {\\n                        ret += it\\n                    }\\n                }\\n\\n            }\\n        }\\n        return ret\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954543,
                "title": "c-o-n-3-simple-solution-using-dictionary",
                "content": "```csharp\\npublic int CountTriplets(int[] nums) \\n{\\n\\tDictionary<int, int> counts = new Dictionary<int, int>();\\n\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tint andResult = nums[i] & nums[j];\\n\\t\\t\\tif(counts.ContainsKey(andResult))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcounts[andResult]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcounts.Add(andResult, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint result = 0;\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tforeach(var key in counts.Keys)\\n\\t\\t{\\n\\t\\t\\tif((num & key) == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult += counts[key];\\n\\t\\t\\t}\\n\\t\\t}            \\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int CountTriplets(int[] nums) \\n{\\n\\tDictionary<int, int> counts = new Dictionary<int, int>();\\n\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tint andResult = nums[i] & nums[j];\\n\\t\\t\\tif(counts.ContainsKey(andResult))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcounts[andResult]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcounts.Add(andResult, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint result = 0;\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tforeach(var key in counts.Keys)\\n\\t\\t{\\n\\t\\t\\tif((num & key) == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult += counts[key];\\n\\t\\t\\t}\\n\\t\\t}            \\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 715380,
                "title": "o-n-max-a-solution-c",
                "content": "The basic idea is to count the number of triplets that do not satisfy, then subtract that number from the total of all possile triplets. Applied Inclusion\\u2013exclusion principle (https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle) to achieve that.\\n\\nComplexity is O(N * max(A)). Since max(A) is bounded by 2^16, you might say it\\'s O(N) :)\\n\\nThe run time for C++ is 1000ms  (beat 5%), but I think it\\'s much faster than the O(N^2) solution when the size of input array is large.\\n\\n\\n```\\nint countTriplets(vector<int>& A) {\\n        int out = 0;\\n        int mx = 1;\\n        for (int a : A) mx = max(mx, a);\\n        for (int i = 1; i <= mx; ++i) {\\n            int ct = 0;\\n            for (int a : A) if ((i & a) == i) ++ct;\\n            if (ct == 0) continue;\\n            int v = ct * ct * ct;\\n            int ones = 0;\\n            int j = i;\\n            while (j) {\\n                if (j & 1) ++ones;\\n                j /= 2;\\n            }\\n            if (ones % 2)\\n                out += v;\\n            else\\n                out -= v;\\n        }\\n        int n = A.size();\\n        return n * n * n - out;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "The basic idea is to count the number of triplets that do not satisfy, then subtract that number from the total of all possile triplets. Applied Inclusion\\u2013exclusion principle (https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle) to achieve that.\\n\\nComplexity is O(N * max(A)). Since max(A) is bounded by 2^16, you might say it\\'s O(N) :)\\n\\nThe run time for C++ is 1000ms  (beat 5%), but I think it\\'s much faster than the O(N^2) solution when the size of input array is large.\\n\\n\\n```\\nint countTriplets(vector<int>& A) {\\n        int out = 0;\\n        int mx = 1;\\n        for (int a : A) mx = max(mx, a);\\n        for (int i = 1; i <= mx; ++i) {\\n            int ct = 0;\\n            for (int a : A) if ((i & a) == i) ++ct;\\n            if (ct == 0) continue;\\n            int v = ct * ct * ct;\\n            int ones = 0;\\n            int j = i;\\n            while (j) {\\n                if (j & 1) ++ones;\\n                j /= 2;\\n            }\\n            if (ones % 2)\\n                out += v;\\n            else\\n                out -= v;\\n        }\\n        int n = A.size();\\n        return n * n * n - out;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 711720,
                "title": "ruby-which-won-t-tle",
                "content": "\\n```\\ndef count_triplets(array)\\n  hash, total, n = {}, 0, (1<<16)\\n  array.repeated_permutation(2).each { |a, b| hash[a & b] ||= 0; hash[a & b]+=1 }\\n  array.each do |a|\\n    i = 0\\n    while i < n\\n      if a & i == 0\\n        total += hash[i].to_i\\n      else\\n\\t    # if a & i !=0, we could skip (a & i)-1\\n        i += (a & i) - 1\\n      end\\n      i += 1\\n    end\\n  end\\n  total\\nend\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef count_triplets(array)\\n  hash, total, n = {}, 0, (1<<16)\\n  array.repeated_permutation(2).each { |a, b| hash[a & b] ||= 0; hash[a & b]+=1 }\\n  array.each do |a|\\n    i = 0\\n    while i < n\\n      if a & i == 0\\n        total += hash[i].to_i\\n      else\\n\\t    # if a & i !=0, we could skip (a & i)-1\\n        i += (a & i) - 1\\n      end\\n      i += 1\\n    end\\n  end\\n  total\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 671546,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n       int length = A.size();\\n       int has[1<<16];\\n       memset(has,0,sizeof has);\\n       \\n        for (int i=0;i<length;i++) {\\n           for(int j=0;j < length; j++) {\\n               int idx = A[i] & A[j];\\n               has[A[i] & A[j]] ++;\\n           }\\n       }   \\n        int ans =0;\\n        for(int i=0;i<length;i++) {\\n            for(int j=0;j<(1<<16);j++) {\\n                if((A[i] & j) ==0 ) {\\n                     ans+= has[j];\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n       int length = A.size();\\n       int has[1<<16];\\n       memset(has,0,sizeof has);\\n       \\n        for (int i=0;i<length;i++) {\\n           for(int j=0;j < length; j++) {\\n               int idx = A[i] & A[j];\\n               has[A[i] & A[j]] ++;\\n           }\\n       }   \\n        int ans =0;\\n        for(int i=0;i<length;i++) {\\n            for(int j=0;j<(1<<16);j++) {\\n                if((A[i] & j) ==0 ) {\\n                     ans+= has[j];\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659459,
                "title": "simple-solution-in-golang",
                "content": "```\\n// attempt 2, to leverage the fact that a & b is in the range of two bytes\\n// (result num is 65536 at most)\\n// so we have to compute 2^16 * 1000 at most\\n\\nfunc countTriplets(A []int) (result int) {\\n\\tn := len(A)\\n\\n\\t//A[i]&A[j] -> array of j+1\\n\\tfrom := make(map[int][]int)\\n\\n\\tfor i := range A {\\n\\t\\tif A[i] == 0 {\\n\\t\\t\\tresult += 1 //1-dups\\n\\t\\t}\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tc := A[i] & A[j]\\n\\t\\t\\tfrom[c] = append(from[c], j+1)\\n\\t\\t\\tif c == 0 {\\n\\t\\t\\t\\tresult += 6 //2-dups\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t//3-dups\\n\\tfor c, pos := range from {\\n\\t\\tfor _, start := range pos {\\n\\t\\t\\tfor k := start; k < n; k++ {\\n\\t\\t\\t\\tif c&A[k] == 0 {\\n\\t\\t\\t\\t\\tresult += 6\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n\\n\\n// A more concise one (with regard to code) that does not\\n// need to wield dicuss on situation, and seems to be faster on the test cases\\n\\nfunc countTriplets(A []int) (result int) {\\n\\tcount := make(map[int]int)\\n\\tfor i := range A {\\n\\t\\tfor j := range A {\\n\\t\\t\\tx := A[i] & A[j]\\n\\t\\t\\tcount[x] = count[x] + 1\\n\\t\\t}\\n\\t}\\n\\tfor x, c := range count {\\n\\t\\tfor i := range A {\\n\\t\\t\\tif x&A[i] == 0 {\\n\\t\\t\\t\\tresult += c\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// attempt 2, to leverage the fact that a & b is in the range of two bytes\\n// (result num is 65536 at most)\\n// so we have to compute 2^16 * 1000 at most\\n\\nfunc countTriplets(A []int) (result int) {\\n\\tn := len(A)\\n\\n\\t//A[i]&A[j] -> array of j+1\\n\\tfrom := make(map[int][]int)\\n\\n\\tfor i := range A {\\n\\t\\tif A[i] == 0 {\\n\\t\\t\\tresult += 1 //1-dups\\n\\t\\t}\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tc := A[i] & A[j]\\n\\t\\t\\tfrom[c] = append(from[c], j+1)\\n\\t\\t\\tif c == 0 {\\n\\t\\t\\t\\tresult += 6 //2-dups\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t//3-dups\\n\\tfor c, pos := range from {\\n\\t\\tfor _, start := range pos {\\n\\t\\t\\tfor k := start; k < n; k++ {\\n\\t\\t\\t\\tif c&A[k] == 0 {\\n\\t\\t\\t\\t\\tresult += 6\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n\\n\\n// A more concise one (with regard to code) that does not\\n// need to wield dicuss on situation, and seems to be faster on the test cases\\n\\nfunc countTriplets(A []int) (result int) {\\n\\tcount := make(map[int]int)\\n\\tfor i := range A {\\n\\t\\tfor j := range A {\\n\\t\\t\\tx := A[i] & A[j]\\n\\t\\t\\tcount[x] = count[x] + 1\\n\\t\\t}\\n\\t}\\n\\tfor x, c := range count {\\n\\t\\tfor i := range A {\\n\\t\\t\\tif x&A[i] == 0 {\\n\\t\\t\\t\\tresult += c\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536665,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    int dp[][];\\n    int nums[];\\n    boolean visit[][];\\n    public int countTriplets(int[] nums) {\\n        this.nums=nums;\\n        int max=0;\\n        for(int n:nums)max=Math.max(n,max);\\n        dp=new int[max+1][3];\\n        visit=new boolean[max+1][3];\\n        int res=0;\\n        for(int n:nums){\\n            res+=dfs(n,0);\\n        }\\n        return res;\\n    }\\n    public int dfs(int num,int level){\\n        if(level==2){\\n            if(num==0)return 1;\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int n:nums){\\n            if(!visit[num&n][level+1]){\\n                dp[num&n][level+1]=dfs(num&n,level+1);\\n                visit[num&n][level+1]=true;\\n            }\\n            ans+=dp[num&n][level+1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    int nums[];\\n    boolean visit[][];\\n    public int countTriplets(int[] nums) {\\n        this.nums=nums;\\n        int max=0;\\n        for(int n:nums)max=Math.max(n,max);\\n        dp=new int[max+1][3];\\n        visit=new boolean[max+1][3];\\n        int res=0;\\n        for(int n:nums){\\n            res+=dfs(n,0);\\n        }\\n        return res;\\n    }\\n    public int dfs(int num,int level){\\n        if(level==2){\\n            if(num==0)return 1;\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int n:nums){\\n            if(!visit[num&n][level+1]){\\n                dp[num&n][level+1]=dfs(num&n,level+1);\\n                visit[num&n][level+1]=true;\\n            }\\n            ans+=dp[num&n][level+1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521793,
                "title": "just-dfs-3-parameters-memoization-current-state-current-counter-current-index",
                "content": "The code has been super clear enough to be self explained\\n```Scala\\n  def countTriplets(array: Array[Int]): Int = {\\n    val len = array.length\\n    if (len == 1) return if (array(0) == 0) 1 else 0\\n    var initialState = 0\\n    for (i <- 0 until 16) initialState |= (1 << i)\\n\\n    import scala.collection.mutable.Map\\n    val cc = Map[String, Int]()\\n\\n    def f(index: Int, count: Int, prevState: Int): Int = {\\n      if (index >= len) return 0\\n      if (count > 3) return 0\\n      if (count == 3) return if (prevState == 0) return 1 else 0\\n      val key = index + \"&\" + count + \"&\" + prevState\\n      if (cc.contains(key)) return cc(key)\\n      var res = 0\\n      for (i <- index until len) res += f(index, count + 1, prevState & array(i))\\n      cc.put(key, res)\\n      res\\n    }\\n    f(0, 0, initialState)\\n  }\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  def countTriplets(array: Array[Int]): Int = {\\n    val len = array.length\\n    if (len == 1) return if (array(0) == 0) 1 else 0\\n    var initialState = 0\\n    for (i <- 0 until 16) initialState |= (1 << i)\\n\\n    import scala.collection.mutable.Map\\n    val cc = Map[String, Int]()\\n\\n    def f(index: Int, count: Int, prevState: Int): Int = {\\n      if (index >= len) return 0\\n      if (count > 3) return 0\\n      if (count == 3) return if (prevState == 0) return 1 else 0\\n      val key = index + \"&\" + count + \"&\" + prevState\\n      if (cc.contains(key)) return cc(key)\\n      var res = 0\\n      for (i <- index until len) res += f(index, count + 1, prevState & array(i))\\n      cc.put(key, res)\\n      res\\n    }\\n    f(0, 0, initialState)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 517293,
                "title": "yet-another-java-solution",
                "content": "```\\nclass Solution {\\n    public int countTriplets(int[] a) {\\n        \\n        if( a == null || a.length == 0 ) return 0;\\n        int n = a.length;\\n        int[] mem = new int[1<<16];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int key=a[i]&a[j];\\n                mem[key]++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<(1<<16);i++){\\n            if(mem[i]==0) continue;\\n            for(int j=0;j<n;j++){\\n                if( (i&a[j]) == 0) {\\n                    cnt+=mem[i];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] a) {\\n        \\n        if( a == null || a.length == 0 ) return 0;\\n        int n = a.length;\\n        int[] mem = new int[1<<16];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int key=a[i]&a[j];\\n                mem[key]++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<(1<<16);i++){\\n            if(mem[i]==0) continue;\\n            for(int j=0;j<n;j++){\\n                if( (i&a[j]) == 0) {\\n                    cnt+=mem[i];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497225,
                "title": "c-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n       int length = A.size();\\n       int has[1<<16];\\n       memset(has,0,sizeof has);\\n       \\n        for (int i=0;i<length;i++) {\\n           for(int j=0;j < length; j++) {\\n               int idx = A[i] & A[j];\\n               has[A[i] & A[j]] ++;\\n           }\\n       } \\n        \\n        int ans =0;\\n        for(int i=0;i<length;i++) {\\n            for(int j=0;j<(1<<16);j++) {\\n                if((A[i] & j) ==0 ) {\\n                     ans+= has[j];\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n       int length = A.size();\\n       int has[1<<16];\\n       memset(has,0,sizeof has);\\n       \\n        for (int i=0;i<length;i++) {\\n           for(int j=0;j < length; j++) {\\n               int idx = A[i] & A[j];\\n               has[A[i] & A[j]] ++;\\n           }\\n       } \\n        \\n        int ans =0;\\n        for(int i=0;i<length;i++) {\\n            for(int j=0;j<(1<<16);j++) {\\n                if((A[i] & j) ==0 ) {\\n                     ans+= has[j];\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492533,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int len = A.length;\\n        if(len == 0) return 0;\\n        int ans  = 0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n        // Creating all possible pairs\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < len; j++) {\\n                int v = A[i]&A[j];\\n                if(hm.containsKey(v)) {\\n                    hm.put(v, hm.get(v) + 1);\\n                } else {\\n                    hm.put(v,1);\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i = 0; i < len; i++) {\\n            for(Integer j : hm.keySet()) {\\n                int v = j & A[i];\\n                if(v == 0) {\\n                    ans += hm.get(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int len = A.length;\\n        if(len == 0) return 0;\\n        int ans  = 0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n        // Creating all possible pairs\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < len; j++) {\\n                int v = A[i]&A[j];\\n                if(hm.containsKey(v)) {\\n                    hm.put(v, hm.get(v) + 1);\\n                } else {\\n                    hm.put(v,1);\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i = 0; i < len; i++) {\\n            for(Integer j : hm.keySet()) {\\n                int v = j & A[i];\\n                if(v == 0) {\\n                    ans += hm.get(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448958,
                "title": "c-24ms-time-o-n-n",
                "content": "1. first, use two for-loop to get the occur times of `A[i] & A[j]`.\\n2. then, for each `A[i]`, to make `x & A[i] == 0`, x must be the subset of  `(~A[i]) & ((1<<16)-1)`. We can just use the trick to find the subset: suppose `a` is the total set, `for(j=a; j; j=(j-1)&a)` with generate the full subset of `a` with a dec sequence.\\n3. Time complexity:\\n`O(max(n*n, 2^16*n))`\\nSpace:\\n`O(2^16)`\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        vector<int> ump(1<<16, 0);\\n        int n = A.size();\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                ump[A[i]&A[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            int t = (~A[i]) & ((1 << 16)-1);\\n            for(int j=t; j; j=(j-1)&t) {\\n                ans += ump[j];\\n            }\\n            ans+=ump[0];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        vector<int> ump(1<<16, 0);\\n        int n = A.size();\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                ump[A[i]&A[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            int t = (~A[i]) & ((1 << 16)-1);\\n            for(int j=t; j; j=(j-1)&t) {\\n                ans += ump[j];\\n            }\\n            ans+=ump[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444694,
                "title": "it-s-not-bad-c-17-solution-like-the-3-sum",
                "content": "```\\nclass Solution {\\n public:\\n  int countTriplets(vector<int>& A) {\\n    std::array<optional<int>, (1 << 16) + 1> memo = {};\\n    for (auto a : A) for (auto b : A) memo[a & b] = memo[a & b].value_or(0) + 1;\\n    return [&](int acc = 0) {\\n      for (auto c : A)\\n        for (int i = 0; i < (1 << 16); ++i)\\n          if (memo[i] and (c & i) == 0) acc += *memo[i];\\n      return acc;\\n    }();\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int countTriplets(vector<int>& A) {\\n    std::array<optional<int>, (1 << 16) + 1> memo = {};\\n    for (auto a : A) for (auto b : A) memo[a & b] = memo[a & b].value_or(0) + 1;\\n    return [&](int acc = 0) {\\n      for (auto c : A)\\n        for (int i = 0; i < (1 << 16); ++i)\\n          if (memo[i] and (c & i) == 0) acc += *memo[i];\\n      return acc;\\n    }();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440354,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int CountTriplets(int[] nums) \\n    {\\n        int result = 0;\\n        var dict = new Dictionary<int, int>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            for(int j = 0; j < nums.Length; j++)\\n            {\\n                var and = nums[i] & nums[j];\\n                if(!dict.ContainsKey(and)) \\n                    dict[and] = 0;\\n                dict[and]++;\\n            }\\n        }\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n            foreach(var kvp in dict)\\n                if ((kvp.Key & nums[i]) == 0) \\n                    result += kvp.Value;\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int CountTriplets(int[] nums) \\n    {\\n        int result = 0;\\n        var dict = new Dictionary<int, int>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            for(int j = 0; j < nums.Length; j++)\\n            {\\n                var and = nums[i] & nums[j];\\n                if(!dict.ContainsKey(and)) \\n                    dict[and] = 0;\\n                dict[and]++;\\n            }\\n        }\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n            foreach(var kvp in dict)\\n                if ((kvp.Key & nums[i]) == 0) \\n                    result += kvp.Value;\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415970,
                "title": "c-n-2-16-solution",
                "content": "```\\nclass Solution {\\n    #define pii pair<int,int>\\n    #define F first\\n    #define S second\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        vector<pair<int,int>> h[(1<<16)+1];\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j = 0;j<A.size();j++)\\n            {\\n                int o = (A[i]&A[j]);\\n                h[o].push_back({i,j});\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j =0;j<(1<<16);j++)\\n            {\\n                if((j&A[i])==0)\\n                    ans += h[j].size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    #define pii pair<int,int>\\n    #define F first\\n    #define S second\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        vector<pair<int,int>> h[(1<<16)+1];\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j = 0;j<A.size();j++)\\n            {\\n                int o = (A[i]&A[j]);\\n                h[o].push_back({i,j});\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j =0;j<(1<<16);j++)\\n            {\\n                if((j&A[i])==0)\\n                    ans += h[j].size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391361,
                "title": "a-simple-rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn count_triplets(a: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        for i in &a {\\n            for j in &a {\\n                for k in &a {\\n                    if i & j & k == 0 {\\n                        result += 1;\\n                    }\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```\\n\\nwhy hard...",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn count_triplets(a: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        for i in &a {\\n            for j in &a {\\n                for k in &a {\\n                    if i & j & k == 0 {\\n                        result += 1;\\n                    }\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365750,
                "title": "map-solution-javascript-o-n-n-2-16-time",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\nvar countTriplets = function(A) {\\n    let res=0;\\n    let map=new Map();\\n    for(let it1 of A){\\n        for(let it2 of A){\\n            let k=(it1&it2);\\n            let v=map.get(k)||0;\\n            map.set(k,v+1);\\n        }\\n    }\\n    for(let [k,v] of map){\\n        for(let it2 of A){\\n            if((k&it2)==0)\\n                res+=v;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\nvar countTriplets = function(A) {\\n    let res=0;\\n    let map=new Map();\\n    for(let it1 of A){\\n        for(let it2 of A){\\n            let k=(it1&it2);\\n            let v=map.get(k)||0;\\n            map.set(k,v+1);\\n        }\\n    }\\n    for(let [k,v] of map){\\n        for(let it2 of A){\\n            if((k&it2)==0)\\n                res+=v;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363049,
                "title": "c-short-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int cnt = 0;\\n        unordered_map<int, int> s;\\n        for(int i = 0; i < A.size(); ++i) {\\n            for(int j = 0; j < A.size(); ++j) {\\n                ++s[A[i] & A[j]];\\n            }\\n        }\\n        for(auto &x: s) {\\n            for(int k = 0; k < A.size(); ++k) {\\n                if((x.first & A[k]) == 0) cnt += x.second;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int cnt = 0;\\n        unordered_map<int, int> s;\\n        for(int i = 0; i < A.size(); ++i) {\\n            for(int j = 0; j < A.size(); ++j) {\\n                ++s[A[i] & A[j]];\\n            }\\n        }\\n        for(auto &x: s) {\\n            for(int k = 0; k < A.size(); ++k) {\\n                if((x.first & A[k]) == 0) cnt += x.second;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330027,
                "title": "principle-of-inclusion-exclusion",
                "content": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int ans = 0;\\n        int N = A.length;\\n        for(int k = 1; k < (1 << 16); k++) {\\n            int count = 0;\\n            for(int i = 0; i < N; i++) {\\n                if((A[i] & k) == k) count++;\\n            }\\n            String s = Integer.toString(k, 2);\\n            int c = 0;\\n            for(int i = 0; i < s.length(); i++) {\\n                if(s.charAt(i) == \\'1\\') c++;\\n            }\\n            if(c % 2 == 1) ans += count * count * count;\\n            else ans -= count * count * count;\\n        }\\n        return N*N*N - ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int ans = 0;\\n        int N = A.length;\\n        for(int k = 1; k < (1 << 16); k++) {\\n            int count = 0;\\n            for(int i = 0; i < N; i++) {\\n                if((A[i] & k) == k) count++;\\n            }\\n            String s = Integer.toString(k, 2);\\n            int c = 0;\\n            for(int i = 0; i < s.length(); i++) {\\n                if(s.charAt(i) == \\'1\\') c++;\\n            }\\n            if(c % 2 == 1) ans += count * count * count;\\n            else ans -= count * count * count;\\n        }\\n        return N*N*N - ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328792,
                "title": "python-solution",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def countTriplets(self, A):\\n        c = Counter(x & y for x in A for y in A)\\n        return sum(c[xy] for xy in c for z in A if xy & z == 0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def countTriplets(self, A):\\n        c = Counter(x & y for x in A for y in A)\\n        return sum(c[xy] for xy in c for z in A if xy & z == 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305709,
                "title": "c-solution-o-n-2",
                "content": "Solution works well, but times seem a bit sluggish - any inputs would be appreciated.\\n\\nSolved this problem in two rounds.\\n\\n* Round 1 - checked all possible combinations of A. Counted how many times each result was reached and remembered new results\\n\\n* Round 2 - checked all combinations of A v.s. the results of round 1. Each time zero was reached,  the number of times the first number was reached in round 1 was added to final result.\\n\\nCheck it out: \\n\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        \\n        int ans = 0; \\n        int n = A.size();\\n        set<int> round1Results;\\n        vector<int> round1Histogram(pow(2,16));\\n        \\n\\t\\t//round 1\\n        //first the diagonal\\n        for (int i = 0; i < n; i++) {\\n            int res = A[i];\\n            round1Results.insert(res);\\n            round1Histogram[res]++;\\n        }\\n        \\n        //next the top half\\n        for (int i=0; i< n; i++ ) {\\n            for (int j=i+1; j< n; j++) {\\n                int res = A[i] & A[j];\\n                round1Results.insert(res);\\n                round1Histogram[res]+=2;\\n            }\\n        }\\n\\t\\t\\n        //round 2\\n        //we compare the results of round 1 with A and try to reach zero\\n        for (int i=0; i< n; i++) {\\n            for (int res1 : round1Results ) {\\n                if ((res1 & A[i]) == 0) {\\n                    ans+= round1Histogram[res1];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        \\n        int ans = 0; \\n        int n = A.size();\\n        set<int> round1Results;\\n        vector<int> round1Histogram(pow(2,16));\\n        \\n\\t\\t//round 1\\n        //first the diagonal\\n        for (int i = 0; i < n; i++) {\\n            int res = A[i];\\n            round1Results.insert(res);\\n            round1Histogram[res]++;\\n        }\\n        \\n        //next the top half\\n        for (int i=0; i< n; i++ ) {\\n            for (int j=i+1; j< n; j++) {\\n                int res = A[i] & A[j];\\n                round1Results.insert(res);\\n                round1Histogram[res]+=2;\\n            }\\n        }\\n\\t\\t\\n        //round 2\\n        //we compare the results of round 1 with A and try to reach zero\\n        for (int i=0; i< n; i++) {\\n            for (int res1 : round1Results ) {\\n                if ((res1 & A[i]) == 0) {\\n                    ans+= round1Histogram[res1];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257346,
                "title": "simple-golang",
                "content": "```\\nfunc countTriplets(A []int) int {\\n    hash := make(map[int]int)\\n    n := len(A)\\n    for i:= 0;i<n;i++ {\\n        for j:=0; j<n;j++ {\\n            hash[A[i] & A[j]]++\\n        }\\n    }\\n    count := 0\\n        for i:= 0;i<n;i++ {\\n            for k,v := range hash {\\n                if A[i] & k == 0 {\\n                    count += v\\n                }\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc countTriplets(A []int) int {\\n    hash := make(map[int]int)\\n    n := len(A)\\n    for i:= 0;i<n;i++ {\\n        for j:=0; j<n;j++ {\\n            hash[A[i] & A[j]]++\\n        }\\n    }\\n    count := 0\\n        for i:= 0;i<n;i++ {\\n            for k,v := range hash {\\n                if A[i] & k == 0 {\\n                    count += v\\n                }\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 240164,
                "title": "java-hashmap-dp-solution",
                "content": "```\\n    public int countTriplets(int[] A) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int a : A) {\\n            for(int b : A) {\\n                int v = a & b;\\n                count.put(v, count.getOrDefault(v, 0) + 1);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int a : A) {\\n            for(int e : count.keySet()) {\\n                if((a & e) == 0) res += count.get(e);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n public int countTriplets(int[] A) {\\n        int N = 1 << 16, M = 4;\\n        int[][] dp = new int[M][N];\\n    \\n        dp[0][N-1] = 1;\\n        for(int i = 0; i < M-1; i++) {\\n            for(int j = 0; j < N; j++) {\\n                for(int a : A) {\\n                    dp[i + 1][j & a] += dp[i][j];\\n                }\\n            }\\n        }\\n        return dp[M-1][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countTriplets(int[] A) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int a : A) {\\n            for(int b : A) {\\n                int v = a & b;\\n                count.put(v, count.getOrDefault(v, 0) + 1);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int a : A) {\\n            for(int e : count.keySet()) {\\n                if((a & e) == 0) res += count.get(e);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n public int countTriplets(int[] A) {\\n        int N = 1 << 16, M = 4;\\n        int[][] dp = new int[M][N];\\n    \\n        dp[0][N-1] = 1;\\n        for(int i = 0; i < M-1; i++) {\\n            for(int j = 0; j < N; j++) {\\n                for(int a : A) {\\n                    dp[i + 1][j & a] += dp[i][j];\\n                }\\n            }\\n        }\\n        return dp[M-1][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237071,
                "title": "java-map-solution-o-n-2-like-3sum",
                "content": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        for(int i = 0;i < A.length;i++){\\n            for(int j = 0;j < A.length;j++){\\n                \\n                int val = A[i] & A[j];\\n                \\n                map.put(val, map.getOrDefault(val, 0) + 1);\\n            }\\n        }\\n        for(Integer key : map.keySet()){\\n             for(int i = 0;i < A.length;i++){\\n                 if((key&A[i]) == 0) count+= map.get(key);\\n             }\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        for(int i = 0;i < A.length;i++){\\n            for(int j = 0;j < A.length;j++){\\n                \\n                int val = A[i] & A[j];\\n                \\n                map.put(val, map.getOrDefault(val, 0) + 1);\\n            }\\n        }\\n        for(Integer key : map.keySet()){\\n             for(int i = 0;i < A.length;i++){\\n                 if((key&A[i]) == 0) count+= map.get(key);\\n             }\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236339,
                "title": "golang-t-o-n-2-s-o-1-64-ms",
                "content": "```\\n// T: O(n^2) S: O(1)\\nfunc countTriplets(A []int) int {\\n    temp := make([]int, 1 << 16)\\n    for i := range A {\\n        temp[A[i]] = temp[A[i]] + 1\\n        for j := 1; j < len(A) - i;j = j + 1  {\\n            temp[A[i] & A[i:len(A)][j]] = temp[A[i] & A[i:len(A)][j]] + 2\\n        }\\n    }\\n    \\n    result := 0\\n    for i := range A {\\n        for j := range temp {\\n            if A[i] & j == 0 {\\n                result = result + temp[j]\\n            }\\n        }  \\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// T: O(n^2) S: O(1)\\nfunc countTriplets(A []int) int {\\n    temp := make([]int, 1 << 16)\\n    for i := range A {\\n        temp[A[i]] = temp[A[i]] + 1\\n        for j := 1; j < len(A) - i;j = j + 1  {\\n            temp[A[i] & A[i:len(A)][j]] = temp[A[i] & A[i:len(A)][j]] + 2\\n        }\\n    }\\n    \\n    result := 0\\n    for i := range A {\\n        for j := range temp {\\n            if A[i] & j == 0 {\\n                result = result + temp[j]\\n            }\\n        }  \\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234767,
                "title": "c-brute-force-o-n-3-time-o-1-space",
                "content": "Simple brute force gives you TLE, so little improvement has been made.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int N = A.size(), ret = 0;\\n        \\n        for (int i = 0; i < N; i++){\\n            if (A[i] == 0){\\n                ret++;\\n            }\\n            for (int j = i + 1; j < N; j++){\\n                if ((A[i] & A[i] & A[j]) == 0) {\\n                    ret += 3; // \"i i j\" can be ordered 3 different ways.\\n                }\\n\\t\\t\\t\\t// Permutation for P(3,3)\\n                if ((A[j] & A[j] & A[i]) == 0) {\\n                    ret += 3; // \"i j j\" can be ordered 3 different ways.\\n                }\\n                for (int k = j + 1; k < N; k++){\\n                    if ((A[i] & A[j] & A[k]) == 0){\\n                        ret += 6; // \"i j k\" can be ordered 6 different ways.\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int N = A.size(), ret = 0;\\n        \\n        for (int i = 0; i < N; i++){\\n            if (A[i] == 0){\\n                ret++;\\n            }\\n            for (int j = i + 1; j < N; j++){\\n                if ((A[i] & A[i] & A[j]) == 0) {\\n                    ret += 3; // \"i i j\" can be ordered 3 different ways.\\n                }\\n\\t\\t\\t\\t// Permutation for P(3,3)\\n                if ((A[j] & A[j] & A[i]) == 0) {\\n                    ret += 3; // \"i j j\" can be ordered 3 different ways.\\n                }\\n                for (int k = j + 1; k < N; k++){\\n                    if ((A[i] & A[j] & A[k]) == 0){\\n                        ret += 6; // \"i j k\" can be ordered 6 different ways.\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229715,
                "title": "python3-solution",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n        multi = defaultdict(int)\\n\\n        for i in range(len(A)):\\n            for j in range(len(A)):\\n                multi[A[i] & A[j]] += 1\\n\\n        ans = 0\\n        for i in range(len(A)):\\n            for key in multi.keys():\\n                if key & A[i] == 0:\\n                    ans += multi[key]\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n        multi = defaultdict(int)\\n\\n        for i in range(len(A)):\\n            for j in range(len(A)):\\n                multi[A[i] & A[j]] += 1\\n\\n        ans = 0\\n        for i in range(len(A)):\\n            for key in multi.keys():\\n                if key & A[i] == 0:\\n                    ans += multi[key]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229557,
                "title": "java-o-n2-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int count = 0;\\n        Map<Integer, List<String>> map = new HashMap();\\n        \\n        for(int i = 0;i < A.length;i++){\\n            for(int j = 0;j < A.length;j++){\\n                if(map.containsKey(A[i] & A[j])){\\n                    map.get(A[i] & A[j]).add(A[i] + \":\" + A[j]);\\n                }else{\\n                    List<String> list = new ArrayList();\\n                    list.add(A[i] + \":\" + A[j]);\\n                    map.put(A[i] & A[j], list);\\n                }\\n            }\\n        }\\n        for(Integer key : map.keySet()){\\n             for(int i = 0;i < A.length;i++){\\n                 if((key&A[i]) == 0) count+= map.get(key).size();\\n             }\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countTriplets(int[] A) {\\n        int count = 0;\\n        Map<Integer, List<String>> map = new HashMap();\\n        \\n        for(int i = 0;i < A.length;i++){\\n            for(int j = 0;j < A.length;j++){\\n                if(map.containsKey(A[i] & A[j])){\\n                    map.get(A[i] & A[j]).add(A[i] + \":\" + A[j]);\\n                }else{\\n                    List<String> list = new ArrayList();\\n                    list.add(A[i] + \":\" + A[j]);\\n                    map.put(A[i] & A[j], list);\\n                }\\n            }\\n        }\\n        for(Integer key : map.keySet()){\\n             for(int i = 0;i < A.length;i++){\\n                 if((key&A[i]) == 0) count+= map.get(key).size();\\n             }\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227664,
                "title": "copied-the-same-solution-but-different-runtime",
                "content": "So hover over the solutions submitted, you end up with a solution with runtime of 1400ms. I thought I would play around and check how it happened. On checking the exact same solution (on copy pasting and submitting) I got a different runtime of 3000ms. The exact same solution but different runtime. Can anyone explain?\\n\\nLink for that solution\\nhttps://leetcode.com/submissions/detail/204225880/",
                "solutionTags": [],
                "code": "So hover over the solutions submitted, you end up with a solution with runtime of 1400ms. I thought I would play around and check how it happened. On checking the exact same solution (on copy pasting and submitting) I got a different runtime of 3000ms. The exact same solution but different runtime. Can anyone explain?\\n\\nLink for that solution\\nhttps://leetcode.com/submissions/detail/204225880/",
                "codeTag": "Unknown"
            },
            {
                "id": 227131,
                "title": "o-n-2-time-trie-based-solution",
                "content": "```\\nclass Solution {\\n\\tclass WordDictionary {\\n\\t\\tTrieNode root;\\n\\n\\t\\tprivate class TrieNode {\\n\\t\\t\\tCharacter val;\\n\\t\\t\\tTrieNode[] map;\\n\\t\\t\\tboolean isString;\\n\\t\\t\\tint pairCount = 0;\\n\\t\\t\\tint singleCount = 0;\\n\\n\\t\\t\\tTrieNode() {\\n\\t\\t\\t\\tval = null;\\n\\t\\t\\t\\tmap = new TrieNode[2];\\n\\t\\t\\t\\tisString = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tTrieNode (Character val) {\\n\\t\\t\\t\\tthis.val = val;\\n\\t\\t\\t\\tmap = new TrieNode[2];\\n\\t\\t\\t\\tisString = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\t/** Initialize your data structure here. */\\n\\t\\tpublic WordDictionary() {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t}\\n\\n\\t\\t/** Adds a word into the data structure. */\\n\\t\\tpublic void addWord1(String word) {\\n\\t\\t\\tif (root == null) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tTrieNode cur  = root;\\n\\t\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\t\\tif (cur.map[c - \\'0\\'] == null) {\\n\\t\\t\\t\\t\\tcur.map[c - \\'0\\'] = new TrieNode(c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcur = cur.map[c - \\'0\\'];\\n\\t\\t\\t}\\n\\t\\t\\tcur.isString = true;\\n\\t\\t\\tcur.singleCount++;\\n\\t\\t}\\n\\n\\t\\tpublic void addWord2(String word) {\\n\\t\\t\\tif (root == null) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tTrieNode cur  = root;\\n\\t\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\t\\tif (cur.map[c - \\'0\\'] == null) {\\n\\t\\t\\t\\t\\tcur.map[c - \\'0\\'] = new TrieNode(c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcur = cur.map[c - \\'0\\'];\\n\\t\\t\\t}\\n\\t\\t\\tcur.isString = true;\\n\\t\\t\\tcur.pairCount++;\\n\\t\\t}\\n\\n\\t\\t/** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n\\t\\tpublic void search(String word,int[] count) {\\n\\t\\t\\tif (word == null) {\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tsearch(word,0,root,count);\\n\\t\\t}\\n\\n\\t\\tpublic void search (String word, int index, TrieNode start,int[] count) {\\n\\t\\t\\tif (index >= word.length()) {\\n\\t\\t\\t\\tcount[0] += start.singleCount;\\n\\t\\t\\t\\tcount[1] += 2 * start.pairCount;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tchar c = word.charAt(index);\\n\\t\\t\\t\\tif (c != \\'.\\') {\\n\\t\\t\\t\\t\\tif (start.map[c - \\'0\\'] == null) {\\n\\t\\t\\t\\t\\t\\treturn ;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tsearch(word,index + 1,start.map[c - \\'0\\'],count);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tboolean found = false;\\n\\t\\t\\t\\t\\tfor (char i = \\'0\\'; i <= \\'1\\'; i++) {\\n\\t\\t\\t\\t\\t\\tif (start.map[i - \\'0\\'] != null) {\\n\\t\\t\\t\\t\\t\\t\\tsearch(word,index + 1,start.map[i - \\'0\\'],count);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tpublic int countTriplets(int[] A) {\\n\\t\\tWordDictionary dict = new WordDictionary();\\n\\t\\tfor (int i = 0; i < A.length; i++) {\\n\\t\\t\\tString w = Integer.toBinaryString(A[i]);\\n\\t\\t\\tStringBuilder wsb = new StringBuilder();\\n\\t\\t\\tfor (int j = 0; j < 17 - w.length(); j++) {\\n\\t\\t\\t\\twsb.append(\\'0\\');\\n\\t\\t\\t}\\n\\t\\t\\twsb.append(w);\\n            \\t\\t\\tw = wsb.toString();\\n\\n\\t\\t\\tdict.addWord1(w);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < A.length; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < A.length; j++) {\\n\\t\\t\\t\\tString w = Integer.toBinaryString(A[i] & A[j]);\\n\\t\\t\\t\\tStringBuilder wsb = new StringBuilder();\\n\\t\\t\\t\\tfor (int k = 0; k < 17 - w.length(); k++) {\\n\\t\\t\\t\\t\\twsb.append(\\'0\\');\\n\\t\\t\\t\\t}\\n            \\n\\t\\t\\t\\twsb.append(w);\\n                \\t\\t\\tw = wsb.toString();\\n\\n\\t\\t\\t\\tdict.addWord2(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint[] count = new int[2];\\n\\t\\tfor (int i = 0; i < A.length; i++) {\\n\\t\\t\\tStringBuilder match = new StringBuilder();\\n\\t\\t\\tString w = Integer.toBinaryString(A[i]);\\n\\t\\t\\tStringBuilder wsb = new StringBuilder();\\n\\t\\t\\tfor (int j = 0; j < 17 - w.length(); j++) {\\n\\t\\t\\t\\twsb.append(\\'0\\');\\n\\t\\t\\t}\\n\\t\\t\\twsb.append(w);\\n\\t\\t\\tw = wsb.toString();\\n\\t\\t\\tfor (int j = 0; j < w.length(); j++) {\\n\\t\\t\\t\\tif (w.charAt(j) == \\'1\\') {\\n\\t\\t\\t\\t\\tmatch.append(\\'0\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tmatch.append(\\'.\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(\"w = \" + w);\\n\\t\\t\\t// System.out.println(\"match = \" + match);\\n\\t\\t\\tdict.search(match.toString(),count);\\n\\t\\t\\t// System.out.println(\"count = \" + (count[0] + count[1]));\\n\\t\\t}\\n\\n\\t\\treturn count[0] + count[1];\\n\\t}\\n}\\n```\\nThis is not very efficient since I use String to represent the binary number and pad the string with leading zero.\\nI think a better solution would be use just numbers and the bit manipulation would be a little tricky.\\nTime complexity is O(N^2)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tclass WordDictionary {\\n\\t\\tTrieNode root;\\n\\n\\t\\tprivate class TrieNode {\\n\\t\\t\\tCharacter val;\\n\\t\\t\\tTrieNode[] map;\\n\\t\\t\\tboolean isString;\\n\\t\\t\\tint pairCount = 0;\\n\\t\\t\\tint singleCount = 0;\\n\\n\\t\\t\\tTrieNode() {\\n\\t\\t\\t\\tval = null;\\n\\t\\t\\t\\tmap = new TrieNode[2];\\n\\t\\t\\t\\tisString = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tTrieNode (Character val) {\\n\\t\\t\\t\\tthis.val = val;\\n\\t\\t\\t\\tmap = new TrieNode[2];\\n\\t\\t\\t\\tisString = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\t/** Initialize your data structure here. */\\n\\t\\tpublic WordDictionary() {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t}\\n\\n\\t\\t/** Adds a word into the data structure. */\\n\\t\\tpublic void addWord1(String word) {\\n\\t\\t\\tif (root == null) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tTrieNode cur  = root;\\n\\t\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\t\\tif (cur.map[c - \\'0\\'] == null) {\\n\\t\\t\\t\\t\\tcur.map[c - \\'0\\'] = new TrieNode(c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcur = cur.map[c - \\'0\\'];\\n\\t\\t\\t}\\n\\t\\t\\tcur.isString = true;\\n\\t\\t\\tcur.singleCount++;\\n\\t\\t}\\n\\n\\t\\tpublic void addWord2(String word) {\\n\\t\\t\\tif (root == null) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tTrieNode cur  = root;\\n\\t\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\t\\tif (cur.map[c - \\'0\\'] == null) {\\n\\t\\t\\t\\t\\tcur.map[c - \\'0\\'] = new TrieNode(c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcur = cur.map[c - \\'0\\'];\\n\\t\\t\\t}\\n\\t\\t\\tcur.isString = true;\\n\\t\\t\\tcur.pairCount++;\\n\\t\\t}\\n\\n\\t\\t/** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n\\t\\tpublic void search(String word,int[] count) {\\n\\t\\t\\tif (word == null) {\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tsearch(word,0,root,count);\\n\\t\\t}\\n\\n\\t\\tpublic void search (String word, int index, TrieNode start,int[] count) {\\n\\t\\t\\tif (index >= word.length()) {\\n\\t\\t\\t\\tcount[0] += start.singleCount;\\n\\t\\t\\t\\tcount[1] += 2 * start.pairCount;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tchar c = word.charAt(index);\\n\\t\\t\\t\\tif (c != \\'.\\') {\\n\\t\\t\\t\\t\\tif (start.map[c - \\'0\\'] == null) {\\n\\t\\t\\t\\t\\t\\treturn ;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tsearch(word,index + 1,start.map[c - \\'0\\'],count);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tboolean found = false;\\n\\t\\t\\t\\t\\tfor (char i = \\'0\\'; i <= \\'1\\'; i++) {\\n\\t\\t\\t\\t\\t\\tif (start.map[i - \\'0\\'] != null) {\\n\\t\\t\\t\\t\\t\\t\\tsearch(word,index + 1,start.map[i - \\'0\\'],count);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tpublic int countTriplets(int[] A) {\\n\\t\\tWordDictionary dict = new WordDictionary();\\n\\t\\tfor (int i = 0; i < A.length; i++) {\\n\\t\\t\\tString w = Integer.toBinaryString(A[i]);\\n\\t\\t\\tStringBuilder wsb = new StringBuilder();\\n\\t\\t\\tfor (int j = 0; j < 17 - w.length(); j++) {\\n\\t\\t\\t\\twsb.append(\\'0\\');\\n\\t\\t\\t}\\n\\t\\t\\twsb.append(w);\\n            \\t\\t\\tw = wsb.toString();\\n\\n\\t\\t\\tdict.addWord1(w);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < A.length; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < A.length; j++) {\\n\\t\\t\\t\\tString w = Integer.toBinaryString(A[i] & A[j]);\\n\\t\\t\\t\\tStringBuilder wsb = new StringBuilder();\\n\\t\\t\\t\\tfor (int k = 0; k < 17 - w.length(); k++) {\\n\\t\\t\\t\\t\\twsb.append(\\'0\\');\\n\\t\\t\\t\\t}\\n            \\n\\t\\t\\t\\twsb.append(w);\\n                \\t\\t\\tw = wsb.toString();\\n\\n\\t\\t\\t\\tdict.addWord2(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint[] count = new int[2];\\n\\t\\tfor (int i = 0; i < A.length; i++) {\\n\\t\\t\\tStringBuilder match = new StringBuilder();\\n\\t\\t\\tString w = Integer.toBinaryString(A[i]);\\n\\t\\t\\tStringBuilder wsb = new StringBuilder();\\n\\t\\t\\tfor (int j = 0; j < 17 - w.length(); j++) {\\n\\t\\t\\t\\twsb.append(\\'0\\');\\n\\t\\t\\t}\\n\\t\\t\\twsb.append(w);\\n\\t\\t\\tw = wsb.toString();\\n\\t\\t\\tfor (int j = 0; j < w.length(); j++) {\\n\\t\\t\\t\\tif (w.charAt(j) == \\'1\\') {\\n\\t\\t\\t\\t\\tmatch.append(\\'0\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tmatch.append(\\'.\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(\"w = \" + w);\\n\\t\\t\\t// System.out.println(\"match = \" + match);\\n\\t\\t\\tdict.search(match.toString(),count);\\n\\t\\t\\t// System.out.println(\"count = \" + (count[0] + count[1]));\\n\\t\\t}\\n\\n\\t\\treturn count[0] + count[1];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227112,
                "title": "javascript-with-memory",
                "content": "Get this solution from \\nhttps://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/discuss/226778/C%2B%2B-2056ms\\n\\n\\n```js\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\nvar countTriplets = function(A) {\\n    var count = 0;\\n    var countMap = {};\\n    \\n    _.each(A, i => {\\n        _.each(A, j => {\\n            var t = i & j;\\n            if (!_.has(countMap, t)) {\\n                countMap[t] = 0;\\n                _.each(A, k => {\\n                    if ((k & t) === 0) countMap[t]++;\\n                })\\n            }\\n            count += countMap[t];\\n        });\\n    });\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\nvar countTriplets = function(A) {\\n    var count = 0;\\n    var countMap = {};\\n    \\n    _.each(A, i => {\\n        _.each(A, j => {\\n            var t = i & j;\\n            if (!_.has(countMap, t)) {\\n                countMap[t] = 0;\\n                _.each(A, k => {\\n                    if ((k & t) === 0) countMap[t]++;\\n                })\\n            }\\n            count += countMap[t];\\n        });\\n    });\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227082,
                "title": "c-14-lines-n-2-simply-enumerate",
                "content": "record every all the result of A[i] & A[j], and then enumerate A[k].\\n\\n```\\nint countTriplets(vector<int>& A) {\\n        int ans = 0;\\n        unordered_map<int, int> record;\\n        for(int i = 0; i < A.size(); i++)\\n            for(int j = 0; j < A.size(); j++) {\\n                record[(A[i] & A[j])] ++;\\n            }\\n        for(auto iter : record) \\n            for(int k = 0; k < A.size(); k++) {\\n                if((iter.first & A[k]) == 0) {\\n                    ans += iter.second;\\n                }\\n            }\\n        return ans;\\n    }\\n```\\n\\n(To be honest, I am not sure it is O(n^2), it beats 82.5%)",
                "solutionTags": [],
                "code": "```\\nint countTriplets(vector<int>& A) {\\n        int ans = 0;\\n        unordered_map<int, int> record;\\n        for(int i = 0; i < A.size(); i++)\\n            for(int j = 0; j < A.size(); j++) {\\n                record[(A[i] & A[j])] ++;\\n            }\\n        for(auto iter : record) \\n            for(int k = 0; k < A.size(); k++) {\\n                if((iter.first & A[k]) == 0) {\\n                    ans += iter.second;\\n                }\\n            }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226974,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int i,j,k,m,n=A.size(),c=0;\\n        for(i=0;i<n;i++){\\n            for(j=i;j<n;j++){\\n                m = A[i] & A[j];\\n                if(m==0){\\n                    if(i==j)c+=1+3*(n-j-1);\\n                    else c+=3+6*(n-j-1);\\n                    continue;\\n                }\\n                for(k=j;k<n;k++){\\n                    if((A[k] & m)==0){\\n                        if(i==j || j==k){\\n                            c+=3;\\n                        }\\n                        else{\\n                            c+=6;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int i,j,k,m,n=A.size(),c=0;\\n        for(i=0;i<n;i++){\\n            for(j=i;j<n;j++){\\n                m = A[i] & A[j];\\n                if(m==0){\\n                    if(i==j)c+=1+3*(n-j-1);\\n                    else c+=3+6*(n-j-1);\\n                    continue;\\n                }\\n                for(k=j;k<n;k++){\\n                    if((A[k] & m)==0){\\n                        if(i==j || j==k){\\n                            c+=3;\\n                        }\\n                        else{\\n                            c+=6;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226831,
                "title": "a-simple-approach-asking-for-optimize",
                "content": "This version has same time complexity O(n^3) as https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/discuss/226655/this-is-too-easy\\nWhy my version is Time Limit Exceeded\\n```\\nclass Solution {//O(n^3) Time Limit Exceeded\\n    int cnt = 0;\\n    public int countTriplets(int[] A) {\\n        int n = A.length;\\n        dfs(A,0,Integer.MAX_VALUE);\\n        return cnt;\\n    }\\n    \\n    void dfs(int[] A, int lvl, int cur){\\n        if(lvl==3){\\n            if(cur==0) cnt++;\\n            return;\\n        }\\n        for(int i=0; i<A.length;i++){\\n            dfs(A,lvl+1, cur&A[i]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {//O(n^3) Time Limit Exceeded\\n    int cnt = 0;\\n    public int countTriplets(int[] A) {\\n        int n = A.length;\\n        dfs(A,0,Integer.MAX_VALUE);\\n        return cnt;\\n    }\\n    \\n    void dfs(int[] A, int lvl, int cur){\\n        if(lvl==3){\\n            if(cur==0) cnt++;\\n            return;\\n        }\\n        for(int i=0; i<A.length;i++){\\n            dfs(A,lvl+1, cur&A[i]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226774,
                "title": "python3-an-easy-solution-6000-ms-to-run",
                "content": "``` python\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n        def find(x: int, dic={}) -> int:\\n            if x not in dic:\\n                dic[x] = sum(1 for i in range(len(A)) if A[i] & x == 0)\\n            return dic[x]\\n\\n        return sum(find(A[i] & A[j]) for i in range(len(A)) for j in range(len(A)))\\n```\\nIt took nearly 6000ms (5948ms) to run but it was still accepted.\\n`find(x)` function finds how many number `i` in `A` could make `i & x == 0`",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def countTriplets(self, A: \\'List[int]\\') -> \\'int\\':\\n        def find(x: int, dic={}) -> int:\\n            if x not in dic:\\n                dic[x] = sum(1 for i in range(len(A)) if A[i] & x == 0)\\n            return dic[x]\\n\\n        return sum(find(A[i] & A[j]) for i in range(len(A)) for j in range(len(A)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226769,
                "title": "the-most-difficult-part-of-the-problem-is-to-understand-the-requirement-correctly",
                "content": "and notice that A[i] < 2^16... The rest has not much space to play with.\\nMore specifically, \\nstep1: generate A[i] & A[j], whose amount is < 2^16. Can use unordered_map<int, int> to store {A[i] & A[j], count}.\\nstep2: for each A[i] & A[j], loop A to see if there is a k that satisfies the requirement, if so, ret += M[A[i]&A[j]];\\nstep3: return ret.\\n\\nThis problem sucks...",
                "solutionTags": [],
                "code": "and notice that A[i] < 2^16... The rest has not much space to play with.\\nMore specifically, \\nstep1: generate A[i] & A[j], whose amount is < 2^16. Can use unordered_map<int, int> to store {A[i] & A[j], count}.\\nstep2: for each A[i] & A[j], loop A to see if there is a k that satisfies the requirement, if so, ret += M[A[i]&A[j]];\\nstep3: return ret.\\n\\nThis problem sucks...",
                "codeTag": "Unknown"
            },
            {
                "id": 226768,
                "title": "o-n-2-3-16-time-solution",
                "content": "//  count[i] :  # A[j]=i\\n//  f[i]         :  # A[j] that the positions where i (regarded as 16-bit string) is 0, is a subset of those of A[j] (eg, i=101011  A[j] should be x0x0xx)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int count[(1<<16)+5],f[(1<<16)+5],S=(1<<16),n=A.size();\\n        for(int i=0;i<S;i++)f[i]=count[i]=0;\\n        for (int i=0;i<n;i++)count[A[i]]++;\\n        for (int i=0;i<S;i++)\\n        {\\n            if(count[i]==0)continue;\\n            \\n            //if(i!=3)continue;\\n            \\n            int m=0;\\n            vector<int> t=vector<int>(17,0);\\n            for (int j=0;j<16;j++)if(((1<<j)&i)==0)\\n            {\\n                m++;\\n                t[m]=j;\\n            }\\n            if(m==0)\\n            {\\n                f[i]+=count[i];\\n                continue;\\n            }\\n            for(int k=0;k<(1<<m);k++)\\n            {\\n                int tmp=i;\\n                for(int j=0;j<m;j++)if((k&(1<<j))!=0)\\n                {\\n                    tmp=tmp|(1<<t[j+1]);\\n                }\\n                f[tmp]+=count[i];\\n            }\\n        }\\n      \\n        int res=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                res+=f[(S-1)^(A[i]&A[j])];\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        int count[(1<<16)+5],f[(1<<16)+5],S=(1<<16),n=A.size();\\n        for(int i=0;i<S;i++)f[i]=count[i]=0;\\n        for (int i=0;i<n;i++)count[A[i]]++;\\n        for (int i=0;i<S;i++)\\n        {\\n            if(count[i]==0)continue;\\n            \\n            //if(i!=3)continue;\\n            \\n            int m=0;\\n            vector<int> t=vector<int>(17,0);\\n            for (int j=0;j<16;j++)if(((1<<j)&i)==0)\\n            {\\n                m++;\\n                t[m]=j;\\n            }\\n            if(m==0)\\n            {\\n                f[i]+=count[i];\\n                continue;\\n            }\\n            for(int k=0;k<(1<<m);k++)\\n            {\\n                int tmp=i;\\n                for(int j=0;j<m;j++)if((k&(1<<j))!=0)\\n                {\\n                    tmp=tmp|(1<<t[j+1]);\\n                }\\n                f[tmp]+=count[i];\\n            }\\n        }\\n      \\n        int res=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                res+=f[(S-1)^(A[i]&A[j])];\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226728,
                "title": "c-backtracking-with-memorization-beats-82",
                "content": "Backtracking with depth 3 for i, j, k with two enhancements:\\n1. Directly set the result if the current AND operation result is 0\\n2. Memorization\\n\\n```\\nclass Solution {\\nprivate:\\n    int n;\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        n = A.size();\\n        sort(A.begin(), A.end());\\n        vector<unordered_map<int, int>> memo(2);\\n        return backtrack(0, 0, A, memo);\\n    }\\n    \\n    int backtrack(int idx, int curr, vector<int>& A, vector<unordered_map<int, int>> &memo)\\n    {\\n        int res = 0;\\n        \\n        if (idx != 0 && memo[idx-1].count(curr))\\n            return memo[idx-1][curr];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int next = (idx == 0)?A[i]:A[i] & curr;\\n            \\n            if (next == 0)\\n            {\\n                if (idx == 2)\\n                    res++;\\n                else if (idx == 1)\\n                    res += n;\\n                else\\n                    res += n*n;\\n            }\\n            else if (idx != 2) \\n            {\\n                res += backtrack(idx+1, next, A, memo);\\n            }\\n        }\\n        \\n        if (idx != 0)\\n            memo[idx-1][curr] = res;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\npublic:\\n    int countTriplets(vector<int>& A) {\\n        n = A.size();\\n        sort(A.begin(), A.end());\\n        vector<unordered_map<int, int>> memo(2);\\n        return backtrack(0, 0, A, memo);\\n    }\\n    \\n    int backtrack(int idx, int curr, vector<int>& A, vector<unordered_map<int, int>> &memo)\\n    {\\n        int res = 0;\\n        \\n        if (idx != 0 && memo[idx-1].count(curr))\\n            return memo[idx-1][curr];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int next = (idx == 0)?A[i]:A[i] & curr;\\n            \\n            if (next == 0)\\n            {\\n                if (idx == 2)\\n                    res++;\\n                else if (idx == 1)\\n                    res += n;\\n                else\\n                    res += n*n;\\n            }\\n            else if (idx != 2) \\n            {\\n                res += backtrack(idx+1, next, A, memo);\\n            }\\n        }\\n        \\n        if (idx != 0)\\n            memo[idx-1][curr] = res;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    }
]