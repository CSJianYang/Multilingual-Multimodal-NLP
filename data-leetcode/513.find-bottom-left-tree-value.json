[
    {
        "title": "Find Bottom Left Tree Value",
        "question_content": "Given the root of a binary tree, return the leftmost value in the last row of the tree.\n&nbsp;\nExample 1:\n\nInput: root = [2,1,3]\nOutput: 1\n\nExample 2:\n\nInput: root = [1,2,3,4,null,5,6,null,null,7]\nOutput: 7\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 104].\n\t-231 <= Node.val <= 231 - 1",
        "solutions": [
            {
                "id": 98779,
                "title": "right-to-left-bfs-python-java",
                "content": "Doing BFS right-to-left means we can simply return the **last** node's value and don't have to keep track of the first node in the current row or even care about rows at all. Inspired by @fallcreek's solution (not published) which uses two nested loops to go row by row but already had the right-to-left idea making it easier. I just took that further.\\n\\n**Python:**\\n\\n    def findLeftMostNode(self, root):\\n        queue = [root]\\n        for node in queue:\\n            queue += filter(None, (node.right, node.left))\\n        return node.val\\n\\n**Java:**\\n\\n    public int findLeftMostNode(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while (!queue.isEmpty()) {\\n            root = queue.poll();\\n            if (root.right != null)\\n                queue.add(root.right);\\n            if (root.left != null)\\n                queue.add(root.left);\\n        }\\n        return root.val;\\n    }",
                "solutionTags": [],
                "code": "Doing BFS right-to-left means we can simply return the **last** node's value and don't have to keep track of the first node in the current row or even care about rows at all. Inspired by @fallcreek's solution (not published) which uses two nested loops to go row by row but already had the right-to-left idea making it easier. I just took that further.\\n\\n**Python:**\\n\\n    def findLeftMostNode(self, root):\\n        queue = [root]\\n        for node in queue:\\n            queue += filter(None, (node.right, node.left))\\n        return node.val\\n\\n**Java:**\\n\\n    public int findLeftMostNode(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while (!queue.isEmpty()) {\\n            root = queue.poll();\\n            if (root.right != null)\\n                queue.add(root.right);\\n            if (root.left != null)\\n                queue.add(root.left);\\n        }\\n        return root.val;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 98802,
                "title": "simple-java-solution-beats-100-0",
                "content": "``` java\\npublic class Solution {\\n    int ans=0, h=0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        findBottomLeftValue(root, 1);\\n        return ans;\\n    }\\n    public void findBottomLeftValue(TreeNode root, int depth) {\\n        if (h<depth) {ans=root.val;h=depth;}\\n        if (root.left!=null) findBottomLeftValue(root.left, depth+1);\\n        if (root.right!=null) findBottomLeftValue(root.right, depth+1);\\n    }\\n}\\n```\\n\\nNo global variables, 6ms (faster):\\n```\\npublic class Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        return findBottomLeftValue(root, 1, new int[]{0,0});\\n    }\\n    public int findBottomLeftValue(TreeNode root, int depth, int[] res) {\\n        if (res[1]<depth) {res[0]=root.val;res[1]=depth;}\\n        if (root.left!=null) findBottomLeftValue(root.left, depth+1, res);\\n        if (root.right!=null) findBottomLeftValue(root.right, depth+1, res);\\n        return res[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\npublic class Solution {\\n    int ans=0, h=0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        findBottomLeftValue(root, 1);\\n        return ans;\\n    }\\n    public void findBottomLeftValue(TreeNode root, int depth) {\\n        if (h<depth) {ans=root.val;h=depth;}\\n        if (root.left!=null) findBottomLeftValue(root.left, depth+1);\\n        if (root.right!=null) findBottomLeftValue(root.right, depth+1);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        return findBottomLeftValue(root, 1, new int[]{0,0});\\n    }\\n    public int findBottomLeftValue(TreeNode root, int depth, int[] res) {\\n        if (res[1]<depth) {res[0]=root.val;res[1]=depth;}\\n        if (root.left!=null) findBottomLeftValue(root.left, depth+1, res);\\n        if (root.right!=null) findBottomLeftValue(root.right, depth+1, res);\\n        return res[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98786,
                "title": "verbose-java-solution-binary-tree-level-order-traversal",
                "content": "Typical way to do binary tree level order traversal. Only additional step is to remember the ```first``` element of each level.\\n```\\npublic class Solution {\\n    public int findLeftMostNode(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        int result = 0;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                if (i == 0) result = node.val;\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```first```\n```\\npublic class Solution {\\n    public int findLeftMostNode(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        int result = 0;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                if (i == 0) result = node.val;\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98843,
                "title": "c-recursive-solution-beats-100-with-basic-explanation",
                "content": "Idea is simple:\\nKeep track of the depth of the tree as you move along. Once you get out of left and right subtree of a node, update the leftVal. Code is quite self explanatory. I have added some basic documentation. I hope that it helps!\\n\\n```\\nclass Solution {\\npublic:\\n    void findBottomLeftValue(TreeNode* root, int& maxDepth, int& leftVal, int depth) {\\n        if (root == NULL) {\\n            return;\\n        }\\n        //Go to the left and right of each node \\n        findBottomLeftValue(root->left, maxDepth, leftVal, depth+1);\\n        findBottomLeftValue(root->right, maxDepth, leftVal, depth+1);\\n        \\n        //Update leftVal and maxDepth\\n        if (depth > maxDepth) {\\n            maxDepth = depth;\\n            leftVal = root->val;\\n        }\\n    }\\n    \\n    //Entry function\\n    int findBottomLeftValue(TreeNode* root) {\\n        int maxDepth = 0;\\n        //Initialize leftVal with root's value to cover the edge case with single node\\n        int leftVal = root->val;\\n        findBottomLeftValue(root, maxDepth, leftVal, 0);\\n        return leftVal;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void findBottomLeftValue(TreeNode* root, int& maxDepth, int& leftVal, int depth) {\\n        if (root == NULL) {\\n            return;\\n        }\\n        //Go to the left and right of each node \\n        findBottomLeftValue(root->left, maxDepth, leftVal, depth+1);\\n        findBottomLeftValue(root->right, maxDepth, leftVal, depth+1);\\n        \\n        //Update leftVal and maxDepth\\n        if (depth > maxDepth) {\\n            maxDepth = depth;\\n            leftVal = root->val;\\n        }\\n    }\\n    \\n    //Entry function\\n    int findBottomLeftValue(TreeNode* root) {\\n        int maxDepth = 0;\\n        //Initialize leftVal with root's value to cover the edge case with single node\\n        int leftVal = root->val;\\n        findBottomLeftValue(root, maxDepth, leftVal, 0);\\n        return leftVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345876,
                "title": "c-solution-based-on-bfs-with-runtime-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n            root=q.front(); // get the value before pop coz pop will not return anyy val\\n            q.pop();\\n            if (root->right) {\\n                q.push(root->right);\\n            }\\n            if(root->left) q.push(root->left);\\n        }\\n        return root->val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n            root=q.front(); // get the value before pop coz pop will not return anyy val\\n            q.pop();\\n            if (root->right) {\\n                q.push(root->right);\\n            }\\n            if(root->left) q.push(root->left);\\n        }\\n        return root->val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235645,
                "title": "python3-beats-100-bfs",
                "content": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: \\'TreeNode\\') -> \\'int\\':\\n        queue = [root]\\n        while queue:\\n            node = queue.pop(0)\\n            res = node.val\\n            if node.right:\\n                queue.append(node.right)\\n            if node.left:\\n                queue.append(node.left)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: \\'TreeNode\\') -> \\'int\\':\\n        queue = [root]\\n        while queue:\\n            node = queue.pop(0)\\n            res = node.val\\n            if node.right:\\n                queue.append(node.right)\\n            if node.left:\\n                queue.append(node.left)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98806,
                "title": "c-clean-code-dfs-recursion-with-explanation",
                "content": "Imaging how we would find the max height of a tree. We can carry a ``max-height`` variable and keep updating it.\\nWith little change we can find the ``bottom-left`` as a byproduct of this process.\\n\\nThe idea is to update the ``bottom-left`` only when the depth reach to the next level, that is, whenever you need to update ``max-height`` when ``height > max-height``;\\n\\n**Find Bottom Left**\\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int bottomLeft = 0;\\n        int height = 0;\\n        dfs(root, 1, height, bottomLeft);\\n        return bottomLeft;\\n    }\\n\\nprivate:\\n    void dfs(TreeNode* node, int depth, int& height, int& res) {\\n        if (!node) {\\n            return;\\n        }\\n        if (depth > height) {\\n            res = node->val;    // update res only when redefine the height\\n            height = depth;\\n        }\\n        dfs(node->left, depth + 1, height, res);\\n        dfs(node->right, depth + 1, height, res);\\n    }\\n};\\n```\\n\\n**Find Tree Height**\\nHere is how would you find the height of the tree in this approach, it is very similar to Find The Bottom Left\\n```\\nclass Solution {\\npublic:\\n    int treeHeight(TreeNode* root) {\\n        int height = 0;\\n        dfs(root, 1, height);\\n        return height;\\n    }\\n\\nprivate:\\n    void dfs(TreeNode* node, int depth, int& height) {\\n        if (!node) {\\n            return;\\n        }\\n        if (depth > height) {\\n            height = depth;\\n        }\\n        dfs(node->left, depth + 1, height);\\n        dfs(node->right, depth + 1, height);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int bottomLeft = 0;\\n        int height = 0;\\n        dfs(root, 1, height, bottomLeft);\\n        return bottomLeft;\\n    }\\n\\nprivate:\\n    void dfs(TreeNode* node, int depth, int& height, int& res) {\\n        if (!node) {\\n            return;\\n        }\\n        if (depth > height) {\\n            res = node->val;    // update res only when redefine the height\\n            height = depth;\\n        }\\n        dfs(node->left, depth + 1, height, res);\\n        dfs(node->right, depth + 1, height, res);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int treeHeight(TreeNode* root) {\\n        int height = 0;\\n        dfs(root, 1, height);\\n        return height;\\n    }\\n\\nprivate:\\n    void dfs(TreeNode* node, int depth, int& height) {\\n        if (!node) {\\n            return;\\n        }\\n        if (depth > height) {\\n            height = depth;\\n        }\\n        dfs(node->left, depth + 1, height);\\n        dfs(node->right, depth + 1, height);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98817,
                "title": "my-bfs-solution-for-python",
                "content": "class Solution(object):\\n\\n    def findBottomLeftValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        queue=[root]; ans=0\\n        while any(queue):\\n            ans=queue[0].val\\n            queue=[leaf for node in queue for leaf in (node.left,node.right) if leaf]\\n        return ans",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def findBottomLeftValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        queue=[root]; ans=0\\n        while any(queue):\\n            ans=queue[0].val\\n            queue=[leaf for node in queue for leaf in (node.left,node.right) if leaf]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 250876,
                "title": "c-9-lines-of-code",
                "content": "int findBottomLeftValue(TreeNode* root) {\\n\\n\\t\\tqueue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* curr;\\n        while(!q.empty()){\\n            curr = q.front();\\n            q.pop();\\n            if(curr->right != NULL) q.push(curr->right);\\n            if(curr->left != NULL) q.push(curr->left);\\n        }\\n        return curr->val;\\n    }",
                "solutionTags": [],
                "code": "int findBottomLeftValue(TreeNode* root) {\\n\\n\\t\\tqueue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* curr;\\n        while(!q.empty()){\\n            curr = q.front();\\n            q.pop();\\n            if(curr->right != NULL) q.push(curr->right);\\n            if(curr->left != NULL) q.push(curr->left);\\n        }\\n        return curr->val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 98770,
                "title": "python-dfs-stack-and-bfs-queue-solution",
                "content": "```\\n#BFS + queue\\n\\n    def findBottomLeftValue(self, root):\\n        if not root:\\n            return\\n\\n        max_depth = 0\\n        queue = [(root, 1)]\\n        \\n        while queue:\\n            curr, level = queue.pop(0)\\n            if curr:\\n                if level > max_depth:\\n                    max_depth = level\\n                    ans = curr.val\\n                queue.append((curr.left, level + 1))\\n                queue.append((curr.right, level + 1))\\n        return ans\\n```     \\n```\\n#DFS + stack   \\n\\n    def findBottomLeftValue(self, root):\\n        if not root:\\n            return\\n        max_depth = 0\\n        stack = [(root, 1)]\\n         \\n        while stack:\\n            curr, level = stack.pop()\\n            if curr:\\n                if level > max_depth:\\n                    max_depth = level\\n                    ans = curr.val\\n                stack.append((curr.right, level + 1))\\n                stack.append((curr.left, level + 1))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n#BFS + queue\\n\\n    def findBottomLeftValue(self, root):\\n        if not root:\\n            return\\n\\n        max_depth = 0\\n        queue = [(root, 1)]\\n        \\n        while queue:\\n            curr, level = queue.pop(0)\\n            if curr:\\n                if level > max_depth:\\n                    max_depth = level\\n                    ans = curr.val\\n                queue.append((curr.left, level + 1))\\n                queue.append((curr.right, level + 1))\\n        return ans\\n```\n```\\n#DFS + stack   \\n\\n    def findBottomLeftValue(self, root):\\n        if not root:\\n            return\\n        max_depth = 0\\n        stack = [(root, 1)]\\n         \\n        while stack:\\n            curr, level = stack.pop()\\n            if curr:\\n                if level > max_depth:\\n                    max_depth = level\\n                    ans = curr.val\\n                stack.append((curr.right, level + 1))\\n                stack.append((curr.left, level + 1))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1518088,
                "title": "java-easy-solution-bfs",
                "content": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        Queue<TreeNode> q=new ArrayDeque<>();\\n        q.add(root);\\n        int res=0;\\n        while(q.size()>0)\\n        {\\n            int s=q.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode node=q.remove();\\n                if(i==0)\\n                {\\n                   res=node.val ;\\n                }\\n                if(node.left!=null)\\n                {\\n                    q.add(node.left);\\n                }\\n                if(node.right!=null)\\n                {\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        Queue<TreeNode> q=new ArrayDeque<>();\\n        q.add(root);\\n        int res=0;\\n        while(q.size()>0)\\n        {\\n            int s=q.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode node=q.remove();\\n                if(i==0)\\n                {\\n                   res=node.val ;\\n                }\\n                if(node.left!=null)\\n                {\\n                    q.add(node.left);\\n                }\\n                if(node.right!=null)\\n                {\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640188,
                "title": "python3-dfs-recursive-and-iterative",
                "content": "### Idea\\n- in here we just need the most left value of the last row. Thus we just know the current row and is it the current most deepest row we traversed. If the current row is the deepest row we have traveled so far, then we take the current value and update the deepest row. How to make the current value is the left. Just do it post-order (left -> right -> val).\\n- In here I implement both recursively and iteratively. Most of time, if you can do it recursively, you can also do it iteratively. Because the idea of iterative implementaion is the same as recursive one.\\n\\n### Code\\n1. DFS - recursive (post-order)\\n```\\ndef findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n    self.last_left, self.last_row = 0, -1\\n\\n    def dfs(cur_node: Optional[TreeNode], cur_row: int):\\n        if not cur_node:\\n            return\\n\\n        if cur_row > self.last_row:\\n            self.last_row = cur_row\\n            self.last_left = cur_node.val\\n\\n        dfs(cur_node.left, cur_row + 1)\\n        dfs(cur_node.right, cur_row + 1)\\n\\n    dfs(root, 0)\\n\\n    return self.last_left\\n```\\n2.  DFS - iterative (stack)\\n```\\ndef findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n    last_left, last_row = 0, -1\\n\\n    stack = [(root, 0)]\\n    while stack:\\n        cur_node, row = stack.pop()\\n\\n        if row > last_row:\\n            last_row = row\\n            last_left = cur_node.val\\n\\n        if cur_node.right:\\n            stack.append((cur_node.right, row + 1))\\n\\n        if cur_node.left:\\n            stack.append((cur_node.left, row + 1))\\n\\n    return last_left\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n    self.last_left, self.last_row = 0, -1\\n\\n    def dfs(cur_node: Optional[TreeNode], cur_row: int):\\n        if not cur_node:\\n            return\\n\\n        if cur_row > self.last_row:\\n            self.last_row = cur_row\\n            self.last_left = cur_node.val\\n\\n        dfs(cur_node.left, cur_row + 1)\\n        dfs(cur_node.right, cur_row + 1)\\n\\n    dfs(root, 0)\\n\\n    return self.last_left\\n```\n```\\ndef findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n    last_left, last_row = 0, -1\\n\\n    stack = [(root, 0)]\\n    while stack:\\n        cur_node, row = stack.pop()\\n\\n        if row > last_row:\\n            last_row = row\\n            last_left = cur_node.val\\n\\n        if cur_node.right:\\n            stack.append((cur_node.right, row + 1))\\n\\n        if cur_node.left:\\n            stack.append((cur_node.left, row + 1))\\n\\n    return last_left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1302584,
                "title": "c-bfs-4ms-beats-98-beginner-friendly-easy-to-understand",
                "content": "In this,\\nWe will just iterate the tree in level order and keep storing the first elements.\\nafter the iteration is over, returning the last element of the elements.\\n\\nHere\\'s the code:\\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n//         creating a vector to store the first elements of every level\\n        int ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode *curr=q.front();\\n                q.pop();\\n                // pushing every first element \\n                if(i==0)   ans=curr->val;\\n                if(curr->left)   q.push(curr->left);\\n                if(curr->right)  q.push(curr->right);\\n            }\\n        }\\n        // returning the last element of the vector\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n//         creating a vector to store the first elements of every level\\n        int ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode *curr=q.front();\\n                q.pop();\\n                // pushing every first element \\n                if(i==0)   ans=curr->val;\\n                if(curr->left)   q.push(curr->left);\\n                if(curr->right)  q.push(curr->right);\\n            }\\n        }\\n        // returning the last element of the vector\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860265,
                "title": "dfs-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int bottomleft = 0, lowestlvl = -1;\\n    void dfs(TreeNode* s,  int lvl){\\n        if(lvl > lowestlvl) {\\n            lowestlvl = lvl;\\n            bottomleft = s->val; \\n        }\\n        if(s->left) dfs(s->left, lvl+1);\\n        if(s->right) dfs(s->right, lvl+1);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        dfs(root, 0);\\n        return bottomleft;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bottomleft = 0, lowestlvl = -1;\\n    void dfs(TreeNode* s,  int lvl){\\n        if(lvl > lowestlvl) {\\n            lowestlvl = lvl;\\n            bottomleft = s->val; \\n        }\\n        if(s->left) dfs(s->left, lvl+1);\\n        if(s->right) dfs(s->right, lvl+1);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        dfs(root, 0);\\n        return bottomleft;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98827,
                "title": "standard-bfs-in-java",
                "content": "```\\n    public int findBottomLeftValue(TreeNode root) {\\n        /*any initial value is valid*/\\n        int result = -1;\\n        ArrayDeque<TreeNode> queue = new ArrayDeque<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            result = queue.peek().val;\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode treeNode = queue.poll();\\n                if (treeNode.left != null) {\\n                    queue.offer(treeNode.left);\\n                }\\n                if (treeNode.right != null) {\\n                    queue.offer(treeNode.right);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findBottomLeftValue(TreeNode root) {\\n        /*any initial value is valid*/\\n        int result = -1;\\n        ArrayDeque<TreeNode> queue = new ArrayDeque<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            result = queue.peek().val;\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode treeNode = queue.poll();\\n                if (treeNode.left != null) {\\n                    queue.offer(treeNode.left);\\n                }\\n                if (treeNode.right != null) {\\n                    queue.offer(treeNode.right);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3289028,
                "title": "513-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a queue with the root node.\\n2. Initialize a variable to store the leftmost node value as the value of the root node.\\n3. Perform level-order traversal using a while loop until the queue becomes empty.\\n4. Get the number of nodes in the current level using the length of the queue.\\n5. Traverse all the nodes in the current level using a for loop.\\n6. Dequeue the front node from the queue.\\n7. Update the leftmost node value if the current node is in the leftmost position of the current level.\\n8. Enqueue the left and right child nodes of the current node (if they exist).\\n9. After the while loop, return the leftmost node value found in the last level.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        # Initialize a queue with the root node\\n        queue = deque([root])\\n        # Initialize a variable to store the leftmost node value\\n        leftmost_val = root.val\\n        \\n        # Perform level-order traversal\\n        while queue:\\n            # Get the number of nodes in the current level\\n            level_size = len(queue)\\n            \\n            # Traverse all the nodes in the current level\\n            for i in range(level_size):\\n                # Dequeue the front node from the queue\\n                node = queue.popleft()\\n                \\n                # Update the leftmost node value if the current node is in the leftmost position of the current level\\n                if i == 0:\\n                    leftmost_val = node.val\\n                \\n                # Enqueue the left and right child nodes of the current node (if they exist)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        \\n        # Return the leftmost node value found in the last level\\n        return leftmost_val\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        # Initialize a queue with the root node\\n        queue = deque([root])\\n        # Initialize a variable to store the leftmost node value\\n        leftmost_val = root.val\\n        \\n        # Perform level-order traversal\\n        while queue:\\n            # Get the number of nodes in the current level\\n            level_size = len(queue)\\n            \\n            # Traverse all the nodes in the current level\\n            for i in range(level_size):\\n                # Dequeue the front node from the queue\\n                node = queue.popleft()\\n                \\n                # Update the leftmost node value if the current node is in the leftmost position of the current level\\n                if i == 0:\\n                    leftmost_val = node.val\\n                \\n                # Enqueue the left and right child nodes of the current node (if they exist)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        \\n        # Return the leftmost node value found in the last level\\n        return leftmost_val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318711,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        Approach:\\n        We travel in inorder and update our leftmost node using\\n        the height variable.\\n    */\\n    \\n    int height;\\n    int leftMost;\\n    \\n    void findLeftMost(TreeNode *root, int currHeight)\\n    {\\n        if(!root) return;\\n        \\n        findLeftMost(root->left, currHeight + 1);\\n        \\n        if(!root->left && !root->right && currHeight > height)\\n        {\\n            height = currHeight;\\n            leftMost = root->val;\\n        }\\n        \\n        findLeftMost(root->right, currHeight + 1);\\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) \\n    {\\n        height = 0;\\n        leftMost = root->val;\\n        \\n        findLeftMost(root, 0);\\n        \\n        return leftMost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        Approach:\\n        We travel in inorder and update our leftmost node using\\n        the height variable.\\n    */\\n    \\n    int height;\\n    int leftMost;\\n    \\n    void findLeftMost(TreeNode *root, int currHeight)\\n    {\\n        if(!root) return;\\n        \\n        findLeftMost(root->left, currHeight + 1);\\n        \\n        if(!root->left && !root->right && currHeight > height)\\n        {\\n            height = currHeight;\\n            leftMost = root->val;\\n        }\\n        \\n        findLeftMost(root->right, currHeight + 1);\\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) \\n    {\\n        height = 0;\\n        leftMost = root->val;\\n        \\n        findLeftMost(root, 0);\\n        \\n        return leftMost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060891,
                "title": "python-straightforward-level-order-traversal-using-bfs",
                "content": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nimport collections\\n\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        left = None\\n        queue = collections.deque([root])\\n        while queue:\\n            size = len(queue)\\n            left = queue[0].val\\n            for _ in range(size):\\n                node = queue.popleft()\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            \\n            \\n        return left\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nimport collections\\n\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        left = None\\n        queue = collections.deque([root])\\n        while queue:\\n            size = len(queue)\\n            left = queue[0].val\\n            for _ in range(size):\\n                node = queue.popleft()\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            \\n            \\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706772,
                "title": "javascript-solution-using-bfs-with-right-node-first",
                "content": "```\\nvar findBottomLeftValue = function(root) {\\n    let queue = [root];\\n    let node = root;\\n    while (queue.length){\\n        if(!queue){\\n            return;\\n        }\\n        node = queue.pop();\\n        if(node.right){\\n            queue.unshift(node.right);\\n        }\\n        if(node.left){\\n            queue.unshift(node.left);\\n        }\\n    }\\n    return node.val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar findBottomLeftValue = function(root) {\\n    let queue = [root];\\n    let node = root;\\n    while (queue.length){\\n        if(!queue){\\n            return;\\n        }\\n        node = queue.pop();\\n        if(node.right){\\n            queue.unshift(node.right);\\n        }\\n        if(node.left){\\n            queue.unshift(node.left);\\n        }\\n    }\\n    return node.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479938,
                "title": "java-0-ms-and-100-faster-simple-dfs-with-simple-comments",
                "content": "```class Solution {\\n    \\n    //to keep track of the level and the left most value by defining global variables\\nint level = 0 ; \\nint leftMost ; \\n    \\n    public int findBottomLeftValue(TreeNode root) {\\n        //edge case \\n        if (root.left == null && root.right == null) return root.val ;  \\n        \\n        //using dfs in-order traversal by calling helper function \\n        dfs(root, level) ;   \\n        \\n        //returning the leftMost value in the last row\\n        return leftMost ; \\n    }\\n    \\n    private void dfs(TreeNode root, int level) {\\n       \\n        \\n        if (root != null) {\\n            \\n            //if the current level is greater then the global variable level, we update the leftMost\\n            if (level > this.level) { \\n                this.level = level ; \\n                leftMost = root.val ; \\n            }\\n              \\n            //recursive call on the left with level + 1, since the child is on the level which is greater by 1 \\n            if (root.left != null)\\n            dfs(root.left, level + 1) ;\\n            \\n            //similarly, recursive call on the right child \\n            if (root.right != null)\\n            dfs(root.right, level + 1) ; \\n        }\\n    } \\n        \\n}```\\n\\nAny q\\'s, comments, or concerns? Would be more than happy to help!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```class Solution {\\n    \\n    //to keep track of the level and the left most value by defining global variables\\nint level = 0 ; \\nint leftMost ; \\n    \\n    public int findBottomLeftValue(TreeNode root) {\\n        //edge case \\n        if (root.left == null && root.right == null) return root.val ;  \\n        \\n        //using dfs in-order traversal by calling helper function \\n        dfs(root, level) ;   \\n        \\n        //returning the leftMost value in the last row\\n        return leftMost ; \\n    }\\n    \\n    private void dfs(TreeNode root, int level) {\\n       \\n        \\n        if (root != null) {\\n            \\n            //if the current level is greater then the global variable level, we update the leftMost\\n            if (level > this.level) { \\n                this.level = level ; \\n                leftMost = root.val ; \\n            }\\n              \\n            //recursive call on the left with level + 1, since the child is on the level which is greater by 1 \\n            if (root.left != null)\\n            dfs(root.left, level + 1) ;\\n            \\n            //similarly, recursive call on the right child \\n            if (root.right != null)\\n            dfs(root.right, level + 1) ; \\n        }\\n    } \\n        \\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1739644,
                "title": "c-bfs-solution-runtime-0ms-beats-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n\\t\\tint ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ans=q.front()->val;\\n            int n=q.size();\\n            while(n--){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n\\t\\tint ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ans=q.front()->val;\\n            int n=q.size();\\n            while(n--){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070485,
                "title": "python-beats-90-dfs",
                "content": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        \\n        res = [root.val, 0]\\n        self.search(root, res, 0)\\n        return res[0]\\n    \\n    def search(self, node, res, curDepth):\\n        \\n        if node:\\n            if curDepth > res[1]:\\n                res[0], res[1] = node.val, curDepth\\n            \\n            self.search(node.left, res, curDepth+1)\\n            self.search(node.right, res, curDepth+1)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        \\n        res = [root.val, 0]\\n        self.search(root, res, 0)\\n        return res[0]\\n    \\n    def search(self, node, res, curDepth):\\n        \\n        if node:\\n            if curDepth > res[1]:\\n                res[0], res[1] = node.val, curDepth\\n            \\n            self.search(node.left, res, curDepth+1)\\n            self.search(node.right, res, curDepth+1)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 682559,
                "title": "java-bfs-using-queue-with-explanation",
                "content": "Complexity `O(n)`\\n\\nTraverse the tree using a Queue (FIFO) by adding the **right node to the queue first then the left node**. \\nThe last node to be popped will be the left most node.\\n```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        \\n        queue.add(root);\\n        TreeNode node = new TreeNode();\\n        \\n        while(!queue.isEmpty()){\\n            node = queue.poll();\\n            if(node.right!=null) queue.add(node.right);\\n            if(node.left!=null) queue.add(node.left);\\n        }\\n        \\n        return node.val;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        \\n        queue.add(root);\\n        TreeNode node = new TreeNode();\\n        \\n        while(!queue.isEmpty()){\\n            node = queue.poll();\\n            if(node.right!=null) queue.add(node.right);\\n            if(node.left!=null) queue.add(node.left);\\n        }\\n        \\n        return node.val;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367517,
                "title": "very-easy-to-understand-readable",
                "content": "**BFS**\\n```java\\n    public int findBottomLeftValue(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer(root);\\n        int min=Integer.MAX_VALUE;\\n        while(!queue.isEmpty()){\\n            int size=queue.size();\\n            min=queue.peek().val;\\n            for(int i=0;i<size;i++){\\n                TreeNode node = queue.poll();\\n                if(node.left!=null) queue.offer(node.left);\\n                if(node.right!=null) queue.offer(node.right);\\n            }\\n        }\\n        return min;\\n    }\\n```\\n\\t\\n    \\n  **DFS**\\n  \\n```java\\n    public int findBottomLeftValue(TreeNode root) {\\n        Map<Integer,TreeNode> map = new HashMap<Integer,TreeNode>();\\n        helper(root,map,0);\\n        Set<Integer> set = map.keySet();\\n        int max = Collections.max(set);\\n        return map.get(max).val;\\n    }\\n    \\n    public void helper(TreeNode root,Map<Integer,TreeNode> map, int level){\\n        if(root.left==null && root.right==null) {\\n            if(map.get(level)==null) map.put(level,root);\\n            return;\\n        }\\n        if(root.left!=null) helper(root.left,map,level+1);\\n        if(root.right!=null) helper(root.right,map,level+1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```java\\n    public int findBottomLeftValue(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer(root);\\n        int min=Integer.MAX_VALUE;\\n        while(!queue.isEmpty()){\\n            int size=queue.size();\\n            min=queue.peek().val;\\n            for(int i=0;i<size;i++){\\n                TreeNode node = queue.poll();\\n                if(node.left!=null) queue.offer(node.left);\\n                if(node.right!=null) queue.offer(node.right);\\n            }\\n        }\\n        return min;\\n    }\\n```\n```java\\n    public int findBottomLeftValue(TreeNode root) {\\n        Map<Integer,TreeNode> map = new HashMap<Integer,TreeNode>();\\n        helper(root,map,0);\\n        Set<Integer> set = map.keySet();\\n        int max = Collections.max(set);\\n        return map.get(max).val;\\n    }\\n    \\n    public void helper(TreeNode root,Map<Integer,TreeNode> map, int level){\\n        if(root.left==null && root.right==null) {\\n            if(map.get(level)==null) map.put(level,root);\\n            return;\\n        }\\n        if(root.left!=null) helper(root.left,map,level+1);\\n        if(root.right!=null) helper(root.right,map,level+1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98895,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLeftMostNode(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        queue<int> level;\\n        \\n        q.push(root);\\n        level.push(0);\\n        \\n        int m=0;\\n        while(q.size()){\\n            TreeNode *r = q.front(); q.pop();\\n            int l = level.front(); level.pop();\\n            if(r->left) {\\n                q.push(r->left);\\n                level.push(l+1);\\n            }\\n            \\n            if(r->right){\\n                q.push(r->right);\\n                level.push(l+1);\\n            }\\n            \\n            if(l > m){\\n                m = l;\\n                root = r;\\n            }\\n        }\\n        \\n        return root->val;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLeftMostNode(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        queue<int> level;\\n        \\n        q.push(root);\\n        level.push(0);\\n        \\n        int m=0;\\n        while(q.size()){\\n            TreeNode *r = q.front(); q.pop();\\n            int l = level.front(); level.pop();\\n            if(r->left) {\\n                q.push(r->left);\\n                level.push(l+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3949613,
                "title": "best-o-n-solution",
                "content": "# Approach\\nLevel Order Traversal (Reverse)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue <TreeNode*> q;\\n        q.push(root);\\n        TreeNode* node;\\n        while (!q.empty()) {\\n            node = q.front();\\n            q.pop();\\n            if (node->right) \\n                q.push(node->right);\\n            if (node->left) \\n                q.push(node->left);\\n        }\\n        return node->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue <TreeNode*> q;\\n        q.push(root);\\n        TreeNode* node;\\n        while (!q.empty()) {\\n            node = q.front();\\n            q.pop();\\n            if (node->right) \\n                q.push(node->right);\\n            if (node->left) \\n                q.push(node->left);\\n        }\\n        return node->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087609,
                "title": "simple-c-solution-using-level-order-traversal-left-view-of-binary-tree",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n          vector<int> ans;\\n       queue<TreeNode*> q;\\n       q.push(root);\\n       if(root == NULL)\\n           return 0;\\n       while(1)\\n       {\\n           int size = q.size();\\n           if(size == 0)\\n               break;\\n           int count = 0;\\n           while(size > 0)\\n           {\\n               TreeNode* temp = q.front();\\n               q.pop();\\n               if(count == 0)\\n                   ans.push_back(temp->val);\\n\\n             if(temp->left!=NULL)\\n                   q.push(temp->left);\\n               \\n             if(temp->right!=NULL)\\n                   q.push(temp->right);\\n               \\n               size--;\\n               count++;\\n           }\\n       }\\n       \\n       return ans[ans.size()-1]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n          vector<int> ans;\\n       queue<TreeNode*> q;\\n       q.push(root);\\n       if(root == NULL)\\n           return 0;\\n       while(1)\\n       {\\n           int size = q.size();\\n           if(size == 0)\\n               break;\\n           int count = 0;\\n           while(size > 0)\\n           {\\n               TreeNode* temp = q.front();\\n               q.pop();\\n               if(count == 0)\\n                   ans.push_back(temp->val);\\n\\n             if(temp->left!=NULL)\\n                   q.push(temp->left);\\n               \\n             if(temp->right!=NULL)\\n                   q.push(temp->right);\\n               \\n               size--;\\n               count++;\\n           }\\n       }\\n       \\n       return ans[ans.size()-1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878060,
                "title": "1-ms-java-solution-using-level-order-traversal-fast-1ms",
                "content": "# class Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int result=0;\\n        while(!q.isEmpty())\\n        {\\n            int count=q.size();\\n            for(int i=0;i<count;i++)\\n            {\\n                TreeNode curr=q.poll();\\n                if(i==0)\\n                {\\n                    result=curr.val;\\n                }\\n                if(curr.left!=null)\\n                {\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    q.add(curr.right);\\n                }\\n            }\\n        }\\n        return result; \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int result=0;\\n        while(!q.isEmpty())\\n        {\\n            int count=q.size();\\n            for(int i=0;i<count;i++)\\n            {\\n                TreeNode curr=q.poll();\\n                if(i==0)\\n                {\\n                    result=curr.val;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2767575,
                "title": "very-very-easy-8-line-code-c",
                "content": "```\\n int findBottomLeftValue(TreeNode *root)\\n        {\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            TreeNode * curr;\\n            while (!q.empty())\\n            {\\n                curr = q.front();\\n                q.pop();\\n                if (curr->right != NULL) q.push(curr->right);\\n                if (curr->left != NULL) q.push(curr->left);\\n            }\\n            return curr->val;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n int findBottomLeftValue(TreeNode *root)\\n        {\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            TreeNode * curr;\\n            while (!q.empty())\\n            {\\n                curr = q.front();\\n                q.pop();\\n                if (curr->right != NULL) q.push(curr->right);\\n                if (curr->left != NULL) q.push(curr->left);\\n            }\\n            return curr->val;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1356139,
                "title": "java-dfs-bfs-from-right-to-left-100",
                "content": "Associate each node with a distance from the root or we call it depth. The bottom level \\nmust have the largest depth, but since we want the left most node we start right child first. \\n\\n```\\nclass Solution {\\n    int res = 0;\\n    int maxDepth = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n    \\n    public void dfs(TreeNode root, int depth){\\n        if(root == null) return;\\n        if(maxDepth <= depth){\\n            res = root.val;\\n            maxDepth = depth;\\n        }\\n        dfs(root.right, depth + 1);\\n        dfs(root.left, depth + 1);\\n    }\\n}\\n```\\n\\nWe can also do this with BFS using a Queue\\n```\\n//BFS solution: always update root pointer until it points to the last one\\n    Queue<TreeNode> queue = new LinkedList<>();\\n    queue.add(root);\\n    while (!queue.isEmpty()) {\\n         root = queue.poll(); // no level size is retrieved because we dont care\\n         if (root.right != null)\\n             queue.add(root.right);\\n         if (root.left != null)\\n             queue.add(root.left);\\n     }\\n     return root.val; // eventually the root pointer will be the bottom left \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    int maxDepth = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n    \\n    public void dfs(TreeNode root, int depth){\\n        if(root == null) return;\\n        if(maxDepth <= depth){\\n            res = root.val;\\n            maxDepth = depth;\\n        }\\n        dfs(root.right, depth + 1);\\n        dfs(root.left, depth + 1);\\n    }\\n}\\n```\n```\\n//BFS solution: always update root pointer until it points to the last one\\n    Queue<TreeNode> queue = new LinkedList<>();\\n    queue.add(root);\\n    while (!queue.isEmpty()) {\\n         root = queue.poll(); // no level size is retrieved because we dont care\\n         if (root.right != null)\\n             queue.add(root.right);\\n         if (root.left != null)\\n             queue.add(root.left);\\n     }\\n     return root.val; // eventually the root pointer will be the bottom left \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102062,
                "title": "java-level-order-traversal-easy-to-understand-beginner-friendly",
                "content": "// A simple Level Order Traversal will work here because ultimately we have to print the value of the leftmost node from the bottom of the tree.\\nclass Solution {\\n\\n    public int findBottomLeftValue(TreeNode root) {\\n\\t\\n        int ans = 0;\\n\\t\\t\\n        Queue<TreeNode> q = new LinkedList();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int count = q.size();\\n            for(int i = 0; i<count; i++){\\n                TreeNode curr = q.poll();\\n                if(i==0)\\n                    ans = curr.val;\\n                if(curr.left!=null)\\n                    q.add(curr.left);\\n                if(curr.right!=null)\\n                    q.add(curr.right);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int findBottomLeftValue(TreeNode root) {\\n\\t\\n        int ans = 0;\\n\\t\\t\\n        Queue<TreeNode> q = new LinkedList();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int count = q.size();\\n            for(int i = 0; i<count; i++){\\n                TreeNode curr = q.poll();\\n                if(i==0)\\n                    ans = curr.val;\\n                if(curr.left!=null)\\n                    q.add(curr.left);\\n                if(curr.right!=null)\\n                    q.add(curr.right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 604968,
                "title": "java-efficient-solution-beats-100-java-online-solution",
                "content": "```\\n\\nclass Solution {\\n    int maxDepth = 0, ans = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        dfs(root, 1);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(root.left == null && root.right == null && depth > maxDepth) {\\n            ans = root.val;\\n            maxDepth = depth;\\n        }\\n        dfs(root.left, depth+1);\\n        dfs(root.right, depth+1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    int maxDepth = 0, ans = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        dfs(root, 1);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(root.left == null && root.right == null && depth > maxDepth) {\\n            ans = root.val;\\n            maxDepth = depth;\\n        }\\n        dfs(root.left, depth+1);\\n        dfs(root.right, depth+1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210034,
                "title": "5-line-code-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int& m,int h){\\n        if(root==NULL)return;\\n        if(h>m){\\n            m = h;\\n            ans = root->val;\\n        }\\n        solve(root->left,ans,m,h+1);\\n        solve(root->right,ans,m,h+1);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        int ans,m = -1;\\n        solve(root,ans,m,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int& m,int h){\\n        if(root==NULL)return;\\n        if(h>m){\\n            m = h;\\n            ans = root->val;\\n        }\\n        solve(root->left,ans,m,h+1);\\n        solve(root->right,ans,m,h+1);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        int ans,m = -1;\\n        solve(root,ans,m,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081493,
                "title": "simple-intuitive-solution-c-using-pair",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int depth, pair<int, int>& pr) {\\n        if(!root) return;\\n        if(pr.second < depth) pr.first = root->val, pr.second = depth;\\n        solve(root->left, depth+1, pr);\\n        solve(root->right, depth+1, pr);\\n    }\\n\\n    int findBottomLeftValue(TreeNode* root) {\\n        pair<int, int> pr = {root->val, 0};\\n        solve(root, 0, pr);\\n        return pr.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int depth, pair<int, int>& pr) {\\n        if(!root) return;\\n        if(pr.second < depth) pr.first = root->val, pr.second = depth;\\n        solve(root->left, depth+1, pr);\\n        solve(root->right, depth+1, pr);\\n    }\\n\\n    int findBottomLeftValue(TreeNode* root) {\\n        pair<int, int> pr = {root->val, 0};\\n        solve(root, 0, pr);\\n        return pr.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659705,
                "title": "with-explanation-comments-time-15-ms-82-53-space-21-7-mb-82-84",
                "content": "**Solution1: DFS**\\n\\nTC: O(n)   //iterate all tree nodes\\nSC: O(height)   //recursion call stack\\nTime: 15 ms (82.53%), Space: 21.7 MB (82.84%)\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    //initialize two variables, one to store the correct node value & one to compare nodes to get the max one\\n    int value=0, max=INT_MIN;\\n    \\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        //base case 1\\n        if(!root)\\n            return -1;\\n        \\n        //recursively, call the helper function with intial value of level counter=0\\n        helper(root, 0);\\n        \\n        //return the final valid value\\n        return value;\\n    }\\n    \\n    void helper(TreeNode* node, int counter){\\n         \\n        //check if we\\'re in the maximum deapth/level in the tree\\n        if(counter>max){\\n            //if yes-> save the max level until now\\n            max=counter;\\n            //save the current node value\\n            value=node->val;\\n        }\\n        \\n        //if the current node have a left node\\n        if(node->left)\\n            //recursively, call the helper function with its left nodes, add the level counter by one\\n            helper(node->left, counter+1);\\n        \\n        //if the current node have a right node\\n        if(node->right)\\n            //recursively, call the helper function with its right nodes, add the level counter by one\\n            helper(node->right, counter+1);\\n    }\\n    \\n};\\n\\'\\'\\'\\n\\n**Solution 2: BFS**\\n\\n\\'\\'\\'\\nTC: O(n)   //iterate all tree nodes\\nSC: O(height)   //initialize a queue\\nTime: 6 ms (98.92%), Space: 21.9 MB (38.14%)\\n\\n\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        //initialize a queue & add the whole tree in it\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        //loop until the queue gets empty\\n        while(!q.empty()){\\n            \\n            //save the current queue element\\'s value\\n            root=q.front();\\n            //remove the current element\\n            q.pop();\\n            \\n            //if the current node have a right node\\n            if(root->right)\\n                //add it to the queue\\n                q.push(root->right);\\n            \\n            //if the current node have a left node\\n            if(root->left)\\n                //add it to the queue\\n                q.push(root->left);\\n        }\\n        \\n        //after that, i just need the last node value in the whole tree\\n        return root->val;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //initialize two variables, one to store the correct node value & one to compare nodes to get the max one\\n    int value=0, max=INT_MIN;\\n    \\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        //base case 1\\n        if(!root)\\n            return -1;\\n        \\n        //recursively, call the helper function with intial value of level counter=0\\n        helper(root, 0);\\n        \\n        //return the final valid value\\n        return value;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2651893,
                "title": "bottom-left-tree-value",
                "content": "***Please upvote if you found it helpful***\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n           root=q.front();\\n            q.pop();\\n            if(root->right) q.push(root->right);\\n            if(root->left) q.push(root->left);\\n            \\n        }\\n        return root->val;\\n    }\\n};\\n\\n```\\n***Please upvote if you found it helpful***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n           root=q.front();\\n            q.pop();\\n            if(root->right) q.push(root->right);\\n            if(root->left) q.push(root->left);\\n            \\n        }\\n        return root->val;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744263,
                "title": "c-bfs-solution-easy-with-explanation",
                "content": "***Upvote If You Like and find it Helpful !***\\n```\\nclass Solution {\\npublic:  \\n int findBottomLeftValue(TreeNode* root) {\\n     queue<TreeNode*>q; int ans=0;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n  // the logic here is as we will do level order traversal(BFS) and only we want the very first node of that level!\\n         int size = q.size();\\n         for(int i=1; i<=size ;i++)\\n         {\\n         TreeNode *front = q.front(); q.pop();\\n            if(i==1) // So here we are printing only very first node of that level which is our left view node of given binary tree.\\n            ans = front->val;\\n         if(front->left) q.push(front->left);\\n         if(front->right) q.push(front->right);\\n         }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n int findBottomLeftValue(TreeNode* root) {\\n     queue<TreeNode*>q; int ans=0;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n  // the logic here is as we will do level order traversal(BFS) and only we want the very first node of that level!\\n         int size = q.size();\\n         for(int i=1; i<=size ;i++)\\n         {\\n         TreeNode *front = q.front(); q.pop();\\n            if(i==1) // So here we are printing only very first node of that level which is our left view node of given binary tree.\\n            ans = front->val;\\n         if(front->left) q.push(front->left);\\n         if(front->right) q.push(front->right);\\n         }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632638,
                "title": "3-approaches-dfs-iterative-simple-easy-c",
                "content": "Implementation\\n\\n**1st Approach\\nUsing level order traversal from left to right\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans = root->val;\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int itr = 0; itr < size; itr++){\\n                TreeNode *temp = q.front();            \\n                q.pop();\\n                if(itr == 0) ans = temp->val;                \\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**2nd Approach\\nUsing level order traversal from right to left\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans = root->val;\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int itr = 0; itr < size; itr++){\\n                TreeNode *temp = q.front();            \\n                q.pop();\\n                if(itr == size-1) ans = temp->val;\\n                if(temp->right) q.push(temp->right);\\n                if(temp->left) q.push(temp->left);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**3rd Approach\\nEfficient Solution\\nUsing DFS\\nTime Complexity = O(N), Space Complexity = O(H), where H is the Height of the tree**\\n```\\nclass Solution {\\npublic:\\n    void findBottomLeftValue(TreeNode* root, int depth, int &maxDepth, int &ans) {\\n        if(!root) return;\\n        findBottomLeftValue(root->left, depth+1, maxDepth, ans);\\n        findBottomLeftValue(root->right, depth+1, maxDepth, ans);\\n        \\n        if(depth > maxDepth){\\n            maxDepth = depth;\\n            ans = root->val;\\n        }\\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) {        \\n        int ans = root->val;\\n        int depth = 0, maxDepth = 0;\\n        findBottomLeftValue(root, depth, maxDepth, ans);\\n        return ans;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans = root->val;\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int itr = 0; itr < size; itr++){\\n                TreeNode *temp = q.front();            \\n                q.pop();\\n                if(itr == 0) ans = temp->val;                \\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans = root->val;\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int itr = 0; itr < size; itr++){\\n                TreeNode *temp = q.front();            \\n                q.pop();\\n                if(itr == size-1) ans = temp->val;\\n                if(temp->right) q.push(temp->right);\\n                if(temp->left) q.push(temp->left);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void findBottomLeftValue(TreeNode* root, int depth, int &maxDepth, int &ans) {\\n        if(!root) return;\\n        findBottomLeftValue(root->left, depth+1, maxDepth, ans);\\n        findBottomLeftValue(root->right, depth+1, maxDepth, ans);\\n        \\n        if(depth > maxDepth){\\n            maxDepth = depth;\\n            ans = root->val;\\n        }\\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) {        \\n        int ans = root->val;\\n        int depth = 0, maxDepth = 0;\\n        findBottomLeftValue(root, depth, maxDepth, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437251,
                "title": "c-well-explained",
                "content": "```\\nIf we have one node in tree, return it as it is the left most value in last row itself.\\nMake a queue to store treenodes and push root to it, initialize final result to 0.\\nTill the queue is empty do the following : ( BTW queue empty means tree traversal is complete )\\nTake queue size into n annd traverse each level based on queue size.\\nNow lets see whats happening when we are traversing nth level :\\nWe are extracting node from queue and popping it from queue cause we are done with it.\\nNow heart of this question: if(i==0) means we are on left most node of any level , in such case update res with that node value. \\nNow keep on adding left and right nodes if exists for temp into your queue and repeat same procedure\\nfor all nodes of a level. When we comes out of for loop , We will check if queue is empty if not what is its size that will be in n.\\nNow go for next level order traversal in similar fashion.\\nLets take an example : \\n     1\\n  2     3\\n4     5   6\\n   7\\nwe have this tree in this case, while loop will execute 4 times as there are 4 levels.\\nInner for loop will execute depending upon number of nodes on each level. like 1 time for 1st level, \\n2 times for 2nd level, 3 times for 3rd level, 1 time for 4th level. Heart of our question : if(i==0) will execute h times , h = no. of levels = 4 times.\\nWhy ? because on each level we have a left most node like 1 , 2 , 4 and 7 . see the tree\\nBasically res is being updated till the last level. Now tree is traversed as queue is empty so return res which is 7 that should be our output.\\nyes, complexity :\\nAt most we are using a queue to store nodes of tree and its maximum size can grow to max number of nodes that can be \\nthere at a particular level. so Space comp : O(k) where k is max number of nodes at any level.\\nTime comp : O(n) where n is number of nodes in tree as we are visiting each node in tree once.\\nupvote if you like it.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findBottomLeftValue(TreeNode* root) \\n    {\\n        if(root->left == NULL && root->right == NULL)\\n            return root->val;\\n        \\n        queue <TreeNode*> q;\\n        q.push(root);\\n        int res = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                if(i == 0)\\n                   res = temp->val;\\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nIf we have one node in tree, return it as it is the left most value in last row itself.\\nMake a queue to store treenodes and push root to it, initialize final result to 0.\\nTill the queue is empty do the following : ( BTW queue empty means tree traversal is complete )\\nTake queue size into n annd traverse each level based on queue size.\\nNow lets see whats happening when we are traversing nth level :\\nWe are extracting node from queue and popping it from queue cause we are done with it.\\nNow heart of this question: if(i==0) means we are on left most node of any level , in such case update res with that node value. \\nNow keep on adding left and right nodes if exists for temp into your queue and repeat same procedure\\nfor all nodes of a level. When we comes out of for loop , We will check if queue is empty if not what is its size that will be in n.\\nNow go for next level order traversal in similar fashion.\\nLets take an example : \\n     1\\n  2     3\\n4     5   6\\n   7\\nwe have this tree in this case, while loop will execute 4 times as there are 4 levels.\\nInner for loop will execute depending upon number of nodes on each level. like 1 time for 1st level, \\n2 times for 2nd level, 3 times for 3rd level, 1 time for 4th level. Heart of our question : if(i==0) will execute h times , h = no. of levels = 4 times.\\nWhy ? because on each level we have a left most node like 1 , 2 , 4 and 7 . see the tree\\nBasically res is being updated till the last level. Now tree is traversed as queue is empty so return res which is 7 that should be our output.\\nyes, complexity :\\nAt most we are using a queue to store nodes of tree and its maximum size can grow to max number of nodes that can be \\nthere at a particular level. so Space comp : O(k) where k is max number of nodes at any level.\\nTime comp : O(n) where n is number of nodes in tree as we are visiting each node in tree once.\\nupvote if you like it.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int findBottomLeftValue(TreeNode* root) \\n    {\\n        if(root->left == NULL && root->right == NULL)\\n            return root->val;\\n        \\n        queue <TreeNode*> q;\\n        q.push(root);\\n        int res = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                if(i == 0)\\n                   res = temp->val;\\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026266,
                "title": "runtime-8-ms-faster-than-98-36-of-c-very-easy-and-clean-code-using-bfs",
                "content": "```\\nint findBottomLeftValue(TreeNode* root) {\\n        //vector<int>v;\\n        if(!root)\\n            return NULL;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n     int ans;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=1;i<=n;i++)\\n            {\\n              TreeNode * temp=q.front();\\n                q.pop();\\n                if(i==1)\\n                    ans=temp->val;\\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n                \\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\nint findBottomLeftValue(TreeNode* root) {\\n        //vector<int>v;\\n        if(!root)\\n            return NULL;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n     int ans;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=1;i<=n;i++)\\n            {\\n              TreeNode * temp=q.front();\\n                q.pop();\\n                if(i==1)\\n                    ans=temp->val;\\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n                \\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 757579,
                "title": "java-bfs-queue",
                "content": "Perform level order traversal and save the first element encountered of each level.\\n\\n```\\npublic int findBottomLeftValue(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n\\t\\tint res = 0;\\n        \\n        while (!q.isEmpty()) {\\n            \\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode curr = q.poll();\\n                \\n                if (i == 0) {\\n                    res = curr.val;\\n                }\\n                \\n                if (curr.left != null) {\\n                    q.add(curr.left);\\n                }\\n                \\n                if (curr.right != null) {\\n                    q.add(curr.right);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\npublic int findBottomLeftValue(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n\\t\\tint res = 0;\\n        \\n        while (!q.isEmpty()) {\\n            \\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode curr = q.poll();\\n                \\n                if (i == 0) {\\n                    res = curr.val;\\n                }\\n                \\n                if (curr.left != null) {\\n                    q.add(curr.left);\\n                }\\n                \\n                if (curr.right != null) {\\n                    q.add(curr.right);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612759,
                "title": "java-solution-using-bfs-fully-explained",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        if(root==null) return -1;\\n        LinkedList<TreeNode> queue=new LinkedList<>();\\n        queue.addLast(root);\\n        \\n        int ans=root.val;\\n        \\n        while(queue.size()!=0){\\n            int size=queue.size();\\n            //----------flag to see if the first element of the level is encountered or not--------\\n            boolean flag=false;\\n            \\n            while(size-->0){\\n                TreeNode node=queue.removeFirst();\\n                \\n                //-------------------------if the node is leaf node or not--------------------------\\n                if(node.left==null && node.right==null){\\n                    \\n                    //-----------if the node is the first leaf node of the current level------------\\n                    if(flag==false){\\n                        ans=node.val;\\n                        flag=true;\\n                    }\\n                }\\n                \\n                //-----------------------Pushing the nodes which are on the next level--------------\\n                if(node.left!=null)  queue.addLast(node.left);\\n                if(node.right!=null)  queue.addLast(node.right);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        if(root==null) return -1;\\n        LinkedList<TreeNode> queue=new LinkedList<>();\\n        queue.addLast(root);\\n        \\n        int ans=root.val;\\n        \\n        while(queue.size()!=0){\\n            int size=queue.size();\\n            //----------flag to see if the first element of the level is encountered or not--------\\n            boolean flag=false;\\n            \\n            while(size-->0){\\n                TreeNode node=queue.removeFirst();\\n                \\n                //-------------------------if the node is leaf node or not--------------------------\\n                if(node.left==null && node.right==null){\\n                    \\n                    //-----------if the node is the first leaf node of the current level------------\\n                    if(flag==false){\\n                        ans=node.val;\\n                        flag=true;\\n                    }\\n                }\\n                \\n                //-----------------------Pushing the nodes which are on the next level--------------\\n                if(node.left!=null)  queue.addLast(node.left);\\n                if(node.right!=null)  queue.addLast(node.right);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583072,
                "title": "concise-python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        last = None\\n        queue = deque()\\n        queue.append(root)\\n        \\n        while queue:\\n            node = queue.popleft()\\n            last = node.val\\n            if node.right:\\n                queue.append(node.right)\\n            if node.left:\\n                queue.append(node.left)\\n        \\n        return last\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        last = None\\n        queue = deque()\\n        queue.append(root)\\n        \\n        while queue:\\n            node = queue.popleft()\\n            last = node.val\\n            if node.right:\\n                queue.append(node.right)\\n            if node.left:\\n                queue.append(node.left)\\n        \\n        return last\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439510,
                "title": "python-dfs-one-pass",
                "content": "```\\nclass Solution:\\n    def get_node(self, root, curr_height=1): \\n        if not root:\\n            return [-1, -1]\\n        if not root.left and not root.right:\\n            return [root.val, curr_height]\\n        left = self.get_node(root.left, curr_height + 1)\\n        right = self.get_node(root.right, curr_height + 1)\\n        return left if left[1] >= right[1] else right\\n        \\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        return self.get_node(root)[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def get_node(self, root, curr_height=1): \\n        if not root:\\n            return [-1, -1]\\n        if not root.left and not root.right:\\n            return [root.val, curr_height]\\n        left = self.get_node(root.left, curr_height + 1)\\n        right = self.get_node(root.right, curr_height + 1)\\n        return left if left[1] >= right[1] else right\\n        \\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        return self.get_node(root)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382952,
                "title": "python3-level-order-solution-faster-than-99-5",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        levels = [root]\\n        ans = 0\\n        while levels:\\n            nxt = []\\n            for node in levels:\\n                if node.left:\\n                    nxt.append(node.left)\\n                if node.right:\\n                    nxt.append(node.right)\\n            if not nxt:\\n                ans = levels[0].val\\n                break\\n            levels = nxt\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        levels = [root]\\n        ans = 0\\n        while levels:\\n            nxt = []\\n            for node in levels:\\n                if node.left:\\n                    nxt.append(node.left)\\n                if node.right:\\n                    nxt.append(node.right)\\n            if not nxt:\\n                ans = levels[0].val\\n                break\\n            levels = nxt\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98822,
                "title": "java-solution-by-post-order-traversal-beats-54",
                "content": "Since most of the answers use pre-order and level-order traversal. Here is my post-order traversal solution as an inspiration. The idea is to get the bottom left value of each subtree at each root, compare their depths and pass onto its parent.\\n\\n```\\nprivate class ResultSet {\\n    final int depth;\\n    final int val;\\n\\n    ResultSet(int depth, int val) {\\n        this.depth = depth;\\n        this.val = val;\\n    }\\n}\\n\\npublic int findBottomLeftValue(TreeNode root) {\\n    return bottomLeft(root, 0).val;\\n}\\n\\nprivate ResultSet bottomLeft(TreeNode root, int depth) {\\n    if (root == null) return null;\\n    if (root.left == null && root.right == null) return new ResultSet(depth, root.val);\\n    else if (root.left == null) return bottomLeft(root.right, depth + 1);\\n    else if (root.right == null) return bottomLeft(root.left, depth + 1);\\n    else {\\n        ResultSet left = bottomLeft(root.left, depth + 1);\\n        ResultSet right = bottomLeft(root.right, depth + 1);\\n        return right.depth > left.depth ? right : left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nprivate class ResultSet {\\n    final int depth;\\n    final int val;\\n\\n    ResultSet(int depth, int val) {\\n        this.depth = depth;\\n        this.val = val;\\n    }\\n}\\n\\npublic int findBottomLeftValue(TreeNode root) {\\n    return bottomLeft(root, 0).val;\\n}\\n\\nprivate ResultSet bottomLeft(TreeNode root, int depth) {\\n    if (root == null) return null;\\n    if (root.left == null && root.right == null) return new ResultSet(depth, root.val);\\n    else if (root.left == null) return bottomLeft(root.right, depth + 1);\\n    else if (root.right == null) return bottomLeft(root.left, depth + 1);\\n    else {\\n        ResultSet left = bottomLeft(root.left, depth + 1);\\n        ResultSet right = bottomLeft(root.right, depth + 1);\\n        return right.depth > left.depth ? right : left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669012,
                "title": "c-bfs-simple",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        TreeNode* curr;\\n        queue<TreeNode*> Q; Q.push(root);\\n\\n        while (!Q.empty()) {\\n            curr = Q.front(); Q.pop();\\n            if (curr->right) Q.push(curr->right);\\n            if (curr->left) Q.push(curr->left);\\n        }\\n\\n        return curr->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        TreeNode* curr;\\n        queue<TreeNode*> Q; Q.push(root);\\n\\n        while (!Q.empty()) {\\n            curr = Q.front(); Q.pop();\\n            if (curr->right) Q.push(curr->right);\\n            if (curr->left) Q.push(curr->left);\\n        }\\n\\n        return curr->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537047,
                "title": "c-bfs-approach-to-find-leftmost",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) ,where n:number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n\\n        int last;   //var for last left most node value\\n        //BST implementation\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.empty()==false)\\n        {\\n            int count=q.size();\\n            for(int i=0;i<count;i++)\\n            {\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(i==0)\\n                    last=curr->val;     //last leftMost val\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return last;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n\\n        int last;   //var for last left most node value\\n        //BST implementation\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.empty()==false)\\n        {\\n            int count=q.size();\\n            for(int i=0;i<count;i++)\\n            {\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(i==0)\\n                    last=curr->val;     //last leftMost val\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return last;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389990,
                "title": "just-do-level-order-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        a = []\\n\\n        def dfs(node, h):\\n            if not node: return\\n            if len(a) == h: a.append([])\\n\\n            a[h].append(node.val)\\n            dfs(node.left, h+1)\\n            dfs(node.right, h+1)\\n\\n        dfs(root, 0)\\n\\n        return a[-1][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        a = []\\n\\n        def dfs(node, h):\\n            if not node: return\\n            if len(a) == h: a.append([])\\n\\n            a[h].append(node.val)\\n            dfs(node.left, h+1)\\n            dfs(node.right, h+1)\\n\\n        dfs(root, 0)\\n\\n        return a[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225629,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        map<int , int> mp;\\n        queue<pair<TreeNode * , int> > q;\\n        int ans = 0;\\n        if(root == NULL)\\n            return ans;\\n        q.push(make_pair(root , 0));\\n        while(!q.empty()){\\n            pair<TreeNode * , int> temp = q.front();\\n            q.pop();\\n            TreeNode *frontNode = temp.first;\\n            int lvl = temp.second;\\n            if(mp.find(lvl) == mp.end())\\n                mp[lvl] = frontNode->val;\\n            if(frontNode->left)\\n                q.push(make_pair(frontNode->left , lvl+1)); \\n            if(frontNode->right)\\n                q.push(make_pair(frontNode->right , lvl+1));\\n        }\\n        return mp[mp.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        map<int , int> mp;\\n        queue<pair<TreeNode * , int> > q;\\n        int ans = 0;\\n        if(root == NULL)\\n            return ans;\\n        q.push(make_pair(root , 0));\\n        while(!q.empty()){\\n            pair<TreeNode * , int> temp = q.front();\\n            q.pop();\\n            TreeNode *frontNode = temp.first;\\n            int lvl = temp.second;\\n            if(mp.find(lvl) == mp.end())\\n                mp[lvl] = frontNode->val;\\n            if(frontNode->left)\\n                q.push(make_pair(frontNode->left , lvl+1)); \\n            if(frontNode->right)\\n                q.push(make_pair(frontNode->right , lvl+1));\\n        }\\n        return mp[mp.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183005,
                "title": "java-0ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static int parent=-1;\\n    static int ans=0;\\n    public int findBottomLeftValue(TreeNode root) {\\n       help(root,0);\\n       int res=ans;ans=0;\\n       parent=-1;\\n       return res;\\n    }\\n\\n    public static void help(TreeNode root,int level)\\n    {\\n        if(root==null)return ;\\n        if(level>parent){\\n            ans=root.val;\\n            parent=level;\\n        }\\n        help(root.left,level+1);\\n        help(root.right,level+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static int parent=-1;\\n    static int ans=0;\\n    public int findBottomLeftValue(TreeNode root) {\\n       help(root,0);\\n       int res=ans;ans=0;\\n       parent=-1;\\n       return res;\\n    }\\n\\n    public static void help(TreeNode root,int level)\\n    {\\n        if(root==null)return ;\\n        if(level>parent){\\n            ans=root.val;\\n            parent=level;\\n        }\\n        help(root.left,level+1);\\n        help(root.right,level+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166907,
                "title": "java-o-n-dfs-100-faster-solution",
                "content": "# Intuition\\nGoing DFS from right to left and writing current level if maxLvl is less than or equal. Thus, I will take the deepest leftmost val.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    int maxlvl;\\n    int val;\\n    public int findBottomLeftValue(TreeNode root) {\\n        maxlvl = 0;\\n        val = root.val;\\n        goDFS(root, 0);\\n        return val;\\n    }\\n\\n    private void goDFS(TreeNode node, int lvl) {\\n        if (node == null) return;\\n\\n        if (maxlvl <= lvl) {\\n            maxlvl = lvl;\\n            val = node.val;\\n        }\\n        lvl++;\\n        goDFS(node.right, lvl);\\n        goDFS(node.left, lvl);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int maxlvl;\\n    int val;\\n    public int findBottomLeftValue(TreeNode root) {\\n        maxlvl = 0;\\n        val = root.val;\\n        goDFS(root, 0);\\n        return val;\\n    }\\n\\n    private void goDFS(TreeNode node, int lvl) {\\n        if (node == null) return;\\n\\n        if (maxlvl <= lvl) {\\n            maxlvl = lvl;\\n            val = node.val;\\n        }\\n        lvl++;\\n        goDFS(node.right, lvl);\\n        goDFS(node.left, lvl);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104150,
                "title": "very-easy-dfs-solution-no-stack-or-queue-used",
                "content": "One very easy solution is to first find the height of the binary tree using a recursive function and then using another dfs function find the left most value at the deepest node.\\n```\\nint res=INT_MIN;\\n    void height(TreeNode* root, int cnt){\\n        if(!root){\\n            res=max(res, cnt);\\n            return;\\n        }\\n        height(root->left, cnt+1);\\n        height(root->right, cnt+1);\\n    }\\n    int ans;\\n    void solve(TreeNode* root, int cnt, int res){\\n        if(!root){\\n            return;\\n        }\\n        if(cnt==res){\\n            ans=root->val;\\n        }\\n        solve(root->right, cnt+1, res); \\n\\t\\tsolve(root->left, cnt+1, res);\\n\\t\\t//we call right side first because we want to save the value of left child in \\n\\t\\t//our answer variable if we would have called the left side first then when the \\n\\t\\t//deepest node would have 2 nodes left and right then the because we called \\n\\t\\t//right side last it would overwrite the value of left child from our answer.\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        height(root, 0);\\n        solve(root, 1, res);\\n        return ans;\\n    }\\n\\t\\n\\tIn the second approach we try to eliminate the function used to find the height of the tree by keeping track of the maximum height encountered so far.\\n\\t\\n\\tint most_deep_node = INT_MIN;\\n    int ans;\\n    void dfs(TreeNode *root, int cnt)\\n    {\\n        if (!root)\\n        {\\n            return;\\n        }\\n        if (cnt>=most_deep_node)  \\n        {\\n            most_deep_node=cnt;\\n            ans = root->val;  //keep track of the most deep node so far and update the answer\\n        }\\n        dfs(root->right, cnt + 1); //right side called first because of the reason discussed in the above solution.\\n        dfs(root->left, cnt + 1);\\n    }\\n    int findBottomLeftValue(TreeNode *root)\\n    {\\n        if (!root)\\n        {\\n            return 0;\\n        }\\n        dfs(root, 0);\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "One very easy solution is to first find the height of the binary tree using a recursive function and then using another dfs function find the left most value at the deepest node.\\n```\\nint res=INT_MIN;\\n    void height(TreeNode* root, int cnt){\\n        if(!root){\\n            res=max(res, cnt);\\n            return;\\n        }\\n        height(root->left, cnt+1);\\n        height(root->right, cnt+1);\\n    }\\n    int ans;\\n    void solve(TreeNode* root, int cnt, int res){\\n        if(!root){\\n            return;\\n        }\\n        if(cnt==res){\\n            ans=root->val;\\n        }\\n        solve(root->right, cnt+1, res); \\n\\t\\tsolve(root->left, cnt+1, res);\\n\\t\\t//we call right side first because we want to save the value of left child in \\n\\t\\t//our answer variable if we would have called the left side first then when the \\n\\t\\t//deepest node would have 2 nodes left and right then the because we called \\n\\t\\t//right side last it would overwrite the value of left child from our answer.\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        height(root, 0);\\n        solve(root, 1, res);\\n        return ans;\\n    }\\n\\t\\n\\tIn the second approach we try to eliminate the function used to find the height of the tree by keeping track of the maximum height encountered so far.\\n\\t\\n\\tint most_deep_node = INT_MIN;\\n    int ans;\\n    void dfs(TreeNode *root, int cnt)\\n    {\\n        if (!root)\\n        {\\n            return;\\n        }\\n        if (cnt>=most_deep_node)  \\n        {\\n            most_deep_node=cnt;\\n            ans = root->val;  //keep track of the most deep node so far and update the answer\\n        }\\n        dfs(root->right, cnt + 1); //right side called first because of the reason discussed in the above solution.\\n        dfs(root->left, cnt + 1);\\n    }\\n    int findBottomLeftValue(TreeNode *root)\\n    {\\n        if (!root)\\n        {\\n            return 0;\\n        }\\n        dfs(root, 0);\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2895124,
                "title": "javascript-bfs-and-dfs-with-comments-and-easy-to-follow",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar findBottomLeftValue = function (root) {\\n  const q = [root];\\n  let res = [];\\n  while (q.length) {\\n    const len = q.length;\\n    //Only record the last row. But all rows can be recorded by 2D array.\\n    res = [];\\n    for (let i = 0; i < len; i++) {\\n      const node = q.shift();\\n      res.push(node.val);\\n      node.left && q.push(node.left);\\n      node.right && q.push(node.right);\\n    }\\n  }\\n  return res[0];\\n};\\n```\\n\\n# Code\\n```\\n\\nvar findBottomLeftValue = function (root) {\\n  let res = 0,\\n    maxDep = -1,\\n    curDep = 0;\\n  DFS(root);\\n  return res;\\n  function DFS(node) {\\n    //When reached to leap node, compare.\\n    if (!node.left && !node.right) {\\n      if (curDep > maxDep) {\\n        res = node.val;\\n        maxDep = curDep;\\n      }\\n    }\\n    if (node.left) {\\n      curDep++;\\n      DFS(node.left);\\n      //backtracking when recursion comes back\\n      curDep--;\\n    }\\n    if (node.right) {\\n      curDep++;\\n      DFS(node.right);\\n      curDep--;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findBottomLeftValue = function (root) {\\n  const q = [root];\\n  let res = [];\\n  while (q.length) {\\n    const len = q.length;\\n    //Only record the last row. But all rows can be recorded by 2D array.\\n    res = [];\\n    for (let i = 0; i < len; i++) {\\n      const node = q.shift();\\n      res.push(node.val);\\n      node.left && q.push(node.left);\\n      node.right && q.push(node.right);\\n    }\\n  }\\n  return res[0];\\n};\\n```\n```\\n\\nvar findBottomLeftValue = function (root) {\\n  let res = 0,\\n    maxDep = -1,\\n    curDep = 0;\\n  DFS(root);\\n  return res;\\n  function DFS(node) {\\n    //When reached to leap node, compare.\\n    if (!node.left && !node.right) {\\n      if (curDep > maxDep) {\\n        res = node.val;\\n        maxDep = curDep;\\n      }\\n    }\\n    if (node.left) {\\n      curDep++;\\n      DFS(node.left);\\n      //backtracking when recursion comes back\\n      curDep--;\\n    }\\n    if (node.right) {\\n      curDep++;\\n      DFS(node.right);\\n      curDep--;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2870411,
                "title": "java-c-easy-solution-level-order",
                "content": "\\n```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        // base case\\n\\t\\tif(root==null) return 0;\\n        // creating queue for iteration over child nodes\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.offer(root);\\n        \\n\\t\\t// creating a node to store the result\\n        TreeNode result = null;\\n\\t\\t\\n        while(!que.isEmpty()){\\n            int size = que.size();\\n           \\n\\t\\t   boolean flag = true;\\n            \\n            for(int i=0;i<size;i++){\\n                TreeNode tempNode = que.poll();\\n               // to make sure that the node should be first\\n\\t\\t\\t   if(flag){\\n                    result = tempNode;\\n                    flag=false;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//adding left and right child of parent node if they exist \\n                if(tempNode.left!=null) que.offer(tempNode.left);\\n                if(tempNode.right!=null) que.offer(tempNode.right);\\n            }\\n        }\\n\\t\\t// return the result\\n        return result.val;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        // base case\\n\\t\\tif(root==null) return 0;\\n        // creating queue for iteration over child nodes\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.offer(root);\\n        \\n\\t\\t// creating a node to store the result\\n        TreeNode result = null;\\n\\t\\t\\n        while(!que.isEmpty()){\\n            int size = que.size();\\n           \\n\\t\\t   boolean flag = true;\\n            \\n            for(int i=0;i<size;i++){\\n                TreeNode tempNode = que.poll();\\n               // to make sure that the node should be first\\n\\t\\t\\t   if(flag){\\n                    result = tempNode;\\n                    flag=false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2680305,
                "title": "pyhton3-bfs-solution-bgg",
                "content": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        q=[[root]]\\n        nodes=[]\\n        while q:\\n            nodes = q.pop(0)\\n            t=[]\\n            for n in nodes:\\n                if n.left:\\n                    t.append(n.left)\\n                if n.right:\\n                    t.append(n.right)\\n            if t:\\n                q.append(t)\\n        return nodes[0].val\\n# Please upvote if you understand the solution",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        q=[[root]]\\n        nodes=[]\\n        while q:\\n            nodes = q.pop(0)\\n            t=[]\\n            for n in nodes:\\n                if n.left:\\n                    t.append(n.left)\\n                if n.right:\\n                    t.append(n.right)\\n            if t:\\n                q.append(t)\\n        return nodes[0].val\\n# Please upvote if you understand the solution",
                "codeTag": "Java"
            },
            {
                "id": 2415621,
                "title": "c-very-easy-bfs-95-faster",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int res=-1;\\n        while(!q.empty())\\n        {\\n            int t=q.size();\\n            res=q.front()->val; // leftmost value at current level\\n            for(int i=0;i<t;i++)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p->left)\\n                    q.push(p->left);\\n                if(p->right)\\n                    q.push(p->right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int res=-1;\\n        while(!q.empty())\\n        {\\n            int t=q.size();\\n            res=q.front()->val; // leftmost value at current level\\n            for(int i=0;i<t;i++)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p->left)\\n                    q.push(p->left);\\n                if(p->right)\\n                    q.push(p->right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109649,
                "title": "find-bottom-left-tree-vaalue-easy-c-solution-runtime-20-ms",
                "content": "```\\n//So I used three functions.\\n//Approach - Calculating the height at every level ,then going in that part which has \\n//more height , i.e. if height of left tree is more or equal then we need to go to root->left. Then repeating the //same cycle for root->left or root->right ( whose height is more ).\\n\\nclass Solution {\\npublic:\\n    int x;\\n\\t//Function 1 ( Calculating Height )\\n    int height(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        if(root->left==NULL && root->right==NULL)\\n            x=root->val;\\n        int lh=height(root->left);\\n        int rh=height(root->right);\\n        \\n        return 1+max(lh,rh);\\n    }\\n\\t//Funtion 2 ( Main Funtion )\\n\\t int findBottomLeftValue(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        \\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            x=root->val;\\n             return x;\\n        }\\n        \\n        int l=height(root->left);\\n        int r=height(root->right);\\n        if(l>=r)\\n            help(root->left);\\n        else\\n            help(root->right);\\n        \\n        return x;\\n    }\\n\\t//Funtion 3 ( Helper )  \\n\\t void help(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return ;\\n        findBottomLeftValue(root);\\n    }\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n//So I used three functions.\\n//Approach - Calculating the height at every level ,then going in that part which has \\n//more height , i.e. if height of left tree is more or equal then we need to go to root->left. Then repeating the //same cycle for root->left or root->right ( whose height is more ).\\n\\nclass Solution {\\npublic:\\n    int x;\\n\\t//Function 1 ( Calculating Height )\\n    int height(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        if(root->left==NULL && root->right==NULL)\\n            x=root->val;\\n        int lh=height(root->left);\\n        int rh=height(root->right);\\n        \\n        return 1+max(lh,rh);\\n    }\\n\\t//Funtion 2 ( Main Funtion )\\n\\t int findBottomLeftValue(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        \\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            x=root->val;\\n             return x;\\n        }\\n        \\n        int l=height(root->left);\\n        int r=height(root->right);\\n        if(l>=r)\\n            help(root->left);\\n        else\\n            help(root->right);\\n        \\n        return x;\\n    }\\n\\t//Funtion 3 ( Helper )  \\n\\t void help(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return ;\\n        findBottomLeftValue(root);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035224,
                "title": "recursive-solution",
                "content": "**\\nvoid solve (TreeNode* root, int level, vector< int >& v)\\n    {\\n        if( !root ) return;\\n        if( level == v.size() )\\n            v.push_back( root->val );    \\n        \\n        solve( root->left , level+1 , v);\\n        solve( root->right, level+1, v);    \\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,0,v);\\n        return v.back();\\n    }\\n**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "**\\nvoid solve (TreeNode* root, int level, vector< int >& v)\\n    {\\n        if( !root ) return;\\n        if( level == v.size() )\\n            v.push_back( root->val );    \\n        \\n        solve( root->left , level+1 , v);\\n        solve( root->right, level+1, v);    \\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,0,v);\\n        return v.back();\\n    }\\n**",
                "codeTag": "Unknown"
            },
            {
                "id": 1843309,
                "title": "c-clean-concise-5-line-code-w-explanation",
                "content": "**Do** \\u2B06\\uFE0F **UPVOTE IF IT WAS HELPFUL**\\n\\n**Intuition-** I want only left most value of each level and my answer would be the last element\\n   I picked. Now the Most important part is **How to keep track of left most value in each level?**\\n   ***Level Order Traversal***  Yup that can be one of the way to approach the solution.\\n   \\n   But since we only care about one element in each level , we can do **preorder traversal cleverly**.\\n   At each level we only need to check if my size variable is equal to level number , then It is sure\\n   that I am at the left most element of my level(Since it is preorder).\\n\\n\\tclass Solution {\\n\\t\\t int ans,size=0;\\n\\tpublic:\\n\\t\\tvoid helper(TreeNode *head,int level){\\n\\t\\t\\tif(head){\\n\\t\\t\\t\\tif(size==level)\\n\\t\\t\\t\\t\\tans=head->val,size++;\\n\\t\\t\\t\\thelper(head->left,level+1);\\n\\t\\t\\t\\thelper(head->right,level+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint findBottomLeftValue(TreeNode* head) {\\n\\t\\t\\thelper(head,0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t int ans,size=0;\\n\\tpublic:\\n\\t\\tvoid helper(TreeNode *head,int level){\\n\\t\\t\\tif(head){\\n\\t\\t\\t\\tif(size==level)\\n\\t\\t\\t\\t\\tans=head->val,size++;\\n\\t\\t\\t\\thelper(head->left,level+1);\\n\\t\\t\\t\\thelper(head->right,level+1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1780783,
                "title": "java-level-order-traversal-solution",
                "content": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        Queue<TreeNode> queue= new LinkedList<>();      \\n        \\n        queue.offer(root);\\n        int leftVal=root.val;\\n        while(!queue.isEmpty()){\\n            int size=queue.size();\\n            for(int i=0;i<size; i++){\\n                TreeNode node= queue.remove();\\n                if(i==0){\\n                    leftVal=node.val;\\n                }\\n                if(node.left!=null){\\n                    queue.offer(node.left);\\n                }\\n                if(node.right!=null){\\n                    queue.offer(node.right);\\n                }\\n\\n            }\\n            \\n        }\\n        return leftVal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        Queue<TreeNode> queue= new LinkedList<>();      \\n        \\n        queue.offer(root);\\n        int leftVal=root.val;\\n        while(!queue.isEmpty()){\\n            int size=queue.size();\\n            for(int i=0;i<size; i++){\\n                TreeNode node= queue.remove();\\n                if(i==0){\\n                    leftVal=node.val;\\n                }\\n                if(node.left!=null){\\n                    queue.offer(node.left);\\n                }\\n                if(node.right!=null){\\n                    queue.offer(node.right);\\n                }\\n\\n            }\\n            \\n        }\\n        return leftVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746708,
                "title": "c-both-using-level-order-traversal-recursion",
                "content": "\\nUsing Level Order Traversal\\n\\n```\\nint findBottomLeftValue(TreeNode* root) {\\n        queue <TreeNode *> q;\\n        \\n        if ( root == NULL) return 0;\\n        \\n        TreeNode *output = root;\\n        q.push(root);\\n        while ( !q.empty()) {\\n            int size = q.size();\\n            output = NULL;\\n            while ( size -- > 0) {\\n                root = q.front();\\n                q.pop();\\n                if ( root ->left) q.push(root->left);\\n                if ( root->right) q.push(root->right);\\n                \\n                if ( output == NULL) output = root;\\n                \\n            }\\n            \\n        }\\n        return output->val;\\n    }\\n\\t\\n\\tUsing Recursion\\n\\t\\n\\nclass Solution {\\n\\tpublic:\\n    \\n    void getNodeAtLevel(TreeNode *root, int level, TreeNode **x) {\\n        if ( root == NULL) return;\\n        if ( level == 1) {\\n            if ( *x == NULL ) {\\n                //cout<<root->val<<endl;\\n                *x = root;\\n                return;\\n            }\\n            \\n        }\\n        if ( root->left) getNodeAtLevel(root->left, level-1, x);\\n        if ( root ->right ) getNodeAtLevel(root->right, level - 1, x);\\n        \\n        return;\\n    }\\n    int height(TreeNode *root) {\\n        if (root == NULL) return 0;\\n        return 1 + max(height(root->left), height(root->right) );\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        // using recursion;\\n        if (root == NULL) return 0;\\n        \\n        int level = height(root);\\n        TreeNode *x = NULL;\\n        getNodeAtLevel(root, level, &x);\\n        return x->val;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    void getNodeAtLevel(TreeNode *root, int level, TreeNode **x) {\\n        if ( root == NULL) return;\\n        if ( level == 1) {\\n            if ( *x == NULL ) {\\n                //cout<<root->val<<endl;\\n                *x = root;\\n                return;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1708889,
                "title": "c-solution-using-recursion-preorder-traversal-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode *root, int level, vector<int> &res){\\n        if (!root) return;\\n        if (level==res.size()) res.push_back(root->val);\\n        solve(root->left,level+1,res);\\n        solve(root->right,level+1,res);\\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int> res;\\n        solve(root,0,res);\\n        return res.back();\\n    }\\n};\\n```\\n\\nPS: if you want to find out left view of binary tree then simply return \"res\" and yes if you found out this solution to be useful, please do \"UPVOTE\" :)\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode *root, int level, vector<int> &res){\\n        if (!root) return;\\n        if (level==res.size()) res.push_back(root->val);\\n        solve(root->left,level+1,res);\\n        solve(root->right,level+1,res);\\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int> res;\\n        solve(root,0,res);\\n        return res.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579656,
                "title": "c-easy-bfs",
                "content": "class Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int res = root->val;\\n        while(!q.empty())\\n        {\\n            int qsize = q.size();\\n            \\n            for(int i = 0; i < qsize; i++)\\n            {\\n               TreeNode *temp = q.front();\\n                q.pop();\\n                if(i == 0)\\n                {\\n                    res = temp->val;\\n                }\\n                \\n                if(temp->left)\\n                    q.push(temp->left);\\n                \\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int res = root->val;\\n        while(!q.empty())\\n        {\\n            int qsize = q.size();\\n            \\n            for(int i = 0; i < qsize; i++)\\n            {\\n               TreeNode *temp = q.front();\\n                q.pop();\\n                if(i == 0)\\n                {\\n                    res = temp->val;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1504442,
                "title": "java-easy-soution",
                "content": "The pre-requisite of this questions are height of tree and K level Down problem\\n\\nclass Solution {\\n\\n\\n    int a=0;\\n    int s=1; //it is being used as a blocker so that same no on the same height does not come after the first one\\n    public int findBottomLeftValue(TreeNode root) {\\n      int ht =  height(root);\\n        \\n      lca(root,ht);\\n        return a ;\\n    }\\n    \\n    public int height(TreeNode root){\\n        if(root==null){\\n            return -1;\\n        }\\n        \\n        int lf=height(root.left);\\n        int rt=height(root.right);\\n        int ht=Math.max(lf,rt)+1;\\n        return ht;\\n    }\\n    \\n    public int lca(TreeNode root,int ht){\\n        if(root==null || ht<0){\\n            return 0;\\n        }\\n        \\n        if(ht==0 && s==1){\\n            a=root.val;\\n            s--;\\n//             print karna hoga tab\\n            \\n        }\\n        lca(root.left,ht-1);\\n        lca(root.right,ht-1);\\n        \\n        return s;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n\\n    int a=0;\\n    int s=1; //it is being used as a blocker so that same no on the same height does not come after the first one\\n    public int findBottomLeftValue(TreeNode root) {\\n      int ht =  height(root);\\n        \\n      lca(root,ht);\\n        return a ;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1453676,
                "title": "4-lines-python-solution-beats-90",
                "content": "**Solution code**\\n```\\ndef findBottomLeftValue(self, root):\\n\\tqueue = [root]\\n\\tfor node in queue:\\n\\t\\tqueue += filter(None, (node.right, node.left))\\n\\treturn node.val  \\n```\\n\\n```\\nqueue += filter(None, (node.right, node.left))\\n```\\nThis line is similar to\\n```\\nif node.right:\\n\\tqueue += [node.right]\\nif node.left:\\n\\tqueue += [node.left]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef findBottomLeftValue(self, root):\\n\\tqueue = [root]\\n\\tfor node in queue:\\n\\t\\tqueue += filter(None, (node.right, node.left))\\n\\treturn node.val  \\n```\n```\\nqueue += filter(None, (node.right, node.left))\\n```\n```\\nif node.right:\\n\\tqueue += [node.right]\\nif node.left:\\n\\tqueue += [node.left]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1440697,
                "title": "simple-java-solution-dfs",
                "content": "\\tclass Solution {\\n    int ans;\\n    public int findBottomLeftValue(TreeNode root) {\\n        ans = root.val;\\n        height(root, 1);\\n        return ans;\\n    }\\n    \\n    int height = 0;\\n    public void height(TreeNode node, int depth){\\n        if(node == null)\\n            return;\\n        \\n        if(depth > height){\\n            height = depth;\\n            ans = node.val;\\n        }\\n        \\n        height(node.left, depth + 1);\\n        height(node.right, depth + 1);\\n    }\\n    \\n}\\n\\n**If you liked solution upvote it**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int ans;\\n    public int findBottomLeftValue(TreeNode root) {\\n        ans = root.val;\\n        height(root, 1);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1282434,
                "title": "c-98-fast",
                "content": "...\\n        \\n\\t\\tint findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*>qu;\\n        if(root==NULL)\\n            return 0;\\n        qu.push(root);\\n        int ans;\\n            while(!qu.empty())\\n            {\\n                TreeNode *curr=qu.front();\\n                ans=qu.back()->val;\\n                qu.pop();\\n                if(curr->right!=NULL)\\n                    qu.push(curr->right);\\n                if(curr->left!=NULL)\\n                    qu.push(curr->left);\\n                \\n            }\\n        return ans;\\n\\t\\t}\\n        \\n    \\n\\t...",
                "solutionTags": [],
                "code": "...\\n        \\n\\t\\tint findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*>qu;\\n        if(root==NULL)\\n            return 0;\\n        qu.push(root);\\n        int ans;\\n            while(!qu.empty())\\n            {\\n                TreeNode *curr=qu.front();\\n                ans=qu.back()->val;\\n                qu.pop();\\n                if(curr->right!=NULL)\\n                    qu.push(curr->right);\\n                if(curr->left!=NULL)\\n                    qu.push(curr->left);\\n                \\n            }\\n        return ans;\\n\\t\\t}\\n        \\n    \\n\\t...",
                "codeTag": "Unknown"
            },
            {
                "id": 1272799,
                "title": "98-7-ms-short-easy-explanation-complexites-c",
                "content": "* **PREREQUISITE : `LEVEL ORDER TRAVERSAL (BFS)`**\\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        // idea is simple, just push right child node first & then left child node after root into queue so that,\\n        // at end our root node pointing to bottom last node, after that, just return current root value \\n        if(root == NULL)\\n            return 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            root = q.front();\\n            q.pop();\\n            if(root->right)\\n                q.push(root->right);\\n            if(root->left)\\n                q.push(root->left);\\n        }\\n        return root->val;\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(N),` Where N: total number of nodes in the Binary Tree..**\\n**SPACE COMPLEXITY : `O(W)` Where W: total Width of the Binary Tree.**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense don\\'t forget to Upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        // idea is simple, just push right child node first & then left child node after root into queue so that,\\n        // at end our root node pointing to bottom last node, after that, just return current root value \\n        if(root == NULL)\\n            return 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            root = q.front();\\n            q.pop();\\n            if(root->right)\\n                q.push(root->right);\\n            if(root->left)\\n                q.push(root->left);\\n        }\\n        return root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264850,
                "title": "storing-length-in-node-s-value-iterative-method-python",
                "content": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        q=[]\\n        qb=-1\\n        qv=None\\n        cnt=0\\n        while(q!=[] or root!=None):\\n            while(root!=None):\\n                if(root.left!=None or root.right!=None):\\n                    root.val=cnt\\n                    cnt+=1\\n                else:\\n                    if(cnt>qb):\\n                        qv=root.val\\n                        qb=cnt\\n                    root.val=cnt\\n                q.append(root)\\n                root=root.left\\n            root=q.pop()\\n            cnt=root.val\\n            cnt+=1\\n            root=root.right\\n        return(qv)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        q=[]\\n        qb=-1\\n        qv=None\\n        cnt=0\\n        while(q!=[] or root!=None):\\n            while(root!=None):\\n                if(root.left!=None or root.right!=None):\\n                    root.val=cnt\\n                    cnt+=1\\n                else:\\n                    if(cnt>qb):\\n                        qv=root.val\\n                        qb=cnt\\n                    root.val=cnt\\n                q.append(root)\\n                root=root.left\\n            root=q.pop()\\n            cnt=root.val\\n            cnt+=1\\n            root=root.right\\n        return(qv)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258733,
                "title": "java-simple-dfs-with-explaination",
                "content": "Use DFS to traverse the tree, while keeping trace of \\n\\t```curDepth``` the depth of the current node.\\n\\t```maxDepth``` the maximum depth of the tree.\\n\\t```maxValue``` the current known leftmost node\\'s value.\\n\\t\\n```\\nclass Solution {\\n    int curDepth = 0;\\n    int maxDepth = 0;\\n    int maxValue = 0;\\n\\n    public int findBottomLeftValue(TreeNode root) {\\n        maxValue = root.val;\\n        dfs(root);\\n        return maxValue;\\n    }\\n\\n    public void dfs(TreeNode cur) {\\n        if (cur == null) {\\n            return;\\n        }\\n        if (curDepth > maxDepth) {\\n            maxDepth = curDepth;\\n            maxValue = cur.val;\\n        }\\n\\n        curDepth++;\\n        dfs(cur.left);\\n        dfs(cur.right);\\n        curDepth--;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```curDepth```\n```maxDepth```\n```maxValue```\n```\\nclass Solution {\\n    int curDepth = 0;\\n    int maxDepth = 0;\\n    int maxValue = 0;\\n\\n    public int findBottomLeftValue(TreeNode root) {\\n        maxValue = root.val;\\n        dfs(root);\\n        return maxValue;\\n    }\\n\\n    public void dfs(TreeNode cur) {\\n        if (cur == null) {\\n            return;\\n        }\\n        if (curDepth > maxDepth) {\\n            maxDepth = curDepth;\\n            maxValue = cur.val;\\n        }\\n\\n        curDepth++;\\n        dfs(cur.left);\\n        dfs(cur.right);\\n        curDepth--;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245434,
                "title": "c-bfs-based-solution-extremely-easy",
                "content": "````\\n   int findBottomLeftValue(TreeNode* root) {\\n        \\n         queue<pair<TreeNode*,int>>q;\\n        int level=1;\\n        \\n        int lev=0;\\n        int ans=root->val;\\n        \\n        q.push({root,0});\\n        \\n       while(q.size()!=0)\\n       {\\n           TreeNode* r=q.front().first;\\n           \\n           if(q.front().second>lev)\\n           {\\n               ans=q.front().first->val;\\n               lev=q.front().second;\\n           }\\n                level=q.front().second+1;\\n                q.pop();\\n           \\n      \\n           if(r->left!=NULL)\\n           {\\n               q.push({r->left,level});\\n           }\\n              if(r->right!=NULL)\\n           {\\n               q.push({r->right,level});\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "````\\n   int findBottomLeftValue(TreeNode* root) {\\n        \\n         queue<pair<TreeNode*,int>>q;\\n        int level=1;\\n        \\n        int lev=0;\\n        int ans=root->val;\\n        \\n        q.push({root,0});\\n        \\n       while(q.size()!=0)\\n       {\\n           TreeNode* r=q.front().first;\\n           \\n           if(q.front().second>lev)\\n           {\\n               ans=q.front().first->val;\\n               lev=q.front().second;\\n           }\\n                level=q.front().second+1;\\n                q.pop();\\n           \\n      \\n           if(r->left!=NULL)\\n           {\\n               q.push({r->left,level});\\n           }\\n              if(r->right!=NULL)\\n           {\\n               q.push({r->right,level});\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 957781,
                "title": "c-easy-undersatnding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> res;\\n    void findBottomLeft(TreeNode* root,int height){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            res.push_back({root->val,height});\\n        }\\n        findBottomLeft(root->left,height+1);\\n        findBottomLeft(root->right,height+1);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        findBottomLeft(root,0);\\n        int maxi=INT_MIN,hmax=INT_MIN;\\n        for(auto i: res){\\n            if(hmax<i.second){\\n                hmax=i.second;\\n                maxi=i.first;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> res;\\n    void findBottomLeft(TreeNode* root,int height){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            res.push_back({root->val,height});\\n        }\\n        findBottomLeft(root->left,height+1);\\n        findBottomLeft(root->right,height+1);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        findBottomLeft(root,0);\\n        int maxi=INT_MIN,hmax=INT_MIN;\\n        for(auto i: res){\\n            if(hmax<i.second){\\n                hmax=i.second;\\n                maxi=i.first;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930348,
                "title": "java-dfs-with-global-variable-0ms",
                "content": "```\\nclass Solution {\\n    public int le, va;\\n    public int findBottomLeftValue(TreeNode root) {\\n        le=0; va=root.val;\\n        dfs(root, 0);\\n        return va;\\n    }\\n    public void dfs(TreeNode o, int l){\\n        if(o==null)return;\\n        if(l>le){va=o.val; le=l;}\\n        dfs(o.left, l+1);\\n        dfs(o.right, l+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int le, va;\\n    public int findBottomLeftValue(TreeNode root) {\\n        le=0; va=root.val;\\n        dfs(root, 0);\\n        return va;\\n    }\\n    public void dfs(TreeNode o, int l){\\n        if(o==null)return;\\n        if(l>le){va=o.val; le=l;}\\n        dfs(o.left, l+1);\\n        dfs(o.right, l+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906000,
                "title": "java-dfs-solution-beats-100-0",
                "content": "I have made global variables and updated them when i encountered the left most tree node.This is a DFS approach. Any questions, comment them, will be happy to help you.\\n```\\nclass Solution {\\n    int l=0;\\n    int ans;\\n    public int findBottomLeftValue(TreeNode root) {\\n       helper(root,1);\\n        return ans;\\n    }\\n    public void helper(TreeNode root,int level){\\n        if(root==null)\\n            return;\\n        \\n        if(l!=level && l<level){\\n            l=level;\\n        ans=root.val;\\n        }\\n        helper(root.left,level+1);\\n        helper(root.right,level+1);\\n        return;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int l=0;\\n    int ans;\\n    public int findBottomLeftValue(TreeNode root) {\\n       helper(root,1);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 836692,
                "title": "faster-than-100-in-0ms-simple-bfs-solution-java",
                "content": "We are basically traversing to the last level and storing all the node values into a list and returning the first element in the list.\\n```\\nclass Solution {\\n    List<Integer> list;\\n    public int height(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int l=height(root.left);\\n        int r=height(root.right);\\n        return Math.max(l,r)+1;\\n    }\\n    \\n    public void bfs(TreeNode root,int l)\\n    {\\n        if(l==0 || root==null)\\n            return;\\n        if(l==1)\\n        {\\n            list.add(root.val);\\n        }\\n        else\\n        {\\n            bfs(root.left,l-1);\\n            bfs(root.right,l-1);\\n        } \\n        \\n    }\\n    public int findBottomLeftValue(TreeNode root) {\\n        int h=height(root);\\n       list=new ArrayList<Integer>();\\n       bfs(root,h);\\n        return list.get(0);\\n    }\\n}\\n```\\n\\n\\nOr to save space, just use two integers, one to store the value and one as a flag, as shown below:\\n```\\nclass Solution {\\n  \\n    int flag=0;\\n    int first=0;\\n    public int height(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int l=height(root.left);\\n        int r=height(root.right);\\n        return Math.max(l,r)+1;\\n    }\\n    \\n    public void bfs(TreeNode root,int l)\\n    {\\n        if(l==0 || root==null)\\n            return;\\n        if(l==1 && flag==0)\\n        {\\n            first=root.val;\\n            flag=1;\\n            return;\\n         \\n        }\\n        else\\n        {\\n            bfs(root.left,l-1);\\n            bfs(root.right,l-1);\\n        } \\n        \\n    }\\n    public int findBottomLeftValue(TreeNode root) {\\n        int h=height(root);\\n        bfs(root,h);\\n        return first;\\n      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> list;\\n    public int height(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int l=height(root.left);\\n        int r=height(root.right);\\n        return Math.max(l,r)+1;\\n    }\\n    \\n    public void bfs(TreeNode root,int l)\\n    {\\n        if(l==0 || root==null)\\n            return;\\n        if(l==1)\\n        {\\n            list.add(root.val);\\n        }\\n        else\\n        {\\n            bfs(root.left,l-1);\\n            bfs(root.right,l-1);\\n        } \\n        \\n    }\\n    public int findBottomLeftValue(TreeNode root) {\\n        int h=height(root);\\n       list=new ArrayList<Integer>();\\n       bfs(root,h);\\n        return list.get(0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n  \\n    int flag=0;\\n    int first=0;\\n    public int height(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int l=height(root.left);\\n        int r=height(root.right);\\n        return Math.max(l,r)+1;\\n    }\\n    \\n    public void bfs(TreeNode root,int l)\\n    {\\n        if(l==0 || root==null)\\n            return;\\n        if(l==1 && flag==0)\\n        {\\n            first=root.val;\\n            flag=1;\\n            return;\\n         \\n        }\\n        else\\n        {\\n            bfs(root.left,l-1);\\n            bfs(root.right,l-1);\\n        } \\n        \\n    }\\n    public int findBottomLeftValue(TreeNode root) {\\n        int h=height(root);\\n        bfs(root,h);\\n        return first;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784209,
                "title": "python-3-solution-beating-99-72",
                "content": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        q=[root]\\n        ans=None\\n        while q:\\n            ans=q[0].val\\n            for _ in range(len(q)): \\n                node=q.pop(0)\\n                if node.left:q.append(node.left)\\n                if node.right:q.append(node.right)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        q=[root]\\n        ans=None\\n        while q:\\n            ans=q[0].val\\n            for _ in range(len(q)): \\n                node=q.pop(0)\\n                if node.left:q.append(node.left)\\n                if node.right:q.append(node.right)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759740,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    int l = -1, res = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode node, int lvl) {\\n        if (node == null) return;\\n        dfs(node.left, lvl + 1);\\n        if (lvl > l) {\\n            l = lvl;\\n            res = node.val;\\n        }\\n        dfs(node.right, lvl + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int l = -1, res = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode node, int lvl) {\\n        if (node == null) return;\\n        dfs(node.left, lvl + 1);\\n        if (lvl > l) {\\n            l = lvl;\\n            res = node.val;\\n        }\\n        dfs(node.right, lvl + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740922,
                "title": "using-left-view-of-binary-tree",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<int> &ans,int level=0){\\n        if(root==NULL)\\n            return;\\n        if(ans.size()<=level)\\n            ans.push_back(root->val);\\n        //go left\\n        helper(root->left,ans,level+1);\\n        //go right\\n        helper(root->right,ans,level+1);\\n        return;\\n        \\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans[ans.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<int> &ans,int level=0){\\n        if(root==NULL)\\n            return;\\n        if(ans.size()<=level)\\n            ans.push_back(root->val);\\n        //go left\\n        helper(root->left,ans,level+1);\\n        //go right\\n        helper(root->right,ans,level+1);\\n        return;\\n        \\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans[ans.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733545,
                "title": "simple-js-dfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar findBottomLeftValue = function(root) {\\n    let nextMaxLevel = 0;\\n    let bottomleftVal = 0;\\n    const dfs = (root, level) => {\\n        if(!root) return;\\n        if(level === nextMaxLevel) {\\n            bottomleftVal = root.val\\n            nextMaxLevel+=1;\\n        }\\n        dfs(root.left, level+1);\\n        dfs(root.right, level+1);\\n    }\\n    dfs(root, 0);\\n    return bottomleftVal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar findBottomLeftValue = function(root) {\\n    let nextMaxLevel = 0;\\n    let bottomleftVal = 0;\\n    const dfs = (root, level) => {\\n        if(!root) return;\\n        if(level === nextMaxLevel) {\\n            bottomleftVal = root.val\\n            nextMaxLevel+=1;\\n        }\\n        dfs(root.left, level+1);\\n        dfs(root.right, level+1);\\n    }\\n    dfs(root, 0);\\n    return bottomleftVal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 710752,
                "title": "c-pre-order-traversal",
                "content": "The idea is simple: do a pre-order traversal of the tree. For every level, pre-order traversal always guarantees that the first element came across is the left most element. \\n\\nRecord the level of traversal, whenever see a new level, record the first element came across in that level. Ignore the rest of them\\n\\n```\\nclass Solution {\\npublic:\\n    void pre_order_trav(TreeNode* nd, int& ans, int depth, int& max_depth)\\n    {\\n        if (!nd)\\n            return;\\n        if (depth > max_depth)\\n        {\\n            max_depth = depth;\\n            ans = nd->val;\\n        }\\n        pre_order_trav(nd->left, ans, depth + 1, max_depth);\\n        pre_order_trav(nd->right, ans, depth + 1, max_depth);\\n        return;\\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        int ans;\\n        int max_depth = -1;\\n        pre_order_trav(root, ans, 0, max_depth);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void pre_order_trav(TreeNode* nd, int& ans, int depth, int& max_depth)\\n    {\\n        if (!nd)\\n            return;\\n        if (depth > max_depth)\\n        {\\n            max_depth = depth;\\n            ans = nd->val;\\n        }\\n        pre_order_trav(nd->left, ans, depth + 1, max_depth);\\n        pre_order_trav(nd->right, ans, depth + 1, max_depth);\\n        return;\\n    }\\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        int ans;\\n        int max_depth = -1;\\n        pre_order_trav(root, ans, 0, max_depth);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690082,
                "title": "python-recursive-iterative-solution",
                "content": "```Iterative:```\\n```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        q = collections.deque()\\n        q.append(root)\\n        bottom_left = root.val\\n        while q:\\n            length = len(q)\\n            for i in range(length):\\n                node = q.popleft()\\n                if i == 0:\\n                    bottom_left = node.val\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return bottom_left\\n```\\n\\n```Recursive:```\\n```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        bottom_left,max_depth = root.val,0\\n        def bottom(root,depth):\\n            nonlocal bottom_left\\n            nonlocal max_depth\\n            if not root:\\n                return None\\n            if depth > max_depth:\\n                max_depth = depth\\n                bottom_left = root.val\\n            bottom(root.left,depth+1)\\n            bottom(root.right,depth+1)\\n        bottom(root,0)\\n        return bottom_left\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```Iterative:```\n```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        q = collections.deque()\\n        q.append(root)\\n        bottom_left = root.val\\n        while q:\\n            length = len(q)\\n            for i in range(length):\\n                node = q.popleft()\\n                if i == 0:\\n                    bottom_left = node.val\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return bottom_left\\n```\n```Recursive:```\n```\\nclass Solution:\\n    def findBottomLeftValue(self, root: TreeNode) -> int:\\n        bottom_left,max_depth = root.val,0\\n        def bottom(root,depth):\\n            nonlocal bottom_left\\n            nonlocal max_depth\\n            if not root:\\n                return None\\n            if depth > max_depth:\\n                max_depth = depth\\n                bottom_left = root.val\\n            bottom(root.left,depth+1)\\n            bottom(root.right,depth+1)\\n        bottom(root,0)\\n        return bottom_left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607429,
                "title": "java-100-time-complexity",
                "content": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    int level = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        findLeft(root, true, 1);\\n        return max;\\n    }\\n    \\n    void findLeft(TreeNode root, Boolean isLeft, int cur) {\\n       if(cur > level) {\\n            max = root.val;\\n            level = cur;\\n        }\\n        \\n        if(root.left == null && root.right == null)\\n            return;\\n        \\n        if(root.left != null)\\n            findLeft(root.left, true, cur+1);\\n        if(root.right != null)\\n            findLeft(root.right, false, cur+1);\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    int level = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        findLeft(root, true, 1);\\n        return max;\\n    }\\n    \\n    void findLeft(TreeNode root, Boolean isLeft, int cur) {\\n       if(cur > level) {\\n            max = root.val;\\n            level = cur;\\n        }\\n        \\n        if(root.left == null && root.right == null)\\n            return;\\n        \\n        if(root.left != null)\\n            findLeft(root.left, true, cur+1);\\n        if(root.right != null)\\n            findLeft(root.right, false, cur+1);\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 462751,
                "title": "java-post-order-traversal-using-object-oriented-programming-faster-than-100",
                "content": "```\\nclass Solution {\\n    class Result {\\n        int val;\\n        int level;\\n        public Result(int val, int level) {\\n            this.val = val;\\n            this.level = level;\\n        }\\n    }\\n    public int findBottomLeftValue(TreeNode root) {\\n        Result res = postorder(root, 0);\\n        return res.val;\\n    }\\n    public Result postorder(TreeNode root, int level) {\\n        if (root == null) return new Result(0,0);\\n        Result left = postorder(root.left, level + 1);\\n        Result right = postorder(root.right, level + 1);\\n        if (left.level > right.level) {\\n            return left;\\n        } else if (right.level > left.level) {\\n            return right;\\n        } else if (left.level == 0 && right.level == 0) {\\n            return new Result(root.val, level);\\n        }\\n        //left level == right level and not equal to 0\\n        return left;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Result {\\n        int val;\\n        int level;\\n        public Result(int val, int level) {\\n            this.val = val;\\n            this.level = level;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 409163,
                "title": "swift-level-traversal",
                "content": "```\\nclass Solution {\\n    var maxLevel = 0\\n    var value = 0\\n    \\n    func findBottomLeftValue(_ root: TreeNode?) -> Int {\\n        guard let r = root else { return 0 }\\n        \\n        value = r.val\\n        level(root, 0)\\n        \\n        return value\\n    }\\n    \\n    func level(_ root: TreeNode?, _ l: Int) {\\n        guard let r = root else { return }\\n        \\n        level(r.left, l+1)\\n        level(r.right, l+1)\\n        \\n        if maxLevel < l {\\n            maxLevel = l\\n            value = r.val\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    var maxLevel = 0\\n    var value = 0\\n    \\n    func findBottomLeftValue(_ root: TreeNode?) -> Int {\\n        guard let r = root else { return 0 }",
                "codeTag": "Java"
            },
            {
                "id": 282021,
                "title": "java-0ms-simple-recursion",
                "content": "```\\nclass Solution {\\n    int level = -1;\\n    int left = 0;\\n    \\n    public int findBottomLeftValue(TreeNode root) {\\n        find(root, 0);\\n        return left;\\n    }\\n    \\n    void find(TreeNode node, int l) {\\n        if (node == null) {\\n            return;\\n        }\\n        if (l > level) {\\n            level = l;\\n            left = node.val;\\n        }\\n        find(node.left, l+1);\\n        find(node.right, l+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int level = -1;\\n    int left = 0;\\n    \\n    public int findBottomLeftValue(TreeNode root) {\\n        find(root, 0);\\n        return left;\\n    }\\n    \\n    void find(TreeNode node, int l) {\\n        if (node == null) {\\n            return;\\n        }\\n        if (l > level) {\\n            level = l;\\n            left = node.val;\\n        }\\n        find(node.left, l+1);\\n        find(node.right, l+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98776,
                "title": "javascript-98ms-beats-100-0",
                "content": "Somewhat surprised such a simple solution came out on top. This solution does a preorder traversal and keeps track of the depth of the current result. If the depth is surpassed, then the leftmost node on the next layer has been found.\\n```\\nvar findBottomLeftValue = function(root) {\\n    var result = root.val;\\n    var resultHeight = 0;\\n    (function recurse (node, height) {\\n        if (node === null) {\\n            return;\\n        }\\n        if (node.left !== null) {\\n            recurse(node.left, height + 1);\\n        }\\n        if (height > resultHeight) {\\n            result = node.val;\\n            resultHeight = height;\\n        }\\n        if (node.right !== null) {\\n            recurse(node.right, height + 1);\\n        }\\n    })(root, 1);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar findBottomLeftValue = function(root) {\\n    var result = root.val;\\n    var resultHeight = 0;\\n    (function recurse (node, height) {\\n        if (node === null) {\\n            return;\\n        }\\n        if (node.left !== null) {\\n            recurse(node.left, height + 1);\\n        }\\n        if (height > resultHeight) {\\n            result = node.val;\\n            resultHeight = height;\\n        }\\n        if (node.right !== null) {\\n            recurse(node.right, height + 1);\\n        }\\n    })(root, 1);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98842,
                "title": "c-recursive-and-o-n",
                "content": "```\\nint get_height (struct TreeNode* root, struct TreeNode** bottom_left, int level, int *max_level) {\\n    if (root == NULL) {\\n        return 0;\\n    }\\n\\n    // if leaf at lowest level we've seen, store it as bottom_left node\\n    if (root->left == NULL && root->right == NULL && level > *max_level)\\n        *bottom_left = root;\\n\\n    if (level > *max_level)\\n        *max_level = level;\\n\\n    int left = 1 + get_height (root->left, bottom_left, level + 1, max_level);\\n    int right = 1 + get_height (root->right, bottom_left, level + 1, max_level);\\n    if (left >= right) {\\n        return left;\\n    } else {\\n        return right;\\n    }\\n} \\n\\nint findBottomLeftValue(struct TreeNode* root) {\\n    int max_level = -1;\\n    struct TreeNode *bottom_left = NULL;    \\n    get_height (root, &bottom_left, 0, &max_level);\\n    \\n    return bottom_left->val;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint get_height (struct TreeNode* root, struct TreeNode** bottom_left, int level, int *max_level) {\\n    if (root == NULL) {\\n        return 0;\\n    }\\n\\n    // if leaf at lowest level we've seen, store it as bottom_left node\\n    if (root->left == NULL && root->right == NULL && level > *max_level)\\n        *bottom_left = root;\\n\\n    if (level > *max_level)\\n        *max_level = level;\\n\\n    int left = 1 + get_height (root->left, bottom_left, level + 1, max_level);\\n    int right = 1 + get_height (root->right, bottom_left, level + 1, max_level);\\n    if (left >= right) {\\n        return left;\\n    } else {\\n        return right;\\n    }\\n} \\n\\nint findBottomLeftValue(struct TreeNode* root) {\\n    int max_level = -1;\\n    struct TreeNode *bottom_left = NULL;    \\n    get_height (root, &bottom_left, 0, &max_level);\\n    \\n    return bottom_left->val;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98824,
                "title": "c-simple-solution-concise-code-o-1-space-with-morris-trv",
                "content": "Simple recursion traversal\\nO(n) space;\\nO(n) time;\\n```\\nclass Solution {\\n    void dfs(TreeNode* cur, int height, pair<int, int>& res) {\\n        if (!cur)\\n            return;\\n        if (height > res.second)\\n            res = {cur->val, height};\\n        dfs(cur->left, height + 1, res);\\n        dfs(cur->right, height + 1, res);\\n    }\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        pair<int, int> res(0, -1);\\n        dfs(root, 0, res);\\n        return res.first;\\n    }\\n};\\n```\\n\\nMorris Traversal\\n[Morris Traversal](http://yongblog.us/2017/01/28/Morris-Traversal/)\\n[Get Height by Morris Traversal](http://yongblog.us/2017/02/06/Get-Height-of-Binary-Tree-by-MorrisTraversal/)\\nO(1) space\\nO(n) time\\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int height = 0;\\n        pair<int, int> res = {0, -1};\\n        TreeNode* cur = root, *prev = nullptr;\\n        while (cur) {\\n            if (cur->left == nullptr) {\\n                //\\n                if (height > res.second)\\n                    res = {cur->val, height};\\n                cur = cur->right;\\n                height++;\\n            } else {\\n                prev = cur->left;\\n                int move = 1;\\n                while (prev->right && prev->right != cur) {\\n                    prev = prev->right;\\n                    move++;\\n                }\\n                if (prev->right == nullptr) {\\n                    prev->right = cur;\\n                    //\\n                    if (height > res.second)\\n                        res = {cur->val, height};\\n                    cur = cur->left;\\n                    height++;\\n                } else {\\n                    prev->right = NULL;\\n                    height -= move + 1;\\n                    cur = cur->right;\\n                    height++;\\n                }\\n                    \\n            }\\n        }\\n        return res.first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(TreeNode* cur, int height, pair<int, int>& res) {\\n        if (!cur)\\n            return;\\n        if (height > res.second)\\n            res = {cur->val, height};\\n        dfs(cur->left, height + 1, res);\\n        dfs(cur->right, height + 1, res);\\n    }\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        pair<int, int> res(0, -1);\\n        dfs(root, 0, res);\\n        return res.first;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int height = 0;\\n        pair<int, int> res = {0, -1};\\n        TreeNode* cur = root, *prev = nullptr;\\n        while (cur) {\\n            if (cur->left == nullptr) {\\n                //\\n                if (height > res.second)\\n                    res = {cur->val, height};\\n                cur = cur->right;\\n                height++;\\n            } else {\\n                prev = cur->left;\\n                int move = 1;\\n                while (prev->right && prev->right != cur) {\\n                    prev = prev->right;\\n                    move++;\\n                }\\n                if (prev->right == nullptr) {\\n                    prev->right = cur;\\n                    //\\n                    if (height > res.second)\\n                        res = {cur->val, height};\\n                    cur = cur->left;\\n                    height++;\\n                } else {\\n                    prev->right = NULL;\\n                    height -= move + 1;\\n                    cur = cur->right;\\n                    height++;\\n                }\\n                    \\n            }\\n        }\\n        return res.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98886,
                "title": "c-solution-using-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int ans = 0, h = -1;\\n        dfs(root, ans, h, 0);\\n        return ans;\\n    }\\nprivate:\\n    void dfs(TreeNode* root, int &ans, int &h, int dep){\\n        if(dep > h){\\n            ans = root->val;\\n            h = dep;\\n        }\\n        if(root->left)\\n            dfs(root->left, ans, h, dep + 1);\\n        if(root->right)\\n            dfs(root->right, ans, h, dep + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int ans = 0, h = -1;\\n        dfs(root, ans, h, 0);\\n        return ans;\\n    }\\nprivate:\\n    void dfs(TreeNode* root, int &ans, int &h, int dep){\\n        if(dep > h){\\n            ans = root->val;\\n            h = dep;\\n        }\\n        if(root->left)\\n            dfs(root->left, ans, h, dep + 1);\\n        if(root->right)\\n            dfs(root->right, ans, h, dep + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98894,
                "title": "java-bfs",
                "content": "```\\n    public int findLeftMostNode(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        int queueSize = 1, lastVal = 0;\\n        while (queueSize > 0) {\\n            for (int i=0;i<queueSize;i++) {\\n                TreeNode cur = queue.poll();\\n                if (i == 0) lastVal = cur.val;\\n                if (cur.left != null) queue.add(cur.left);\\n                if (cur.right != null) queue.add(cur.right);\\n            }\\n            queueSize = queue.size();\\n        }\\n        return lastVal;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findLeftMostNode(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        int queueSize = 1, lastVal = 0;\\n        while (queueSize > 0) {\\n            for (int i=0;i<queueSize;i++) {\\n                TreeNode cur = queue.poll();\\n                if (i == 0) lastVal = cur.val;\\n                if (cur.left != null) queue.add(cur.left);\\n                if (cur.right != null) queue.add(cur.right);\\n            }\\n            queueSize = queue.size();\\n        }\\n        return lastVal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043928,
                "title": "beats-95-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a queue within which we can iterate over the tree, while doing it, keep track of most left node, (because we prioritazing left over right), once we are done with whole tree, return the last element in answear, which is the left-most node\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        queue=deque([root])\\n        ans=[]\\n        while queue:\\n            curr=len(queue)\\n            ans.append(queue[0].val)\\n            for i in range(curr):\\n                node=queue.popleft()\\n                if node.left:\\n                    queue.append(node.left)\\n\\n                if node.right:\\n                    queue.append(node.right)\\n        return ans[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        queue=deque([root])\\n        ans=[]\\n        while queue:\\n            curr=len(queue)\\n            ans.append(queue[0].val)\\n            for i in range(curr):\\n                node=queue.popleft()\\n                if node.left:\\n                    queue.append(node.left)\\n\\n                if node.right:\\n                    queue.append(node.right)\\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933569,
                "title": "easy-c-solution-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<pair<TreeNode*,int>> q;\\n        int ans;\\n        int maxl = -1;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            pair<TreeNode*,int> t = q.front();\\n            q.pop();\\n            \\n            TreeNode* node = t.first;\\n            int l = t.second;\\n\\n            if(l > maxl){\\n                maxl = l;\\n                ans = node->val;\\n            }\\n\\n            if(node->left){\\n                q.push({node->left,l+1});\\n            }\\n            if(node->right){\\n                q.push({node->right,l+1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<pair<TreeNode*,int>> q;\\n        int ans;\\n        int maxl = -1;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            pair<TreeNode*,int> t = q.front();\\n            q.pop();\\n            \\n            TreeNode* node = t.first;\\n            int l = t.second;\\n\\n            if(l > maxl){\\n                maxl = l;\\n                ans = node->val;\\n            }\\n\\n            if(node->left){\\n                q.push({node->left,l+1});\\n            }\\n            if(node->right){\\n                q.push({node->right,l+1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798211,
                "title": "find-bottom-left-tree-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/16753362-da8e-487e-ba40-06d8cf3b6024_1689965546.5048196.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        l=defaultdict(list)\\n        def bfs(root,h):\\n            if root is None:\\n                return\\n            l[h].append(root.val)\\n            bfs(root.left,h+1)\\n            bfs(root.right,h+1)\\n        bfs(root,0)\\n        return l[len(l)-1][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        l=defaultdict(list)\\n        def bfs(root,h):\\n            if root is None:\\n                return\\n            l[h].append(root.val)\\n            bfs(root.left,h+1)\\n            bfs(root.right,h+1)\\n        bfs(root,0)\\n        return l[len(l)-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792416,
                "title": "beats-90",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int>ans;\\n            ans.first=0;\\n            ans.second=0;\\n            return ans;\\n        }\\n        pair<int,int>ans;\\n        ans.first=0;\\n        ans.second=1;\\n        if(root->left==NULL && root->right==NULL){\\n            ans.first=root->val;\\n            return ans;\\n        }\\n        pair leftAns=helper(root->left);\\n        pair rightAns=helper(root->right);\\n        ans.second+=max(leftAns.second , rightAns.second);\\n        if(leftAns.second >= rightAns.second){\\n            ans.first=leftAns.first;\\n            return ans;\\n        }\\n        ans.first=rightAns.first;\\n        return ans;\\n\\n    }\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        pair<int,int>ans=helper(root);\\n        return ans.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int>ans;\\n            ans.first=0;\\n            ans.second=0;\\n            return ans;\\n        }\\n        pair<int,int>ans;\\n        ans.first=0;\\n        ans.second=1;\\n        if(root->left==NULL && root->right==NULL){\\n            ans.first=root->val;\\n            return ans;\\n        }\\n        pair leftAns=helper(root->left);\\n        pair rightAns=helper(root->right);\\n        ans.second+=max(leftAns.second , rightAns.second);\\n        if(leftAns.second >= rightAns.second){\\n            ans.first=leftAns.first;\\n            return ans;\\n        }\\n        ans.first=rightAns.first;\\n        return ans;\\n\\n    }\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        pair<int,int>ans=helper(root);\\n        return ans.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733992,
                "title": "easy-c-solution-beats-99-easy-to-understand-and-implement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**So the intuition or idea behind this approach is left view of binary tree.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- So we need to find the bottom left tree value for the given tree.This means that if we view the tree from left side then the last appearing node will be our ans.\\n\\n\\n\\n- To acheive this task we take a vector ans which store all the values of left view of the tree, and the last value that is stored in our vector will be our result.\\n\\n- Now, to store the left view of tree we use inorder traversal.\\n\\n- For current node we will check whether the size of vector is equal to its level or not.\\n\\n- If it is equal this significe that the root is the first value in the current level and is part of our left tree.\\n\\n- So we store it in our ans.\\n\\n- When the tree is fully traversed then our ans will contain the left view of tree.\\n\\nWe return the last value in ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N),where N->Total number of nodes\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N),where N->Total number of nodes\\n\\n# Code\\n```************\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void find(TreeNode *root,int level,vector<int>&ans){\\n        if(root==NULL)return ;\\n        //If size of vector is equal to level or not.\\n        if(level==ans.size())ans.push_back(root->val);\\n        find(root->left,level+1,ans);\\n        find(root->right,level+1,ans);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int>ans;\\n        find(root,0,ans);\\n        return ans.back();\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```************\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void find(TreeNode *root,int level,vector<int>&ans){\\n        if(root==NULL)return ;\\n        //If size of vector is equal to level or not.\\n        if(level==ans.size())ans.push_back(root->val);\\n        find(root->left,level+1,ans);\\n        find(root->right,level+1,ans);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int>ans;\\n        find(root,0,ans);\\n        return ans.back();\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663501,
                "title": "java-easy-dfs-traversal-without-using-global-variables",
                "content": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        return helper(root, 0).getKey().val;\\n    }\\n\\n    private Pair<TreeNode, Integer> helper(TreeNode root, int height) {\\n        if(root != null) {\\n            Pair<TreeNode, Integer> left = helper(root.left, height + 1);\\n            Pair<TreeNode, Integer> right = helper(root.right, height + 1);\\n\\n            if(left.getKey() == null && right.getKey() == null)\\n                return new Pair<>(root, height);\\n            \\n            if(right.getValue() > left.getValue())\\n                return right;\\n\\n            return left;\\n        }\\n\\n        return new Pair<>(null, Integer.MIN_VALUE);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        return helper(root, 0).getKey().val;\\n    }\\n\\n    private Pair<TreeNode, Integer> helper(TreeNode root, int height) {\\n        if(root != null) {\\n            Pair<TreeNode, Integer> left = helper(root.left, height + 1);\\n            Pair<TreeNode, Integer> right = helper(root.right, height + 1);\\n\\n            if(left.getKey() == null && right.getKey() == null)\\n                return new Pair<>(root, height);\\n            \\n            if(right.getValue() > left.getValue())\\n                return right;\\n\\n            return left;\\n        }\\n\\n        return new Pair<>(null, Integer.MIN_VALUE);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499099,
                "title": "c-bfs-with-3ms-runtime",
                "content": "\\n# Approach\\nSince we need the left most value, we will apply BFS from right to left.\\nRest of the code is pretty much self explanatory.  \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(w), where w is the maximum width of the tree.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nqueue<TreeNode*> q;\\n    int findBottomLeftValue(TreeNode* root) {\\n        q.push(root);\\n        int left_val;\\n        while(!q.empty())\\n        {\\n            if(q.front()->right) q.push(q.front()->right);\\n            if(q.front()->left) q.push(q.front()->left);\\n            left_val=q.front()->val;\\n            q.pop();\\n        }\\n        return left_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nqueue<TreeNode*> q;\\n    int findBottomLeftValue(TreeNode* root) {\\n        q.push(root);\\n        int left_val;\\n        while(!q.empty())\\n        {\\n            if(q.front()->right) q.push(q.front()->right);\\n            if(q.front()->left) q.push(q.front()->left);\\n            left_val=q.front()->val;\\n            q.pop();\\n        }\\n        return left_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385190,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void calculate(TreeNode* head,int level,int &maxlevel,int &ans){\\n        if(level>maxlevel){\\n            ans=head->val;\\n            maxlevel=level;\\n        }\\n        if(head->left){\\n            calculate(head->left,level+1,maxlevel,ans);\\n        }\\n        if(head->right){\\n            calculate(head->right,level+1,maxlevel,ans);\\n        }\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        int maxlevel=-1,ans=-1;\\n        calculate(root,0,maxlevel,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        def rec(node, level):\\n            if not node.left and not node.right:\\n                return node.val, level\\n            if node.left:\\n                leftnode, leftlevel = rec(node.left, level+1)\\n            else:\\n                leftnode, leftlevel = 0, float(\\'-inf\\')\\n            if node.right:\\n                rightnode, rightlevel = rec(node.right, level+1)\\n            else:\\n                rightnode, rightlevel = 0, float(\\'-inf\\')\\n            if rightlevel > leftlevel:\\n                return rightnode, rightlevel\\n            else:\\n                return leftnode, leftlevel\\n        ans, level = rec(root, 0)\\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    static int parent=-1;\\n    static int ans=0;\\n    public int findBottomLeftValue(TreeNode root) {\\n       help(root,0);\\n       int res=ans;ans=0;\\n       parent=-1;\\n       return res;\\n    }\\n    public static void help(TreeNode root,int level)\\n    {\\n        if(root==null)return ;\\n        if(level>parent){\\n            ans=root.val;\\n            parent=level;\\n        }\\n        help(root.left,level+1);\\n        help(root.right,level+1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void calculate(TreeNode* head,int level,int &maxlevel,int &ans){\\n        if(level>maxlevel){\\n            ans=head->val;\\n            maxlevel=level;\\n        }\\n        if(head->left){\\n            calculate(head->left,level+1,maxlevel,ans);\\n        }\\n        if(head->right){\\n            calculate(head->right,level+1,maxlevel,ans);\\n        }\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        int maxlevel=-1,ans=-1;\\n        calculate(root,0,maxlevel,ans);\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        def rec(node, level):\\n            if not node.left and not node.right:\\n                return node.val, level\\n            if node.left:\\n                leftnode, leftlevel = rec(node.left, level+1)\\n            else:\\n                leftnode, leftlevel = 0, float(\\'-inf\\')\\n            if node.right:\\n                rightnode, rightlevel = rec(node.right, level+1)\\n            else:\\n                rightnode, rightlevel = 0, float(\\'-inf\\')\\n            if rightlevel > leftlevel:\\n                return rightnode, rightlevel\\n            else:\\n                return leftnode, leftlevel\\n        ans, level = rec(root, 0)\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    static int parent=-1;\\n    static int ans=0;\\n    public int findBottomLeftValue(TreeNode root) {\\n       help(root,0);\\n       int res=ans;ans=0;\\n       parent=-1;\\n       return res;\\n    }\\n    public static void help(TreeNode root,int level)\\n    {\\n        if(root==null)return ;\\n        if(level>parent){\\n            ans=root.val;\\n            parent=level;\\n        }\\n        help(root.left,level+1);\\n        help(root.right,level+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359631,
                "title": "python3-bfs",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        depth = 0\\n        stack = collections.deque([(root)])\\n        d = {}\\n        a = 0\\n        while stack:\\n            lvl = []\\n            for i in range(len(stack)):\\n                n = stack.popleft()\\n                lvl.append(n.val)\\n                if n.left: stack.append(n.left)\\n                if n.right: stack.append(n.right)\\n        return lvl[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        depth = 0\\n        stack = collections.deque([(root)])\\n        d = {}\\n        a = 0\\n        while stack:\\n            lvl = []\\n            for i in range(len(stack)):\\n                n = stack.popleft()\\n                lvl.append(n.val)\\n                if n.left: stack.append(n.left)\\n                if n.right: stack.append(n.right)\\n        return lvl[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258734,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution \\n{\\n    public int findBottomLeftValue(TreeNode root) \\n    {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int i=0,result=0;\\n        while(q.isEmpty() == false)\\n        {\\n            int count=q.size();\\n            for(i=0;i<count;i++)\\n            {\\n                TreeNode curr=q.poll();\\n                if(i==0)\\n                    result=curr.val;\\n                if(curr.left!=null)\\n                    q.add(curr.left);\\n                if(curr.right!=null)\\n                    q.add(curr.right);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findBottomLeftValue(TreeNode root) \\n    {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int i=0,result=0;\\n        while(q.isEmpty() == false)\\n        {\\n            int count=q.size();\\n            for(i=0;i<count;i++)\\n            {\\n                TreeNode curr=q.poll();\\n                if(i==0)\\n                    result=curr.val;\\n                if(curr.left!=null)\\n                    q.add(curr.left);\\n                if(curr.right!=null)\\n                    q.add(curr.right);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183608,
                "title": "java-bfs-level-order-traversal",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ traverse all nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n\\n        int leftmost = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int levelSize = q.size();\\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode node = q.poll();\\n                if (i == 0) { // left most at each level is always the first node in queue\\n                    leftmost = node.val;\\n                }\\n                if (node.left != null) {\\n                    q.add(node.left);\\n                }\\n                if (node.right != null) {\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        return leftmost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n\\n        int leftmost = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int levelSize = q.size();\\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode node = q.poll();\\n                if (i == 0) { // left most at each level is always the first node in queue\\n                    leftmost = node.val;\\n                }\\n                if (node.left != null) {\\n                    q.add(node.left);\\n                }\\n                if (node.right != null) {\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        return leftmost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152645,
                "title": "java-solution-using-a-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        ArrayDeque<TreeNode> queue = new ArrayDeque<>(List.of(root));\\n        int bottomLeftVal = 0;\\n\\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n            bottomLeftVal = node.val;\\n\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n        }\\n\\n        return bottomLeftVal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        ArrayDeque<TreeNode> queue = new ArrayDeque<>(List.of(root));\\n        int bottomLeftVal = 0;\\n\\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n            bottomLeftVal = node.val;\\n\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n        }\\n\\n        return bottomLeftVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138312,
                "title": "c-solution-99-80-time-96-93-space-inorder-tree-traversal",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\ntypedef struct {\\n    int depth;\\n    int value;\\n} leftMostTreeData;\\n\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root);\\n\\n    void inorderTraversal(TreeNode* node, leftMostTreeData &l, int depth);\\n};\\n/************************************************************/\\nint Solution::findBottomLeftValue(TreeNode* root) {\\n    leftMostTreeData l;\\n    int depth = 0;\\n    /* l initialization */\\n    l.depth = -1;\\n    l.value = 0;\\n    inorderTraversal(root, l, depth);\\n    return l.value;\\n}\\n/************************************************************/\\nvoid Solution::inorderTraversal(TreeNode* node, leftMostTreeData \\n        &l, int depth) {\\n    if (node->left != nullptr) {\\n        inorderTraversal(node->left, l, depth+1);\\n    }\\n    if (l.depth < depth) {\\n        l.depth = depth;\\n        l.value = node->val;\\n    }\\n    if (node->right != nullptr) {\\n        inorderTraversal(node->right, l, depth+1);\\n    }\\n    return;\\n}\\n/************************************************************/\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\ntypedef struct {\\n    int depth;\\n    int value;\\n} leftMostTreeData;\\n\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root);\\n\\n    void inorderTraversal(TreeNode* node, leftMostTreeData &l, int depth);\\n};\\n/************************************************************/\\nint Solution::findBottomLeftValue(TreeNode* root) {\\n    leftMostTreeData l;\\n    int depth = 0;\\n    /* l initialization */\\n    l.depth = -1;\\n    l.value = 0;\\n    inorderTraversal(root, l, depth);\\n    return l.value;\\n}\\n/************************************************************/\\nvoid Solution::inorderTraversal(TreeNode* node, leftMostTreeData \\n        &l, int depth) {\\n    if (node->left != nullptr) {\\n        inorderTraversal(node->left, l, depth+1);\\n    }\\n    if (l.depth < depth) {\\n        l.depth = depth;\\n        l.value = node->val;\\n    }\\n    if (node->right != nullptr) {\\n        inorderTraversal(node->right, l, depth+1);\\n    }\\n    return;\\n}\\n/************************************************************/\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136749,
                "title": "python3-solution-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return None\\n        q = []\\n        ans = []\\n        if root:\\n            q.append(root)\\n        while(q):\\n            node = q.pop(0)\\n            ans.append(node.val)\\n            if node.right:q.append(node.right)\\n            if node.left:q.append(node.left)\\n        return ans[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return None\\n        q = []\\n        ans = []\\n        if root:\\n            q.append(root)\\n        while(q):\\n            node = q.pop(0)\\n            ans.append(node.val)\\n            if node.right:q.append(node.right)\\n            if node.left:q.append(node.left)\\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093005,
                "title": "bfs-dfs-python-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        ans = 0\\n        q = deque() \\n        q.append((root,0)) \\n        while q:\\n            node,level = q.popleft() \\n            ans = node.val\\n            if node.right:\\n                q.append((node.right,level+1)) \\n            if node.left:\\n                q.append((node.left,level+1)) \\n        return ans \\n\\n        # if root:\\n        #     if not root.left and not root.right:\\n        #         return root.val   \\n        # ans = [0] \\n        # max = [0] \\n        # def dfs(root , level):\\n        #     if not root:\\n        #         return; \\n        #     if level>max[0]:\\n        #         max[0] = level \\n        #         ans[0] = root.val\\n        #     dfs(root.left,level+1) \\n        #     dfs(root.right,level+1) \\n        # dfs(root,0) \\n        # return ans[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        ans = 0\\n        q = deque() \\n        q.append((root,0)) \\n        while q:\\n            node,level = q.popleft() \\n            ans = node.val\\n            if node.right:\\n                q.append((node.right,level+1)) \\n            if node.left:\\n                q.append((node.left,level+1)) \\n        return ans \\n\\n        # if root:\\n        #     if not root.left and not root.right:\\n        #         return root.val   \\n        # ans = [0] \\n        # max = [0] \\n        # def dfs(root , level):\\n        #     if not root:\\n        #         return; \\n        #     if level>max[0]:\\n        #         max[0] = level \\n        #         ans[0] = root.val\\n        #     dfs(root.left,level+1) \\n        #     dfs(root.right,level+1) \\n        # dfs(root,0) \\n        # return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063181,
                "title": "python-solution-pre-order-traversal-recursion-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        self.leftmostelm = root.val\\n        self.depth = 0\\n        self.path = \\'z\\'\\n        self.find(root)\\n        return self.leftmostelm\\n    \\n    def find(self,root,s=\\'r\\',d=0):\\n        if root == None:\\n            return\\n        if self.depth < d or ( self.path > s):\\n            self.depth = d\\n            self.path = s\\n            self.leftmostelm = root.val\\n        self.find(root.left,s+\\'l\\',d+1)\\n        self.find(root.right,s+\\'r\\',d+1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        self.leftmostelm = root.val\\n        self.depth = 0\\n        self.path = \\'z\\'\\n        self.find(root)\\n        return self.leftmostelm\\n    \\n    def find(self,root,s=\\'r\\',d=0):\\n        if root == None:\\n            return\\n        if self.depth < d or ( self.path > s):\\n            self.depth = d\\n            self.path = s\\n            self.leftmostelm = root.val\\n        self.find(root.left,s+\\'l\\',d+1)\\n        self.find(root.right,s+\\'r\\',d+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965733,
                "title": "easy-tree-traversal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndo inorder tree taversal ans store the node values with there levels at which the are present\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(number of nodes)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<pair<int,int>>&v,int k)\\n    {\\n        if(root==NULL)return;\\n        else if(root->left==NULL&&root->right==NULL)\\n        {\\n            v.push_back({root->val,k});\\n        }\\n        helper(root->left,v,k+1);\\n        helper(root->right,v,k+1);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<pair<int,int>>v;\\n        helper(root,v,0);\\n        int ans,flag=-1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(flag<v[i].second)\\n            {\\n                ans=v[i].first;\\n                flag=v[i].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<pair<int,int>>&v,int k)\\n    {\\n        if(root==NULL)return;\\n        else if(root->left==NULL&&root->right==NULL)\\n        {\\n            v.push_back({root->val,k});\\n        }\\n        helper(root->left,v,k+1);\\n        helper(root->right,v,k+1);\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<pair<int,int>>v;\\n        helper(root,v,0);\\n        int ans,flag=-1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(flag<v[i].second)\\n            {\\n                ans=v[i].first;\\n                flag=v[i].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947737,
                "title": "swift-dfs-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var (maxLevel, maxValue) = (0, -1)\\n\\n    func findBottomLeftValue(_ root: TreeNode?) -> Int {\\n        DFS(root, 1)\\n        return maxValue\\n    }\\n\\n    func DFS(_ root: TreeNode?, _ currentLevel: Int) {\\n        if root == nil { return }\\n\\n        if currentLevel > maxLevel {\\n            maxLevel = currentLevel\\n            maxValue = root!.val\\n        }\\n\\n        DFS(root!.left, currentLevel + 1)\\n        DFS(root!.right, currentLevel + 1)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var (maxLevel, maxValue) = (0, -1)\\n\\n    func findBottomLeftValue(_ root: TreeNode?) -> Int {\\n        DFS(root, 1)\\n        return maxValue\\n    }\\n\\n    func DFS(_ root: TreeNode?, _ currentLevel: Int) {\\n        if root == nil { return }\\n\\n        if currentLevel > maxLevel {\\n            maxLevel = currentLevel\\n            maxValue = root!.val\\n        }\\n\\n        DFS(root!.left, currentLevel + 1)\\n        DFS(root!.right, currentLevel + 1)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838011,
                "title": "go-simple-solution",
                "content": "\\n\\n```\\nfunc findBottomLeftValue(root *TreeNode) int {\\n    s := []*TreeNode{root}\\n    var res int\\n    for s != nil {\\n        res = s[0].Val\\n        s = do(s)\\n    }\\n    return res\\n    \\n}\\n\\n\\nfunc do(s []*TreeNode) []*TreeNode {\\n    var res []*TreeNode\\n    for _, v := range s {\\n        if v.Left != nil {\\n            res = append(res, v.Left)\\n        }\\n        if v.Right != nil {\\n            res = append(res, v.Right)\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findBottomLeftValue(root *TreeNode) int {\\n    s := []*TreeNode{root}\\n    var res int\\n    for s != nil {\\n        res = s[0].Val\\n        s = do(s)\\n    }\\n    return res\\n    \\n}\\n\\n\\nfunc do(s []*TreeNode) []*TreeNode {\\n    var res []*TreeNode\\n    for _, v := range s {\\n        if v.Left != nil {\\n            res = append(res, v.Left)\\n        }\\n        if v.Right != nil {\\n            res = append(res, v.Right)\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2796042,
                "title": "99-72-faster-solution-of-python-submissions-understanding-easy-explained",
                "content": "Runtime: 36 ms, faster than 99.72% of Python3 online submissions for Find Bottom Left Tree Value.\\nMemory Usage: 16.2 MB, less than 64.89% of Python3 online submissions for Find Bottom Left Tree Value.\\n\\nBy using Level Order Traversal BFS \\n\\n```\\nfrom collections import deque     # requires deque dfs solution \\n\\n# Below code goes inside of given function\\nstorage = deque([root])           # Using deque imported from Collections \\nlast_known = None\\n\\n# BFS loop \\nwhile storage: \\n\\tlast_known = storage[0]\\n\\n\\tfor _ in range(len(storage)):\\n\\t\\tcatch = storage.popleft()\\n\\n\\t\\tif catch.left:storage.append(catch.left)\\n\\n\\t\\tif catch.right:storage.append(catch.right)\\n\\nreturn last.val # finally returning asnwer \\n````",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque     # requires deque dfs solution \\n\\n# Below code goes inside of given function\\nstorage = deque([root])           # Using deque imported from Collections \\nlast_known = None\\n\\n# BFS loop \\nwhile storage: \\n\\tlast_known = storage[0]\\n\\n\\tfor _ in range(len(storage)):\\n\\t\\tcatch = storage.popleft()\\n\\n\\t\\tif catch.left:storage.append(catch.left)\\n\\n\\t\\tif catch.right:storage.append(catch.right)\\n\\nreturn last.val # finally returning asnwer \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2648191,
                "title": "c-solution-find-bottom-left-tree-value",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        map<int , int> mp; //mapping level to leftmost node\\n        queue<pair<TreeNode * , int> > q;\\n        \\n        int ans = 0;\\n        if(root == NULL)\\n            return ans;\\n        \\n        q.push(make_pair(root , 0));\\n        \\n        while(!q.empty()){\\n            pair<TreeNode * , int> temp = q.front();\\n            q.pop();\\n            \\n            TreeNode *frontNode = temp.first;\\n            int lvl = temp.second;\\n            \\n            if(mp.find(lvl) == mp.end())\\n                mp[lvl] = frontNode->val;\\n            \\n            if(frontNode->left)\\n                q.push(make_pair(frontNode->left , lvl+1));\\n                        \\n            if(frontNode->right)\\n                q.push(make_pair(frontNode->right , lvl+1));\\n        }\\n        return mp[mp.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        map<int , int> mp; //mapping level to leftmost node\\n        queue<pair<TreeNode * , int> > q;\\n        \\n        int ans = 0;\\n        if(root == NULL)\\n            return ans;\\n        \\n        q.push(make_pair(root , 0));\\n        \\n        while(!q.empty()){\\n            pair<TreeNode * , int> temp = q.front();\\n            q.pop();\\n            \\n            TreeNode *frontNode = temp.first;\\n            int lvl = temp.second;\\n            \\n            if(mp.find(lvl) == mp.end())\\n                mp[lvl] = frontNode->val;\\n            \\n            if(frontNode->left)\\n                q.push(make_pair(frontNode->left , lvl+1));\\n                        \\n            if(frontNode->right)\\n                q.push(make_pair(frontNode->right , lvl+1));\\n        }\\n        return mp[mp.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542050,
                "title": "simple-java-solution-beats-100-0",
                "content": "```\\nclass Solution {\\n    int maxHeight = Integer.MIN_VALUE;\\n    int ans = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        dfs(root , 0);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode node , int height){\\n        if (node == null) return;\\n        if (height > maxHeight){\\n            maxHeight = height;\\n            ans = node.val;\\n        }\\n\\n        dfs(node.left , height+1);\\n        dfs(node.right , height+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxHeight = Integer.MIN_VALUE;\\n    int ans = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        dfs(root , 0);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode node , int height){\\n        if (node == null) return;\\n        if (height > maxHeight){\\n            maxHeight = height;\\n            ans = node.val;\\n        }\\n\\n        dfs(node.left , height+1);\\n        dfs(node.right , height+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539457,
                "title": "python-easy-bfs",
                "content": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        curlevel = [root]\\n        while curlevel:\\n            leftmost = curlevel[0]\\n            nxtlevel = []\\n            for i in range(len(curlevel)):\\n                v = curlevel[i]\\n                if v.left: nxtlevel.append(v.left)\\n                if v.right: nxtlevel.append(v.right)\\n            curlevel = nxtlevel\\n        return leftmost.val",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        curlevel = [root]\\n        while curlevel:\\n            leftmost = curlevel[0]\\n            nxtlevel = []\\n            for i in range(len(curlevel)):\\n                v = curlevel[i]\\n                if v.left: nxtlevel.append(v.left)\\n                if v.right: nxtlevel.append(v.right)\\n            curlevel = nxtlevel\\n        return leftmost.val",
                "codeTag": "Java"
            },
            {
                "id": 2539354,
                "title": "simple-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans = -1;\\n        \\n        // get the first value of level and store it\\n        while(!q.empty()){\\n            int size = q.size();\\n            auto top = q.front(); \\n            ans = top->val;\\n            \\n            for(int i =0 ;i<size;i++){\\n                top = q.front(), q.pop();\\n                if(top->left) q.push(top->left);\\n                if(top->right)q.push(top->right);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int ans = -1;\\n        \\n        // get the first value of level and store it\\n        while(!q.empty()){\\n            int size = q.size();\\n            auto top = q.front(); \\n            ans = top->val;\\n            \\n            for(int i =0 ;i<size;i++){\\n                top = q.front(), q.pop();\\n                if(top->left) q.push(top->left);\\n                if(top->right)q.push(top->right);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524228,
                "title": "2-different-solutions-in-java-0-ms-and-1ms",
                "content": "**Upvote if you found it helpful it really helps and motivates me in this journey!!**\\n****\\n**Solution 1 : using ArrayList and storing all the left view nodes and returning the last indexed value \\nruntime : 1ms faster than 82% java submissions\\ntime complexity : O(N) \\nspace Complexity : O(N)**\\n```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        helper(root , ans , 0);\\n        return ans.get(ans.size() - 1);\\n    }\\n    public void helper(TreeNode root , List<Integer> ans , int level){\\n        if(root == null) return;\\n        if(level == ans.size()){\\n            ans.add(root.val);\\n        }\\n        helper(root.left ,ans , level + 1);\\n        helper(root.right ,ans , level + 1);\\n    }\\n}\\n```\\n****\\n**Solution 2 : Creating a Global variable and updating it whenever we go to next level \\nruntime : 0 ms , faster than 100% java submissions \\ntime complexity : O(N) \\nspace Complexity : O(1)**\\n```\\nclass Solution {\\n    // create global variables \\n        int h = 0;\\n        int ans = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        // start from level 1 \\n        helper(root , 1);\\n        return ans;\\n    }\\n    public void helper(TreeNode root , int level){\\n        // if root is null then return\\n        if(root == null) return;\\n        // if current level is greater than previous one then update the ans\\n        if(level > h){\\n            ans = root.val;\\n            h = level;\\n        }\\n        // call for left and right respectively\\n        helper(root.left , level + 1);\\n        helper(root.right , level + 1);\\n    }\\n}\\n```\\n****\\n**Thank You , Do Upvote if You liked it!!**\\n****\\n# java\\n# tree",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        helper(root , ans , 0);\\n        return ans.get(ans.size() - 1);\\n    }\\n    public void helper(TreeNode root , List<Integer> ans , int level){\\n        if(root == null) return;\\n        if(level == ans.size()){\\n            ans.add(root.val);\\n        }\\n        helper(root.left ,ans , level + 1);\\n        helper(root.right ,ans , level + 1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // create global variables \\n        int h = 0;\\n        int ans = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        // start from level 1 \\n        helper(root , 1);\\n        return ans;\\n    }\\n    public void helper(TreeNode root , int level){\\n        // if root is null then return\\n        if(root == null) return;\\n        // if current level is greater than previous one then update the ans\\n        if(level > h){\\n            ans = root.val;\\n            h = level;\\n        }\\n        // call for left and right respectively\\n        helper(root.left , level + 1);\\n        helper(root.right , level + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354550,
                "title": "c-simple-dfs",
                "content": "\\t void dfs(TreeNode* root , int dp , int &maxdp , int &ans){\\n       if(root == nullptr) return;\\n       \\n       if(dp>maxdp){\\n           maxdp = dp;\\n           ans = root->val;\\n       }\\n       \\n       dfs(root->left , dp+1 , maxdp , ans);\\n       dfs(root->right , dp+1 , maxdp , ans);\\n\\t   } \\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        int ans = root->val;\\n        int max = 0;\\n        dfs(root,0,max,ans);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "\\t void dfs(TreeNode* root , int dp , int &maxdp , int &ans){\\n       if(root == nullptr) return;\\n       \\n       if(dp>maxdp){\\n           maxdp = dp;\\n           ans = root->val;\\n       }\\n       \\n       dfs(root->left , dp+1 , maxdp , ans);\\n       dfs(root->right , dp+1 , maxdp , ans);\\n\\t   } \\n    \\n    int findBottomLeftValue(TreeNode* root) {\\n        int ans = root->val;\\n        int max = 0;\\n        dfs(root,0,max,ans);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2340257,
                "title": "java-0ms-find-bottom-left-tree-value",
                "content": "class Solution {\\n    int maxlevel=0;\\n    int val=0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        findval(root,1);\\n        return val;\\n        \\n    }\\n    public void findval(TreeNode root, int level)\\n    {\\n        if(root==null)\\n            return;\\n        findval(root.left,level+1);\\n        if(level>maxlevel)\\n        {\\n            maxlevel=level;\\n            val=root.val;\\n        }\\n        findval(root.right,level+1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    int maxlevel=0;\\n    int val=0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        findval(root,1);\\n        return val;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2340204,
                "title": "c-short-code-answer-well-explained",
                "content": "```\\n/* save the left most number at evey height as you go down the tree\\nand return the last saved number in hash\\n*/\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    void check(int i, TreeNode*p){\\n        if(!p) return;\\n        //only store the left most element\\n        if(mp.find(i) == mp.end()) mp[i]=p->val;\\n        check(i+1,p->left);\\n        check(i+1,p->right)}\\n    int findBottomLeftValue(TreeNode* root) {\\n       check(0,root);\\n       return mp[mp.size()-1];\\n    }\\n};\\n```\\n\\nif liked please upvote :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* save the left most number at evey height as you go down the tree\\nand return the last saved number in hash\\n*/\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    void check(int i, TreeNode*p){\\n        if(!p) return;\\n        //only store the left most element\\n        if(mp.find(i) == mp.end()) mp[i]=p->val;\\n        check(i+1,p->left);\\n        check(i+1,p->right)}\\n    int findBottomLeftValue(TreeNode* root) {\\n       check(0,root);\\n       return mp[mp.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333435,
                "title": "java-0-ms-100-faster-recursion",
                "content": "```\\n\\tint max_lvl = 0;int max_val=0;\\n    public int findBottomLeftValue(TreeNode root){\\n        find(root,1);\\n        return max_val;\\n    }\\n    public void find(TreeNode root , int depth){\\n        if(root ==null){return;}\\n        find(root.left,depth+1);\\n        if(depth>max_lvl){\\n            max_lvl = depth;\\n            max_val = root.val;\\n        }\\n        find(root.right,depth+1);   \\n    }\\n\\t",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n\\tint max_lvl = 0;int max_val=0;\\n    public int findBottomLeftValue(TreeNode root){\\n        find(root,1);\\n        return max_val;\\n    }\\n    public void find(TreeNode root , int depth){\\n        if(root ==null){return;}\\n        find(root.left,depth+1);\\n        if(depth>max_lvl){\\n            max_lvl = depth;\\n            max_val = root.val;\\n        }\\n        find(root.right,depth+1);   \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2299048,
                "title": "easy-approach",
                "content": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        queue = deque([root])\\n        \\n        while queue:\\n            root = queue.popleft()\\n            \\n            if root.right:\\n                queue.append(root.right)\\n            if root.left:\\n                queue.append(root.left)\\n        return root.val\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0\\n        queue = deque([root])\\n        \\n        while queue:\\n            root = queue.popleft()\\n            \\n            if root.right:\\n                queue.append(root.right)\\n            if root.left:\\n                queue.append(root.left)\\n        return root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291648,
                "title": "bfs-c-solution-level-order-solution-easy-and-simple",
                "content": "```\\nint findBottomLeftValue(TreeNode* root) {\\n\\t\\t if(!root) return 0;\\n\\t\\t int val;\\n\\t\\t queue<TreeNode *> q;\\n\\t\\t q.push(root);\\n\\t\\t while(!q.empty()){\\n\\t\\t    int n = q.size();\\n            int cnt=0;\\n\\t\\t    for(int i=0;i<n;i++){\\n\\t\\t        TreeNode *node = q.front(); q.pop();\\n                if(cnt==0) val=node->val;\\n\\t\\t        if(node->left) q.push(node->left);\\n\\t\\t        if(node->right) q.push(node->right);\\n                cnt++;\\n\\t\\t    }\\n\\t\\t }\\n\\t\\t return val;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nint findBottomLeftValue(TreeNode* root) {\\n\\t\\t if(!root) return 0;\\n\\t\\t int val;\\n\\t\\t queue<TreeNode *> q;\\n\\t\\t q.push(root);\\n\\t\\t while(!q.empty()){\\n\\t\\t    int n = q.size();\\n            int cnt=0;\\n\\t\\t    for(int i=0;i<n;i++){\\n\\t\\t        TreeNode *node = q.front(); q.pop();\\n                if(cnt==0) val=node->val;\\n\\t\\t        if(node->left) q.push(node->left);\\n\\t\\t        if(node->right) q.push(node->right);\\n                cnt++;\\n\\t\\t    }\\n\\t\\t }\\n\\t\\t return val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2278860,
                "title": "find-bottom-left-tree-value",
                "content": "Runtime: 11 ms, faster than 92.92% of C++ online submissions for Find Bottom Left Tree Value.\\n### Memory Usage: 21.7 MB, less than 83.01% of C++ online submissions for Find Bottom Left Tree Value.******\\n```\\nclass Solution {\\npublic:\\n     void solve(TreeNode* root,vector<int> &ans, int level){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(ans.size()==level){\\n            ans.push_back(root->val);\\n        }\\n        solve(root->left,ans,level+1);\\n        solve(root->right,ans,level+1);\\n        \\n        \\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,ans,0);\\n        int n=ans.size();\\n        for(auto i:ans){\\n            cout<<i<<\" \";\\n        }\\n        return ans[n-1];\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void solve(TreeNode* root,vector<int> &ans, int level){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(ans.size()==level){\\n            ans.push_back(root->val);\\n        }\\n        solve(root->left,ans,level+1);\\n        solve(root->right,ans,level+1);\\n        \\n        \\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,ans,0);\\n        int n=ans.size();\\n        for(auto i:ans){\\n            cout<<i<<\" \";\\n        }\\n        return ans[n-1];\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2256252,
                "title": "85-tc-and-76-sc-easy-python-solution-using-dfs",
                "content": "```\\ndef findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n\\tself.max_row = -1\\n\\tself.ans = []\\n\\tdef dfs(node, r, c):\\n\\t\\tif(not node):\\n\\t\\t\\treturn\\n\\t\\tif(r == self.max_row):\\n\\t\\t\\tif(c < self.ans[0]):\\n\\t\\t\\t\\tself.ans = [c, node.val]\\n\\t\\telif(r > self.max_row):\\n\\t\\t\\tself.max_row = r\\n\\t\\t\\tself.ans = [c, node.val]\\n\\t\\tdfs(node.left, r+1, c-1)\\n\\t\\tdfs(node.right, r+1, c+1)\\n\\n\\tdfs(root, 0, 0)\\n\\treturn self.ans[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n\\tself.max_row = -1\\n\\tself.ans = []\\n\\tdef dfs(node, r, c):\\n\\t\\tif(not node):\\n\\t\\t\\treturn\\n\\t\\tif(r == self.max_row):\\n\\t\\t\\tif(c < self.ans[0]):\\n\\t\\t\\t\\tself.ans = [c, node.val]\\n\\t\\telif(r > self.max_row):\\n\\t\\t\\tself.max_row = r\\n\\t\\t\\tself.ans = [c, node.val]\\n\\t\\tdfs(node.left, r+1, c-1)\\n\\t\\tdfs(node.right, r+1, c+1)\\n\\n\\tdfs(root, 0, 0)\\n\\treturn self.ans[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2247243,
                "title": "c-using-bfs-approach",
                "content": "```\\nint findBottomLeftValue(TreeNode* root) {\\n        int res;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode *curr=q.front();\\n                q.pop();\\n                //first element of every level \\n                if(i==0) res=curr->val;\\n                if(curr->left)  q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n        }\\n        //now res will have the value of last left node \\n        return res;\\n    }\\n```\\nIf you like the solution, don\\'t forget to upvote! :) \\u2B06\\uFE0F\\n*Thanks!* \\uD83D\\uDE0A",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint findBottomLeftValue(TreeNode* root) {\\n        int res;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode *curr=q.front();\\n                q.pop();\\n                //first element of every level \\n                if(i==0) res=curr->val;\\n                if(curr->left)  q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n        }\\n        //now res will have the value of last left node \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246903,
                "title": "right-to-left-bfs",
                "content": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        \\n        Queue<TreeNode>queue = new LinkedList<>();\\n        queue.add(root);\\n        int left = root.val;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i<size ; i++){\\n                TreeNode node = queue.poll();\\n                left = node.val;\\n                if(node.right!=null)\\n                    queue.offer(node.right);\\n                if(node.left!=null)\\n                    queue.offer(node.left);\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        \\n        Queue<TreeNode>queue = new LinkedList<>();\\n        queue.add(root);\\n        int left = root.val;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i<size ; i++){\\n                TreeNode node = queue.poll();\\n                left = node.val;\\n                if(node.right!=null)\\n                    queue.offer(node.right);\\n                if(node.left!=null)\\n                    queue.offer(node.left);\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245659,
                "title": "easy-java-solution-using-arraylist-and-recursion",
                "content": "```\\nclass Solution {\\n    int maxlevel=1;\\n    ArrayList<Integer> ans=new ArrayList<>();\\n    public int findBottomLeftValue(TreeNode root) {\\n        find(root,1);\\n        return ans.get(0);\\n        \\n    }\\n    void find(TreeNode root,int level)\\n    {\\n       if(root==null)\\n           return;\\n        find(root.left,level+1);\\n         if(root.left==null && root.right==null)\\n        {\\n            if(level>=maxlevel)\\n        {\\n            if(level==maxlevel)\\n            {\\n                ans.add(root.val);\\n                maxlevel=level;\\n            }\\n                else\\n                {\\n                    if(ans.size()>0)\\n                    ans.set(0,root.val);\\n                    else\\n                        ans.add(root.val);\\n                    maxlevel=level;\\n                }\\n            \\n        }\\n            \\n            return;\\n        }\\n        find(root.right,level+1);\\n        \\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxlevel=1;\\n    ArrayList<Integer> ans=new ArrayList<>();\\n    public int findBottomLeftValue(TreeNode root) {\\n        find(root,1);\\n        return ans.get(0);\\n        \\n    }\\n    void find(TreeNode root,int level)\\n    {\\n       if(root==null)\\n           return;\\n        find(root.left,level+1);\\n         if(root.left==null && root.right==null)\\n        {\\n            if(level>=maxlevel)\\n        {\\n            if(level==maxlevel)\\n            {\\n                ans.add(root.val);\\n                maxlevel=level;\\n            }\\n                else\\n                {\\n                    if(ans.size()>0)\\n                    ans.set(0,root.val);\\n                    else\\n                        ans.add(root.val);\\n                    maxlevel=level;\\n                }\\n            \\n        }\\n            \\n            return;\\n        }\\n        find(root.right,level+1);\\n        \\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231495,
                "title": "python-bfs-top-down-dfs-top-down",
                "content": "BFS Top-Down\\n```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        \\n        if not root:\\n            return \\n        \\n        queue = collections.deque([root])\\n        \\n        while queue:\\n            len_queue = len(queue)\\n            first_value = None\\n            for _ in range(len_queue):\\n                \\n                node = queue.popleft()\\n                \\n                if first_value == None:\\n                    first_value = node.val\\n                    \\n                if node.left:\\n                    queue.append(node.left)\\n                \\n                if node.right:\\n                    queue.append(node.right)\\n                \\n        \\n        return first_value\\n```\\nDFS \\n```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        \\n        \\n        left_most = []\\n        def dfs(node, parent_depth):\\n            \\n            my_depth = parent_depth + 1\\n            \\n            if my_depth > len(left_most):\\n                left_most.append(node.val)\\n            \\n            \\n            if node.left:\\n                dfs(node.left, my_depth)\\n            if node.right:\\n                dfs(node.right, my_depth)\\n\\n        dfs(root, 0)\\n        \\n        return left_most[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        \\n        if not root:\\n            return \\n        \\n        queue = collections.deque([root])\\n        \\n        while queue:\\n            len_queue = len(queue)\\n            first_value = None\\n            for _ in range(len_queue):\\n                \\n                node = queue.popleft()\\n                \\n                if first_value == None:\\n                    first_value = node.val\\n                    \\n                if node.left:\\n                    queue.append(node.left)\\n                \\n                if node.right:\\n                    queue.append(node.right)\\n                \\n        \\n        return first_value\\n```\n```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        \\n        \\n        left_most = []\\n        def dfs(node, parent_depth):\\n            \\n            my_depth = parent_depth + 1\\n            \\n            if my_depth > len(left_most):\\n                left_most.append(node.val)\\n            \\n            \\n            if node.left:\\n                dfs(node.left, my_depth)\\n            if node.right:\\n                dfs(node.right, my_depth)\\n\\n        dfs(root, 0)\\n        \\n        return left_most[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216471,
                "title": "java-12-lines-0ms-with-comments",
                "content": "Please comment any question you have.\\nPlease **Upvote** if you find this helpful!\\n```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        int[] result = {1, root.val}; // The first element is current depth, last is the root.val\\n        search(root, result, 1);\\n        return result[1];\\n    }\\n    \\n    public static void search(TreeNode root, int[] result, int depth) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (depth > result[0]) { // This ensures the last row get the priority\\n            result[0] = depth;\\n            result[1] = root.val;\\n        }\\n        search(root.left, result, depth+1); // We always want the left most answer\\n        search(root.right, result, depth+1); // if not left, right is the left most answer\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        int[] result = {1, root.val}; // The first element is current depth, last is the root.val\\n        search(root, result, 1);\\n        return result[1];\\n    }\\n    \\n    public static void search(TreeNode root, int[] result, int depth) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (depth > result[0]) { // This ensures the last row get the priority\\n            result[0] = depth;\\n            result[1] = root.val;\\n        }\\n        search(root.left, result, depth+1); // We always want the left most answer\\n        search(root.right, result, depth+1); // if not left, right is the left most answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192373,
                "title": "easy-c-level-order",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        queue<TreeNode*>q;\\n        vector<int>v;\\n        q.push(root);\\n        while(q.empty()==false)\\n        {\\n            int count =q.size();\\n            for(int i=0;i<count;i++)\\n            {\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(i==0)\\n                    v.push_back(curr->val);\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        int n=v.size();\\n        return v[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        queue<TreeNode*>q;\\n        vector<int>v;\\n        q.push(root);\\n        while(q.empty()==false)\\n        {\\n            int count =q.size();\\n            for(int i=0;i<count;i++)\\n            {\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(i==0)\\n                    v.push_back(curr->val);\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        int n=v.size();\\n        return v[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181682,
                "title": "bfs-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int valva;\\n   if(root==NULL) return -1;\\n   //to store the adreess of the Node of the tree, we make queue.\\n   queue<TreeNode *> q;\\n   \\n   //push the root in the queue.\\n   q.push(root);\\n   \\n   while(q.empty()!=true){\\n       int count = q.size();\\n       for(int i = 0; i<count; i++){\\n           TreeNode * curr = q.front();\\n           q.pop();\\n           if(i==0){\\n               valva = (curr->val);\\n           }\\n           if(curr->left!=NULL) q.push(curr->left);\\n           if(curr->right!=NULL) q.push(curr->right);\\n       }\\n   }\\n   return valva;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int valva;\\n   if(root==NULL) return -1;\\n   //to store the adreess of the Node of the tree, we make queue.\\n   queue<TreeNode *> q;\\n   \\n   //push the root in the queue.\\n   q.push(root);\\n   \\n   while(q.empty()!=true){\\n       int count = q.size();\\n       for(int i = 0; i<count; i++){\\n           TreeNode * curr = q.front();\\n           q.pop();\\n           if(i==0){\\n               valva = (curr->val);\\n           }\\n           if(curr->left!=NULL) q.push(curr->left);\\n           if(curr->right!=NULL) q.push(curr->right);\\n       }\\n   }\\n   return valva;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174967,
                "title": "c-short-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int mx_h = -1, val = -1;\\n        function <void(TreeNode*, int)> go = [&](TreeNode* root, int h) {\\n            if (root == NULL) return;\\n            if (h > mx_h) {\\n                mx_h = h;\\n                val = root->val;\\n            }\\n            go(root->left, h + 1);\\n            go(root->right, h + 1);\\n            return ;\\n        };\\n        go(root, 0);\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        int mx_h = -1, val = -1;\\n        function <void(TreeNode*, int)> go = [&](TreeNode* root, int h) {\\n            if (root == NULL) return;\\n            if (h > mx_h) {\\n                mx_h = h;\\n                val = root->val;\\n            }\\n            go(root->left, h + 1);\\n            go(root->right, h + 1);\\n            return ;\\n        };\\n        go(root, 0);\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164673,
                "title": "bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);   // push root to queue\\n        TreeNode*left;  // to store left most value at each level\\n        while(!q.empty())\\n        {\\n            int size = q.size();  // size of each level\\n            for(int i = 0; i < size; i++) // loop for each level\\n            {\\n                TreeNode*front = q.front();\\n                \\n                if(i == 0)          // when i is 0 it means that it is the left most node of that level so store it and update it on each level\\n                    left = front;  \\n\\n                q.pop();\\n                if(front->left) q.push(front->left);\\n                if(front->right) q.push(front->right);\\n            }\\n        }\\n        return left->val;  // in end, left variable will have deepest left node \\n    }\\n};\\n```\\n## **upvote if you got it :)**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);   // push root to queue\\n        TreeNode*left;  // to store left most value at each level\\n        while(!q.empty())\\n        {\\n            int size = q.size();  // size of each level\\n            for(int i = 0; i < size; i++) // loop for each level\\n            {\\n                TreeNode*front = q.front();\\n                \\n                if(i == 0)          // when i is 0 it means that it is the left most node of that level so store it and update it on each level\\n                    left = front;  \\n\\n                q.pop();\\n                if(front->left) q.push(front->left);\\n                if(front->right) q.push(front->right);\\n            }\\n        }\\n        return left->val;  // in end, left variable will have deepest left node \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162896,
                "title": "python3-runtime-66ms-47-69-memory-16-2mb-62-20",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # O(n) || O(h) where n is the number of nodes present in the tree and h is the height of the tree\\n#     Runtime: 66ms 47.69% || memory: 16.2mb 62.20%\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return None\\n        \\n        # return self.findBottomLeftValueByBFS(root)\\n    \\n        return self.findBottomLeftValueByDFS(root, 0, root.val, 0)\\n        \\n    def findBottomLeftValueByBFS(self, root):\\n        \\n        queue = [root]\\n        bottomLeftValue = 0\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.pop(0)\\n                bottomLeftValue = node.val\\n                \\n                if node.right:\\n                    queue.append(node.right)\\n                if node.left:\\n                    queue.append(node.left)\\n                    \\n        return bottomLeftValue\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # O(n) || O(h) where n is the number of nodes present in the tree and h is the height of the tree\\n#     Runtime: 66ms 47.69% || memory: 16.2mb 62.20%\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return None\\n        \\n        # return self.findBottomLeftValueByBFS(root)\\n    \\n        return self.findBottomLeftValueByDFS(root, 0, root.val, 0)\\n        \\n    def findBottomLeftValueByBFS(self, root):\\n        \\n        queue = [root]\\n        bottomLeftValue = 0\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.pop(0)\\n                bottomLeftValue = node.val\\n                \\n                if node.right:\\n                    queue.append(node.right)\\n                if node.left:\\n                    queue.append(node.left)\\n                    \\n        return bottomLeftValue\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130733,
                "title": "simple-c-soln-using-level-order-traversal",
                "content": "\\tint findBottomLeftValue(TreeNode* root) {\\n\\t\\t\\tqueue<TreeNode*>q;\\n\\t\\t\\tq.push(root);\\n\\t\\t\\tTreeNode*temp;\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif(temp->right)\\n\\t\\t\\t\\t\\tq.push(temp->right);\\n\\t\\t\\t\\tif(temp->left)\\n\\t\\t\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t}\\n\\t\\t\\treturn temp->val;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "\\tint findBottomLeftValue(TreeNode* root) {\\n\\t\\t\\tqueue<TreeNode*>q;\\n\\t\\t\\tq.push(root);\\n\\t\\t\\tTreeNode*temp;\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif(temp->right)\\n\\t\\t\\t\\t\\tq.push(temp->right);\\n\\t\\t\\t\\tif(temp->left)\\n\\t\\t\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t}\\n\\t\\t\\treturn temp->val;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2124457,
                "title": "beginner-friendly-soln-o-n-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    int ans;\\n    int printlevel=-1;\\n    public int findBottomLeftValue(TreeNode root) {\\n        preOrder(root , 0);\\n        return ans;\\n    }\\n    void preOrder(TreeNode root , int level){\\n        if(root==null)return ;\\n        if(level > printlevel){\\n            ans=root.val;\\n            printlevel=level;\\n        }\\n        preOrder(root.left,level+1);\\n        preOrder(root.right,level+1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int ans;\\n    int printlevel=-1;\\n    public int findBottomLeftValue(TreeNode root) {\\n        preOrder(root , 0);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2106400,
                "title": "java-solution-very-easy-bfs-traversal",
                "content": "```\\nclass Solution {\\n\\n    public int findBottomLeftValue(TreeNode root) {\\n        if (root.left == null && root.right == null) return root.val;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int count = q.size();\\n            for (int i = 0; i < count; i++) {\\n                TreeNode curr = q.poll();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n            }\\n            res = q.peek() == null ? res : q.peek().val;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int findBottomLeftValue(TreeNode root) {\\n        if (root.left == null && root.right == null) return root.val;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int count = q.size();\\n            for (int i = 0; i < count; i++) {\\n                TreeNode curr = q.poll();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n            }\\n            res = q.peek() == null ? res : q.peek().val;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089616,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using BFS***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(max. width of binary tree)***\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        queue<TreeNode*> q;\\n        \\n        q.push(root);\\n        \\n        int ans = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            for(int k = 0; k < size; k++)\\n            {\\n                TreeNode* curr = q.front();\\n                \\n                q.pop();\\n                \\n                if(k == 0)\\n                {\\n                    ans = curr -> val;\\n                }\\n                \\n                if(curr -> left)\\n                {\\n                    q.push(curr -> left);\\n                }\\n                \\n                if(curr -> right)\\n                {\\n                    q.push(curr -> right);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        queue<TreeNode*> q;\\n        \\n        q.push(root);\\n        \\n        int ans = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            for(int k = 0; k < size; k++)\\n            {\\n                TreeNode* curr = q.front();\\n                \\n                q.pop();\\n                \\n                if(k == 0)\\n                {\\n                    ans = curr -> val;\\n                }\\n                \\n                if(curr -> left)\\n                {\\n                    q.push(curr -> left);\\n                }\\n                \\n                if(curr -> right)\\n                {\\n                    q.push(curr -> right);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076713,
                "title": "c-find-bottom-left-tree-value",
                "content": "```\\n/**\\n *Definition for a binary tree node.\\n *struct TreeNode {\\n *    int val;\\n *    TreeNode * left;\\n *    TreeNode * right;\\n *    TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n *};\\n */\\nclass Solution\\n{\\n    public:\\n        int findBottomLeftValue(TreeNode *root)\\n        {\\n            queue<TreeNode*> q;\\n            vector<vector < int>> result;\\n            \\n            q.push(root);\\n            while (!q.empty())\\n            {\\n                vector<int> temp;\\n                int k = q.size();\\n                for (int i = 0; i < k; i++)\\n                {\\n                    temp.push_back(q.front()->val);\\n                    if (q.front()->left != NULL)\\n                        q.push(q.front()->left);\\n                    if (q.front()->right != NULL)\\n                        q.push(q.front()->right);\\n                    q.pop();\\n                }\\n\\n                result.push_back(temp);\\n            }\\n\\n            return result[result.size() - 1][0];\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n *Definition for a binary tree node.\\n *struct TreeNode {\\n *    int val;\\n *    TreeNode * left;\\n *    TreeNode * right;\\n *    TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n *};\\n */\\nclass Solution\\n{\\n    public:\\n        int findBottomLeftValue(TreeNode *root)\\n        {\\n            queue<TreeNode*> q;\\n            vector<vector < int>> result;\\n            \\n            q.push(root);\\n            while (!q.empty())\\n            {\\n                vector<int> temp;\\n                int k = q.size();\\n                for (int i = 0; i < k; i++)\\n                {\\n                    temp.push_back(q.front()->val);\\n                    if (q.front()->left != NULL)\\n                        q.push(q.front()->left);\\n                    if (q.front()->right != NULL)\\n                        q.push(q.front()->right);\\n                    q.pop();\\n                }\\n\\n                result.push_back(temp);\\n            }\\n\\n            return result[result.size() - 1][0];\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047877,
                "title": "easy-java-solution-using-left-view-logic",
                "content": "\\tpublic int findBottomLeftValue(TreeNode root) {\\n        \\n        Queue<TreeNode> queue = new LinkedList<>() ;\\n        queue.add(root) ;\\n        \\n        int res = 0 ;\\n        while(!queue.isEmpty()){\\n            int size = queue.size() ;\\n            \\n            for(int i=0 ; i<size ; i++){\\n                TreeNode rn = queue.remove() ;\\n                if(i == 0)\\n                    res = rn.val ;  // this will be updated fro each lvl and last it will store the first node val of last lvl\\n                \\n                if(rn.left!=null)\\n                    queue.add(rn.left) ;\\n                \\n                if(rn.right!=null)\\n                    queue.add(rn.right) ;\\n                \\n            }\\n        }\\n        \\n        return res ;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\tpublic int findBottomLeftValue(TreeNode root) {\\n        \\n        Queue<TreeNode> queue = new LinkedList<>() ;\\n        queue.add(root) ;\\n        \\n        int res = 0 ;\\n        while(!queue.isEmpty()){\\n            int size = queue.size() ;\\n            \\n            for(int i=0 ; i<size ; i++){\\n                TreeNode rn = queue.remove() ;\\n                if(i == 0)\\n                    res = rn.val ;  // this will be updated fro each lvl and last it will store the first node val of last lvl\\n                \\n                if(rn.left!=null)\\n                    queue.add(rn.left) ;\\n                \\n                if(rn.right!=null)\\n                    queue.add(rn.right) ;\\n                \\n            }\\n        }\\n        \\n        return res ;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2035070,
                "title": "why-is-this-a-medium-problem",
                "content": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        queue = [root]\\n        last = 0\\n        \\n        while len(queue):\\n            node = queue.pop(0)\\n            last = node.val\\n            \\n            if node.right:\\n                queue.append(node.right)\\n            if node.left:\\n                queue.append(node.left)\\n                \\n                \\n        return last\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        queue = [root]\\n        last = 0\\n        \\n        while len(queue):\\n            node = queue.pop(0)\\n            last = node.val\\n            \\n            if node.right:\\n                queue.append(node.right)\\n            if node.left:\\n                queue.append(node.left)\\n                \\n                \\n        return last\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032708,
                "title": "c-level-order-traversing-of-last-level",
                "content": "```\\nint findheight(TreeNode*root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        return max(findheight(root->right),findheight(root->left))+1;\\n    }\\n\\t\\n    void findleveltraversal(vector<int>&temp,int i,int h,TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(i==h)\\n        {\\n            temp.push_back(root->val);\\n            return;\\n        }\\n        findleveltraversal(temp,i+1,h,root->left);\\n        findleveltraversal(temp,i+1,h,root->right);\\n    }\\n\\t\\n    int findBottomLeftValue(TreeNode* root) {\\n        int h=findheight(root);\\n        vector<int>temp;\\n        findleveltraversal(temp,1,h,root);\\n        return temp[0];\\n    }\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nint findheight(TreeNode*root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        return max(findheight(root->right),findheight(root->left))+1;\\n    }\\n\\t\\n    void findleveltraversal(vector<int>&temp,int i,int h,TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(i==h)\\n        {\\n            temp.push_back(root->val);\\n            return;\\n        }\\n        findleveltraversal(temp,i+1,h,root->left);\\n        findleveltraversal(temp,i+1,h,root->right);\\n    }\\n\\t\\n    int findBottomLeftValue(TreeNode* root) {\\n        int h=findheight(root);\\n        vector<int>temp;\\n        findleveltraversal(temp,1,h,root);\\n        return temp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2005329,
                "title": "find-bottom-left-tree-value-using-bfs-dfs-recursive-approach",
                "content": "**I am first calculating the no. of levels in the binary tree to make an vector<vector<int>> of that length such that with that many rows ( representing levels)**\\n*here I am traversing using BFS approach in binary trees from right to left so that our last level array list will contain that element which is left most to the bottom of our tree at the end . And finally we will return the last element of the last row of our vector<vector> which is our desired answer*\\n```\\nclass Solution {\\npublic:\\n    void BFS(TreeNode* root,vector<vector<int>>& q,int level){\\n        if(root==nullptr) return;\\n        q[level].push_back(root->val);\\n        BFS(root->right,q,level+1);\\n        BFS(root->left,q,level+1);\\n    }\\n    int findLevel(TreeNode* root,int level){\\n        if(!root) return level;\\n        return max(findLevel(root->right,level+1),findLevel(root->left,level+1));\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        if(root==nullptr) return NULL;\\n        int level = findLevel(root,0);\\n        //appliying BSF\\n        vector<vector<int>> q(level);\\n        BFS(root,q,0);\\n        int n = q.size()-1;\\n        int m = q[n].size()-1;\\n        return q[n][m];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void BFS(TreeNode* root,vector<vector<int>>& q,int level){\\n        if(root==nullptr) return;\\n        q[level].push_back(root->val);\\n        BFS(root->right,q,level+1);\\n        BFS(root->left,q,level+1);\\n    }\\n    int findLevel(TreeNode* root,int level){\\n        if(!root) return level;\\n        return max(findLevel(root->right,level+1),findLevel(root->left,level+1));\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        if(root==nullptr) return NULL;\\n        int level = findLevel(root,0);\\n        //appliying BSF\\n        vector<vector<int>> q(level);\\n        BFS(root,q,0);\\n        int n = q.size()-1;\\n        int m = q[n].size()-1;\\n        return q[n][m];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999629,
                "title": "java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    \\n    int ans;\\n    int maxLevel;\\n    public int findBottomLeftValue(TreeNode root) {\\n        ans = 0;\\n        maxLevel = -1;\\n        inorder(root, 0);\\n        return ans;\\n    }\\n    \\n    public void inorder(TreeNode root, int level) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left, level + 1);\\n        if (maxLevel < level) {\\n            maxLevel = level;\\n            ans = root.val;\\n        }\\n        inorder(root.right, level + 1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    \\n    int ans;\\n    int maxLevel;\\n    public int findBottomLeftValue(TreeNode root) {\\n        ans = 0;\\n        maxLevel = -1;\\n        inorder(root, 0);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1931880,
                "title": "c-98-faster-bfs-easy-to-understand",
                "content": "**Approach:** \\n                     **1.** I hope you are familiare with BFS thats mean level order traversing.\\n\\t\\t\\t\\t\\t **2.** We will traverse the entire tree level by level and maintain a variable which will store the first value of level and by after each level we will update that value by first element.\\n\\t\\t\\t\\t\\t **3.** And after iteration of entire tree we will return the value of variable which were mainting from the start.\\n```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        queue<TreeNode* > q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            ans=q.front()->val;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                if(temp->left!=NULL) q.push(temp->left);\\n                if(temp->right!=NULL) q.push(temp->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you found helpful !!**\\n**Please upvote it !!**\\n\\n**If you have any doubt regarding this explation please comment down. I would be happy to help you.**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        queue<TreeNode* > q;\\n        q.push(root);\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            ans=q.front()->val;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                if(temp->left!=NULL) q.push(temp->left);\\n                if(temp->right!=NULL) q.push(temp->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900912,
                "title": "easy-solution-faster-than-others-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        //BFS traversal\\n        int left_most;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int count=q.size();\\n            for(int i=0;i<count;i++){\\n                TreeNode *curr=q.front();\\n                if(i==0)\\n                    left_most=q.front()->val;\\n                q.pop();\\n                if(curr->left!=NULL)\\n                    q.push(curr->left);\\n                if(curr->right!=NULL)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return left_most;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        //BFS traversal\\n        int left_most;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int count=q.size();\\n            for(int i=0;i<count;i++){\\n                TreeNode *curr=q.front();\\n                if(i==0)\\n                    left_most=q.front()->val;\\n                q.pop();\\n                if(curr->left!=NULL)\\n                    q.push(curr->left);\\n                if(curr->right!=NULL)\\n                    q.push(curr->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1888976,
                "title": "using-depth-limit-approach-c",
                "content": "We can find the left most node using depth limit search \\nFirst we find the height of the tree which will also be the last level of the tree\\nwe also pass a ans treeNode which will represent our last leftmost node\\n\\nif the ans is null and level == last \\nthen assign the ans == root (which will be the left most node)\\nassume the last level have more than 1 children the if just simply added an if condition to check is ans is null or not it its not null that means we already stored the left most node\\nand we simply return from it.\\n```\\nclass Solution {\\n    int height(TreeNode *root)\\n    {\\n        if(!root) return 0;\\n        int lh = height(root->left);   \\n        int rh = height(root->right);\\n        return max(lh, rh)+1;\\n    }\\n    void helper(TreeNode *root, TreeNode *&ans, int depth)\\n    {\\n        if(!root || depth<1 ) return;\\n\\tif(depth == 1 && !ans)\\n        {\\n            if(!ans)\\n                ans = root;\\n            return;\\n        }\\n        helper(root->left, ans, depth-1);\\n        helper(root->right, ans, depth-1);\\n    }\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        TreeNode *ans = NULL;\\n        int h = height(root);\\n        helper(root, ans, h);\\n        return ans->val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int height(TreeNode *root)\\n    {\\n        if(!root) return 0;\\n        int lh = height(root->left);   \\n        int rh = height(root->right);\\n        return max(lh, rh)+1;\\n    }\\n    void helper(TreeNode *root, TreeNode *&ans, int depth)\\n    {\\n        if(!root || depth<1 ) return;\\n\\tif(depth == 1 && !ans)\\n        {\\n            if(!ans)\\n                ans = root;\\n            return;\\n        }\\n        helper(root->left, ans, depth-1);\\n        helper(root->right, ans, depth-1);\\n    }\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        TreeNode *ans = NULL;\\n        int h = height(root);\\n        helper(root, ans, h);\\n        return ans->val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873184,
                "title": "c-clean-code-using-level-order-traversal",
                "content": "```\\n\\n class Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        \\n        vector<int> currLevel;\\n        \\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty()){\\n            \\n            root = q.front();  q.pop();\\n            \\n            if(!root){\\n                \\n                if(!q.empty())\\n                    q.push(nullptr);\\n                \\n                currLevel.clear();\\n                \\n                continue;\\n            }\\n            \\n            currLevel.push_back(root -> val);\\n            \\n            if(root -> left)\\n                q.push(root -> left);\\n            \\n            if(root -> right)\\n                q.push(root -> right);\\n        }\\n        \\n        return currLevel[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n class Solution {\\npublic:\\n    int findBottomLeftValue(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        \\n        vector<int> currLevel;\\n        \\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty()){\\n            \\n            root = q.front();  q.pop();\\n            \\n            if(!root){\\n                \\n                if(!q.empty())\\n                    q.push(nullptr);\\n                \\n                currLevel.clear();\\n                \\n                continue;\\n            }\\n            \\n            currLevel.push_back(root -> val);\\n            \\n            if(root -> left)\\n                q.push(root -> left);\\n            \\n            if(root -> right)\\n                q.push(root -> right);\\n        }\\n        \\n        return currLevel[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868126,
                "title": "easy-c-level-order-traversal-bfs",
                "content": "```\\nint findBottomLeftValue(TreeNode* root) {\\n    if(root==nullptr) return {};\\n    queue<TreeNode*> nodes;\\n    int level;\\n    int n;\\n    nodes.push(root);\\n    level = root->val;\\n    while(!nodes.empty()){\\n        n = nodes.size();\\n        while(n){\\n            --n;\\n            if(nodes.front()->right)\\n                level = nodes.front()->right->val,nodes.push(nodes.front()->right);\\n            if(nodes.front()->left)\\n                level = nodes.front()->left->val,nodes.push(nodes.front()->left);\\n            nodes.pop();\\n        }\\n    }\\n    return level;    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nint findBottomLeftValue(TreeNode* root) {\\n    if(root==nullptr) return {};\\n    queue<TreeNode*> nodes;\\n    int level;\\n    int n;\\n    nodes.push(root);\\n    level = root->val;\\n    while(!nodes.empty()){\\n        n = nodes.size();\\n        while(n){\\n            --n;\\n            if(nodes.front()->right)\\n                level = nodes.front()->right->val,nodes.push(nodes.front()->right);\\n            if(nodes.front()->left)\\n                level = nodes.front()->left->val,nodes.push(nodes.front()->left);\\n            nodes.pop();\\n        }\\n    }\\n    return level;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862251,
                "title": "java-100-faster",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxHeight=0,ans =0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        if(root==null) return 0;\\n        if(root.left==null && root.right==null) return root.val;\\n        dfs(root,0);\\n        return ans;\\n    }\\n     public void dfs(TreeNode root,int currHeight) {\\n        if(root == null) return;\\n         dfs(root.left,currHeight+1);\\n         dfs(root.right,currHeight+1);\\n        if(maxHeight < currHeight){\\n            maxHeight = currHeight;\\n            ans=root.val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxHeight=0,ans =0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        if(root==null) return 0;\\n        if(root.left==null && root.right==null) return root.val;\\n        dfs(root,0);\\n        return ans;\\n    }\\n     public void dfs(TreeNode root,int currHeight) {\\n        if(root == null) return;\\n         dfs(root.left,currHeight+1);\\n         dfs(root.right,currHeight+1);\\n        if(maxHeight < currHeight){\\n            maxHeight = currHeight;\\n            ans=root.val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565752,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1989535,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1572193,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 2044598,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1928791,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 2048231,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 2043350,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1976380,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1947494,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1919753,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1565752,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1989535,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1572193,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 2044598,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1928791,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 2048231,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 2043350,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1976380,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1947494,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            },
            {
                "id": 1919753,
                "content": [
                    {
                        "username": "shellcodeloaded",
                        "content": "Why answer for [1,null,1]  is 1?\\n\\nThe tree is:\\n\\n    1\\n      \\\\\\n       1\\n\\nThe last row has no left element.  The question said return the left most element in the last row.  The root node is not in the last row."
                    },
                    {
                        "username": "Peet_code",
                        "content": "I think the question statement should be like this \n ``` return the deepest left leaf node in a binary tree ``` \nthen it will be more clear"
                    },
                    {
                        "username": "subhamoysarkar526",
                        "content": "it\\'s said from left , the first leaf node(last row, ) not only left nodes, therefore it\\'s answer is 1, i.e right leaf node"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem should definitely be an easy problem."
                    },
                    {
                        "username": "sssss29",
                        "content": "[0,null,-1]\\nAnswer : -1\\n\\nQuestion asked about leftmost node .\\nThis tree has root 0 , left Null and right -1 value. So why answer expected -1 not root node or None"
                    },
                    {
                        "username": "chenmst",
                        "content": "because the leftmost is not node.left, just the leftmost one on the deepest layer. So in your case, the deepest layer is -1, so the leftmost one is -1."
                    },
                    {
                        "username": "fenster",
                        "content": "I know it\\'s long overdue, but just to breathe some fresh air into the discussion tab:\\nthink about it as a leftmost element at the maximum depth in the tree. So that\\'s why!"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "Problem statement simplified  :- \"Return the first node in the last level\";"
                    },
                    {
                        "username": "Prianshu18",
                        "content": "Yes Exactly!\\n"
                    },
                    {
                        "username": "akash_789",
                        "content": "I think the question should be return value of deepest node instead of leftmost node."
                    },
                    {
                        "username": "Prianshu18",
                        "content": "i think not, because imagine a tree with the last row filled up completely, in that case the leftmost node will be our answer since all the nodes are at the same depth in the last row"
                    },
                    {
                        "username": "SinghArpt",
                        "content": "The prompt of the question is not sentenced well. By leftmost it means the deepest node. If it would have been leftmost then the answer for the test case [0, None, -1] would have been 0 but the expected answer is -1. So just return the deepest node and save yourself from some mental frustration."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\\n\\nDo a bfs traversal, but push the right child first then the left, this way, at the end, only the leftmost node will remain in the queue"
                    },
                    {
                        "username": "pyush98",
                        "content": "The first non null value from the last level of the tree."
                    },
                    {
                        "username": "Ujjawal_gu1",
                        "content": "Why is it called return leftmost value in last row of tree, when actually you just have to return first value in level order traversal of the deepest level, it has nothing to do with whether the answer node is left child or right like... Like in TestCase [0,Null,1] answer is 1 which is right child. ?"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "I dont understand the question and its testcases are quite different "
                    }
                ]
            }
        ]
    }
]