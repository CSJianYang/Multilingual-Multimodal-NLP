[
    {
        "title": "Minimum Additions to Make Valid String",
        "question_content": "Given a string word to which you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times, return the minimum number of letters that must be inserted so that word becomes valid.\nA string is called valid if it can be formed by concatenating the string \"abc\" several times.\n&nbsp;\nExample 1:\n\nInput: word = \"b\"\nOutput: 2\nExplanation: Insert the letter \"a\" right before \"b\", and the letter \"c\" right next to \"a\" to obtain the valid string \"abc\".\n\nExample 2:\n\nInput: word = \"aaa\"\nOutput: 6\nExplanation: Insert letters \"b\" and \"c\" next to each \"a\" to obtain the valid string \"abcabcabc\".\n\nExample 3:\n\nInput: word = \"abc\"\nOutput: 0\nExplanation: word is already valid. No modifications are needed. \n\n&nbsp;\nConstraints:\n\n\t1 <= word.length <= 50\n\tword consists of letters \"a\", \"b\"&nbsp;and \"c\" only.&nbsp;",
        "solutions": [
            {
                "id": 3421831,
                "title": "java-c-python-easy-and-concise-with-explanation",
                "content": "# Why somebody downvoted me without a word?\\n# Please Upvote \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n<br>\\n\\n# **Intuition**\\nSame problem:\\nFind out the minimum `k` where `word` is subsequence of `\"abc\"` repeated `k` times.\\n\\nSince `\"abc\"` is increasing,\\nso we can split the original `work` into `k` strict increasing subarray.\\n<br>\\n\\n# **Explanation**\\nInitial the `prev` as a big char,\\nthen iterate each char `c` in `word`.\\nIf `c <= prev`, it means we need to start a new `\"abc\"`,\\nthen we increase `k++`.\\n\\nFinally we find `k`, `word` is subsequence of `\"abc\"` repeated `k` times.\\nWe return `k * 3 - n`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int addMinimum(String word) {\\n        int k = 0, prev = \\'z\\', n = word.length();\\n        for (int i = 0; i < n; ++i) {\\n            k += word.charAt(i) <= prev ? 1 : 0;\\n            prev = word.charAt(i);\\n        }\\n        return k * 3 - n;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int addMinimum(string word) {\\n        int k = 0, prev = \\'z\\';\\n        for (char& c: word) {\\n            k += c <= prev;\\n            prev = c;\\n        }\\n        return k * 3 - word.size();\\n    }\\n```\\n\\n**Python**\\n```py\\n    def addMinimum(self, word: str) -> int:\\n        k, prev = 0, \\'z\\'\\n        for c in word:\\n            k += c <= prev\\n            prev = c\\n        return k * 3 - len(word)\\n```\\n\\n**Python 1-Liner**\\n```py\\n    def addMinimum(self, word: str) -> int:\\n        return 3 + sum(a >= b for a,b in pairwise(word)) * 3 - len(word)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int addMinimum(String word) {\\n        int k = 0, prev = \\'z\\', n = word.length();\\n        for (int i = 0; i < n; ++i) {\\n            k += word.charAt(i) <= prev ? 1 : 0;\\n            prev = word.charAt(i);\\n        }\\n        return k * 3 - n;\\n    }\\n```\n```cpp\\n    int addMinimum(string word) {\\n        int k = 0, prev = \\'z\\';\\n        for (char& c: word) {\\n            k += c <= prev;\\n            prev = c;\\n        }\\n        return k * 3 - word.size();\\n    }\\n```\n```py\\n    def addMinimum(self, word: str) -> int:\\n        k, prev = 0, \\'z\\'\\n        for c in word:\\n            k += c <= prev\\n            prev = c\\n        return k * 3 - len(word)\\n```\n```py\\n    def addMinimum(self, word: str) -> int:\\n        return 3 + sum(a >= b for a,b in pairwise(word)) * 3 - len(word)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3421709,
                "title": "c-java-python-o-n-greedy-solution-easy-to-understand",
                "content": "**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int n = word.size(), i = 0, res = 0;\\n        \\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;i++;\\n            }\\n             \\n            if(i < n and word[i] == \\'b\\') {\\n                count++;i++;\\n            }\\n            \\n            if(i < n and word[i] == \\'c\\') {\\n                count++;i++;\\n            }\\n            \\n            res += 3 - count;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Java Code**\\n```\\npublic class Solution {\\n    public int addMinimum(String word) {\\n        int n = word.length(), i = 0, res = 0;\\n        \\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word.charAt(i) == \\'a\\') {\\n                count++;\\n                i++;\\n            }\\n             \\n            if(i < n && word.charAt(i) == \\'b\\') {\\n                count++;\\n                i++;\\n            }\\n            \\n            if(i < n && word.charAt(i) == \\'c\\') {\\n                count++;\\n                i++;\\n            }\\n            \\n            res += 3 - count;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Python Code**\\n\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n = len(word)\\n        i = 0\\n        res = 0\\n        \\n        while i < n:\\n            count = 0\\n            \\n            if word[i] == \\'a\\':\\n                count += 1\\n                i += 1\\n             \\n            if i < n and word[i] == \\'b\\':\\n                count += 1\\n                i += 1\\n            \\n            if i < n and word[i] == \\'c\\':\\n                count += 1\\n                i += 1\\n            \\n            res += 3 - count\\n        \\n        return res\\n```\\n\\n**Thanks. Please do upvote**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int n = word.size(), i = 0, res = 0;\\n        \\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;i++;\\n            }\\n             \\n            if(i < n and word[i] == \\'b\\') {\\n                count++;i++;\\n            }\\n            \\n            if(i < n and word[i] == \\'c\\') {\\n                count++;i++;\\n            }\\n            \\n            res += 3 - count;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int addMinimum(String word) {\\n        int n = word.length(), i = 0, res = 0;\\n        \\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word.charAt(i) == \\'a\\') {\\n                count++;\\n                i++;\\n            }\\n             \\n            if(i < n && word.charAt(i) == \\'b\\') {\\n                count++;\\n                i++;\\n            }\\n            \\n            if(i < n && word.charAt(i) == \\'c\\') {\\n                count++;\\n                i++;\\n            }\\n            \\n            res += 3 - count;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n = len(word)\\n        i = 0\\n        res = 0\\n        \\n        while i < n:\\n            count = 0\\n            \\n            if word[i] == \\'a\\':\\n                count += 1\\n                i += 1\\n             \\n            if i < n and word[i] == \\'b\\':\\n                count += 1\\n                i += 1\\n            \\n            if i < n and word[i] == \\'c\\':\\n                count += 1\\n                i += 1\\n            \\n            res += 3 - count\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421894,
                "title": "short-intuitive-code-no-long-conditions-time-o-n",
                "content": "# Intuition\\nTake maximum number of characters present in increasing order (`a < b < c`)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string& s) {\\n        int n = s.size(), i = 0, result = 0;\\n        while (i < n) {\\n            string s2 = s.substr(i, 2);\\n            if (s.substr(i, 3) == \"abc\") {\\n                i += 3;\\n            } else if (s2 == \"ab\" || s2 == \"ac\" || s2 == \"bc\") {\\n                i += 2;\\n                result += 1;\\n            } else {\\n                i += 1;\\n                result += 2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string& s) {\\n        int n = s.size(), i = 0, result = 0;\\n        while (i < n) {\\n            string s2 = s.substr(i, 2);\\n            if (s.substr(i, 3) == \"abc\") {\\n                i += 3;\\n            } else if (s2 == \"ab\" || s2 == \"ac\" || s2 == \"bc\") {\\n                i += 2;\\n                result += 1;\\n            } else {\\n                i += 1;\\n                result += 2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421701,
                "title": "clean-solution-easy-to-understand",
                "content": "T.C: O(n)\\nS.C: O(1)\\n**Python3 code**\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        it = 0\\n        result = 0\\n        while it < len(word) :\\n            if word[it:it+3] == \"abc\":\\n                it += 3  \\n            elif word[it:it+2] in [\"ab\",\"ac\",\"bc\"]:\\n                result += 1\\n                it += 2\\n            else:\\n                result += 2\\n                it += 1\\n        return result\\n                    \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "T.C: O(n)\\nS.C: O(1)\\n**Python3 code**\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        it = 0\\n        result = 0\\n        while it < len(word) :\\n            if word[it:it+3] == \"abc\":\\n                it += 3  \\n            elif word[it:it+2] in [\"ab\",\"ac\",\"bc\"]:\\n                result += 1\\n                it += 2\\n            else:\\n                result += 2\\n                it += 1\\n        return result\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 3422183,
                "title": "concise-easy-to-understand-c-intutive-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used a variable current which will represent the current character we need to form the sequence \"abc\".\\nThere are two possible cases :\\n1. We will get the required current character at a[i] -> In this one, we will increment the index i.\\n2. If the current character required is not a[i] -> In this case, we will increment our ans (imagining that we have added that current character hypothetically) \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string a) {\\n        int n = a.size();\\n        int current = 0,i=0,ans=0;\\n        // For current=  0 ->\\'a\\', 1 -> \\'b\\', 2-> \\'c\\' \\n        while(i<n || current!=0)\\n        {\\n            if(i<n && a[i]-\\'a\\' == cur)\\n            {\\n                current++;\\n                i++;\\n            }\\n            else\\n            {\\n                current++;\\n                ans++;\\n            }\\n            current%=3;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string a) {\\n        int n = a.size();\\n        int current = 0,i=0,ans=0;\\n        // For current=  0 ->\\'a\\', 1 -> \\'b\\', 2-> \\'c\\' \\n        while(i<n || current!=0)\\n        {\\n            if(i<n && a[i]-\\'a\\' == cur)\\n            {\\n                current++;\\n                i++;\\n            }\\n            else\\n            {\\n                current++;\\n                ans++;\\n            }\\n            current%=3;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421989,
                "title": "circular-matching-constant-space",
                "content": "We will do Circular Matching with **abc**, using which we will get to know the absent characters.\\n# Explanation:\\n+ We will iterate and match with `curr` :\\n    + If matched, we will move forward\\n    + else, we will keep moving the `curr` only until it matches with current character.\\n> Number of times `curr` mismatched is our answer\\n   \\n\\n# C++    \\n\\tint addMinimum(string A, char curr = \\'a\\', int res = 0) {\\n        for(int i = 0;i < A.size();){\\n            if(A[i] == curr) ++i;\\n            else ++res;\\n\\t\\t\\tcurr = \\'a\\' + ((curr - \\'a\\') + 1) % 3;\\n\\t\\t}\\n        return res + (curr == \\'a\\' ? 0 : \\'c\\' - curr + 1);\\n    }\\n# Java\\n    public int addMinimum(String A) {\\n        char curr = \\'a\\';\\n        int res = 0;\\n        for(int i = 0;i < A.length();){\\n            if(A.charAt(i) == curr) ++i;\\n            else ++res;\\n\\t\\t\\tcurr = (char)(\\'a\\' + ((curr - \\'a\\') + 1) % 3);\\n\\t\\t}\\n        return res + (curr == \\'a\\' ? 0 : \\'c\\' - curr + 1);\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "We will do Circular Matching with **abc**, using which we will get to know the absent characters.\\n# Explanation:\\n+ We will iterate and match with `curr` :\\n    + If matched, we will move forward\\n    + else, we will keep moving the `curr` only until it matches with current character.\\n> Number of times `curr` mismatched is our answer\\n   \\n\\n# C++    \\n\\tint addMinimum(string A, char curr = \\'a\\', int res = 0) {\\n        for(int i = 0;i < A.size();){\\n            if(A[i] == curr) ++i;\\n            else ++res;\\n\\t\\t\\tcurr = \\'a\\' + ((curr - \\'a\\') + 1) % 3;\\n\\t\\t}\\n        return res + (curr == \\'a\\' ? 0 : \\'c\\' - curr + 1);\\n    }\\n# Java\\n    public int addMinimum(String A) {\\n        char curr = \\'a\\';\\n        int res = 0;\\n        for(int i = 0;i < A.length();){\\n            if(A.charAt(i) == curr) ++i;\\n            else ++res;\\n\\t\\t\\tcurr = (char)(\\'a\\' + ((curr - \\'a\\') + 1) % 3);\\n\\t\\t}\\n        return res + (curr == \\'a\\' ? 0 : \\'c\\' - curr + 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3421967,
                "title": "linear-scan",
                "content": "# Intuition\\nOnly add \"wanted\" character.\\n\\n# Approach\\nLinear scan\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char want = \\'a\\';\\n        int r = 0;\\n        for (int i = 0; i < word.length() || want != \\'a\\'; ) {\\n            if (i < word.length() && word[i] == want) {\\n                ++i;\\n            } else {\\n                ++r;\\n            }\\n            if (++want == \\'d\\') {\\n                want = \\'a\\';\\n            }\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char want = \\'a\\';\\n        int r = 0;\\n        for (int i = 0; i < word.length() || want != \\'a\\'; ) {\\n            if (i < word.length() && word[i] == want) {\\n                ++i;\\n            } else {\\n                ++r;\\n            }\\n            if (++want == \\'d\\') {\\n                want = \\'a\\';\\n            }\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421694,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n  \\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int val=0,size=word.length();\\n        if(word.charAt(0)==\\'b\\')\\n        {\\n            val+=1;\\n        }\\n        if(word.charAt(0)==\\'c\\')\\n        {\\n            val+=2;\\n        }\\n        if(word.charAt(size-1)==\\'b\\')\\n        {\\n            val+=1;\\n        }\\n        if(word.charAt(size-1)==\\'a\\')\\n        {\\n            val+=2;\\n        }\\n        for(int i=0;i<size-1;i++)\\n        {\\n            char c=word.charAt(i);\\n            char d=word.charAt(i+1);\\n            if((c==\\'a\\' && d==\\'a\\') || (c==\\'b\\' && d==\\'b\\') || (c==\\'c\\' && d==\\'c\\'))\\n            {\\n                val+=2;\\n            }\\n            else if((c==\\'a\\' && d==\\'c\\') || (c==\\'b\\' && d==\\'a\\') || (c==\\'c\\' && d==\\'b\\'))\\n            {\\n                val+=1;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int val=0,size=word.length();\\n        if(word.charAt(0)==\\'b\\')\\n        {\\n            val+=1;\\n        }\\n        if(word.charAt(0)==\\'c\\')\\n        {\\n            val+=2;\\n        }\\n        if(word.charAt(size-1)==\\'b\\')\\n        {\\n            val+=1;\\n        }\\n        if(word.charAt(size-1)==\\'a\\')\\n        {\\n            val+=2;\\n        }\\n        for(int i=0;i<size-1;i++)\\n        {\\n            char c=word.charAt(i);\\n            char d=word.charAt(i+1);\\n            if((c==\\'a\\' && d==\\'a\\') || (c==\\'b\\' && d==\\'b\\') || (c==\\'c\\' && d==\\'c\\'))\\n            {\\n                val+=2;\\n            }\\n            else if((c==\\'a\\' && d==\\'c\\') || (c==\\'b\\' && d==\\'a\\') || (c==\\'c\\' && d==\\'b\\'))\\n            {\\n                val+=1;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422479,
                "title": "c-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count = 0;\\n         for(int i = 0; i < word.size(); i++) {\\n             if(i == 0) {\\n                 if(word[i] == \\'b\\') count++;\\n                 else if(word[i] == \\'c\\') count += 2;\\n             }\\n             if(i == word.size() - 1) {\\n                 if(word[i] == \\'a\\') count += 2;\\n                 else if(word[i] == \\'b\\') count++;\\n             }\\n             else {\\n                 if(word[i] == word[i + 1]) count += 2;\\n                 else if(word[i] == \\'a\\' && word[i + 1] == \\'c\\') count++;\\n                 else if(word[i] == \\'a\\' && word[i + 1] == \\'c\\') count++;\\n                 else if(word[i] == \\'b\\' && word[i + 1] == \\'a\\') count++;\\n                 else if(word[i] == \\'c\\' && word[i + 1] == \\'b\\') count++;\\n             }\\n         }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count = 0;\\n         for(int i = 0; i < word.size(); i++) {\\n             if(i == 0) {\\n                 if(word[i] == \\'b\\') count++;\\n                 else if(word[i] == \\'c\\') count += 2;\\n             }\\n             if(i == word.size() - 1) {\\n                 if(word[i] == \\'a\\') count += 2;\\n                 else if(word[i] == \\'b\\') count++;\\n             }\\n             else {\\n                 if(word[i] == word[i + 1]) count += 2;\\n                 else if(word[i] == \\'a\\' && word[i + 1] == \\'c\\') count++;\\n                 else if(word[i] == \\'a\\' && word[i + 1] == \\'c\\') count++;\\n                 else if(word[i] == \\'b\\' && word[i + 1] == \\'a\\') count++;\\n                 else if(word[i] == \\'c\\' && word[i + 1] == \\'b\\') count++;\\n             }\\n         }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606616,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem requires us to determine the minimum number of letters that need to be inserted into a given string to make it valid. A valid string is defined as a string that can be formed by concatenating the string \"abc\" multiple times. To solve this problem, we can iteratively search for occurrences of \"abc\" and replace them with a placeholder, \"---\". Additionally, we also need to handle occurrences of \"ab\", \"ac\", and \"bc\" separately, replacing them with \"--\" while keeping track of the count. Finally, we count the remaining characters in the string that are not placeholders and add twice their count to the overall result.\\n\\n\\n# Approach\\nWe initialize a variable count to keep track of the minimum number of letters that need to be inserted. We then proceed with the following steps:\\n\\n1. While there is an occurrence of \"abc\" in the given word, we find its index i using the find function and replace it with \"---\" by modifying the word string.\\n2. Similarly, we search for occurrences of \"ab\", \"ac\", and \"bc\" in the word string using the find function. For each occurrence found, we replace it with \"--\" and increment the count by 1.\\n3. After handling all occurrences of \"abc\", \"ab\", \"ac\", and \"bc\", we iterate through the remaining characters in the word string. For each character that is not a placeholder (\"-\"), we increment the count by 2 to account for the necessary insertions.\\n4. Finally, we return the count as the minimum number of letters required to make the word string valid.\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution depends on the size of the word string. In the worst case, we may need to iterate over the entire word string multiple times to replace occurrences of \"abc\", \"ab\", \"ac\", and \"bc\". Therefore, the time complexity is O(n), where n represents the length of the word string.\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is O(1) since we are not using any additional data structures that grow with the input size. We only require a constant amount of extra space to store the count variable and temporary variables for string modifications.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        count=0\\n        while word.find(\"abc\")!=-1:\\n            i=word.find(\"abc\")\\n            word=word[:i]+\"---\"+word[i+3:]\\n        while word.find(\"ab\")!=-1:\\n            i=word.find(\"ab\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        while word.find(\"ac\")!=-1:\\n            i=word.find(\"ac\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        while word.find(\"bc\")!=-1:\\n            i=word.find(\"bc\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        for i in range(len(word)):\\n            if word[i]!=\"-\":\\n                count+=2\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        count=0\\n        while word.find(\"abc\")!=-1:\\n            i=word.find(\"abc\")\\n            word=word[:i]+\"---\"+word[i+3:]\\n        while word.find(\"ab\")!=-1:\\n            i=word.find(\"ab\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        while word.find(\"ac\")!=-1:\\n            i=word.find(\"ac\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        while word.find(\"bc\")!=-1:\\n            i=word.find(\"bc\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        for i in range(len(word)):\\n            if word[i]!=\"-\":\\n                count+=2\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421739,
                "title": "java-c-python-simple-and-fastest-solution-with-proper-board-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple one pointer solution single iteration solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will iterate over string and check for the current char and next char and next to next char \\nwe will maintain two variables \\n(ans) to calc res \\n(i) as a pointer\\n\\nthen there will be 3 conditions\\ncurrent char = c\\nnex char = cnex\\n\\n# conditon 1 if(c==\\'a\\')\\n![image.png](https://assets.leetcode.com/users/images/1086b0c5-776e-42a4-8965-b26ee391e0ca_1681618245.0409527.png)\\n\\n# conditon 2 if(c==\\'b\\')\\n![image.png](https://assets.leetcode.com/users/images/78822399-4d1d-4355-ae46-1db6a86630ef_1681618123.6426458.png)\\n\\n# conditon 3 if(c==\\'c\\')\\n![image.png](https://assets.leetcode.com/users/images/7f4450fd-cd54-4f07-ae68-029421604b2f_1681618169.4481125.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: none\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```c++ []\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n       int len = word.length();\\n        int ans = 0;\\n        int i = 0;\\n        while (i < len - 1) {\\n            char c = word[i];\\n            char cnex = word[i+1];\\n            if (c == \\'a\\') {\\n                if (cnex == \\'a\\')\\n                    ans += 2;\\n                else if (i < len-2 && cnex == \\'b\\' && word[i+2] == \\'c\\')\\n                    i += 2;\\n                else {\\n                    ans++;\\n                    i++;\\n                }\\n            } else if (c == \\'b\\') {\\n                if (cnex == \\'c\\') {\\n                    ans++;\\n                    i++;\\n                } else\\n                    ans += 2;\\n            } else\\n                ans += 2;\\n            i++;\\n        }\\n        if (i < len)\\n            ans += 2;\\n        return ans; \\n    }\\n};\\nConsole\\n\\n```\\n```python []\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \\n        len_word = len(word)\\n        ans = 0\\n        i = 0\\n        while i < len_word - 1:\\n            c = word[i]\\n            cnex = word[i+1]\\n            if c == \\'a\\':\\n                if cnex == \\'a\\':\\n                    ans += 2\\n                elif i < len_word-2 and cnex == \\'b\\' and word[i+2] == \\'c\\':\\n                    i += 2\\n                else:\\n                    ans += 1\\n                    i += 1\\n            elif c == \\'b\\':\\n                if cnex == \\'c\\':\\n                    ans += 1\\n                    i += 1\\n                else:\\n                    ans += 2\\n            else:\\n                ans += 2\\n            i += 1\\n        if i < len_word:\\n            ans += 2\\n        return ans\\n\\n```\\n```java []\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        int ans =0;\\n        int i=0;\\n        while(i<len-1){\\n            char c = word.charAt(i);\\n            char cnex = word.charAt(i+1);\\n            if(c==\\'a\\'){\\n                if(cnex ==\\'a\\')ans+=2;\\n                else if(i<len-2 && cnex==\\'b\\' && word.charAt(i+2)==\\'c\\')i+=2;\\n                else{\\n                    ans++;\\n                    i++;\\n                }\\n            }else if(c==\\'b\\'){\\n                if(cnex ==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else ans+=2;\\n            }else ans+=2;\\n            i++;\\n        }\\n        if(i<len)ans+=2;\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n       int len = word.length();\\n        int ans = 0;\\n        int i = 0;\\n        while (i < len - 1) {\\n            char c = word[i];\\n            char cnex = word[i+1];\\n            if (c == \\'a\\') {\\n                if (cnex == \\'a\\')\\n                    ans += 2;\\n                else if (i < len-2 && cnex == \\'b\\' && word[i+2] == \\'c\\')\\n                    i += 2;\\n                else {\\n                    ans++;\\n                    i++;\\n                }\\n            } else if (c == \\'b\\') {\\n                if (cnex == \\'c\\') {\\n                    ans++;\\n                    i++;\\n                } else\\n                    ans += 2;\\n            } else\\n                ans += 2;\\n            i++;\\n        }\\n        if (i < len)\\n            ans += 2;\\n        return ans; \\n    }\\n};\\nConsole\\n\\n```\n```python []\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \\n        len_word = len(word)\\n        ans = 0\\n        i = 0\\n        while i < len_word - 1:\\n            c = word[i]\\n            cnex = word[i+1]\\n            if c == \\'a\\':\\n                if cnex == \\'a\\':\\n                    ans += 2\\n                elif i < len_word-2 and cnex == \\'b\\' and word[i+2] == \\'c\\':\\n                    i += 2\\n                else:\\n                    ans += 1\\n                    i += 1\\n            elif c == \\'b\\':\\n                if cnex == \\'c\\':\\n                    ans += 1\\n                    i += 1\\n                else:\\n                    ans += 2\\n            else:\\n                ans += 2\\n            i += 1\\n        if i < len_word:\\n            ans += 2\\n        return ans\\n\\n```\n```java []\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        int ans =0;\\n        int i=0;\\n        while(i<len-1){\\n            char c = word.charAt(i);\\n            char cnex = word.charAt(i+1);\\n            if(c==\\'a\\'){\\n                if(cnex ==\\'a\\')ans+=2;\\n                else if(i<len-2 && cnex==\\'b\\' && word.charAt(i+2)==\\'c\\')i+=2;\\n                else{\\n                    ans++;\\n                    i++;\\n                }\\n            }else if(c==\\'b\\'){\\n                if(cnex ==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else ans+=2;\\n            }else ans+=2;\\n            i++;\\n        }\\n        if(i<len)ans+=2;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427029,
                "title": "0-ms-clean-code-two-pointer",
                "content": "<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        const string a = \"abc\";\\n        int n = s.size();\\n        int i=0;\\n        int ans = 0;\\n        while(i<n){\\n            int j=0;\\n            while(i<n and j<3){\\n                if(s[i]!=a[j]){\\n                    ++ans;\\n                    ++j;\\n                }\\n                else if(s[i]==a[j]){\\n                    if(i+1<n)++i,++j;\\n                    else{\\n                        ans+=2-j;\\n                        return ans;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        const string a = \"abc\";\\n        int n = s.size();\\n        int i=0;\\n        int ans = 0;\\n        while(i<n){\\n            int j=0;\\n            while(i<n and j<3){\\n                if(s[i]!=a[j]){\\n                    ++ans;\\n                    ++j;\\n                }\\n                else if(s[i]==a[j]){\\n                    if(i+1<n)++i,++j;\\n                    else{\\n                        ans+=2-j;\\n                        return ans;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421752,
                "title": "c-using-conditions-explained-with-example",
                "content": "# Intuition\\nThe idea is to traverse the string character by character, and based on the current character and the previous character(s), determine the number of characters that need to be added to make the string valid. \\nSay we have a string `bbca`\\n```\\nfor \\'b\\', \\nas it is the first character, we need to add \\'a\\' before it. \\nThen check if \\'c\\' exists after it, as it doesn\\'t add a \\'c\\' after it.\\n=> count=2\\n```\\n```\\nfor \\'b\\', \\nas \\'a\\' doesn\\'t exist before it, we need to add \\'a\\' before it . \\nThen check if \\'c\\' exists after it, as it does, we skip over the character \\'c\\'.\\n=> count=2+1=3\\n```\\n```\\nWe skipped \\'c\\' as it was already used for previous combination.\\n```\\n\\n```\\nfor \\'a\\', \\nas \\'a\\' is the last character, we need to add \\'b\\' and \\'c\\' after it.\\n=> count=3+2=5\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        int count = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'a\\') { \\n                if (i == n - 1) count += 2; // If \\'a\\' is the last character, add 2\\n                else if (s[i + 1] == \\'c\\') {\\n                    ++count; // If the next character is \\'c\\', add 1\\n                    ++i; // Skip the next character\\n                }\\n                else if (s[i + 1] == \\'b\\' && (i + 2 != n && s[i + 2] == \\'c\\')) i += 2; // If the next two characters are \\'bc\\', skip them\\n                else if (s[i + 1] == \\'b\\' && (i + 2 == n || s[i + 2] != \\'c\\')) {\\n                    ++count; // If the next character is \\'b\\' and the character after that is not \\'c\\', add 1\\n                    ++i; \\n                }\\n                else count += 2; // If the next character is not \\'b\\' or \\'c\\', i.e another a, add 2\\n            }\\n            else if (s[i] == \\'b\\') { \\n                if (i == n - 1) { // If b is the last character\\n                    count+=2;\\n                }\\n                else if (s[i + 1] == \\'c\\') {\\n                    ++count; // If the next character is \\'c\\', we only need to add \\'a\\' in front of bc\\n                    ++i; \\n                }\\n                else count += 2; \\n            }\\n            else {\\n                count += 2; // If the character is \\'c\\', add 2 for \"ab` before it\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor \\'b\\', \\nas it is the first character, we need to add \\'a\\' before it. \\nThen check if \\'c\\' exists after it, as it doesn\\'t add a \\'c\\' after it.\\n=> count=2\\n```\n```\\nfor \\'b\\', \\nas \\'a\\' doesn\\'t exist before it, we need to add \\'a\\' before it . \\nThen check if \\'c\\' exists after it, as it does, we skip over the character \\'c\\'.\\n=> count=2+1=3\\n```\n```\\nWe skipped \\'c\\' as it was already used for previous combination.\\n```\n```\\nfor \\'a\\', \\nas \\'a\\' is the last character, we need to add \\'b\\' and \\'c\\' after it.\\n=> count=3+2=5\\n```\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        int count = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'a\\') { \\n                if (i == n - 1) count += 2; // If \\'a\\' is the last character, add 2\\n                else if (s[i + 1] == \\'c\\') {\\n                    ++count; // If the next character is \\'c\\', add 1\\n                    ++i; // Skip the next character\\n                }\\n                else if (s[i + 1] == \\'b\\' && (i + 2 != n && s[i + 2] == \\'c\\')) i += 2; // If the next two characters are \\'bc\\', skip them\\n                else if (s[i + 1] == \\'b\\' && (i + 2 == n || s[i + 2] != \\'c\\')) {\\n                    ++count; // If the next character is \\'b\\' and the character after that is not \\'c\\', add 1\\n                    ++i; \\n                }\\n                else count += 2; // If the next character is not \\'b\\' or \\'c\\', i.e another a, add 2\\n            }\\n            else if (s[i] == \\'b\\') { \\n                if (i == n - 1) { // If b is the last character\\n                    count+=2;\\n                }\\n                else if (s[i + 1] == \\'c\\') {\\n                    ++count; // If the next character is \\'c\\', we only need to add \\'a\\' in front of bc\\n                    ++i; \\n                }\\n                else count += 2; \\n            }\\n            else {\\n                count += 2; // If the character is \\'c\\', add 2 for \"ab` before it\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421697,
                "title": "easiest-code-to-understand-simple-logic",
                "content": "\\u201Ca\\u201D, \\u201Cb\\u201D , \\u201Cc\\u201D can be convert to \\u201Cabc\\u201D in 2 steps\\n \\u201Cab\\u201D, \\u201Cac\\u201D, \\u201Cbc\\u201D can be converted to \\u201Cabc\\u201D in 1 steps\\n \\u201Cabc\\u201D can be converted to \\u201Cabc\\u201D in 0 steps\\n\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word)\\n    {\\n        int n = word.size(), ans = 0;\\n        int i = 0;\\n        while(i < n)\\n        {\\n            //getting the character indexes\\n            int curr = word[i] - \\'a\\';\\n            int next = (i + 1 >= n)? -1 : word[i + 1] - \\'a\\';\\n            int nextToNext = (i + 2 >= n)? -1 : word[i + 2] - \\'a\\';\\n            \\n            if (curr < next && next < nextToNext) { i += 3; }  //\"abc\"\\n            else if (curr < next) { ans++; i += 2; } //\"ab\" or \"ac\" or \"bc\"\\n            else { ans += 2; i++; } //\"a\" or \"b\" or \"c\"\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word)\\n    {\\n        int n = word.size(), ans = 0;\\n        int i = 0;\\n        while(i < n)\\n        {\\n            //getting the character indexes\\n            int curr = word[i] - \\'a\\';\\n            int next = (i + 1 >= n)? -1 : word[i + 1] - \\'a\\';\\n            int nextToNext = (i + 2 >= n)? -1 : word[i + 2] - \\'a\\';\\n            \\n            if (curr < next && next < nextToNext) { i += 3; }  //\"abc\"\\n            else if (curr < next) { ans++; i += 2; } //\"ab\" or \"ac\" or \"bc\"\\n            else { ans += 2; i++; } //\"a\" or \"b\" or \"c\"\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424460,
                "title": "python-3-1-liner-using-replace-t-m-92-100",
                "content": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n\\n        return len(word.replace(\\'abc\\',\\'X\\' )\\n                       .replace(\\'ab\\' ,\\'C\\' )\\n                       .replace(\\'ac\\' ,\\'B\\' )\\n                       .replace(\\'bc\\' ,\\'A\\' )\\n                       .replace(\\'a\\'  ,\\'AA\\')\\n                       .replace(\\'b\\'  ,\\'BB\\')\\n                       .replace(\\'c\\'  ,\\'CC\\')\\n                       .replace(\\'X\\'  ,\\'\\'  ))\\n```\\n[https://leetcode.com/problems/minimum-additions-to-make-valid-string/submissions/934853699/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n\\n        return len(word.replace(\\'abc\\',\\'X\\' )\\n                       .replace(\\'ab\\' ,\\'C\\' )\\n                       .replace(\\'ac\\' ,\\'B\\' )\\n                       .replace(\\'bc\\' ,\\'A\\' )\\n                       .replace(\\'a\\'  ,\\'AA\\')\\n                       .replace(\\'b\\'  ,\\'BB\\')\\n                       .replace(\\'c\\'  ,\\'CC\\')\\n                       .replace(\\'X\\'  ,\\'\\'  ))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423624,
                "title": "c-2-pointer-o-n-easy-explanation",
                "content": "\\t// Just try to form more number of \"abc\".\\n\\t// Creater two pointers i and j for string word and \"abc\" respectively.\\n\\t// if any of chars in word does not match with abc then increase the count else move the i pointer.\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tint addMinimum(string word) {\\n\\n\\t\\t\\tstring abc=\"abc\";\\n\\t\\t\\tint count=0,j=0;\\n\\n\\t\\t\\tfor(int i=0;i<word.size();)\\n\\t\\t\\t{\\n\\t\\t\\t\\tj=j%3;\\n\\n\\t\\t\\t\\tif(word[i]==abc[j])\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount++;\\n\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcount +=(3-j);        // if last letter was not c then add count of remaining chars \\n\\t\\t\\treturn count;\\n\\t\\t }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\tint addMinimum(string word) {\\n\\n\\t\\t\\tstring abc=\"abc\";\\n\\t\\t\\tint count=0,j=0;\\n\\n\\t\\t\\tfor(int i=0;i<word.size();)\\n\\t\\t\\t{\\n\\t\\t\\t\\tj=j%3;\\n\\n\\t\\t\\t\\tif(word[i]==abc[j])\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount++;\\n\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3421808,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string val = \"abc\";\\n        int n = word.length(),i=0,c=0;\\n        string str1,str2;\\n        \\n        while(i<n){\\n            if(i+2<n)\\n                str1 = word.substr(i,3);\\n            if(i+1<n)\\n                str2 = word.substr(i,2);\\n            \\n            if(i+2 < n && str1 == \"abc\"){\\n                i+=3;\\n            }\\n            else if(i+1<n  &&  (( str2 == \"ab\") || (str2 == \"bc\") || (str2== \"ac\") )  ){\\n                    i+=2;\\n                    c++;\\n            }\\n            else{\\n                c+=2;\\n                i++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string val = \"abc\";\\n        int n = word.length(),i=0,c=0;\\n        string str1,str2;\\n        \\n        while(i<n){\\n            if(i+2<n)\\n                str1 = word.substr(i,3);\\n            if(i+1<n)\\n                str2 = word.substr(i,2);\\n            \\n            if(i+2 < n && str1 == \"abc\"){\\n                i+=3;\\n            }\\n            else if(i+1<n  &&  (( str2 == \"ab\") || (str2 == \"bc\") || (str2== \"ac\") )  ){\\n                    i+=2;\\n                    c++;\\n            }\\n            else{\\n                c+=2;\\n                i++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425733,
                "title": "2645-minimum-additions-to-make-valid-string",
                "content": "<iframe src=\"https://leetcode.com/playground/mjpv5oYM/shared\" frameBorder=\"0\" width=\"560\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C",
                    "Array",
                    "String",
                    "Greedy"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/mjpv5oYM/shared\" frameBorder=\"0\" width=\"560\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3422456,
                "title": "easy-8-line-code-2-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        //Calculate value of k => the number of times repeatance of \"abc\" is required\\n        int k=0;\\n        // take prev as last char of \"abc\" \\n        char prev=\\'c\\';\\n        for(int i=0;i<word.length();i++){\\n            k+= prev >= word.charAt(i)?1:0;\\n            prev= word.charAt(i);\\n        }\\n        return 3*k-word.length();\\n    }\\n}\\n```\\n\\n#**Code 2**\\n```\\nclass Solution {\\n    int addMinimum(String word) {\\n    int ans=0;\\n    for(int i=0; i<word.length();){\\n        if(word.charAt(i)== \\'a\\') i++; else ans++;         \\n        if( i < word.length() && word.charAt(i)== \\'b\\')i++; else ans++;\\n        if(i < word.length() && word.charAt(i) == \\'c\\')i++; else ans++;\\n    }\\n    return ans;\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        //Calculate value of k => the number of times repeatance of \"abc\" is required\\n        int k=0;\\n        // take prev as last char of \"abc\" \\n        char prev=\\'c\\';\\n        for(int i=0;i<word.length();i++){\\n            k+= prev >= word.charAt(i)?1:0;\\n            prev= word.charAt(i);\\n        }\\n        return 3*k-word.length();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int addMinimum(String word) {\\n    int ans=0;\\n    for(int i=0; i<word.length();){\\n        if(word.charAt(i)== \\'a\\') i++; else ans++;         \\n        if( i < word.length() && word.charAt(i)== \\'b\\')i++; else ans++;\\n        if(i < word.length() && word.charAt(i) == \\'c\\')i++; else ans++;\\n    }\\n    return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422061,
                "title": "best-c-well-explained-two-pointer",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointer method\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0, j=0, cnt=0;\\n        string s = \"abc\";   // this string is used to matching\\n        \\n        while(i < word.length())    {\\n            // if match then go forward\\n            if(word[i] == s[j]) {\\n                i++;\\n                j++;\\n                if(j >= 3)  j = 0;\\n            }\\n            // here character is not matching s[j] so increment the count and go next char of s\\n            else    {\\n                cnt++;\\n                j++;\\n                if(j >= 3)  j = 0;\\n            }\\n        }\\n        if(j==1)    cnt += 2;\\n        if(j==2)    cnt += 1;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0, j=0, cnt=0;\\n        string s = \"abc\";   // this string is used to matching\\n        \\n        while(i < word.length())    {\\n            // if match then go forward\\n            if(word[i] == s[j]) {\\n                i++;\\n                j++;\\n                if(j >= 3)  j = 0;\\n            }\\n            // here character is not matching s[j] so increment the count and go next char of s\\n            else    {\\n                cnt++;\\n                j++;\\n                if(j >= 3)  j = 0;\\n            }\\n        }\\n        if(j==1)    cnt += 2;\\n        if(j==2)    cnt += 1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421996,
                "title": "java-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we take a = 0, b = 1, c = 2, then the string must follow the pattern 012 012...\\nSo we can iterate over the characters and check if `(previous + 1) % 3 = current`\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans = 0;\\n        int prev = 2;\\n        int i = 0;\\n        while (i < word.length()) {\\n            int curr = word.charAt(i) - \\'a\\';\\n            if ((prev+1)%3 == curr) {\\n                i++;\\n                prev = curr;\\n            }\\n            else {\\n                ans++;\\n                prev = (prev+1)%3;\\n            }\\n        }\\n        return ans + 2 - prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans = 0;\\n        int prev = 2;\\n        int i = 0;\\n        while (i < word.length()) {\\n            int curr = word.charAt(i) - \\'a\\';\\n            if ((prev+1)%3 == curr) {\\n                i++;\\n                prev = curr;\\n            }\\n            else {\\n                ans++;\\n                prev = (prev+1)%3;\\n            }\\n        }\\n        return ans + 2 - prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926257,
                "title": "beat-100-c-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0, i = 0;\\n        while(i < word.size()){\\n            (word[i] == \\'a\\') ? i++ : ans++;         \\n            (word[i] == \\'b\\') ? i++ : ans++;\\n            (word[i] == \\'c\\') ? i++ : ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Python \\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        ans = 0\\n        i = 0\\n        while i < len(word):\\n            if word[i] == \\'a\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n            if word[i] == \\'b\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n            if word[i] == \\'c\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n        return ans\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0, i = 0;\\n        while(i < word.size()){\\n            (word[i] == \\'a\\') ? i++ : ans++;         \\n            (word[i] == \\'b\\') ? i++ : ans++;\\n            (word[i] == \\'c\\') ? i++ : ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        ans = 0\\n        i = 0\\n        while i < len(word):\\n            if word[i] == \\'a\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n            if word[i] == \\'b\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n            if word[i] == \\'c\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731536,
                "title": "two-pointers-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a temporary string \"abc\" and count the number of insertions to make it a valid string.\\n**For Ex:- string word = \"abb\"**\\n\\na b b **(i pointer)**\\n|----------->    same character increment i and j by 1.\\nabc  **(j pointer)**\\n\\na b b\\n--|----------->  same character increment i and j by 1.\\n-abc\\n\\na b b\\n----|-----------> Not same increment j  and count by 1. count = 1\\n-abc\\n\\na b b\\n----|-----------> Not same increment j  and count by 1. count = 2\\n----abc\\na b b\\n----|-----------> same character increment i and j by 1.\\n---abc\\n\\n**return count+3-j;**\\n\\n\\n# Complexity\\n- Time complexity:O(3*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        string s = \"abc\";\\n        int ans = 0;\\n        int j = 0,i = 0;\\n        while(i<w.size())\\n        {\\n            if(s[j]!=w[i])\\n            {\\n                ans++;\\n                j = (j==2) ? 0:j+1;\\n            }\\n            else\\n            {\\n                i++;\\n                j = (j==2) ? 0:j+1;\\n            }\\n        }\\n        if(j!=0) ans+=3-j;\\n        return ans; \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/9802c181-91d8-447d-8966-5ee30a62072f_1688723009.8175957.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        string s = \"abc\";\\n        int ans = 0;\\n        int j = 0,i = 0;\\n        while(i<w.size())\\n        {\\n            if(s[j]!=w[i])\\n            {\\n                ans++;\\n                j = (j==2) ? 0:j+1;\\n            }\\n            else\\n            {\\n                i++;\\n                j = (j==2) ? 0:j+1;\\n            }\\n        }\\n        if(j!=0) ans+=3-j;\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553528,
                "title": "faster-than-light-10-line-java-code-faster-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int res = 0 ,cur = 0, pos = 0, len = word.length();;   \\n        while(pos < len){\\n            if(cur == word.charAt(pos) - \\'a\\') pos ++;\\n            else   res ++;\\n            cur  = (cur + 1) % 3;\\n        }\\n        return res + \\'c\\' -  word.charAt(len - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int res = 0 ,cur = 0, pos = 0, len = word.length();;   \\n        while(pos < len){\\n            if(cur == word.charAt(pos) - \\'a\\') pos ++;\\n            else   res ++;\\n            cur  = (cur + 1) % 3;\\n        }\\n        return res + \\'c\\' -  word.charAt(len - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538679,
                "title": "c-simple-iteration-no-dp-100-time-limit",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0;\\n        int i=0;\\n        int z=word.size()-2;\\n        for(i=0;i<z;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'b\\'&&word[i+2]==\\'c\\') i+=2;\\n                else if(word[i+1]==\\'b\\'||word[i+1]==\\'c\\'){ans++; i++;}\\n                else {ans+=2;}\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i+1]==\\'c\\'){ans++;i++;}\\n                else { ans+=2;}\\n            }\\n            else if(word[i]==\\'c\\') ans+=2;\\n        }\\n        int n=word.size()-1;\\n        if(i==n-1)\\n        {\\n            if(word[n-1]==\\'a\\')\\n            {\\n                if(word[n]==\\'b\\'||word[n]==\\'c\\') ans++;\\n                else\\n                {\\n                    ans+=4;\\n                }\\n            }\\n            else if(word[n-1]==\\'b\\')\\n            {\\n                if(word[n]==\\'c\\') ans++;\\n                else\\n                {\\n                    ans+=4;\\n                }\\n            }\\n            else if(word[n-1]==\\'c\\')\\n            {\\n                ans+=4;\\n            }\\n        }\\n        else if(i==n)\\n        {\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0;\\n        int i=0;\\n        int z=word.size()-2;\\n        for(i=0;i<z;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'b\\'&&word[i+2]==\\'c\\') i+=2;\\n                else if(word[i+1]==\\'b\\'||word[i+1]==\\'c\\'){ans++; i++;}\\n                else {ans+=2;}\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i+1]==\\'c\\'){ans++;i++;}\\n                else { ans+=2;}\\n            }\\n            else if(word[i]==\\'c\\') ans+=2;\\n        }\\n        int n=word.size()-1;\\n        if(i==n-1)\\n        {\\n            if(word[n-1]==\\'a\\')\\n            {\\n                if(word[n]==\\'b\\'||word[n]==\\'c\\') ans++;\\n                else\\n                {\\n                    ans+=4;\\n                }\\n            }\\n            else if(word[n-1]==\\'b\\')\\n            {\\n                if(word[n]==\\'c\\') ans++;\\n                else\\n                {\\n                    ans+=4;\\n                }\\n            }\\n            else if(word[n-1]==\\'c\\')\\n            {\\n                ans+=4;\\n            }\\n        }\\n        else if(i==n)\\n        {\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434022,
                "title": "c-most-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        int n=word.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string s1=\"\",s2=\"\";\\n            if(i+2<n)\\n            s1=word.substr(i,3);\\n            if(i+1<n)\\n            s2=word.substr(i,2);\\n            if(s1==\"abc\")\\n            {\\n                i+=2;\\n            }\\n            else if(s2==\"ab\" or s2==\"ac\" or s2==\"bc\")\\n            {\\n                i+=1;\\n                ans++;\\n            }\\n            else\\n            {\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        int n=word.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string s1=\"\",s2=\"\";\\n            if(i+2<n)\\n            s1=word.substr(i,3);\\n            if(i+1<n)\\n            s2=word.substr(i,2);\\n            if(s1==\"abc\")\\n            {\\n                i+=2;\\n            }\\n            else if(s2==\"ab\" or s2==\"ac\" or s2==\"bc\")\\n            {\\n                i+=1;\\n                ans++;\\n            }\\n            else\\n            {\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430920,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int k=0;\\n        int i=0, n=w.size();\\n        while(i<n)\\n        {\\n          int c=0;\\n          if(i<n && w[i]==\\'a\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n          if(i<n && w[i]==\\'b\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n          if(i<n && w[i]==\\'c\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n            k+=(3-c);\\n            \\n        }\\n       return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int k=0;\\n        int i=0, n=w.size();\\n        while(i<n)\\n        {\\n          int c=0;\\n          if(i<n && w[i]==\\'a\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n          if(i<n && w[i]==\\'b\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n          if(i<n && w[i]==\\'c\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n            k+=(3-c);\\n            \\n        }\\n       return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429950,
                "title": "java-solution-easy-to-understand",
                "content": "![upvote.jpeg](https://assets.leetcode.com/users/images/3a1c7f54-0891-406c-a144-fa071056ca4c_1681802025.596787.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        if(word.equals(\"abc\"))return 0;\\n        int count=0;\\n        int i=0;\\n        for(i=0;i<word.length()-1;i++){\\n            if(i+3<=word.length()){\\n                String h=word.substring(i,i+3);\\n                if(h.equals(\"abc\")){\\n                i+=2;\\n                continue;\\n            }\\n        }\\n            String l=word.substring(i,i+2);\\n            if(l.equals(\"ab\")||l.equals(\"bc\")||l.equals(\"ac\")){\\n                count++;\\n                i++;\\n                continue;\\n            }\\n            \\n            char ch=word.charAt(i);\\n            if(ch==\\'a\\'||ch==\\'b\\'||ch==\\'c\\')count+=2;\\n        }\\n        if(i==word.length()-1){\\n            char ch=word.charAt(i);\\n            if(ch==\\'a\\'||ch==\\'b\\'||ch==\\'c\\')count+=2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        if(word.equals(\"abc\"))return 0;\\n        int count=0;\\n        int i=0;\\n        for(i=0;i<word.length()-1;i++){\\n            if(i+3<=word.length()){\\n                String h=word.substring(i,i+3);\\n                if(h.equals(\"abc\")){\\n                i+=2;\\n                continue;\\n            }\\n        }\\n            String l=word.substring(i,i+2);\\n            if(l.equals(\"ab\")||l.equals(\"bc\")||l.equals(\"ac\")){\\n                count++;\\n                i++;\\n                continue;\\n            }\\n            \\n            char ch=word.charAt(i);\\n            if(ch==\\'a\\'||ch==\\'b\\'||ch==\\'c\\')count+=2;\\n        }\\n        if(i==word.length()-1){\\n            char ch=word.charAt(i);\\n            if(ch==\\'a\\'||ch==\\'b\\'||ch==\\'c\\')count+=2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428861,
                "title": "c-replace-abc-ab-bc-ac-a-b-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMark the matched string with star(s).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReplace \"abc\"/\"ab\"/\"bc\"/\"ac\"/\"a\"/\"b\"/\"c\" with star(s).\\nCount the char(s) we need to insert for each replacement.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int ans = 0;\\n        \\n        // replace \"abc\"\\n        for (int i = 0; (i + 2) < n; i++) {\\n            if (word.substr(i, 3) == \"abc\") {\\n                word[i] = \\'*\\';\\n                word[i + 1] = \\'*\\';\\n                word[i + 2] = \\'*\\';\\n            }\\n        }\\n        \\n        // replace \"ab\"/\"bc\"/\"ac\"\\n        for (int i = 0; (i + 1) < n; i++) {\\n            string str = word.substr(i, 2);\\n            if ((str == \"ab\") || (str == \"bc\") || (str == \"ac\")) {\\n                word[i] = \\'*\\';\\n                word[i + 1] = \\'*\\';\\n                ans++;\\n            }\\n        }\\n        \\n        // replace \"a\"/\"b\"/\"c\"\\n        for (int i = 0; i < n; i++) {\\n            if (word[i] != \\'*\\') ans += 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int ans = 0;\\n        \\n        // replace \"abc\"\\n        for (int i = 0; (i + 2) < n; i++) {\\n            if (word.substr(i, 3) == \"abc\") {\\n                word[i] = \\'*\\';\\n                word[i + 1] = \\'*\\';\\n                word[i + 2] = \\'*\\';\\n            }\\n        }\\n        \\n        // replace \"ab\"/\"bc\"/\"ac\"\\n        for (int i = 0; (i + 1) < n; i++) {\\n            string str = word.substr(i, 2);\\n            if ((str == \"ab\") || (str == \"bc\") || (str == \"ac\")) {\\n                word[i] = \\'*\\';\\n                word[i + 1] = \\'*\\';\\n                ans++;\\n            }\\n        }\\n        \\n        // replace \"a\"/\"b\"/\"c\"\\n        for (int i = 0; i < n; i++) {\\n            if (word[i] != \\'*\\') ans += 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426386,
                "title": "swift-linear-solution-o-n",
                "content": "**Code:**\\n```\\nclass Solution {\\n    func addMinimum(_ word: String) -> Int {\\n        let word = Array(word)\\n        var i = 0\\n        var j = 0\\n        var res = 0\\n        let letters: [Character] = [\"a\", \"b\", \"c\"]\\n\\n        while i < word.count {\\n            if word[i] == letters[j] {\\n                i += 1\\n            } else {\\n                res += 1\\n            }\\n            j += 1\\n            j %= letters.count\\n        }\\n\\n        if j != 0 {\\n            res += letters.count - j\\n        }\\n\\n        return res\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func addMinimum(_ word: String) -> Int {\\n        let word = Array(word)\\n        var i = 0\\n        var j = 0\\n        var res = 0\\n        let letters: [Character] = [\"a\", \"b\", \"c\"]\\n\\n        while i < word.count {\\n            if word[i] == letters[j] {\\n                i += 1\\n            } else {\\n                res += 1\\n            }\\n            j += 1\\n            j %= letters.count\\n        }\\n\\n        if j != 0 {\\n            res += letters.count - j\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424647,
                "title": "state-machine-linear",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn next(c: char) -> char {\\n        match c {\\n            \\'a\\' => { \\'b\\' }\\n            \\'b\\' => { \\'c\\' }\\n            \\'c\\' => { \\'a\\' } \\n            _ => { \\' \\' }\\n        }\\n    }\\n    pub fn diff(e: char, g: char) -> (i32,char) {\\n        match (e,g) {\\n            (\\'a\\',\\'b\\') => (1, \\'c\\'),\\n            (\\'a\\',\\'c\\') => (2, \\'a\\'),\\n            (\\'b\\',\\'a\\') => (2, \\'b\\'),\\n            (\\'b\\',\\'c\\') => (1, \\'a\\'),\\n            (\\'c\\',\\'a\\') => (1, \\'b\\'),\\n            (\\'c\\',\\'b\\') => (2, \\'c\\'),\\n            (_,_) => (0, \\'a\\'),\\n        }\\n    }\\n    pub fn add_minimum(word: String) -> i32 {\\n        let mut cnt: i32 = 0;\\n        let mut n: char = \\'a\\';\\n        for c in word.chars() {\\n            if c != n {\\n                let (d,f) = Solution::diff(n, c);\\n                cnt += d;\\n                n = f;\\n            }\\n            else {\\n                n = Solution::next(n);\\n            }\\n        }\\n        match word.chars().last().unwrap() {\\n            \\'a\\' => cnt += 2,\\n            \\'b\\' => cnt += 1,\\n            _ => {}\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn next(c: char) -> char {\\n        match c {\\n            \\'a\\' => { \\'b\\' }\\n            \\'b\\' => { \\'c\\' }\\n            \\'c\\' => { \\'a\\' } \\n            _ => { \\' \\' }\\n        }\\n    }\\n    pub fn diff(e: char, g: char) -> (i32,char) {\\n        match (e,g) {\\n            (\\'a\\',\\'b\\') => (1, \\'c\\'),\\n            (\\'a\\',\\'c\\') => (2, \\'a\\'),\\n            (\\'b\\',\\'a\\') => (2, \\'b\\'),\\n            (\\'b\\',\\'c\\') => (1, \\'a\\'),\\n            (\\'c\\',\\'a\\') => (1, \\'b\\'),\\n            (\\'c\\',\\'b\\') => (2, \\'c\\'),\\n            (_,_) => (0, \\'a\\'),\\n        }\\n    }\\n    pub fn add_minimum(word: String) -> i32 {\\n        let mut cnt: i32 = 0;\\n        let mut n: char = \\'a\\';\\n        for c in word.chars() {\\n            if c != n {\\n                let (d,f) = Solution::diff(n, c);\\n                cnt += d;\\n                n = f;\\n            }\\n            else {\\n                n = Solution::next(n);\\n            }\\n        }\\n        match word.chars().last().unwrap() {\\n            \\'a\\' => cnt += 2,\\n            \\'b\\' => cnt += 1,\\n            _ => {}\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3423089,
                "title": "java-simple-and-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String str) {\\n        int i=0,ans=0;\\n       while(i<str.length())\\n       {int count=0;\\n        if(str.charAt(i)==\\'a\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        if(i<str.length() && str.charAt(i)==\\'b\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        if(i<str.length() && str.charAt(i)==\\'c\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        ans=ans+(3-count);\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String str) {\\n        int i=0,ans=0;\\n       while(i<str.length())\\n       {int count=0;\\n        if(str.charAt(i)==\\'a\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        if(i<str.length() && str.charAt(i)==\\'b\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        if(i<str.length() && str.charAt(i)==\\'c\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        ans=ans+(3-count);\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422424,
                "title": "simplest-4-line-solution-no-loop-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find what makes abc and its ab,bc,ac that makes abc in 1 additions\\nelse all in 2 additions\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst remove all present abc as they are not required\\nthen count all ab,bc,ac\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, w: str) -> int:\\n        w=w.replace(\"abc\",\" \")\\n        r=w.count(\"ab\")+w.count(\"bc\")+w.count(\"ac\")\\n        k=w.count(\"a\")+w.count(\"b\")+w.count(\"c\")\\n        return k*2-r*3\\n                    \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, w: str) -> int:\\n        w=w.replace(\"abc\",\" \")\\n        r=w.count(\"ab\")+w.count(\"bc\")+w.count(\"ac\")\\n        k=w.count(\"a\")+w.count(\"b\")+w.count(\"c\")\\n        return k*2-r*3\\n                    \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422144,
                "title": "c-stack-greedy-2-approaches",
                "content": "## Explanation\\nWe can use stack or greedy approaches to solve this problem. For explanation, check code comments :-)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Code\\n\\n##  Greedy\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int res = 0, n = word.length();\\n        \\n        if(word.length() == 1) return 2;\\n        \\n        // checking if the first character is \\'a\\'\\n        // else if \\'b\\' insert a - 1\\n        // else if \\'c\\' insert ab - 2\\n        if(word[0] == \\'b\\') res++;\\n        else if(word[0] == \\'c\\') res += 2;\\n\\n        // checking if the last character is \\'c\\'\\n        // else if \\'a\\' insert bc - 2\\n        // else if \\'b\\' insert c - 1\\n        if(word[n-1] == \\'b\\') res++;\\n        else if(word[n-1] == \\'a\\') res += 2;\\n    \\n        for(int i = 0; i < word.length()-1; i++){\\n            int curr = word[i] - \\'a\\', next = word[i+1] - \\'a\\';\\n\\n            // if \"ab\" or \"bc\" or \"ca\" are the adjacent characters, continue\\n            if(curr == 0 and next == 1 or curr == 1 and next == 2 or curr == 2 and next == 0) continue;\\n            // if \"aa\" or \"bb\" or \"cc\" , insert two characters inbetween them\\n            else if(curr==next) res+=2;\\n            // if \"ac\" or \"cb\" or \"ba\"\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n## Stack\\n\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack <int> st;\\n        for(char c : word) st.push(c-\\'a\\');\\n        int res = 0;\\n\\n        while( !st.empty() ){\\n\\n            // stack would have the string reversed . so \"cba\" is the string to be concatenated\\n            // finding \"cba\" patterns \\n            \\n            if( !st.empty() and st.top() == 2) st.pop();\\n            else res++;\\n\\n            if( !st.empty() and st.top() == 1) st.pop();\\n            else res++;\\n\\n            if( !st.empty() and st.top() == 0) st.pop();\\n            else res++;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int res = 0, n = word.length();\\n        \\n        if(word.length() == 1) return 2;\\n        \\n        // checking if the first character is \\'a\\'\\n        // else if \\'b\\' insert a - 1\\n        // else if \\'c\\' insert ab - 2\\n        if(word[0] == \\'b\\') res++;\\n        else if(word[0] == \\'c\\') res += 2;\\n\\n        // checking if the last character is \\'c\\'\\n        // else if \\'a\\' insert bc - 2\\n        // else if \\'b\\' insert c - 1\\n        if(word[n-1] == \\'b\\') res++;\\n        else if(word[n-1] == \\'a\\') res += 2;\\n    \\n        for(int i = 0; i < word.length()-1; i++){\\n            int curr = word[i] - \\'a\\', next = word[i+1] - \\'a\\';\\n\\n            // if \"ab\" or \"bc\" or \"ca\" are the adjacent characters, continue\\n            if(curr == 0 and next == 1 or curr == 1 and next == 2 or curr == 2 and next == 0) continue;\\n            // if \"aa\" or \"bb\" or \"cc\" , insert two characters inbetween them\\n            else if(curr==next) res+=2;\\n            // if \"ac\" or \"cb\" or \"ba\"\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack <int> st;\\n        for(char c : word) st.push(c-\\'a\\');\\n        int res = 0;\\n\\n        while( !st.empty() ){\\n\\n            // stack would have the string reversed . so \"cba\" is the string to be concatenated\\n            // finding \"cba\" patterns \\n            \\n            if( !st.empty() and st.top() == 2) st.pop();\\n            else res++;\\n\\n            if( !st.empty() and st.top() == 1) st.pop();\\n            else res++;\\n\\n            if( !st.empty() and st.top() == 0) st.pop();\\n            else res++;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422127,
                "title": "c-simple-easy-to-understand",
                "content": "````class Solution {\\npublic:\\n    int addMinimum(string str) {\\n        int a = 0, b = 0, c = 0, ans = 0;\\n        int i = 0, n = str.length();\\n        if(n==1)return 2;\\n        for(i = 0; i < n; i++){\\n            if(str[i]==\\'a\\'){\\n                if(i+1<n&&str[i+1]==\\'b\\'){\\n                    if(i+2<n&&str[i+2]==\\'c\\'){\\n                        i++;\\n                    }else{\\n                        ans++;\\n                    }\\n                    i++;\\n                }else if(i+1<n&&str[i+1]==\\'a\\'){\\n                    ans += 2;\\n                }else if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'b\\'){\\n                if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else if(i+1<n&&str[i+1]!=\\'c\\'){\\n                    ans += 2;\\n                }else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'c\\'){\\n                ans += 2;\\n            }\\n        }\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````class Solution {\\npublic:\\n    int addMinimum(string str) {\\n        int a = 0, b = 0, c = 0, ans = 0;\\n        int i = 0, n = str.length();\\n        if(n==1)return 2;\\n        for(i = 0; i < n; i++){\\n            if(str[i]==\\'a\\'){\\n                if(i+1<n&&str[i+1]==\\'b\\'){\\n                    if(i+2<n&&str[i+2]==\\'c\\'){\\n                        i++;\\n                    }else{\\n                        ans++;\\n                    }\\n                    i++;\\n                }else if(i+1<n&&str[i+1]==\\'a\\'){\\n                    ans += 2;\\n                }else if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'b\\'){\\n                if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else if(i+1<n&&str[i+1]!=\\'c\\'){\\n                    ans += 2;\\n                }else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'c\\'){\\n                ans += 2;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422081,
                "title": "step-by-step-explanation-go-c",
                "content": "1 Initialize variables: order to keep track of the current pattern order (0, 1 or 2), pattern to store the pattern \"abc\", i to loop through the characters in word, and n to store the minimum number of changes required to make word follow the pattern.\\n2 Loop through the characters in word until the end is reached.\\n3 Compare the current character with the character in the pattern that corresponds to the current order value (0, 1 or 2).\\n4 If the characters are not equal, increment n to indicate that a change is required.\\n5 If the characters are equal, move to the next character in word.\\n6 Increment order to move to the next character in the pattern.\\n7 After the loop, calculate the remaining number of characters required to complete the pattern (3 - order % 3) % 3.\\n8 Add the remaining number of characters to n and return it as the minimum number of changes required to make word follow the pattern.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nGo\\n```\\nfunc addMinimum(word string) int {\\n    order, n := 0, 0\\n    pattern := \"abc\"\\n    \\n    for i := 0; i < len(word); {\\n        c := word[i]\\n        if pattern[order%3] != c {\\n            n++\\n        } else {\\n            i++\\n        }\\n        order++\\n    }\\n    \\n    n += (3 - order % 3) % 3\\n    \\n    return n\\n}\\n```\\nC#\\n```\\npublic class Solution {\\n    public int AddMinimum(string word) {\\n        var order = 0;\\n        var pattern = \"abc\";\\n        var i = 0;\\n        var n = 0;\\n        while (i < word.Length) {\\n            var c = word[i];\\n            if (pattern[order % 3] != c) n++;\\n            else i++;\\n            order++;\\n        }\\n\\n        n += (3 - order % 3) % 3;\\n\\n        return n;\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```\\nfunc addMinimum(word string) int {\\n    order, n := 0, 0\\n    pattern := \"abc\"\\n    \\n    for i := 0; i < len(word); {\\n        c := word[i]\\n        if pattern[order%3] != c {\\n            n++\\n        } else {\\n            i++\\n        }\\n        order++\\n    }\\n    \\n    n += (3 - order % 3) % 3\\n    \\n    return n\\n}\\n```\n```\\npublic class Solution {\\n    public int AddMinimum(string word) {\\n        var order = 0;\\n        var pattern = \"abc\";\\n        var i = 0;\\n        var n = 0;\\n        while (i < word.Length) {\\n            var c = word[i];\\n            if (pattern[order % 3] != c) n++;\\n            else i++;\\n            order++;\\n        }\\n\\n        n += (3 - order % 3) % 3;\\n\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422044,
                "title": "short-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int cnt = 0;\\n        string s = \"abc\";\\n        int x = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(word[i] == s[x % 3]){\\n                x++;\\n                continue;\\n            }\\n            cnt++;\\n            x++;\\n            i--;\\n        }\\n        \\n        cnt += ((3 - x % 3) % 3);\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int cnt = 0;\\n        string s = \"abc\";\\n        int x = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(word[i] == s[x % 3]){\\n                x++;\\n                continue;\\n            }\\n            cnt++;\\n            x++;\\n            i--;\\n        }\\n        \\n        cnt += ((3 - x % 3) % 3);\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422031,
                "title": "add-characters-by-rules-ii-no-need-to-really-add-characters",
                "content": "# Intuition\\nSame as https://leetcode.com/problems/minimum-additions-to-make-valid-string/solutions/3422008/add-character-s-by-rules/.\\n\\n# Approach\\n(1) Add \\'c\\' after each \\'b\\' if necessary.\\n(2) Add \\'b\\' before each \\'c\\' if necessary.\\n(3) Add \\'a\\' before each \\'b\\' if necessary.\\n(4) Add \"bc\" after each \\'a\\' if necessary.\\n\\nNo need to really add characters.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        const int n = word.length();\\n        int r = 0;\\n        for (int i = 0; i < n; ++i) {\\n            switch(word[i]) {\\n                case \\'c\\':\\n                    r += 2;\\n                    break;\\n                case \\'b\\':\\n                    ++r;\\n                    if (i + 1 >= n || word[i + 1] != \\'c\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    break;\\n                case \\'a\\':\\n                    if (i + 1 >= n || word[i + 1] != \\'b\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    if (i + 1 >= n || word[i + 1] != \\'c\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    break;   \\n            }\\n            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        const int n = word.length();\\n        int r = 0;\\n        for (int i = 0; i < n; ++i) {\\n            switch(word[i]) {\\n                case \\'c\\':\\n                    r += 2;\\n                    break;\\n                case \\'b\\':\\n                    ++r;\\n                    if (i + 1 >= n || word[i + 1] != \\'c\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    break;\\n                case \\'a\\':\\n                    if (i + 1 >= n || word[i + 1] != \\'b\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    if (i + 1 >= n || word[i + 1] != \\'c\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    break;   \\n            }\\n            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422008,
                "title": "add-character-s-by-rules",
                "content": "# Intuition\\nAdd characters by rules.\\n\\n# Approach\\nAdd characters by rules.\\n\\n(1) Add \\'c\\' after each \\'b\\' if necessary.\\n(2) Add \\'b\\' before each \\'c\\' if necessary.\\n(3) Add \\'a\\' before each \\'b\\' if necessary.\\n(4) Add \"bc\" after each \\'a\\' if necessary.\\n\\n# Complexity\\n- Time complexity:\\nO(n ^ 2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        const int n = word.length();\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'b\\' && (i + 1 >= word.length() || word[i + 1] != \\'c\\')) {\\n                word = word.substr(0, i + 1) + \\'c\\' + word.substr(i + 1);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'c\\' && (i == 0 || word[i - 1] != \\'b\\')) {\\n                word = word.substr(0, i) + \\'b\\' + word.substr(i);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'b\\' && (i == 0 || word[i - 1] != \\'a\\')) {\\n                word = word.substr(0, i) + \\'a\\' + word.substr(i);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'a\\' && (i + 1 >= word.length() || word[i + 1] != \\'b\\')) {\\n                word = word.substr(0, i + 1) + \"bc\" + word.substr(i + 1);\\n                i += 2;\\n            }\\n        }\\n        return word.length() - n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        const int n = word.length();\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'b\\' && (i + 1 >= word.length() || word[i + 1] != \\'c\\')) {\\n                word = word.substr(0, i + 1) + \\'c\\' + word.substr(i + 1);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'c\\' && (i == 0 || word[i - 1] != \\'b\\')) {\\n                word = word.substr(0, i) + \\'b\\' + word.substr(i);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'b\\' && (i == 0 || word[i - 1] != \\'a\\')) {\\n                word = word.substr(0, i) + \\'a\\' + word.substr(i);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'a\\' && (i + 1 >= word.length() || word[i + 1] != \\'b\\')) {\\n                word = word.substr(0, i + 1) + \"bc\" + word.substr(i + 1);\\n                i += 2;\\n            }\\n        }\\n        return word.length() - n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421978,
                "title": "brute-force-checking-subsequence",
                "content": "# Intuition\\nAdd substring \"abc\" until we have a string that has word as a subsequence.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n ^ 2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    bool isSubsequence(const string &s, const string &w) {\\n        int j = 0;\\n        for (int i = j = 0; i < s.length() && j < w.length(); ++i) {\\n            if (s[i] == w[j]) {\\n                ++j;\\n            }\\n        }\\n        return j >= w.length();\\n    }\\npublic:\\n    int addMinimum(string word) {\\n        string s;\\n        for (;!isSubsequence(s, word); s.append(\"abc\"))\\n        ;\\n        return s.length() - word.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool isSubsequence(const string &s, const string &w) {\\n        int j = 0;\\n        for (int i = j = 0; i < s.length() && j < w.length(); ++i) {\\n            if (s[i] == w[j]) {\\n                ++j;\\n            }\\n        }\\n        return j >= w.length();\\n    }\\npublic:\\n    int addMinimum(string word) {\\n        string s;\\n        for (;!isSubsequence(s, word); s.append(\"abc\"))\\n        ;\\n        return s.length() - word.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421920,
                "title": "java-code-using-stack-100-faster-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Stack Data Structure\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- If the character is \\'a\\' you can push it into the stack.\\n- If the character is \\'b\\' then you have to check the peek character is \\'a\\' or not, if not then you have to push respective characters first and then push character \\'b\\'.\\n- If the character is \\'c\\' then check peek character is \\'b\\' or not , if not then push the respective characters first then push \\'c\\'.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String s) {\\n        Stack<Character> stack = new Stack<>();\\n       \\n        for(char c : s.toCharArray()) {\\n            if(stack.isEmpty()) {\\n                if(c == \\'b\\') {\\n                    stack.push(\\'a\\');\\n                   \\n                    stack.push(c);\\n                }\\n                else if(c == \\'c\\') {\\n                    stack.push(\\'a\\');\\n                    stack.push(\\'b\\');\\n                    stack.push(c);\\n                    \\n                }\\n                else stack.push(c);\\n            }\\n            else {\\n                if(c == \\'b\\') {\\n                   \\n                   if(stack.peek() == \\'b\\') {\\n                       stack.push(\\'c\\');\\n                       stack.push(\\'a\\');\\n                      \\n                   }\\n                    else if(stack.peek() == \\'c\\') {\\n                        stack.push(\\'a\\');\\n                        \\n                    }\\n                   \\n                }\\n                else if(c == \\'c\\') {\\n                   \\n                    if(stack.peek() == \\'a\\') {\\n                         \\n                        stack.push(\\'b\\');\\n                        \\n                        \\n                    }\\n                    else if(stack.peek() == c) {\\n                        stack.push(\\'a\\');\\n                        stack.push(\\'b\\');\\n                        \\n                    }\\n                }\\n                else {\\n                    if(stack.peek() == \\'a\\') {\\n                        \\n                        stack.push(\\'b\\');\\n                        stack.push(\\'c\\');\\n                       \\n                       \\n                    }\\n                    else if(stack.peek()==\\'b\\') {\\n                        stack.push(\\'c\\');\\n                       \\n                    }\\n                }\\n                stack.push(c);\\n            }\\n        }\\n        if(stack.peek() == \\'a\\') {\\n            stack.push(\\'b\\');\\n            stack.push(\\'c\\');\\n           \\n        }\\n        else if(stack.peek() == \\'b\\') {\\n            stack.push(\\'c\\');\\n           \\n        }\\n        \\n        return stack.size() - s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String s) {\\n        Stack<Character> stack = new Stack<>();\\n       \\n        for(char c : s.toCharArray()) {\\n            if(stack.isEmpty()) {\\n                if(c == \\'b\\') {\\n                    stack.push(\\'a\\');\\n                   \\n                    stack.push(c);\\n                }\\n                else if(c == \\'c\\') {\\n                    stack.push(\\'a\\');\\n                    stack.push(\\'b\\');\\n                    stack.push(c);\\n                    \\n                }\\n                else stack.push(c);\\n            }\\n            else {\\n                if(c == \\'b\\') {\\n                   \\n                   if(stack.peek() == \\'b\\') {\\n                       stack.push(\\'c\\');\\n                       stack.push(\\'a\\');\\n                      \\n                   }\\n                    else if(stack.peek() == \\'c\\') {\\n                        stack.push(\\'a\\');\\n                        \\n                    }\\n                   \\n                }\\n                else if(c == \\'c\\') {\\n                   \\n                    if(stack.peek() == \\'a\\') {\\n                         \\n                        stack.push(\\'b\\');\\n                        \\n                        \\n                    }\\n                    else if(stack.peek() == c) {\\n                        stack.push(\\'a\\');\\n                        stack.push(\\'b\\');\\n                        \\n                    }\\n                }\\n                else {\\n                    if(stack.peek() == \\'a\\') {\\n                        \\n                        stack.push(\\'b\\');\\n                        stack.push(\\'c\\');\\n                       \\n                       \\n                    }\\n                    else if(stack.peek()==\\'b\\') {\\n                        stack.push(\\'c\\');\\n                       \\n                    }\\n                }\\n                stack.push(c);\\n            }\\n        }\\n        if(stack.peek() == \\'a\\') {\\n            stack.push(\\'b\\');\\n            stack.push(\\'c\\');\\n           \\n        }\\n        else if(stack.peek() == \\'b\\') {\\n            stack.push(\\'c\\');\\n           \\n        }\\n        \\n        return stack.size() - s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421816,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length(),ans=0;\\n        for(int i=0;i<n;i++){\\n            if(word[i]==\\'a\\'){\\n                if(i<n-2 && word[i+1]==\\'b\\' && word[i+2]==\\'c\\') i+=2;\\n                else if(i<n-1 && (word[i+1]==\\'b\\' || word[i+1]==\\'c\\')) {\\n                    ans+=1;\\n                    i+=1;\\n                }\\n                else ans+=2;\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(i<n-1 && word[i+1]==\\'c\\'){\\n                    ans+=1;\\n                    i+=1;\\n                }\\n                else ans+=2;\\n            }\\n            else ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length(),ans=0;\\n        for(int i=0;i<n;i++){\\n            if(word[i]==\\'a\\'){\\n                if(i<n-2 && word[i+1]==\\'b\\' && word[i+2]==\\'c\\') i+=2;\\n                else if(i<n-1 && (word[i+1]==\\'b\\' || word[i+1]==\\'c\\')) {\\n                    ans+=1;\\n                    i+=1;\\n                }\\n                else ans+=2;\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(i<n-1 && word[i+1]==\\'c\\'){\\n                    ans+=1;\\n                    i+=1;\\n                }\\n                else ans+=2;\\n            }\\n            else ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421803,
                "title": "c-beginer-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int i=0;\\n        \\n        int cnt=0;\\n        char pehla=\\'a\\';\\n        while(i<w.size()){\\n            if(w[i]==pehla){\\n                i++;\\n            }\\n            else{\\n                cnt++;\\n            }\\n        \\n        if(pehla==\\'a\\')pehla=\\'b\\';\\n        else if(pehla==\\'b\\')pehla=\\'c\\';\\n        else{\\n            pehla=\\'a\\';\\n        }\\n        }\\n        if(w[w.size()-1]==\\'a\\'){\\n            cnt++;\\n        cnt++;\\n        }\\n        else if(w[w.size()-1]==\\'b\\'){\\n            cnt++;\\n        }\\n        return cnt;}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int i=0;\\n        \\n        int cnt=0;\\n        char pehla=\\'a\\';\\n        while(i<w.size()){\\n            if(w[i]==pehla){\\n                i++;\\n            }\\n            else{\\n                cnt++;\\n            }\\n        \\n        if(pehla==\\'a\\')pehla=\\'b\\';\\n        else if(pehla==\\'b\\')pehla=\\'c\\';\\n        else{\\n            pehla=\\'a\\';\\n        }\\n        }\\n        if(w[w.size()-1]==\\'a\\'){\\n            cnt++;\\n        cnt++;\\n        }\\n        else if(w[w.size()-1]==\\'b\\'){\\n            cnt++;\\n        }\\n        return cnt;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421726,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int count=0;\\n        HashMap<Character,Character> hm=new HashMap<>();\\n        <!-- next character needed -->\\n        hm.put(\\'a\\',\\'b\\');\\n        hm.put(\\'b\\',\\'c\\');\\n        hm.put(\\'c\\',\\'a\\');\\n        if(word.charAt(0)==\\'b\\')\\n            count+=1;\\n        if(word.charAt(0)==\\'c\\'){\\n            count+=2;\\n            if(word.length()==1)\\n                return count;\\n        }\\n        for(int i=0;i<word.length();i++){\\n            if(i==word.length()-1){\\n                if(word.charAt(i)==\\'a\\')\\n                    count+=2;\\n                if(word.charAt(i)==\\'b\\')\\n                    count+=1;\\n                break;\\n            }\\n            char ch=word.charAt(i);\\n            char ch2=word.charAt(i+1);\\n            if(ch==ch2)\\n                count+=2;\\n            else{\\n                if(ch2!=hm.get(ch))\\n                    count+=1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int count=0;\\n        HashMap<Character,Character> hm=new HashMap<>();\\n        <!-- next character needed -->\\n        hm.put(\\'a\\',\\'b\\');\\n        hm.put(\\'b\\',\\'c\\');\\n        hm.put(\\'c\\',\\'a\\');\\n        if(word.charAt(0)==\\'b\\')\\n            count+=1;\\n        if(word.charAt(0)==\\'c\\'){\\n            count+=2;\\n            if(word.length()==1)\\n                return count;\\n        }\\n        for(int i=0;i<word.length();i++){\\n            if(i==word.length()-1){\\n                if(word.charAt(i)==\\'a\\')\\n                    count+=2;\\n                if(word.charAt(i)==\\'b\\')\\n                    count+=1;\\n                break;\\n            }\\n            char ch=word.charAt(i);\\n            char ch2=word.charAt(i+1);\\n            if(ch==ch2)\\n                count+=2;\\n            else{\\n                if(ch2!=hm.get(ch))\\n                    count+=1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421683,
                "title": "easiest-and-detailed-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        \\n        if(word.equals(\"abc\")) return 0;\\n        if(word.length() == 1) return 2;\\n        \\n        int moves = 0, n = word.length();\\n        \\n        //If first char is \\'b\\', then we need to add \"a\", so count += 1\\n        if(word.charAt(0) == \\'b\\') moves += 1;\\n        \\n        //Similarly, if first char is \\'c\\', then we need to add \"ab\", so count += 2\\n        if(word.charAt(0) == \\'c\\') moves += 2;\\n        \\n        //We check char after curr_char in each step, and increment count accordingly\\n        for(int i = 0; i < word.length() - 1; i++){\\n            \\n            int curr = word.charAt(i) - \\'a\\', next = word.charAt(i + 1) - \\'a\\';\\n            \\n            //Suppose, if curr_char is b and next_char is b, so need we need to add \"ca\" to make the string valid\\n            if(curr == next){\\n                moves += 2;\\n            }\\n            \\n            //Add \"b\" in between\\n            else if(word.charAt(i) == \\'a\\' && word.charAt(i + 1) == \\'c\\'){\\n                moves += 1;\\n            }\\n            \\n            //Add \"c\" in between\\n            else if(word.charAt(i) == \\'b\\' && word.charAt(i + 1) == \\'a\\'){\\n                moves += 1;\\n            }\\n            \\n            //Add \"a\" in between\\n            else if(word.charAt(i) == \\'c\\' && word.charAt(i + 1) == \\'b\\'){\\n                moves += 1;\\n            }\\n            \\n        }\\n        \\n        //Checks for last char\\n        if(word.charAt(n - 1) == \\'a\\') moves += 2;\\n        if(word.charAt(n - 1) == \\'b\\') moves += 1;\\n        \\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        \\n        if(word.equals(\"abc\")) return 0;\\n        if(word.length() == 1) return 2;\\n        \\n        int moves = 0, n = word.length();\\n        \\n        //If first char is \\'b\\', then we need to add \"a\", so count += 1\\n        if(word.charAt(0) == \\'b\\') moves += 1;\\n        \\n        //Similarly, if first char is \\'c\\', then we need to add \"ab\", so count += 2\\n        if(word.charAt(0) == \\'c\\') moves += 2;\\n        \\n        //We check char after curr_char in each step, and increment count accordingly\\n        for(int i = 0; i < word.length() - 1; i++){\\n            \\n            int curr = word.charAt(i) - \\'a\\', next = word.charAt(i + 1) - \\'a\\';\\n            \\n            //Suppose, if curr_char is b and next_char is b, so need we need to add \"ca\" to make the string valid\\n            if(curr == next){\\n                moves += 2;\\n            }\\n            \\n            //Add \"b\" in between\\n            else if(word.charAt(i) == \\'a\\' && word.charAt(i + 1) == \\'c\\'){\\n                moves += 1;\\n            }\\n            \\n            //Add \"c\" in between\\n            else if(word.charAt(i) == \\'b\\' && word.charAt(i + 1) == \\'a\\'){\\n                moves += 1;\\n            }\\n            \\n            //Add \"a\" in between\\n            else if(word.charAt(i) == \\'c\\' && word.charAt(i + 1) == \\'b\\'){\\n                moves += 1;\\n            }\\n            \\n        }\\n        \\n        //Checks for last char\\n        if(word.charAt(n - 1) == \\'a\\') moves += 2;\\n        if(word.charAt(n - 1) == \\'b\\') moves += 1;\\n        \\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421681,
                "title": "o-n-but-why-the-length-is-just-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        word += \"  \";\\n        int ans = 0;\\n        for(int i = 0; i < word.size() - 2; i++) {\\n            int c = word[i];\\n            if(c == \\'a\\') {\\n                if(word[i + 1] == \\'b\\') {\\n                    i++;\\n                    if(word[i + 1] == \\'c\\') {\\n                        i++;\\n                    } else {\\n                        ans++;\\n                    }\\n                } else if(word[i + 1] == \\'c\\'){\\n                    i++;\\n                    ++ans;\\n                } else {\\n                    ans += 2;\\n                }\\n            } else if(c == \\'b\\') {\\n                if(word[i + 1] == \\'c\\') {\\n                    i++;\\n                    ++ans;\\n                } else {\\n                    ans += 2;\\n                }\\n            } else if(c == \\'c\\') {\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        word += \"  \";\\n        int ans = 0;\\n        for(int i = 0; i < word.size() - 2; i++) {\\n            int c = word[i];\\n            if(c == \\'a\\') {\\n                if(word[i + 1] == \\'b\\') {\\n                    i++;\\n                    if(word[i + 1] == \\'c\\') {\\n                        i++;\\n                    } else {\\n                        ans++;\\n                    }\\n                } else if(word[i + 1] == \\'c\\'){\\n                    i++;\\n                    ++ans;\\n                } else {\\n                    ans += 2;\\n                }\\n            } else if(c == \\'b\\') {\\n                if(word[i + 1] == \\'c\\') {\\n                    i++;\\n                    ++ans;\\n                } else {\\n                    ans += 2;\\n                }\\n            } else if(c == \\'c\\') {\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503622,
                "title": "python-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n=len(word)\\n        i=0 #iterator \\n        s=0   \\n        while (i<n):\\n            c=0\\n            if word[i]==\\'a\\':\\n                c+=1\\n                i+=1\\n            \\n            if i<n and word[i]==\\'b\\':\\n                c+=1\\n                i+=1\\n            \\n            if i<n and word[i]==\\'c\\':\\n                c+=1\\n                i+=1\\n            \\n            s+=3-c\\n        \\n        return s\\n\\n\\n             \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n=len(word)\\n        i=0 #iterator \\n        s=0   \\n        while (i<n):\\n            c=0\\n            if word[i]==\\'a\\':\\n                c+=1\\n                i+=1\\n            \\n            if i<n and word[i]==\\'b\\':\\n                c+=1\\n                i+=1\\n            \\n            if i<n and word[i]==\\'c\\':\\n                c+=1\\n                i+=1\\n            \\n            s+=3-c\\n        \\n        return s\\n\\n\\n             \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476967,
                "title": "simple-c-solution-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Problem is not that complex if you think we just need to print the extra characters that will be added to make the entire string in the form (abc)^x.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo we first initialize a string s as \"abc\" and then we check if the current index (idx) on string s matches the character i of string word then we continue else we just iterate on string s till it matches the char of word and also increase count by 1 for every iteration of while loop.\\n\\nI am doing %3 so that idx stays in the range of 3 for string s.\\nFor the last statement i am checking if the char at last place is c or not if not then it can onlu ne a or b hence we add that diff to count.\\n\\n# Complexity\\n- Time complexity: O(3N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count = 0,idx=0;\\n        string s = \"abc\";\\n        for(auto i:word){\\n            while(i!=s[(idx++)%3]){\\n                count++;\\n            }\\n        }\\n        return count + (\\'c\\' - word[word.size()-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count = 0,idx=0;\\n        string s = \"abc\";\\n        for(auto i:word){\\n            while(i!=s[(idx++)%3]){\\n                count++;\\n            }\\n        }\\n        return count + (\\'c\\' - word[word.size()-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463556,
                "title": "c-linear-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using a linear dynamic programming approach. We maintain a linear sequence (the given string \"word\") and use the values of previous states to compute the current state.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- For `dp[0]`, we set it to 2 since for one character, 2 additions are needed to form \"abc\". This is our base case.\\n- For each subsequent character, if the current character is greater than the previous character, we can decrease the number of additions required by 1. Otherwise, we increase the number of additions required by 2.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where n is the length of the input string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        vector<int> dp(n);\\n        dp[0] = 2;\\n        for (int i = 1; i < n; ++i)\\n            dp[i] = word[i] > word[i-1] ? dp[i-1] - 1 : dp[i-1] + 2;\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        vector<int> dp(n);\\n        dp[0] = 2;\\n        for (int i = 1; i < n; ++i)\\n            dp[i] = word[i] > word[i-1] ? dp[i-1] - 1 : dp[i-1] + 2;\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456679,
                "title": "easy-peesy-c-100-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0;\\n        char temp=\\'a\\';\\n        int count=0;\\n        while(i<word.size())\\n        {\\n            if(word[i]==temp)\\n            {\\n                i++;\\n            }\\n            else\\n                count++;\\n            \\n            if(temp==\\'a\\')\\n                temp=\\'b\\';\\n            else if(temp==\\'b\\')\\n                temp=\\'c\\';\\n            else\\n                temp=\\'a\\';\\n        }\\n        if(word[word.size()-1]==\\'a\\')\\n            count=count+2;\\n        else if(word[word.size()-1]==\\'b\\')\\n            count=count+1;\\n    \\n        return count;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0;\\n        char temp=\\'a\\';\\n        int count=0;\\n        while(i<word.size())\\n        {\\n            if(word[i]==temp)\\n            {\\n                i++;\\n            }\\n            else\\n                count++;\\n            \\n            if(temp==\\'a\\')\\n                temp=\\'b\\';\\n            else if(temp==\\'b\\')\\n                temp=\\'c\\';\\n            else\\n                temp=\\'a\\';\\n        }\\n        if(word[word.size()-1]==\\'a\\')\\n            count=count+2;\\n        else if(word[word.size()-1]==\\'b\\')\\n            count=count+1;\\n    \\n        return count;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437959,
                "title": "c-beginner-s-approach",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        stack<char>s;\\n        int cnt=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.empty()){\\n                if(w[i]==\\'a\\'){\\n                    s.push(\\'a\\');\\n                }\\n                else if(w[i]==\\'b\\'){\\n                    cnt++;\\n                    s.push(\\'a\\');\\n                    s.push(\\'b\\');\\n                }\\n                else{\\n                    cnt+=2;\\n                }\\n            }\\n            else{\\n                if(s.top()==\\'a\\'){\\n                    if(w[i]==\\'a\\'){\\n                        cnt+=2;\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else if(w[i]==\\'b\\'){\\n                        s.push(w[i]);\\n                    }\\n                    else{\\n                        cnt++;\\n                        s.pop();\\n                    }\\n                }\\n                else if(s.top()==\\'b\\'){\\n                    if(w[i]==\\'a\\'){\\n                        cnt++;\\n                        s.pop();\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else if(w[i]==\\'b\\'){\\n                        cnt+=2;\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else{\\n                        s.pop();\\n                        s.pop();\\n                    }\\n                }\\n            }\\n        }\\n        //cout<<cnt<<\" \"<<s.size()<<endl;\\n        while(!s.empty()){\\n            if(s.top()==\\'a\\'){\\n                cnt+=2;\\n                s.pop();\\n            }\\n            else if(s.top()==\\'b\\'){\\n                cnt++;\\n                s.pop();\\n                s.pop();\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        stack<char>s;\\n        int cnt=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.empty()){\\n                if(w[i]==\\'a\\'){\\n                    s.push(\\'a\\');\\n                }\\n                else if(w[i]==\\'b\\'){\\n                    cnt++;\\n                    s.push(\\'a\\');\\n                    s.push(\\'b\\');\\n                }\\n                else{\\n                    cnt+=2;\\n                }\\n            }\\n            else{\\n                if(s.top()==\\'a\\'){\\n                    if(w[i]==\\'a\\'){\\n                        cnt+=2;\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else if(w[i]==\\'b\\'){\\n                        s.push(w[i]);\\n                    }\\n                    else{\\n                        cnt++;\\n                        s.pop();\\n                    }\\n                }\\n                else if(s.top()==\\'b\\'){\\n                    if(w[i]==\\'a\\'){\\n                        cnt++;\\n                        s.pop();\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else if(w[i]==\\'b\\'){\\n                        cnt+=2;\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else{\\n                        s.pop();\\n                        s.pop();\\n                    }\\n                }\\n            }\\n        }\\n        //cout<<cnt<<\" \"<<s.size()<<endl;\\n        while(!s.empty()){\\n            if(s.top()==\\'a\\'){\\n                cnt+=2;\\n                s.pop();\\n            }\\n            else if(s.top()==\\'b\\'){\\n                cnt++;\\n                s.pop();\\n                s.pop();\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3432266,
                "title": "c-beats-100-simple-iteration-greedy",
                "content": "# Intuition\\nSimple iteration\\n\\n# Approach\\nGreddy\\n\\n## Don\\'t forget to upvote and give a like \\uD83D\\uDE43\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int count = 0;\\n        int i = 0;\\n        while(i<n){\\n            if(word[i] == \\'a\\'){\\n                if(word[i+1] == \\'b\\' and word[i+2] == \\'c\\'){\\n                    i+=3;\\n                }\\n                else if(word[i+1] == \\'b\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else if(word[i+1] == \\'c\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else if(word[i+1] == \\'a\\'){\\n                    count+=2;\\n                    i++;\\n                }\\n                else{\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n            if(word[i] == \\'b\\'){\\n                if(word[i+1] == \\'c\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else{\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n            if(word[i] == \\'c\\'){\\n                count+=2;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n### I hope the solution is clear; use the comment section regarding any doubt.",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int count = 0;\\n        int i = 0;\\n        while(i<n){\\n            if(word[i] == \\'a\\'){\\n                if(word[i+1] == \\'b\\' and word[i+2] == \\'c\\'){\\n                    i+=3;\\n                }\\n                else if(word[i+1] == \\'b\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else if(word[i+1] == \\'c\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else if(word[i+1] == \\'a\\'){\\n                    count+=2;\\n                    i++;\\n                }\\n                else{\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n            if(word[i] == \\'b\\'){\\n                if(word[i+1] == \\'c\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else{\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n            if(word[i] == \\'c\\'){\\n                count+=2;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432215,
                "title": "o-n-solution-easy-approach-beginner-friendly-code-c",
                "content": "# Approach\\nCheck if \"abc\" substring is present in the given string then skip them else for \"ab\", \"bc\", \"ac\" add 1 to your answer else add 2 for single substrings and move the pointer accordingly\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        if (word == \"abc\") {\\n            return 0;\\n        }\\n        int n = word.size();\\n        int i = 0;\\n        int ans = 0;\\n        while (i < n) {\\n            if (i == n-1) {\\n                ans += 2;\\n                i++;\\n            } else if (i+2 < n && word.substr(i, 3) == \"abc\") {\\n                i += 3;\\n            } else if (i+1 < n) {\\n                if (word.substr(i, 2) == \"ab\" || word.substr(i, 2) == \"bc\" || word.substr(i, 2) == \"ac\") {\\n                    ans += 1;\\n                    i += 2;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you like the solution please upvote. Thanks \\uD83D\\uDE0A\\uD83D\\uDE03",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        if (word == \"abc\") {\\n            return 0;\\n        }\\n        int n = word.size();\\n        int i = 0;\\n        int ans = 0;\\n        while (i < n) {\\n            if (i == n-1) {\\n                ans += 2;\\n                i++;\\n            } else if (i+2 < n && word.substr(i, 3) == \"abc\") {\\n                i += 3;\\n            } else if (i+1 < n) {\\n                if (word.substr(i, 2) == \"ab\" || word.substr(i, 2) == \"bc\" || word.substr(i, 2) == \"ac\") {\\n                    ans += 1;\\n                    i += 2;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430671,
                "title": "two-pointer",
                "content": "# Approach\\nTwo Pointer\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        \\n        target = \"abc\"\\n        i, j = 0, 0\\n        count = 0\\n\\n        while i < len(word):\\n            if j == len(target):\\n                j = 0\\n            if word[i] == target[j]:            \\n                i += 1\\n                j += 1\\n            else:         \\n                count += 1\\n                j += 1\\n    \\n        count += len(target) - j\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        \\n        target = \"abc\"\\n        i, j = 0, 0\\n        count = 0\\n\\n        while i < len(word):\\n            if j == len(target):\\n                j = 0\\n            if word[i] == target[j]:            \\n                i += 1\\n                j += 1\\n            else:         \\n                count += 1\\n                j += 1\\n    \\n        count += len(target) - j\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429563,
                "title": "easy-greedy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.size();\\n        int res=0;\\n        int i=0;\\n        while(i<n){\\n            int cnt=0;\\n            if(word[i]==\\'a\\'){\\n                cnt++;i++;\\n            }\\n            if(i<n && word[i]==\\'b\\'){\\n                cnt++;i++;\\n            }\\n            if(i<n && word[i]==\\'c\\'){\\n                cnt++;i++;\\n            }\\n            res+=(3-cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.size();\\n        int res=0;\\n        int i=0;\\n        while(i<n){\\n            int cnt=0;\\n            if(word[i]==\\'a\\'){\\n                cnt++;i++;\\n            }\\n            if(i<n && word[i]==\\'b\\'){\\n                cnt++;i++;\\n            }\\n            if(i<n && word[i]==\\'c\\'){\\n                cnt++;i++;\\n            }\\n            res+=(3-cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428432,
                "title": "c-easy-to-understand-concise-gready-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int countSections = 1;\\n        for(int i=0; i<word.size()-1; i++){\\n            if(word[i] >= word[i+1]) countSections++;\\n        }\\n        \\n        return (3*countSections) - word.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int countSections = 1;\\n        for(int i=0; i<word.size()-1; i++){\\n            if(word[i] >= word[i+1]) countSections++;\\n        }\\n        \\n        return (3*countSections) - word.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425944,
                "title": "eazy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) \\n    {\\n        int add = 0;\\n        int offset = 0;\\n        int idx = 0;\\n        while(idx < (word.length()))\\n        {\\n            char expected_char = char(\\'a\\' + offset);\\n            if(word[idx] == expected_char)\\n            {\\n                idx++;\\n                offset = offset + 1;\\n\\n                if(char(\\'a\\' + offset) == \\'d\\')\\n                offset = 0;\\n            }\\n            else\\n            {\\n                 add++;\\n                 offset = offset + 1;\\n\\n                 if(char(\\'a\\' + offset) == \\'d\\')\\n                 offset = 0;\\t \\n            }\\n        }\\n        char expected_char = char(\\'a\\' + offset);\\n        if(expected_char == \\'a\\') return add;\\n        else if(expected_char == \\'b\\') return add+2;\\n\\n        return add+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) \\n    {\\n        int add = 0;\\n        int offset = 0;\\n        int idx = 0;\\n        while(idx < (word.length()))\\n        {\\n            char expected_char = char(\\'a\\' + offset);\\n            if(word[idx] == expected_char)\\n            {\\n                idx++;\\n                offset = offset + 1;\\n\\n                if(char(\\'a\\' + offset) == \\'d\\')\\n                offset = 0;\\n            }\\n            else\\n            {\\n                 add++;\\n                 offset = offset + 1;\\n\\n                 if(char(\\'a\\' + offset) == \\'d\\')\\n                 offset = 0;\\t \\n            }\\n        }\\n        char expected_char = char(\\'a\\' + offset);\\n        if(expected_char == \\'a\\') return add;\\n        else if(expected_char == \\'b\\') return add+2;\\n\\n        return add+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424967,
                "title": "python-stack-deque",
                "content": "# Intuition\\nNeed to find the correct sequence of letters, parse and correct errors where necessary. \\n\\n# Approach\\nInspect from the end using a stack. \\nAlternatively use deque for inspection from beginning. \\n\\n# Complexity\\n- Time/space complexity:\\nO(n), n = length of input\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        stack = list(word)\\n        result = 0\\n        while stack:\\n            for l in \"cba\":\\n                if stack and stack[-1] == l: stack.pop()\\n                else: result += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        stack = list(word)\\n        result = 0\\n        while stack:\\n            for l in \"cba\":\\n                if stack and stack[-1] == l: stack.pop()\\n                else: result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424455,
                "title": "easy-c-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(3)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) \\n    {\\n        string abc = \"abc\";\\n        int n = 3;\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i<word.length())\\n        {\\n            if(j==3)\\n            {\\n                j=0;\\n            }\\n            if(word[i]==abc[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                count++;\\n                j++;\\n            }\\n        }\\n        count += n - j;\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) \\n    {\\n        string abc = \"abc\";\\n        int n = 3;\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i<word.length())\\n        {\\n            if(j==3)\\n            {\\n                j=0;\\n            }\\n            if(word[i]==abc[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                count++;\\n                j++;\\n            }\\n        }\\n        count += n - j;\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424398,
                "title": "c-recursion",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(string s, char compa, int i, int& cnt){\\n        if (i>=s.size())return;\\n        if (s[i]!=compa){cnt++;i=i-1;}\\n        helper(s,(\\'a\\'+(compa-\\'a\\'+1)%3),i+1,cnt);\\n    }\\n    int addMinimum(string s) {\\n        int cnt=0;\\n        int n= s.size();\\n        char compa=\\'a\\';\\n        helper(s,compa,0,cnt);\\n        if (s.back()==\\'a\\')cnt+=2;\\n        if (s.back()==\\'b\\')cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(string s, char compa, int i, int& cnt){\\n        if (i>=s.size())return;\\n        if (s[i]!=compa){cnt++;i=i-1;}\\n        helper(s,(\\'a\\'+(compa-\\'a\\'+1)%3),i+1,cnt);\\n    }\\n    int addMinimum(string s) {\\n        int cnt=0;\\n        int n= s.size();\\n        char compa=\\'a\\';\\n        helper(s,compa,0,cnt);\\n        if (s.back()==\\'a\\')cnt+=2;\\n        if (s.back()==\\'b\\')cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424033,
                "title": "c-probably-the-most-easiest-solution-beats-80-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        if(word[0]==\\'b\\')\\n            ans = ans + 1;\\n        if(word[0]==\\'c\\')\\n            ans = ans + 2;\\n        \\n        if(word[word.size()-1] == \\'a\\')\\n            ans = ans + 2;\\n        if(word[word.size()-1]==\\'b\\')\\n            ans = ans + 1;\\n        \\n        for(int i=0;i<word.size()-1;i++)\\n        {\\n            char c1 = word[i];\\n            char c2 = word[i+1];\\n            \\n            if(c1 == c2)\\n                ans = ans + 2;\\n            if(c1 == \\'a\\' && c2 == \\'c\\' || c1 == \\'b\\' && c2 == \\'a\\' || c1==\\'c\\' && c2 == \\'b\\' )\\n                ans = ans+1;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        if(word[0]==\\'b\\')\\n            ans = ans + 1;\\n        if(word[0]==\\'c\\')\\n            ans = ans + 2;\\n        \\n        if(word[word.size()-1] == \\'a\\')\\n            ans = ans + 2;\\n        if(word[word.size()-1]==\\'b\\')\\n            ans = ans + 1;\\n        \\n        for(int i=0;i<word.size()-1;i++)\\n        {\\n            char c1 = word[i];\\n            char c2 = word[i+1];\\n            \\n            if(c1 == c2)\\n                ans = ans + 2;\\n            if(c1 == \\'a\\' && c2 == \\'c\\' || c1 == \\'b\\' && c2 == \\'a\\' || c1==\\'c\\' && c2 == \\'b\\' )\\n                ans = ans+1;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423633,
                "title": "python-simple-two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:     \\n       s=\\'abc\\'\\n       i=0\\n       j=0\\n       res=0 \\n       while i<len(word):\\n           if j==3:\\n               j=0\\n           if word[i]==s[j]:\\n              i+=1\\n           else:\\n             res+=1   \\n           j+=1        \\n       return res+3-j \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:     \\n       s=\\'abc\\'\\n       i=0\\n       j=0\\n       res=0 \\n       while i<len(word):\\n           if j==3:\\n               j=0\\n           if word[i]==s[j]:\\n              i+=1\\n           else:\\n             res+=1   \\n           j+=1        \\n       return res+3-j \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423014,
                "title": "simple-c-solution",
                "content": "# Intuition + Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou just have to increase the index if it matches with the current character you have assigned.\\nAlso change the character according to the needed string ```abc```.\\nThen see the last index of string if it is ```a``` add 2 in cnt if ```b``` add 1 in cnt else add 0 in cnt.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.length(), i = 0; \\n        char c = \\'a\\'; \\n        int cnt = 0; \\n        while(i < n) { \\n            if(word[i] == c) i++; \\n            else cnt++; \\n             \\n            if(c == \\'a\\') c = \\'b\\';\\n            else if(c == \\'b\\') c = \\'c\\';\\n            else c = \\'a\\';\\n        } \\n         \\n         \\n        if(word[n-1] == \\'a\\') cnt += 2;\\n        else if(word[n-1] == \\'b\\') cnt++;\\n         \\n        return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```abc```\n```a```\n```b```\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.length(), i = 0; \\n        char c = \\'a\\'; \\n        int cnt = 0; \\n        while(i < n) { \\n            if(word[i] == c) i++; \\n            else cnt++; \\n             \\n            if(c == \\'a\\') c = \\'b\\';\\n            else if(c == \\'b\\') c = \\'c\\';\\n            else c = \\'a\\';\\n        } \\n         \\n         \\n        if(word[n-1] == \\'a\\') cnt += 2;\\n        else if(word[n-1] == \\'b\\') cnt++;\\n         \\n        return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422705,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        k=0\\n        prev=\\'z\\'\\n        for c in word:\\n            k+=c<=prev\\n            prev=c\\n\\n        return k*3-len(word)    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        k=0\\n        prev=\\'z\\'\\n        for c in word:\\n            k+=c<=prev\\n            prev=c\\n\\n        return k*3-len(word)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422482,
                "title": "simple-stupid-javascript-logic-with-comments-84-ms",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar addMinimum = function(word) {\\n    let result = 0;\\n\\n    for (let i = 0; i < word.length; ++i) {\\n        if (word[i] === \"a\") {\\n            if (word[i + 1] === \"b\" && word[i + 2] === \"c\") i += 2; // we have abc\\n            else if (word[i + 1] === \"b\" || word[i + 1] === \"c\") { // ab or ac only\\n                ++i;\\n                ++result;\\n            } else { // just a\\n                result += 2;\\n            }\\n        } else if (word[i] === \"b\") { // we start from b\\n            ++result;\\n            if (word[i + 1] === \"c\") { // it is bc\\n                ++i;\\n            } else ++result; // just b\\n        } else {\\n            result += 2; // only c\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar addMinimum = function(word) {\\n    let result = 0;\\n\\n    for (let i = 0; i < word.length; ++i) {\\n        if (word[i] === \"a\") {\\n            if (word[i + 1] === \"b\" && word[i + 2] === \"c\") i += 2; // we have abc\\n            else if (word[i + 1] === \"b\" || word[i + 1] === \"c\") { // ab or ac only\\n                ++i;\\n                ++result;\\n            } else { // just a\\n                result += 2;\\n            }\\n        } else if (word[i] === \"b\") { // we start from b\\n            ++result;\\n            if (word[i + 1] === \"c\") { // it is bc\\n                ++i;\\n            } else ++result; // just b\\n        } else {\\n            result += 2; // only c\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422428,
                "title": "easy-and-intutive-algorightm-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is every character should be valid.\\n\\'a\\' will be valid if \\'b\\' follows it similarly,\\n\\'b\\' will be valid if \\'c\\' follows it and \\n\\'c\\' will be valid if it is last or \\'a\\' follows it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow when the character is not valid:\\n- when \\'a\\' is followed by \\'a\\'\\nso in this case we will be adding \"bc\" after \\'a\\' i.e performing 2 operations (we are not actully adding in string).\\n- when \\'a\\' is followed by \\'c\\'\\nso in this case we will be adding \"b\" after \\'a\\' i.e performing 1 operation (we are not actully adding in string).\\n- when \\'a is followed by \\'b\\' its already a valid case, so no need to perform any operation. REPEAT SIMILAR STEPS FOR \\'b\\' and \\'c\\'\\n\\n- THE MAIN IDEA HERE IS WE DO NOT WORRY ABOUT PREV CHARCATERS AS THEY ARE ALREADY TAKEN CARE OF.\\n- MEANS PREV CHAR HAS DONE ITS OPERATION AND HAS MADE STRING VALID TILL CURRENT CHAR. \\n- NOTE:we\\'ve to make first letter \\'a\\' in order to begin with algorithm and we have to take care of last char seprately\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int cnt=0;\\n        if(word[0]!=\\'a\\'){\\n            word=\"a\"+word;\\n            cnt++;\\n        }\\n        int n=word.size();\\n        for(int i=0;i<n-1;i++){\\n            if(word[i]==\\'a\\'){\\n                if(word[i+1]==\\'a\\')cnt+=2;\\n                if(word[i+1]==\\'c\\')cnt+=1;\\n            }\\n            if(word[i]==\\'b\\'){\\n                if(word[i+1]==\\'b\\')cnt+=2;\\n                if(word[i+1]==\\'a\\')cnt+=1;\\n            }\\n            if(word[i]==\\'c\\'){\\n                if(word[i+1]==\\'c\\')cnt+=2;\\n                if(word[i+1]==\\'b\\')cnt+=1;\\n            }\\n        }\\n        if(word[n-1]==\\'a\\')cnt+=2;\\n        if(word[n-1]==\\'b\\')cnt+=1;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int cnt=0;\\n        if(word[0]!=\\'a\\'){\\n            word=\"a\"+word;\\n            cnt++;\\n        }\\n        int n=word.size();\\n        for(int i=0;i<n-1;i++){\\n            if(word[i]==\\'a\\'){\\n                if(word[i+1]==\\'a\\')cnt+=2;\\n                if(word[i+1]==\\'c\\')cnt+=1;\\n            }\\n            if(word[i]==\\'b\\'){\\n                if(word[i+1]==\\'b\\')cnt+=2;\\n                if(word[i+1]==\\'a\\')cnt+=1;\\n            }\\n            if(word[i]==\\'c\\'){\\n                if(word[i+1]==\\'c\\')cnt+=2;\\n                if(word[i+1]==\\'b\\')cnt+=1;\\n            }\\n        }\\n        if(word[n-1]==\\'a\\')cnt+=2;\\n        if(word[n-1]==\\'b\\')cnt+=1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422302,
                "title": "easy-and-simple-c-solution",
                "content": "# Approach\\n1. First store the count of abc, ab, bc, ac ,a,b,c patterns in the map.\\n2. And then count the remaining letters from the patterns to make  string \"abc\".\\n3. Then return the no. of count.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            string t=\"\";\\n            int ind=s[i]-\\'a\\';\\n            t=t+s[i];\\n            int index=i;\\n            for(int j=i+1;j<index+3 && j<s.size();j++){\\n                \\n                // handle \\'a\\' and then \\'c\\' patterns\\n                  if(s[i]==\\'a\\'&&s[j]-\\'a\\'==ind+2){\\n                    t=t+s[j];\\n                    i++;\\n                    break;\\n                }\\n\\n                //handle \"a\",\"b\",\"c\",\"ab\",\"bc\" and \"abc\" kind of patterns\\n                if(s[j]-\\'a\\'==ind+1){\\n                    t=t+s[j];\\n                    ind++;\\n                    i++;\\n                }else break;\\n            }\\n            mp[t]++;\\n        }\\n        int ans=0;\\n        // And then count remaining letters of different patterns to make \"abc\" string\\n        for(auto it:mp){\\n            if(it.first.size()==3)continue;\\n            else if(it.first.size()==2)ans=ans+it.second;\\n            else ans=ans+(it.second*2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            string t=\"\";\\n            int ind=s[i]-\\'a\\';\\n            t=t+s[i];\\n            int index=i;\\n            for(int j=i+1;j<index+3 && j<s.size();j++){\\n                \\n                // handle \\'a\\' and then \\'c\\' patterns\\n                  if(s[i]==\\'a\\'&&s[j]-\\'a\\'==ind+2){\\n                    t=t+s[j];\\n                    i++;\\n                    break;\\n                }\\n\\n                //handle \"a\",\"b\",\"c\",\"ab\",\"bc\" and \"abc\" kind of patterns\\n                if(s[j]-\\'a\\'==ind+1){\\n                    t=t+s[j];\\n                    ind++;\\n                    i++;\\n                }else break;\\n            }\\n            mp[t]++;\\n        }\\n        int ans=0;\\n        // And then count remaining letters of different patterns to make \"abc\" string\\n        for(auto it:mp){\\n            if(it.first.size()==3)continue;\\n            else if(it.first.size()==2)ans=ans+it.second;\\n            else ans=ans+(it.second*2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422290,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn add_minimum(word: String) -> i32 {\\n        let words: Vec<char> = word.chars().collect();\\n        let mut dp = vec![2; words.len()];\\n        for i in 1..words.len() {\\n            if words[i] > words[i - 1] {\\n                dp[i] = dp[i - 1] - 1;\\n            } else {\\n                dp[i] = dp[i - 1] + 2;\\n            }\\n        }\\n        dp[dp.len() - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn add_minimum(word: String) -> i32 {\\n        let words: Vec<char> = word.chars().collect();\\n        let mut dp = vec![2; words.len()];\\n        for i in 1..words.len() {\\n            if words[i] > words[i - 1] {\\n                dp[i] = dp[i - 1] - 1;\\n            } else {\\n                dp[i] = dp[i - 1] + 2;\\n            }\\n        }\\n        dp[dp.len() - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422274,
                "title": "java-easy-o-n-sliding-window-easy-solution",
                "content": "upvote if you like\\n```\\n\\nclass Solution {\\n    public int addMinimum(String word) {\\n        HashMap<String,Integer>map= new HashMap<>();\\n        map.put(\"a\",2);\\n        map.put(\"ab\",1);\\n        map.put(\"ac\",1);\\n        map.put(\"abc\",0);\\n        map.put(\"b\",2);\\n        map.put(\"bc\",1);\\n        map.put(\"c\",2);\\n      //  map.put(\"\",0);\\n        int i=0;\\n       // int k=0;\\n        int sum=0;\\n        String temp=\"\";\\n        int k=0;\\n            while(i<word.length())\\n            {\\n                int l=0;\\n                  temp=word.substring(k,k+1);\\n                while(map.containsKey(temp))\\n                {\\n                    i++;\\n                     if(i==word.length()) \\n                    {\\n                       // temp=word.substring(k,i);\\n                        l++;\\n                        break;\\n                    }\\n                    temp=word.substring(k,i+1);\\n                   \\n                }\\n                if(l>0)\\n                {\\n                    sum+=map.get(temp);\\n                }\\n                else\\n                {\\n                String ans=word.substring(k,i);\\n                    sum+=map.get(ans);\\n                   ;\\n                    k=i;\\n                   \\n                }\\n            }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int addMinimum(String word) {\\n        HashMap<String,Integer>map= new HashMap<>();\\n        map.put(\"a\",2);\\n        map.put(\"ab\",1);\\n        map.put(\"ac\",1);\\n        map.put(\"abc\",0);\\n        map.put(\"b\",2);\\n        map.put(\"bc\",1);\\n        map.put(\"c\",2);\\n      //  map.put(\"\",0);\\n        int i=0;\\n       // int k=0;\\n        int sum=0;\\n        String temp=\"\";\\n        int k=0;\\n            while(i<word.length())\\n            {\\n                int l=0;\\n                  temp=word.substring(k,k+1);\\n                while(map.containsKey(temp))\\n                {\\n                    i++;\\n                     if(i==word.length()) \\n                    {\\n                       // temp=word.substring(k,i);\\n                        l++;\\n                        break;\\n                    }\\n                    temp=word.substring(k,i+1);\\n                   \\n                }\\n                if(l>0)\\n                {\\n                    sum+=map.get(temp);\\n                }\\n                else\\n                {\\n                String ans=word.substring(k,i);\\n                    sum+=map.get(ans);\\n                   ;\\n                    k=i;\\n                   \\n                }\\n            }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422266,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            st.push(word[i]);\\n        }\\n        int count=0;\\n        while(!st.empty())\\n        {\\n            if(!st.empty()&&st.top()==\\'c\\')\\n            st.pop();\\n            else\\n            count++;\\n            if(!st.empty()&&st.top()==\\'b\\'){\\n                      st.pop();\\n            } \\n            else\\n            count++;\\n            if(!st.empty()&&st.top()==\\'a\\')\\n            st.pop();\\n            else\\n            count++;\\n            if(st.empty())\\n            break;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            st.push(word[i]);\\n        }\\n        int count=0;\\n        while(!st.empty())\\n        {\\n            if(!st.empty()&&st.top()==\\'c\\')\\n            st.pop();\\n            else\\n            count++;\\n            if(!st.empty()&&st.top()==\\'b\\'){\\n                      st.pop();\\n            } \\n            else\\n            count++;\\n            if(!st.empty()&&st.top()==\\'a\\')\\n            st.pop();\\n            else\\n            count++;\\n            if(st.empty())\\n            break;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422135,
                "title": "simple-and-easy-structured-java-solution",
                "content": "# Approach\\nIn this solution, we check for the following things:\\n```\\n - if element is a, \\n check if it is followed by bc -> ans+0 | \"abc\"\\n if followed by only b or only c -> ans+1 | \"ab\"/\"ac\"\\n if followed by none -> ans+2 | \"a\"\\n\\n - if element is b,\\n  check if it is followed by c -> ans+1 | \"bc\"\\n  else -> ans+2 | \"b\"\\n\\n - if element is c -> ans+2 | \"c\"\\n\\n```\\nNOTE: Conditions for b and c are less because they\\'re already covered in the conditions above them.\\n\\n ALSO: once we\\'ve checked the element is a following one, we do not iterate to it again, Hence, we need to update `i` pointer accordingly.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans=0;\\n        for(int i=0;i<word.length();i++){\\n            if(word.charAt(i)==\\'a\\'){\\n                if(i+1<word.length() && word.charAt(i+1)==\\'b\\'){\\n                    if(i+2<word.length() && word.charAt(i+2)==\\'c\\')\\n                        i+=2;\\n                    else{\\n                        ans++;\\n                        i++;\\n                    }\\n                }\\n                else if(i+1<word.length() && word.charAt(i+1)==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else\\n                    ans+=2;\\n            }\\n            else if(word.charAt(i)==\\'b\\'){\\n                if(i+1<word.length() && word.charAt(i+1)==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n            else\\n                ans+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n - if element is a, \\n check if it is followed by bc -> ans+0 | \"abc\"\\n if followed by only b or only c -> ans+1 | \"ab\"/\"ac\"\\n if followed by none -> ans+2 | \"a\"\\n\\n - if element is b,\\n  check if it is followed by c -> ans+1 | \"bc\"\\n  else -> ans+2 | \"b\"\\n\\n - if element is c -> ans+2 | \"c\"\\n\\n```\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans=0;\\n        for(int i=0;i<word.length();i++){\\n            if(word.charAt(i)==\\'a\\'){\\n                if(i+1<word.length() && word.charAt(i+1)==\\'b\\'){\\n                    if(i+2<word.length() && word.charAt(i+2)==\\'c\\')\\n                        i+=2;\\n                    else{\\n                        ans++;\\n                        i++;\\n                    }\\n                }\\n                else if(i+1<word.length() && word.charAt(i+1)==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else\\n                    ans+=2;\\n            }\\n            else if(word.charAt(i)==\\'b\\'){\\n                if(i+1<word.length() && word.charAt(i+1)==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n            else\\n                ans+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422078,
                "title": "c-easy-intuitive-approach-generalized-for-string-length-abc-but-in-lex-order",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep string \"abc\" and match somehow \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep given string w=\"abc\"\\nand at index i, string matching it with w\\nsuppose matching at \\n\"abc\"\\n\\n\"a b b c c a a c\"\\n 0 1 2 3 4 5 6 7\\na matches with a, we increment both counters, b matches with b, again increment, but b and c does not match, so we **determine the count**=2 matched characters.\\n\\nNext **directly move to 2nd index** as 1st index is already included in previous match \\n\\nNow, we are not only incrementing counters when character of w matches with word, but when character of word is **greater than w\\'s character also**,\\n\\n**word[j]>=w[k]**\\n\\nConsider next iteration\\nwe get after matching \"bc\"\\nwe only have to add \"a\" to it.\\n\\nanother example at 6th index, we will get \"ac\" after matching as\\na matched with a \\nb matched with c as **c>=b**\\n\\nHere we only have to insert \"a\" in between.\\n\\n **Also consider,** \\nthe condition word[j]>=w[k] might repeat characters, as \\n\\nabc will get matched with \"bb\" as\\na with b as b>=a\\nb with b as b>=b\\n\\nabc will get matched with \"cb\" as\\na with c as c>=a\\nb with b as b>=b\\n\\nwhich is **wrong**\\nSo make sure while matching,\\n1. **same character does not gets repeated** \\n2. **they do not get matched in decreasing order**\\n\\ntherefore I added the condition :  if(j>i && word[j-1]>=word[j]) break;\\n\\nOnce determined the count at an iteration, subtract it with length of \"abc\" and add it to final Answer\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string w=\"abc\";\\n        int ans=0;\\n        for(int i=0;i<word.size();i++){\\n            int j=i;\\n            int k=0;\\n            \\n            while(j<word.size() && k<3 && word[j]>=w[k]){\\n                if(j>i && word[j-1]>=word[j]) break;\\n                j++;\\n                k++;\\n            }\\n            int cnt=j-i;\\n            if(j-i<=1) ans+=2;\\n            else if(j-i==2) ans+=1;\\n            if(j>i+1) i=j-1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string w=\"abc\";\\n        int ans=0;\\n        for(int i=0;i<word.size();i++){\\n            int j=i;\\n            int k=0;\\n            \\n            while(j<word.size() && k<3 && word[j]>=w[k]){\\n                if(j>i && word[j-1]>=word[j]) break;\\n                j++;\\n                k++;\\n            }\\n            int cnt=j-i;\\n            if(j-i<=1) ans+=2;\\n            else if(j-i==2) ans+=1;\\n            if(j>i+1) i=j-1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421993,
                "title": "c-o-n-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count=0;\\n        int n=word.size();\\n        if(n==1)\\n        {\\n            return 2;\\n        }\\n     \\n        for(int i=0;i<n;i++)\\n        {   \\n            \\n            if(i==n-1 && i>=1)\\n            {\\n                if(word[i]==\\'a\\')\\n                {\\n                  count+=2;\\n                    continue;\\n                }\\n                else if(word[i]==\\'b\\')\\n                {\\n                   count+=1;\\n                }\\n            \\n                    \\n            }\\n            else{\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'a\\')count+=2;\\n                else if(word[i+1]==\\'b\\')continue;\\n                else if(word[i+1]==\\'c\\')count+=1;\\n                //cout<<\"yes\"<<endl;\\n            }\\n            if(word[i]==\\'b\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(word[i+1]==\\'c\\')count+=1;\\n                    else if(word[i+1]==\\'b\\')count+=3;\\n                    else if(word[i+1]==\\'a\\')count+=2;\\n                }\\n                else if(i>0)\\n                {\\n                    if(word[i]==\\'c\\')continue;\\n                    else if(word[i+1]==\\'b\\')count+=2;\\n                    else if(word[i+1]==\\'a\\')count+=1;\\n                }\\n            }\\n            if(word[i]==\\'c\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(word[i+1]==\\'a\\')count+=2;\\n                    else if(word[i+1]==\\'b\\')count+=3;\\n                    else if(word[i+1]==\\'c\\')count+=4;\\n                }\\n                else if(i>0)\\n                {\\n                    if(word[i+1]==\\'a\\')continue;\\n                    else if(word[i+1]==\\'b\\')count+=1;\\n                    else if(word[i+1]==\\'c\\')count+=2;\\n                }\\n            }\\n            \\n        }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count=0;\\n        int n=word.size();\\n        if(n==1)\\n        {\\n            return 2;\\n        }\\n     \\n        for(int i=0;i<n;i++)\\n        {   \\n            \\n            if(i==n-1 && i>=1)\\n            {\\n                if(word[i]==\\'a\\')\\n                {\\n                  count+=2;\\n                    continue;\\n                }\\n                else if(word[i]==\\'b\\')\\n                {\\n                   count+=1;\\n                }\\n            \\n                    \\n            }\\n            else{\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'a\\')count+=2;\\n                else if(word[i+1]==\\'b\\')continue;\\n                else if(word[i+1]==\\'c\\')count+=1;\\n                //cout<<\"yes\"<<endl;\\n            }\\n            if(word[i]==\\'b\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(word[i+1]==\\'c\\')count+=1;\\n                    else if(word[i+1]==\\'b\\')count+=3;\\n                    else if(word[i+1]==\\'a\\')count+=2;\\n                }\\n                else if(i>0)\\n                {\\n                    if(word[i]==\\'c\\')continue;\\n                    else if(word[i+1]==\\'b\\')count+=2;\\n                    else if(word[i+1]==\\'a\\')count+=1;\\n                }\\n            }\\n            if(word[i]==\\'c\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(word[i+1]==\\'a\\')count+=2;\\n                    else if(word[i+1]==\\'b\\')count+=3;\\n                    else if(word[i+1]==\\'c\\')count+=4;\\n                }\\n                else if(i>0)\\n                {\\n                    if(word[i+1]==\\'a\\')continue;\\n                    else if(word[i+1]==\\'b\\')count+=1;\\n                    else if(word[i+1]==\\'c\\')count+=2;\\n                }\\n            }\\n            \\n        }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3421970,
                "title": "c-solutions-beginner-friendly-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char now=\\'a\\';\\n        int ans=0;\\n        for(auto it:word){\\n            while(now!=it){\\n                ans++;\\n                now=now+1;\\n                if(now==\\'d\\')now=\\'a\\';\\n            }\\n            now=now+1;\\n            if(now==\\'d\\')now=\\'a\\';\\n        }\\n        while(now!=\\'a\\'){\\n            ans++;\\n            now=now+1;\\n            if(now==\\'d\\')now=\\'a\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char now=\\'a\\';\\n        int ans=0;\\n        for(auto it:word){\\n            while(now!=it){\\n                ans++;\\n                now=now+1;\\n                if(now==\\'d\\')now=\\'a\\';\\n            }\\n            now=now+1;\\n            if(now==\\'d\\')now=\\'a\\';\\n        }\\n        while(now!=\\'a\\'){\\n            ans++;\\n            now=now+1;\\n            if(now==\\'d\\')now=\\'a\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421926,
                "title": "c-stack-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int cnt=0;\\n        map<char, int>m;\\n        for(int i=0; i<w.size(); i++){\\n            m[w[i]]++;\\n        }\\n        if(w.size()==1){return 2;}\\n        if(w.size()==2){\\n            if(m.size()==1){\\n                return 4;\\n            }\\n            else{\\n                if(w[0]>w[1]){\\n                    return 4;\\n                }\\n                else{\\n                    return 1;\\n                }\\n            }\\n        }\\n        stack<char>s;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.empty()){\\n                if(w[i]==\\'a\\'){\\n                    s.push(w[i]);\\n                }\\n                else if(w[i]==\\'b\\'){\\n                    cnt++;\\n                    s.push(w[i]);\\n                }\\n                else{\\n                    cnt+=2;\\n                }\\n            }\\n            else{\\n                if(w[i]-s.top()==2){\\n                    cnt++;\\n                    s.pop();\\n                }\\n                else if(w[i]-s.top()==1){\\n                    s.push(w[i]);\\n                    if(w[i]==\\'c\\'){\\n                        while(!s.empty()){s.pop();}\\n                    }\\n                }\\n                else if(w[i]-s.top()==0){\\n                    cnt+=2;\\n                    while(!s.empty()){s.pop();}\\n                    s.push(w[i]);\\n                }\\n                else{\\n                    cnt++;\\n                    while(!s.empty()){\\n                        s.pop();\\n                    }\\n                    s.push(w[i]);\\n                }\\n            }\\n        }\\n        cout<<cnt<<endl;\\n        if(!s.empty()){\\n            cout<<s.top()<<endl;\\n            if(s.top()==\\'a\\'){cnt+=2;}\\n            else if(s.top()==\\'b\\'){cnt++;}\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int cnt=0;\\n        map<char, int>m;\\n        for(int i=0; i<w.size(); i++){\\n            m[w[i]]++;\\n        }\\n        if(w.size()==1){return 2;}\\n        if(w.size()==2){\\n            if(m.size()==1){\\n                return 4;\\n            }\\n            else{\\n                if(w[0]>w[1]){\\n                    return 4;\\n                }\\n                else{\\n                    return 1;\\n                }\\n            }\\n        }\\n        stack<char>s;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.empty()){\\n                if(w[i]==\\'a\\'){\\n                    s.push(w[i]);\\n                }\\n                else if(w[i]==\\'b\\'){\\n                    cnt++;\\n                    s.push(w[i]);\\n                }\\n                else{\\n                    cnt+=2;\\n                }\\n            }\\n            else{\\n                if(w[i]-s.top()==2){\\n                    cnt++;\\n                    s.pop();\\n                }\\n                else if(w[i]-s.top()==1){\\n                    s.push(w[i]);\\n                    if(w[i]==\\'c\\'){\\n                        while(!s.empty()){s.pop();}\\n                    }\\n                }\\n                else if(w[i]-s.top()==0){\\n                    cnt+=2;\\n                    while(!s.empty()){s.pop();}\\n                    s.push(w[i]);\\n                }\\n                else{\\n                    cnt++;\\n                    while(!s.empty()){\\n                        s.pop();\\n                    }\\n                    s.push(w[i]);\\n                }\\n            }\\n        }\\n        cout<<cnt<<endl;\\n        if(!s.empty()){\\n            cout<<s.top()<<endl;\\n            if(s.top()==\\'a\\'){cnt+=2;}\\n            else if(s.top()==\\'b\\'){cnt++;}\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3421918,
                "title": "one-pass-c-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int addMinimum(string str) {\\n        int a = 0, b = 0, c = 0, ans = 0;\\n        int i = 0, n = str.length();\\n        if(n==1)return 2;\\n        for(i = 0; i < n; i++){\\n            if(str[i]==\\'a\\'){\\n                if(i+1<n&&str[i+1]==\\'b\\'){\\n                    if(i+2<n&&str[i+2]==\\'c\\'){\\n                        i++;\\n                    }else{\\n                        ans++;\\n                    }\\n                    i++;\\n                }else if(i+1<n&&str[i+1]==\\'a\\'){\\n                    ans += 2;\\n                }else if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'b\\'){\\n                if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else if(i+1<n&&str[i+1]!=\\'c\\'){\\n                    ans += 2;\\n                }else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'c\\'){\\n                ans += 2;\\n            }\\n            cout<<ans<<\" \";\\n        }\\n        // if(str[n-1]==\\'a\\')ans += 2;\\n        // if(n-2>=0&&str[n-1]==\\'b\\'&&str[n-2]==\\'a\\')ans++;\\n        // if(n-2>=0&&str[n-1]==\\'b\\'&&str[n-2]!=\\'a\\')ans += 2;\\n        // if(n-2>0&&str[n-1]==\\'c\\'&&str[n-2]!=\\'c\\')ans += 2;\\n            return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int addMinimum(string str) {\\n        int a = 0, b = 0, c = 0, ans = 0;\\n        int i = 0, n = str.length();\\n        if(n==1)return 2;\\n        for(i = 0; i < n; i++){\\n            if(str[i]==\\'a\\'){\\n                if(i+1<n&&str[i+1]==\\'b\\'){\\n                    if(i+2<n&&str[i+2]==\\'c\\'){\\n                        i++;\\n                    }else{\\n                        ans++;\\n                    }\\n                    i++;\\n                }else if(i+1<n&&str[i+1]==\\'a\\'){\\n                    ans += 2;\\n                }else if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'b\\'){\\n                if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else if(i+1<n&&str[i+1]!=\\'c\\'){\\n                    ans += 2;\\n                }else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'c\\'){\\n                ans += 2;\\n            }\\n            cout<<ans<<\" \";\\n        }\\n        // if(str[n-1]==\\'a\\')ans += 2;\\n        // if(n-2>=0&&str[n-1]==\\'b\\'&&str[n-2]==\\'a\\')ans++;\\n        // if(n-2>=0&&str[n-1]==\\'b\\'&&str[n-2]!=\\'a\\')ans += 2;\\n        // if(n-2>0&&str[n-1]==\\'c\\'&&str[n-2]!=\\'c\\')ans += 2;\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3421870,
                "title": "easy-to-understand-c",
                "content": "\\n\\n\\n# Approach\\nFirst we will look for \\'a\\' and if it is found we will look for further \\'b\\' and \\'c\\'. If \\'b\\' is found on next index we will increment our temp by 1 and also if \\'c\\' is also found on next to next index again we will increment temp by 1.\\n\\nSimilarly if \\'b\\' is found we will look for \\'c\\' and if \\'c\\' is found on next index we will increment temp by 1.\\n\\nFor \\'c\\' there is no need for looking for any character.\\n\\nadd+= (3-temp) in every if else gives required additions we need to perform\\n\\n# Complexity\\n- Time complexity:\\nO(N)  --> N is length of string\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int add=0;\\n        \\n        for(int i=0; i<word.size(); i++){\\n\\n            if(word[i]==\\'a\\'){\\n\\n                int temp=1;\\n\\n                if(i+1<word.size() && word[i+1]==\\'b\\'){\\n                    temp++;\\n                    i++;\\n\\n                    if (i+1<word.size() && word[i+1]==\\'c\\')\\n                    {\\n                        temp++;\\n                        i++;\\n                    }\\n                    \\n                }\\n                else if(i+1<word.size() && word[i+1]==\\'c\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                \\n\\n                add+=3-temp;\\n            }\\n\\n            else if (word[i]==\\'b\\')\\n            {\\n                int temp=1;\\n\\n                if(i+1<word.size() && word[i+1]==\\'c\\'){\\n                    temp++;\\n                    i++;\\n                }\\n\\n                add+=3-temp;\\n            }\\n\\n            else if(word[i]==\\'c\\'){\\n                int temp=1;\\n\\n                add+=3-temp;\\n            }\\n            \\n        }\\n\\n        return add;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int add=0;\\n        \\n        for(int i=0; i<word.size(); i++){\\n\\n            if(word[i]==\\'a\\'){\\n\\n                int temp=1;\\n\\n                if(i+1<word.size() && word[i+1]==\\'b\\'){\\n                    temp++;\\n                    i++;\\n\\n                    if (i+1<word.size() && word[i+1]==\\'c\\')\\n                    {\\n                        temp++;\\n                        i++;\\n                    }\\n                    \\n                }\\n                else if(i+1<word.size() && word[i+1]==\\'c\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                \\n\\n                add+=3-temp;\\n            }\\n\\n            else if (word[i]==\\'b\\')\\n            {\\n                int temp=1;\\n\\n                if(i+1<word.size() && word[i+1]==\\'c\\'){\\n                    temp++;\\n                    i++;\\n                }\\n\\n                add+=3-temp;\\n            }\\n\\n            else if(word[i]==\\'c\\'){\\n                int temp=1;\\n\\n                add+=3-temp;\\n            }\\n            \\n        }\\n\\n        return add;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421798,
                "title": "python-saving-last-seen-letter",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        last = \"c\"\\n        res = 0\\n        \\n        for letter in word:\\n            if letter == \"a\":\\n                if last != \"c\":\\n                    if last == \"a\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            elif letter == \"b\":\\n                if last != \"a\":\\n                    if last == \"b\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            else:\\n                if last != \"b\":\\n                    if last == \"c\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            last = letter\\n        \\n        if last == \"a\":\\n            res += 2\\n        elif last == \"b\":\\n            res += 1\\n        \\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        last = \"c\"\\n        res = 0\\n        \\n        for letter in word:\\n            if letter == \"a\":\\n                if last != \"c\":\\n                    if last == \"a\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            elif letter == \"b\":\\n                if last != \"a\":\\n                    if last == \"b\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            else:\\n                if last != \"b\":\\n                    if last == \"c\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            last = letter\\n        \\n        if last == \"a\":\\n            res += 2\\n        elif last == \"b\":\\n            res += 1\\n        \\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421723,
                "title": "java-two-pointers-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int addMinimum(String word) {\\n         int c=0;\\n         char[] m = {\\'a\\',\\'b\\',\\'c\\'};\\n         int i=0, j=0;\\n         while(i<word.length()){\\n             if(word.charAt(i)==m[j%3]){\\n                 i++;\\n             }\\n             else{\\n                 c++;\\n             }\\n             j++;\\n         }\\n         char last = (word.charAt(word.length()-1));\\n         if(last==\\'a\\'){\\n             return c+2;\\n         }\\n         if(last==\\'b\\'){\\n            return c+1;\\n         }\\n         return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int addMinimum(String word) {\\n         int c=0;\\n         char[] m = {\\'a\\',\\'b\\',\\'c\\'};\\n         int i=0, j=0;\\n         while(i<word.length()){\\n             if(word.charAt(i)==m[j%3]){\\n                 i++;\\n             }\\n             else{\\n                 c++;\\n             }\\n             j++;\\n         }\\n         char last = (word.charAt(word.length()-1));\\n         if(last==\\'a\\'){\\n             return c+2;\\n         }\\n         if(last==\\'b\\'){\\n            return c+1;\\n         }\\n         return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421706,
                "title": "python3-one-pass-o-n-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n = len(word)\\n        ans, curr = 0, 1\\n        for i in range(n):\\n            if i + 1 < n and word[i] < word[i + 1]:\\n                curr += 1\\n            else:\\n                ans += 3 - curr\\n                curr = 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n = len(word)\\n        ans, curr = 0, 1\\n        for i in range(n):\\n            if i + 1 < n and word[i] < word[i + 1]:\\n                curr += 1\\n            else:\\n                ans += 3 - curr\\n                curr = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421703,
                "title": "10-line-simple-python-solution-two-pointers",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:        \\n        s = \"abc\"\\n        i,j,count = 0, 0, 0\\n        while j < len(word) :\\n            if i == 3 :\\n                i = 0\\n            if word[j] != s[i] :\\n                count += 1\\n            else :\\n                j += 1\\n            i += 1\\n        return count + (3-i)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:        \\n        s = \"abc\"\\n        i,j,count = 0, 0, 0\\n        while j < len(word) :\\n            if i == 3 :\\n                i = 0\\n            if word[j] != s[i] :\\n                count += 1\\n            else :\\n                j += 1\\n            i += 1\\n        return count + (3-i)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421699,
                "title": "easy-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        if(word.length() == 1)\\n        {\\n            return 2;\\n        }\\n        int count = 0;\\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            if(i != word.length()-1)\\n            {\\n                if(word[i] == \\'a\\' && word[i+1] == \\'b\\')\\n                {\\n\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'c\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                else if(word[i] == \\'a\\' && word[i+1] == \\'c\\')\\n                {\\n                    count++;\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'a\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 2;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }            \\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'b\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 3;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }\\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'a\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 2;\\n                    }\\n                    else\\n                    {\\n                        \\n                    }\\n                }\\n                else if(word[i] == \\'a\\' && word[i+1] == \\'a\\')\\n                {\\n                    count = count + 2;\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'b\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 3;\\n                    }\\n                    else\\n                    {\\n                        count = count + 2;\\n                    }\\n                    \\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'c\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 4;\\n                    }\\n                    else\\n                    {\\n                        count = count + 2;\\n                    }\\n                    \\n                }\\n            }\\n            else\\n            {\\n                if(word[i] == \\'a\\')\\n                {\\n                    count = count+2;\\n                }\\n                else if(word[i] == \\'b\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        if(word.length() == 1)\\n        {\\n            return 2;\\n        }\\n        int count = 0;\\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            if(i != word.length()-1)\\n            {\\n                if(word[i] == \\'a\\' && word[i+1] == \\'b\\')\\n                {\\n\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'c\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                else if(word[i] == \\'a\\' && word[i+1] == \\'c\\')\\n                {\\n                    count++;\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'a\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 2;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }            \\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'b\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 3;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }\\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'a\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 2;\\n                    }\\n                    else\\n                    {\\n                        \\n                    }\\n                }\\n                else if(word[i] == \\'a\\' && word[i+1] == \\'a\\')\\n                {\\n                    count = count + 2;\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'b\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 3;\\n                    }\\n                    else\\n                    {\\n                        count = count + 2;\\n                    }\\n                    \\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'c\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 4;\\n                    }\\n                    else\\n                    {\\n                        count = count + 2;\\n                    }\\n                    \\n                }\\n            }\\n            else\\n            {\\n                if(word[i] == \\'a\\')\\n                {\\n                    count = count+2;\\n                }\\n                else if(word[i] == \\'b\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421691,
                "title": "c-o-n-6-simple-condition",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0,x=0;\\n        int i=0;\\n        while(i<word.size()){\\n            if(x==0 && word[i]==\\'a\\') i+=1;\\n            else if(x==0 && word[i]!=\\'a\\') ans+=1;\\n            else if(x==1 && word[i]==\\'b\\') i+=1;\\n            else if(x==1 && word[i]!=\\'b\\') ans+=1;\\n            else if(x==2 && word[i]==\\'c\\') i+=1;\\n            else if(x==2 && word[i]!=\\'c\\') ans+=1;\\n            x = (x+1)%3;\\n        }\\n        if(x!=0) ans += (3-x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0,x=0;\\n        int i=0;\\n        while(i<word.size()){\\n            if(x==0 && word[i]==\\'a\\') i+=1;\\n            else if(x==0 && word[i]!=\\'a\\') ans+=1;\\n            else if(x==1 && word[i]==\\'b\\') i+=1;\\n            else if(x==1 && word[i]!=\\'b\\') ans+=1;\\n            else if(x==2 && word[i]==\\'c\\') i+=1;\\n            else if(x==2 && word[i]!=\\'c\\') ans+=1;\\n            x = (x+1)%3;\\n        }\\n        if(x!=0) ans += (3-x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088680,
                "title": "2-methods-minimum-additions-to-make-valid-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Traversal of the given string\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i, count=0;\\n\\n        for(i=0 ; i<word.length() ; i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(i<word.length()-1)\\n                {\\n                    if(word[i+1]==\\'a\\')\\n                        count += 2;\\n                    else if(word[i+1]==\\'c\\')\\n                        count++;\\n                }\\n                else\\n                    count += 2;\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(i>0 && i<word.length()-1)\\n                {\\n                    if(word[i-1]!=\\'a\\')\\n                        count++;\\n                    if(word[i+1]!=\\'c\\')\\n                        count++;\\n                }\\n                else\\n                {\\n                    if(i==0 && i==word.length()-1)\\n                        count += 2;\\n                    else if(i==0 && i<word.length()-1 && word[i+1]!=\\'c\\')\\n                        count += 2;\\n                    else if(i==0 && i<word.length()-1 && word[i+1]==\\'c\\')\\n                        count += 1;\\n                    else if(i>0 && i==word.length()-1 && word[i-1]!=\\'a\\')\\n                        count += 2;\\n                    else if(i>0 && i==word.length()-1 && word[i-1]==\\'a\\')\\n                        count += 1;\\n                }\\n            }\\n            else if(word[i]==\\'c\\')\\n            {\\n                if(i>0)\\n                {\\n                    if(word[i-1]==\\'c\\')\\n                        count += 2;\\n                }\\n                else\\n                    count += 2;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\nOptimum Approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0, ans=0;\\n        while(i<word.size())\\n        {\\n            if(word[i]==\\'a\\')\\n                i++;\\n            else\\n                ans++;\\n            if(word[i]==\\'b\\')\\n                i++;\\n            else\\n                ans++;\\n            if(word[i]==\\'c\\')\\n                i++;\\n            else\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/b4ee092c-6ff8-43c2-acb2-b6d398639553_1695646639.0620859.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i, count=0;\\n\\n        for(i=0 ; i<word.length() ; i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(i<word.length()-1)\\n                {\\n                    if(word[i+1]==\\'a\\')\\n                        count += 2;\\n                    else if(word[i+1]==\\'c\\')\\n                        count++;\\n                }\\n                else\\n                    count += 2;\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(i>0 && i<word.length()-1)\\n                {\\n                    if(word[i-1]!=\\'a\\')\\n                        count++;\\n                    if(word[i+1]!=\\'c\\')\\n                        count++;\\n                }\\n                else\\n                {\\n                    if(i==0 && i==word.length()-1)\\n                        count += 2;\\n                    else if(i==0 && i<word.length()-1 && word[i+1]!=\\'c\\')\\n                        count += 2;\\n                    else if(i==0 && i<word.length()-1 && word[i+1]==\\'c\\')\\n                        count += 1;\\n                    else if(i>0 && i==word.length()-1 && word[i-1]!=\\'a\\')\\n                        count += 2;\\n                    else if(i>0 && i==word.length()-1 && word[i-1]==\\'a\\')\\n                        count += 1;\\n                }\\n            }\\n            else if(word[i]==\\'c\\')\\n            {\\n                if(i>0)\\n                {\\n                    if(word[i-1]==\\'c\\')\\n                        count += 2;\\n                }\\n                else\\n                    count += 2;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0, ans=0;\\n        while(i<word.size())\\n        {\\n            if(word[i]==\\'a\\')\\n                i++;\\n            else\\n                ans++;\\n            if(word[i]==\\'b\\')\\n                i++;\\n            else\\n                ans++;\\n            if(word[i]==\\'c\\')\\n                i++;\\n            else\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087932,
                "title": "basic-approach-with-70-using-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        string=\\'abc\\'\\n        count=0\\n        i=0\\n        if not word:\\n            return count\\n        count+=string.index(word[i])\\n        index=0\\n        while i<len(word)-1:\\n            index=string.index(word[i])\\n            next_index=(index+1)%3\\n            if string[next_index]!=word[i+1]:\\n                count+=1\\n                word=word[:i+1]+string[next_index]+word[i+1:]\\n            i+=1\\n        if word[-1]==\\'a\\':\\n            count+=2\\n        elif word[-1]==\\'b\\':\\n            count+=1\\n        return count\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        string=\\'abc\\'\\n        count=0\\n        i=0\\n        if not word:\\n            return count\\n        count+=string.index(word[i])\\n        index=0\\n        while i<len(word)-1:\\n            index=string.index(word[i])\\n            next_index=(index+1)%3\\n            if string[next_index]!=word[i+1]:\\n                count+=1\\n                word=word[:i+1]+string[next_index]+word[i+1:]\\n            i+=1\\n        if word[-1]==\\'a\\':\\n            count+=2\\n        elif word[-1]==\\'b\\':\\n            count+=1\\n        return count\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074813,
                "title": "c-simple-solution-in-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTravesring string and checking for requirement\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversing the string and checking if \\'abc\\' is there, go to i+3 index. If \\'ab\\' or \\'ac\\' or \\'bc\\' is there, increment ans by 1 and go to i+2 index. if none of them is there then we need to increment ans by 2 and go to i+1 index.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(i+2<word.size() && word[i]==\\'a\\' && word[i+1]==\\'b\\' && word[i+2]==\\'c\\')\\n            {\\n                i+=2;\\n                continue;\\n            }\\n            else\\n            {\\n                if(i+1 < word.size() && word[i]==\\'a\\' && word[i+1]==\\'b\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else if(i+1 < word.size() && word[i]==\\'a\\' && word[i+1]==\\'c\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else if(i+1 < word.size() && word[i]==\\'b\\' && word[i+1]==\\'c\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else\\n                {\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you liked solution",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(i+2<word.size() && word[i]==\\'a\\' && word[i+1]==\\'b\\' && word[i+2]==\\'c\\')\\n            {\\n                i+=2;\\n                continue;\\n            }\\n            else\\n            {\\n                if(i+1 < word.size() && word[i]==\\'a\\' && word[i+1]==\\'b\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else if(i+1 < word.size() && word[i]==\\'a\\' && word[i+1]==\\'c\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else if(i+1 < word.size() && word[i]==\\'b\\' && word[i+1]==\\'c\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else\\n                {\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054576,
                "title": "python3-solution-beginner-friendly",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        s = [\"a\", \"b\", \"c\"]\\n        i, count = 0, 0\\n        while i < len(word):\\n            for char in s:\\n                if i < len(word) and char == word[i]:\\n                    i += 1\\n                else:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        s = [\"a\", \"b\", \"c\"]\\n        i, count = 0, 0\\n        while i < len(word):\\n            for char in s:\\n                if i < len(word) and char == word[i]:\\n                    i += 1\\n                else:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050111,
                "title": "2645-minimum-additions-to-make-valid-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n\\n        int ans=0;\\n    for(int i=0; i<word.length();){\\n        if(word.charAt(i)== \\'a\\') i++; else ans++;         \\n        if( i < word.length() && word.charAt(i)== \\'b\\')i++; else ans++;\\n        if(i < word.length() && word.charAt(i) == \\'c\\')i++; else ans++;\\n    }\\n    return ans;\\n        \\n    }\\n}\\n\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n\\n        int ans=0;\\n    for(int i=0; i<word.length();){\\n        if(word.charAt(i)== \\'a\\') i++; else ans++;         \\n        if( i < word.length() && word.charAt(i)== \\'b\\')i++; else ans++;\\n        if(i < word.length() && word.charAt(i) == \\'c\\')i++; else ans++;\\n    }\\n    return ans;\\n        \\n    }\\n}\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044877,
                "title": "c-easy-solution-using-stack",
                "content": "class Solution {\\npublic:\\n    int addMinimum(string s) {\\n        stack<char>st;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            st.push(s[i]);\\n        }\\n        char c=\\'a\\';int ans=0;\\n        while(!st.empty())\\n        {\\n            if(st.top()!=c)\\n            {\\n               ans++; \\n            }\\n            else{\\n                st.pop();\\n            }\\n            c=c+1;\\n            if(c==\\'d\\')\\n            {\\n                c=\\'a\\';\\n            }\\n            \\n        }\\n        if(c==\\'b\\')\\n        {\\n            ans=ans+2;\\n        }\\n        else if(c==\\'c\\')\\n        {\\n            ans++;\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int addMinimum(string s) {\\n        stack<char>st;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            st.push(s[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4026174,
                "title": "c-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string& word, string s)\\n    {\\n        int ans = 0;\\n        int i = 0;\\n        int j = 0;\\n        while(i<word.length())\\n        {\\n            if(word[i]!=s[j]) ans++;\\n            else i++;\\n            j++;\\n            j = j%3;\\n        }\\n        if(j!=0) ans = ans+(3-j);\\n        return ans;\\n    }\\n    int addMinimum(string word) \\n    {\\n        return solve(word, \"abc\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& word, string s)\\n    {\\n        int ans = 0;\\n        int i = 0;\\n        int j = 0;\\n        while(i<word.length())\\n        {\\n            if(word[i]!=s[j]) ans++;\\n            else i++;\\n            j++;\\n            j = j%3;\\n        }\\n        if(j!=0) ans = ans+(3-j);\\n        return ans;\\n    }\\n    int addMinimum(string word) \\n    {\\n        return solve(word, \"abc\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021986,
                "title": "beats-69-runtime",
                "content": "# Intuition\\nby simple observation we can do this problem\\n\\n# Approach\\nbasic maths\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int l=word.length();\\n        if(l==1) return 2;\\n        int cnt=0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            if(word[i]==\\'a\\' && word[i+1]==\\'a\\') cnt+=2;\\n            if(word[i]==\\'a\\' && word[i+1]==\\'c\\') cnt++;\\n            if(word[i]==\\'b\\' && word[i+1]==\\'a\\') cnt++;\\n            if(word[i]==\\'b\\' && word[i+1]==\\'b\\') cnt+=2;\\n            if(word[i]==\\'c\\' && word[i+1]==\\'b\\') cnt++;\\n            if(word[i]==\\'c\\' && word[i+1]==\\'c\\') cnt+=2;\\n        }\\n        if(word[0]==\\'b\\') cnt++;\\n        if(word[0]==\\'c\\') cnt+=2;\\n        if(word[l-1]==\\'a\\') cnt+=2;\\n        if(word[l-1]==\\'b\\') cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int l=word.length();\\n        if(l==1) return 2;\\n        int cnt=0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            if(word[i]==\\'a\\' && word[i+1]==\\'a\\') cnt+=2;\\n            if(word[i]==\\'a\\' && word[i+1]==\\'c\\') cnt++;\\n            if(word[i]==\\'b\\' && word[i+1]==\\'a\\') cnt++;\\n            if(word[i]==\\'b\\' && word[i+1]==\\'b\\') cnt+=2;\\n            if(word[i]==\\'c\\' && word[i+1]==\\'b\\') cnt++;\\n            if(word[i]==\\'c\\' && word[i+1]==\\'c\\') cnt+=2;\\n        }\\n        if(word[0]==\\'b\\') cnt++;\\n        if(word[0]==\\'c\\') cnt+=2;\\n        if(word[l-1]==\\'a\\') cnt+=2;\\n        if(word[l-1]==\\'b\\') cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010194,
                "title": "count-number-of-updated-string-as-you-go-c-100-96-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        int ans=1;\\n        for(int i=1;i<s.size();i++){\\n            if(!(s[i]>s[i-1])){\\n                ans++;\\n            }\\n        }\\n        return (3*ans)-s.size();\\n    }\\n};\\n\\n// a ab bc c\\n// abc abc abc abc\\n\\n// a ac c b b\\n// abc abc abc abc abc\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        int ans=1;\\n        for(int i=1;i<s.size();i++){\\n            if(!(s[i]>s[i-1])){\\n                ans++;\\n            }\\n        }\\n        return (3*ans)-s.size();\\n    }\\n};\\n\\n// a ab bc c\\n// abc abc abc abc\\n\\n// a ac c b b\\n// abc abc abc abc abc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008844,
                "title": "java-solution-easy",
                "content": "# Intuition\\nFor any given letter at any index we need to make it like \"abc\". \\n\\n# Approach\\nWe have a given pattern. For a given character we will keep on appending to the left based on patternIndex. At last we will add characters to the right so that pattern \"abc\" can be form \\n\\nFor eg: Word -> \"aaa\" Pattern -> \"abc\";\\nat 0th index of word character is \\'a\\'\\nat 0th index of Pattern character is \\'a\\'\\nso nothing will appended to the left. \\n\\nat 1st index of word character is \\'a\\'\\nat 0th index of Pattern character is \\'b\\'\\nCharacters are not matching so move the patternIndex in ciruclar fashion so that it matches. \\n2 characters will be added before 1st Index of word \\'b\\', \\'c\\' and now bothe word and pattern index are pointing to the same character.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        String pattern = \"abc\";\\n        int patternIndex = 0;\\n        int additionalCount = 0;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            char currentChar = word.charAt(i);\\n            \\n            while (currentChar != pattern.charAt(patternIndex)) {\\n                additionalCount++;\\n                patternIndex = (patternIndex + 1) % 3; // loop within bounds of \\'abc\\'\\n            }\\n            patternIndex = (patternIndex + 1) % 3; // move to next expected character in pattern\\n        }\\n\\n        switch (word.charAt(word.length() - 1)) {\\n            case \\'a\\':\\n                additionalCount += 2;\\n                break;\\n            case \\'b\\':\\n                additionalCount += 1;\\n                break;\\n        }\\n\\n        return additionalCount;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        String pattern = \"abc\";\\n        int patternIndex = 0;\\n        int additionalCount = 0;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            char currentChar = word.charAt(i);\\n            \\n            while (currentChar != pattern.charAt(patternIndex)) {\\n                additionalCount++;\\n                patternIndex = (patternIndex + 1) % 3; // loop within bounds of \\'abc\\'\\n            }\\n            patternIndex = (patternIndex + 1) % 3; // move to next expected character in pattern\\n        }\\n\\n        switch (word.charAt(word.length() - 1)) {\\n            case \\'a\\':\\n                additionalCount += 2;\\n                break;\\n            case \\'b\\':\\n                additionalCount += 1;\\n                break;\\n        }\\n\\n        return additionalCount;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006616,
                "title": "concise-and-clear-two-pointers-approach",
                "content": "# Intuition\\n\\n  First of all take the idea from the **hint** section then come here because this logic is totally based upon that hint part.\\n\\n  Take the string \"abc\" and keep one pointer at 0th index of original string nd keep another pointer at 0th index of \"abc\" string so here if both the characters get match it means we are going in the right direction but if both the character doesn\\'t match then keep incrementing \"abc\" string and incrementing your answer untill you didn\\'t get your desire character.\\n\\nNow in the end if your last character from the original string doesn\\'t have \\'c\\' character then you need to add (3-j) in your answer , the reason is that suppose your last character is \\'b\\' then it did calculate for the previous characters but it misses out the track for the last character so for such situation you need to add (3-j) in your answer.\\n\\n# Approach\\n  Two Pointers.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        String check = \"abc\";\\n        int j=0,ans=0;\\n        for(int i=0;i<len;j++){\\n            j=j%3;\\n            if(word.charAt(i)==check.charAt(j)) i++;\\n            else ans++;\\n        }\\n        if(word.charAt(len-1)!=\\'c\\') ans+=(3-j);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        String check = \"abc\";\\n        int j=0,ans=0;\\n        for(int i=0;i<len;j++){\\n            j=j%3;\\n            if(word.charAt(i)==check.charAt(j)) i++;\\n            else ans++;\\n        }\\n        if(word.charAt(len-1)!=\\'c\\') ans+=(3-j);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995677,
                "title": "easy-case-by-case-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {    \\n    \\n        int n = s.length();\\n        int i = 0;\\n        int ans = 0;\\n\\n        while(i < n){\\n            if(s[i] == \\'a\\'){\\n                char c1 = \\'*\\';\\n                char c2 = \\'*\\';\\n                \\n                if(i+1 < n){\\n                    c1 = s[i+1];\\n                }\\n                if(i+2 < n){\\n                    c2 = s[i+2];\\n                }\\n\\n                if(c1 == \\'b\\' && c2 == \\'c\\'){\\n                    i += 3;\\n                } else if(c1 == \\'b\\'){\\n                    i += 2;\\n                    ans++;\\n                } else if(c1 == \\'c\\'){\\n                    i += 2;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            } else if(s[i] == \\'b\\'){\\n                if(i+1 < n && s[i+1] == \\'c\\') {\\n                    ans++;\\n                    i += 2;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            } else {\\n                ans += 2;\\n                i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {    \\n    \\n        int n = s.length();\\n        int i = 0;\\n        int ans = 0;\\n\\n        while(i < n){\\n            if(s[i] == \\'a\\'){\\n                char c1 = \\'*\\';\\n                char c2 = \\'*\\';\\n                \\n                if(i+1 < n){\\n                    c1 = s[i+1];\\n                }\\n                if(i+2 < n){\\n                    c2 = s[i+2];\\n                }\\n\\n                if(c1 == \\'b\\' && c2 == \\'c\\'){\\n                    i += 3;\\n                } else if(c1 == \\'b\\'){\\n                    i += 2;\\n                    ans++;\\n                } else if(c1 == \\'c\\'){\\n                    i += 2;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            } else if(s[i] == \\'b\\'){\\n                if(i+1 < n && s[i+1] == \\'c\\') {\\n                    ans++;\\n                    i += 2;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            } else {\\n                ans += 2;\\n                i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986815,
                "title": "minimum-additions-to-make-valid-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int i=0;\\n        String s = \"abc\";\\n        int count =0;\\n        while(i<word.length())\\n        {for(int j=0;j<s.length();j++)\\n        {\\n            if(i<word.length()&&word.charAt(i)==s.charAt(j))\\n            i++;\\n            else\\n            count++;\\n        }}\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int i=0;\\n        String s = \"abc\";\\n        int count =0;\\n        while(i<word.length())\\n        {for(int j=0;j<s.length();j++)\\n        {\\n            if(i<word.length()&&word.charAt(i)==s.charAt(j))\\n            i++;\\n            else\\n            count++;\\n        }}\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984045,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0;\\n        string ref=\"abc\";\\n        int i=0,p=0;\\n        while(i<word.size()){\\n           if(word[i]==ref[p]){\\n               i++;\\n           }\\n           else{\\n               ans++;\\n           }\\n           p++;\\n           if(p>=3)\\n           p=0;\\n        }\\n        if(p>0)\\n        ans+=3-p;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0;\\n        string ref=\"abc\";\\n        int i=0,p=0;\\n        while(i<word.size()){\\n           if(word[i]==ref[p]){\\n               i++;\\n           }\\n           else{\\n               ans++;\\n           }\\n           p++;\\n           if(p>=3)\\n           p=0;\\n        }\\n        if(p>0)\\n        ans+=3-p;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972963,
                "title": "minimum-additions-to-make-valid-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Count the occurrences of \\'a\\', \\'b\\', and \\'c\\' in the string. Determine the valid \"abc\" chunks that can be formed. Calculate the minimum insertions needed by adding remaining characters based on valid chunks.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Force Approach (Inefficient):\\nGenerate all possible strings by inserting \\'a\\', \\'b\\', and \\'c\\' into the given string, and calculate the minimum additions required to make them valid. This approach has exponential time complexity due to the large number of possibilities.\\n\\n- Optimal Approach (Efficient):(read code)\\nIt iterates through the characters in the input string using the index i and keeps track of the required additions using the ans variable. For each character, it checks if it is \\'a\\', \\'b\\', or \\'c\\', and either increments the index i (if the character is already valid) or increments the ans variable (if the character needs to be added to form a valid \"abc\" chunk). The final value of ans represents the minimum number of characters needed to make the string valid..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- 1\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0, i = 0; // Initialize ans (answer) to keep track of additions needed, and i to iterate through the characters\\n        \\n        // Loop through the characters in the word\\n        while (i < word.size()) {\\n            // If the current character is \\'a\\', increment i to skip this character\\n            // If it\\'s not \\'a\\', increment ans since we need to add a character to form a valid \"abc\" chunk\\n            (word[i] == \\'a\\') ? i++ : ans++;\\n            \\n            // Similar logic for \\'b\\'\\n            (word[i] == \\'b\\') ? i++ : ans++;\\n            \\n            // Similar logic for \\'c\\'\\n            (word[i] == \\'c\\') ? i++ : ans++;\\n        }\\n        \\n        return ans; // Return the minimum number of additions needed\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0, i = 0; // Initialize ans (answer) to keep track of additions needed, and i to iterate through the characters\\n        \\n        // Loop through the characters in the word\\n        while (i < word.size()) {\\n            // If the current character is \\'a\\', increment i to skip this character\\n            // If it\\'s not \\'a\\', increment ans since we need to add a character to form a valid \"abc\" chunk\\n            (word[i] == \\'a\\') ? i++ : ans++;\\n            \\n            // Similar logic for \\'b\\'\\n            (word[i] == \\'b\\') ? i++ : ans++;\\n            \\n            // Similar logic for \\'c\\'\\n            (word[i] == \\'c\\') ? i++ : ans++;\\n        }\\n        \\n        return ans; // Return the minimum number of additions needed\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971296,
                "title": "easy-solution-recursion-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int solve(int i,string word,string s)\\n   {\\n     if(i>=word.size())\\n    {   cout<<s;\\n        return(\\'c\\'-word[word.size()-1]);\\n   }\\n     int insert=0,noinsert=0;\\n     if(s.size()==0)\\n     {\\n       if(word[0]==\\'a\\')\\n       {\\n         return(solve(i+1,word,s+word[i]));\\n       }\\n       else\\n       {\\n         return(solve(i,word,s+\\'a\\'))+1;\\n       }\\n     }\\n     if(s[s.size()-1]==\\'c\\'&&word[i]==\\'a\\'||s[s.size()-1]==\\'a\\'&&word[i]==\\'b\\'||s[s.size()-1]==\\'b\\'&&word[i]==\\'c\\')\\n     {\\n        return solve(i+1,word,s+word[i]);\\n     }\\n     else\\n     {\\n       char ch;\\n       if(s[s.size()-1]==\\'c\\')\\n       ch=\\'a\\';\\n       else\\n       {\\n         if(s[s.size()-1]==\\'a\\')\\n         ch=\\'b\\';\\n         else\\n         ch=\\'c\\';\\n       }\\n       cout<<word[i]<<endl;\\n       return solve(i,word,s+ch)+1;\\n     }\\n   }\\n    int addMinimum(string word) {\\n        if(word.size()==0)\\n        return(0);\\n        string s;\\n       return(solve(0,word,s));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int solve(int i,string word,string s)\\n   {\\n     if(i>=word.size())\\n    {   cout<<s;\\n        return(\\'c\\'-word[word.size()-1]);\\n   }\\n     int insert=0,noinsert=0;\\n     if(s.size()==0)\\n     {\\n       if(word[0]==\\'a\\')\\n       {\\n         return(solve(i+1,word,s+word[i]));\\n       }\\n       else\\n       {\\n         return(solve(i,word,s+\\'a\\'))+1;\\n       }\\n     }\\n     if(s[s.size()-1]==\\'c\\'&&word[i]==\\'a\\'||s[s.size()-1]==\\'a\\'&&word[i]==\\'b\\'||s[s.size()-1]==\\'b\\'&&word[i]==\\'c\\')\\n     {\\n        return solve(i+1,word,s+word[i]);\\n     }\\n     else\\n     {\\n       char ch;\\n       if(s[s.size()-1]==\\'c\\')\\n       ch=\\'a\\';\\n       else\\n       {\\n         if(s[s.size()-1]==\\'a\\')\\n         ch=\\'b\\';\\n         else\\n         ch=\\'c\\';\\n       }\\n       cout<<word[i]<<endl;\\n       return solve(i,word,s+ch)+1;\\n     }\\n   }\\n    int addMinimum(string word) {\\n        if(word.size()==0)\\n        return(0);\\n        string s;\\n       return(solve(0,word,s));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3968455,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        for(int i =0; i < word.length();) {\\n            if(word.charAt(i) == \\'a\\') \\n            i++; \\n            else\\n             ans++;\\n            if(i < word.length() && word.charAt(i) == \\'b\\') \\n            i++;\\n             else \\n             ans++;\\n            if(i < word.length() && word.charAt(i) == \\'c\\') {\\n                 i++;\\n            }else {\\n                       ans++; \\n                    }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        for(int i =0; i < word.length();) {\\n            if(word.charAt(i) == \\'a\\') \\n            i++; \\n            else\\n             ans++;\\n            if(i < word.length() && word.charAt(i) == \\'b\\') \\n            i++;\\n             else \\n             ans++;\\n            if(i < word.length() && word.charAt(i) == \\'c\\') {\\n                 i++;\\n            }else {\\n                       ans++; \\n                    }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963511,
                "title": "simple-implementation-using-if-else-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHow can we make every character part of an abc substring.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing simple if else condition.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(len(word))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length();\\n        int count=0;\\n        for(int i=0;i<=n-2;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'a\\')\\n                    count+=2;\\n                if(word[i+1]==\\'c\\')\\n                    count+=1;\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i+1]==\\'b\\')\\n                    count+=2;\\n                if(word[i+1]==\\'a\\')\\n                    count+=1;\\n            }\\n            else if(word[i]==\\'c\\')\\n            {\\n                if(word[i+1]==\\'c\\')\\n                    count+=2;\\n                if(word[i+1]==\\'b\\')\\n                    count+=1;\\n            }\\n        }\\n        //checking for first\\n        if(word[0]==\\'b\\')\\n            count+=1;\\n        if(word[0]==\\'c\\')\\n            count+=2;\\n        //checking for last\\n           if(word[n-1]==\\'b\\')\\n            count+=1;\\n          if(word[n-1]==\\'a\\')\\n            count+=2;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length();\\n        int count=0;\\n        for(int i=0;i<=n-2;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'a\\')\\n                    count+=2;\\n                if(word[i+1]==\\'c\\')\\n                    count+=1;\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i+1]==\\'b\\')\\n                    count+=2;\\n                if(word[i+1]==\\'a\\')\\n                    count+=1;\\n            }\\n            else if(word[i]==\\'c\\')\\n            {\\n                if(word[i+1]==\\'c\\')\\n                    count+=2;\\n                if(word[i+1]==\\'b\\')\\n                    count+=1;\\n            }\\n        }\\n        //checking for first\\n        if(word[0]==\\'b\\')\\n            count+=1;\\n        if(word[0]==\\'c\\')\\n            count+=2;\\n        //checking for last\\n           if(word[n-1]==\\'b\\')\\n            count+=1;\\n          if(word[n-1]==\\'a\\')\\n            count+=2;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950691,
                "title": "dp-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        // std::vector<int> dp(word.size(),0);\\n        ans = word[0] - \\'a\\';\\n        for(int i = 1; i < word.size(); i ++){\\n            if(word[i]-word[i-1] > 0)\\n                ans = ans + word[i]-word[i-1] -1;\\n            else{\\n                ans = ans + \\'c\\' - word[i-1] + word[i] - \\'a\\';\\n            }\\n        }\\n        return ans + \\'c\\' - word[word.size()-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        // std::vector<int> dp(word.size(),0);\\n        ans = word[0] - \\'a\\';\\n        for(int i = 1; i < word.size(); i ++){\\n            if(word[i]-word[i-1] > 0)\\n                ans = ans + word[i]-word[i-1] -1;\\n            else{\\n                ans = ans + \\'c\\' - word[i-1] + word[i] - \\'a\\';\\n            }\\n        }\\n        return ans + \\'c\\' - word[word.size()-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948000,
                "title": "python-beats-98-77",
                "content": "![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/e451422b-c134-4362-8e73-c239268e2d5f_1692757950.2525883.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        Output = 0\\n        word = \\'_\\' + \\'_\\' + word + \\'_\\' + \\'_\\'\\n\\n        for i in range(2,len(word)-2):\\n            if word[i] == \\'a\\':\\n                if word[i+1] == \\'a\\':\\n                    Output = Output + 2\\n                elif word[i+1] == \\'b\\':\\n                    if word[i+2] == \\'c\\':\\n                        pass\\n                    else:\\n                        Output = Output + 1\\n                elif word[i+1] == \\'c\\':\\n                    Output = Output + 1\\n                else:\\n                    Output = Output + 2\\n            elif word[i] == \\'b\\':\\n                if word[i-1] == \\'a\\':\\n                    pass\\n                elif word[i-1] != \\'a\\':\\n                    if word[i+1] == \\'c\\':\\n                        Output = Output + 1\\n                    else:\\n                        Output = Output + 2\\n            elif word[i] == \\'c\\':\\n                if word[i-1] == \\'a\\':\\n                    pass\\n                elif word[i-1] == \\'b\\':\\n                    pass\\n                else:\\n                    Output = Output + 2\\n        \\n        return Output\\n\\n        # 20230823\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        Output = 0\\n        word = \\'_\\' + \\'_\\' + word + \\'_\\' + \\'_\\'\\n\\n        for i in range(2,len(word)-2):\\n            if word[i] == \\'a\\':\\n                if word[i+1] == \\'a\\':\\n                    Output = Output + 2\\n                elif word[i+1] == \\'b\\':\\n                    if word[i+2] == \\'c\\':\\n                        pass\\n                    else:\\n                        Output = Output + 1\\n                elif word[i+1] == \\'c\\':\\n                    Output = Output + 1\\n                else:\\n                    Output = Output + 2\\n            elif word[i] == \\'b\\':\\n                if word[i-1] == \\'a\\':\\n                    pass\\n                elif word[i-1] != \\'a\\':\\n                    if word[i+1] == \\'c\\':\\n                        Output = Output + 1\\n                    else:\\n                        Output = Output + 2\\n            elif word[i] == \\'c\\':\\n                if word[i-1] == \\'a\\':\\n                    pass\\n                elif word[i-1] == \\'b\\':\\n                    pass\\n                else:\\n                    Output = Output + 2\\n        \\n        return Output\\n\\n        # 20230823\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945762,
                "title": "basic-approach-c-using-maps-and-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->used maps and stacks to solve this question\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->made a mapping for each a ,b, c with their next alphaber resp. Iterated through the string and then checked the conditions\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        int cnt = 0;\\n        map<char, char> mp = { {\\'a\\', \\'b\\'}, {\\'b\\', \\'c\\'}, {\\'c\\', \\'a\\'} };\\n        int i = 0;\\n        while(i<word.length()){\\n\\n            if(st.empty() && word[i] != \\'a\\'){\\n                st.push(\\'a\\');\\n                cnt++;\\n            }\\n            \\n            if(!st.empty() && mp[st.top()] != word[i]){\\n                while(mp[st.top()] != word[i]){\\n                    st.push(mp[st.top()]);\\n                    cnt++;\\n                }\\n\\n                st.push(word[i]);\\n            }\\n\\n            \\n            else{\\n                st.push(word[i]);\\n            }\\n            i++;\\n\\n        }\\n\\n        if(st.top() != \\'c\\'){\\n            while(st.top() != \\'c\\'){\\n                st.push(mp[st.top()]);\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        int cnt = 0;\\n        map<char, char> mp = { {\\'a\\', \\'b\\'}, {\\'b\\', \\'c\\'}, {\\'c\\', \\'a\\'} };\\n        int i = 0;\\n        while(i<word.length()){\\n\\n            if(st.empty() && word[i] != \\'a\\'){\\n                st.push(\\'a\\');\\n                cnt++;\\n            }\\n            \\n            if(!st.empty() && mp[st.top()] != word[i]){\\n                while(mp[st.top()] != word[i]){\\n                    st.push(mp[st.top()]);\\n                    cnt++;\\n                }\\n\\n                st.push(word[i]);\\n            }\\n\\n            \\n            else{\\n                st.push(word[i]);\\n            }\\n            i++;\\n\\n        }\\n\\n        if(st.top() != \\'c\\'){\\n            while(st.top() != \\'c\\'){\\n                st.push(mp[st.top()]);\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926087,
                "title": "python-simple-solution-beats-98-26",
                "content": "# Intuition\\ncheck each letter and the letter before it, count missed letter in them, finally we got the answer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfor better performance, I build a dict to count missed letter quickly, then check each letter, don\\'t forget check the head and the tail\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        mp={\\'aa\\':2,\\'ab\\':0,\\'ac\\':1,\\'ba\\':1,\\'bb\\':2,\\'bc\\':0,\\'ca\\':0,\\'cb\\':1,\\'cc\\':2}\\n        res=mp[\\'c\\'+word[0]]+mp[word[-1]+\\'a\\']\\n        for i in range(1,len(word)):\\n            res+=mp[word[i-1:i+1]]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        mp={\\'aa\\':2,\\'ab\\':0,\\'ac\\':1,\\'ba\\':1,\\'bb\\':2,\\'bc\\':0,\\'ca\\':0,\\'cb\\':1,\\'cc\\':2}\\n        res=mp[\\'c\\'+word[0]]+mp[word[-1]+\\'a\\']\\n        for i in range(1,len(word)):\\n            res+=mp[word[i-1:i+1]]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894330,
                "title": "best-solution-c-with-comments-beats-100-in-time-complexity-97-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();  //finding size of the word\\n        int flag = 0; //to determine what should be the character at particular position 0 means\\'a\\' , 1 means \\'b\\' , 2 means\\'c\\'\\n        int insert = 0; //to count number of inserts in string\\n        \\n        int i = 0; //pointer to traverse string\\n        while(i<n) {\\n            //flag can be 0,1,2\\n\\n            if(flag==0) { \\n                //represents that the char should be \\'a\\' at this position\\n                if(word[i]==\\'a\\') i++; //if character is already \\'a\\' then increase the pointer \\n                else insert++; //if character is not \\'a\\' then \\'a\\' need to be added\\n                \\n                flag = 1; //next character should be \\'b\\'\\n            }\\n\\n            else if(flag==1) {\\n                 //represents that the char should be \\'b\\' at this position\\n                if(word[i]==\\'b\\') i++; //if character is already \\'b\\' then increase the pointer\\n                else insert++; //if character is not \\'b\\' then \\'b\\' need to be added\\n                \\n                flag = 2; //next character should be \\'c\\'\\n            }\\n\\n            else {\\n                //represents that the char should be \\'c\\' at this position\\n                if(word[i]==\\'c\\') i++; //if character is already \\'c\\' then increase the pointer\\n                else insert++; //if character is not \\'c\\' then \\'c\\' need to be added\\n                \\n                flag = 0; //next character should be \\'a\\'\\n            }\\n            \\n        }\\n        \\n        if(flag==1) insert+=2; //flag = 1 means last char was \\'a\\' thus two more inserts are needed\\n        else if(flag==2) insert+=1; //flag = 2 means last char was \\'b\\' thus one more insert is needed\\n        \\n        return insert;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();  //finding size of the word\\n        int flag = 0; //to determine what should be the character at particular position 0 means\\'a\\' , 1 means \\'b\\' , 2 means\\'c\\'\\n        int insert = 0; //to count number of inserts in string\\n        \\n        int i = 0; //pointer to traverse string\\n        while(i<n) {\\n            //flag can be 0,1,2\\n\\n            if(flag==0) { \\n                //represents that the char should be \\'a\\' at this position\\n                if(word[i]==\\'a\\') i++; //if character is already \\'a\\' then increase the pointer \\n                else insert++; //if character is not \\'a\\' then \\'a\\' need to be added\\n                \\n                flag = 1; //next character should be \\'b\\'\\n            }\\n\\n            else if(flag==1) {\\n                 //represents that the char should be \\'b\\' at this position\\n                if(word[i]==\\'b\\') i++; //if character is already \\'b\\' then increase the pointer\\n                else insert++; //if character is not \\'b\\' then \\'b\\' need to be added\\n                \\n                flag = 2; //next character should be \\'c\\'\\n            }\\n\\n            else {\\n                //represents that the char should be \\'c\\' at this position\\n                if(word[i]==\\'c\\') i++; //if character is already \\'c\\' then increase the pointer\\n                else insert++; //if character is not \\'c\\' then \\'c\\' need to be added\\n                \\n                flag = 0; //next character should be \\'a\\'\\n            }\\n            \\n        }\\n        \\n        if(flag==1) insert+=2; //flag = 1 means last char was \\'a\\' thus two more inserts are needed\\n        else if(flag==2) insert+=1; //flag = 2 means last char was \\'b\\' thus one more insert is needed\\n        \\n        return insert;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894329,
                "title": "best-solution-c-with-comments-beats-100-in-time-complexity-97-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();  //finding size of the word\\n        int flag = 0; //to determine what should be the character at particular position 0 means\\'a\\' , 1 means \\'b\\' , 2 means\\'c\\'\\n        int insert = 0; //to count number of inserts in string\\n        \\n        int i = 0; //pointer to traverse string\\n        while(i<n) {\\n            //flag can be 0,1,2\\n\\n            if(flag==0) { \\n                //represents that the char should be \\'a\\' at this position\\n                if(word[i]==\\'a\\') i++; //if character is already \\'a\\' then increase the pointer \\n                else insert++; //if character is not \\'a\\' then \\'a\\' need to be added\\n                \\n                flag = 1; //next character should be \\'b\\'\\n            }\\n\\n            else if(flag==1) {\\n                 //represents that the char should be \\'b\\' at this position\\n                if(word[i]==\\'b\\') i++; //if character is already \\'b\\' then increase the pointer\\n                else insert++; //if character is not \\'b\\' then \\'b\\' need to be added\\n                \\n                flag = 2; //next character should be \\'c\\'\\n            }\\n\\n            else {\\n                //represents that the char should be \\'c\\' at this position\\n                if(word[i]==\\'c\\') i++; //if character is already \\'c\\' then increase the pointer\\n                else insert++; //if character is not \\'c\\' then \\'c\\' need to be added\\n                \\n                flag = 0; //next character should be \\'a\\'\\n            }\\n            \\n        }\\n        \\n        if(flag==1) insert+=2; //flag = 1 means last char was \\'a\\' thus two more inserts are needed\\n        else if(flag==2) insert+=1; //flag = 2 means last char was \\'b\\' thus one more insert is needed\\n        \\n        return insert;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();  //finding size of the word\\n        int flag = 0; //to determine what should be the character at particular position 0 means\\'a\\' , 1 means \\'b\\' , 2 means\\'c\\'\\n        int insert = 0; //to count number of inserts in string\\n        \\n        int i = 0; //pointer to traverse string\\n        while(i<n) {\\n            //flag can be 0,1,2\\n\\n            if(flag==0) { \\n                //represents that the char should be \\'a\\' at this position\\n                if(word[i]==\\'a\\') i++; //if character is already \\'a\\' then increase the pointer \\n                else insert++; //if character is not \\'a\\' then \\'a\\' need to be added\\n                \\n                flag = 1; //next character should be \\'b\\'\\n            }\\n\\n            else if(flag==1) {\\n                 //represents that the char should be \\'b\\' at this position\\n                if(word[i]==\\'b\\') i++; //if character is already \\'b\\' then increase the pointer\\n                else insert++; //if character is not \\'b\\' then \\'b\\' need to be added\\n                \\n                flag = 2; //next character should be \\'c\\'\\n            }\\n\\n            else {\\n                //represents that the char should be \\'c\\' at this position\\n                if(word[i]==\\'c\\') i++; //if character is already \\'c\\' then increase the pointer\\n                else insert++; //if character is not \\'c\\' then \\'c\\' need to be added\\n                \\n                flag = 0; //next character should be \\'a\\'\\n            }\\n            \\n        }\\n        \\n        if(flag==1) insert+=2; //flag = 1 means last char was \\'a\\' thus two more inserts are needed\\n        else if(flag==2) insert+=1; //flag = 2 means last char was \\'b\\' thus one more insert is needed\\n        \\n        return insert;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881135,
                "title": "beat-100-of-all-t-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string nums) \\n    {\\n        int step=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n            {if(nums[i]!=\\'c\\'&&nums[i+1]!=nums[i]+1){\\n                nums.insert(i+1,1,nums[i]+1);step++;}\\n            else if(nums[i]==\\'c\\'&&nums[i+1]!=\\'a\\'){\\n                nums.insert(i+1,1,\\'a\\');step++;}}\\n        if(nums[0]==\\'b\\')\\n            {nums=\\'a\\'+nums;step++;}\\n        else if(nums[0]==\\'c\\')\\n            {nums=\"ab\"+nums;step+=2;}\\n        \\n        if(nums.back()==\\'b\\')\\n            {nums=nums+\\'c\\';step++;}\\n        else if(nums.back()==\\'a\\')\\n            {nums=nums+\"bc\";step+=2;}\\n        \\n        return step;\\n                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string nums) \\n    {\\n        int step=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n            {if(nums[i]!=\\'c\\'&&nums[i+1]!=nums[i]+1){\\n                nums.insert(i+1,1,nums[i]+1);step++;}\\n            else if(nums[i]==\\'c\\'&&nums[i+1]!=\\'a\\'){\\n                nums.insert(i+1,1,\\'a\\');step++;}}\\n        if(nums[0]==\\'b\\')\\n            {nums=\\'a\\'+nums;step++;}\\n        else if(nums[0]==\\'c\\')\\n            {nums=\"ab\"+nums;step+=2;}\\n        \\n        if(nums.back()==\\'b\\')\\n            {nums=nums+\\'c\\';step++;}\\n        else if(nums.back()==\\'a\\')\\n            {nums=nums+\"bc\";step+=2;}\\n        \\n        return step;\\n                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876837,
                "title": "c-very-easy-solution-understand-just-by-looking",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n     int count=0,i=0;\\n        while(i<word.size())\\n        {\\n            (word[i]==\\'a\\')?i++:count++;\\n            (word[i]==\\'b\\')?i++:count++;\\n            (word[i]==\\'c\\')?i++:count++;\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n     int count=0,i=0;\\n        while(i<word.size())\\n        {\\n            (word[i]==\\'a\\')?i++:count++;\\n            (word[i]==\\'b\\')?i++:count++;\\n            (word[i]==\\'c\\')?i++:count++;\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876609,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(3*n)$$\\n- Space complexity:$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int n=word.length();\\n        int op=0;\\n        StringBuilder s=new StringBuilder();\\n        for(int i=0;i<n;i++) s.append(\"abc\");\\n        if(word.charAt(n-1)!=\\'c\\'){\\n            word=word+\\'c\\';\\n            op++;\\n        }\\n        int count=0;\\n        int index=0;\\n        for(int i=0;i<s.length() && index<word.length();i++){\\n            if(s.charAt(i)!=word.charAt(index)){\\n                count++;\\n            }\\n            else{\\n                index++;\\n                op+=count;\\n                count=0;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int n=word.length();\\n        int op=0;\\n        StringBuilder s=new StringBuilder();\\n        for(int i=0;i<n;i++) s.append(\"abc\");\\n        if(word.charAt(n-1)!=\\'c\\'){\\n            word=word+\\'c\\';\\n            op++;\\n        }\\n        int count=0;\\n        int index=0;\\n        for(int i=0;i<s.length() && index<word.length();i++){\\n            if(s.charAt(i)!=word.charAt(index)){\\n                count++;\\n            }\\n            else{\\n                index++;\\n                op+=count;\\n                count=0;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866672,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction addMinimum(word) {\\n    if (word.length === 1) return 2;\\n    let res = 0;\\n    if (word[0] === \\'b\\') res++;\\n    if (word[0] === \\'c\\') res += 2;\\n    const stack = [word[0]];\\n    let i = 1;\\n    while (i < word.length) {\\n        const peek = stack[stack.length-1];\\n        if (peek === \\'a\\') {\\n            if (word[i] === \\'a\\') {\\n                res += 2;\\n            }\\n            else if (word[i] === \\'b\\'){\\n            } \\n            else {\\n                res++; \\n            }\\n        } else if (peek === \\'b\\') {\\n            if (word[i] === \\'a\\') {\\n                res++;\\n            }\\n            else if (word[i] === \\'b\\'){\\n                res += 2;\\n            } \\n            else {\\n                // res++;\\n            }\\n        } else {\\n            if (word[i] === \\'a\\') {\\n            }\\n            else if (word[i] === \\'b\\'){\\n                res++;\\n            } \\n            else {\\n                res += 2;\\n            }\\n        }\\n        stack.push(word[i]);\\n        i++;\\n\\n    }\\n    if (word[word.length-1] === \\'a\\') res +=2;\\n    if (word[word.length-1] === \\'b\\') res++;\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction addMinimum(word) {\\n    if (word.length === 1) return 2;\\n    let res = 0;\\n    if (word[0] === \\'b\\') res++;\\n    if (word[0] === \\'c\\') res += 2;\\n    const stack = [word[0]];\\n    let i = 1;\\n    while (i < word.length) {\\n        const peek = stack[stack.length-1];\\n        if (peek === \\'a\\') {\\n            if (word[i] === \\'a\\') {\\n                res += 2;\\n            }\\n            else if (word[i] === \\'b\\'){\\n            } \\n            else {\\n                res++; \\n            }\\n        } else if (peek === \\'b\\') {\\n            if (word[i] === \\'a\\') {\\n                res++;\\n            }\\n            else if (word[i] === \\'b\\'){\\n                res += 2;\\n            } \\n            else {\\n                // res++;\\n            }\\n        } else {\\n            if (word[i] === \\'a\\') {\\n            }\\n            else if (word[i] === \\'b\\'){\\n                res++;\\n            } \\n            else {\\n                res += 2;\\n            }\\n        }\\n        stack.push(word[i]);\\n        i++;\\n\\n    }\\n    if (word[word.length-1] === \\'a\\') res +=2;\\n    if (word[word.length-1] === \\'b\\') res++;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864831,
                "title": "java-easy-solution-comparing-current-and-prev-characters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        char prev = \\'c\\';\\n        int min = 0;\\n        for(char ch : word.toCharArray()) {\\n            if(ch == \\'a\\' && prev != \\'c\\') \\n                min += prev == \\'a\\' ? 2 : 1;\\n            else if(ch == \\'b\\' && prev != \\'a\\') \\n                min += prev == \\'c\\' ? 1: 2;\\n            else if(ch == \\'c\\' && prev != \\'b\\') \\n                min += prev == \\'c\\' ? 2 : 1;\\n            prev = ch;\\n        }\\n        if(prev == \\'c\\') return min;\\n        return prev == \\'a\\' ? min + 2 : min + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        char prev = \\'c\\';\\n        int min = 0;\\n        for(char ch : word.toCharArray()) {\\n            if(ch == \\'a\\' && prev != \\'c\\') \\n                min += prev == \\'a\\' ? 2 : 1;\\n            else if(ch == \\'b\\' && prev != \\'a\\') \\n                min += prev == \\'c\\' ? 1: 2;\\n            else if(ch == \\'c\\' && prev != \\'b\\') \\n                min += prev == \\'c\\' ? 2 : 1;\\n            prev = ch;\\n        }\\n        if(prev == \\'c\\') return min;\\n        return prev == \\'a\\' ? min + 2 : min + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856244,
                "title": "two-pointers-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s = \"abc\";\\n        int j=0,ct=0;\\n        for(int i=0;i<word.size();){\\n            if(s[j%3]==word[i]){\\n                j++;i++;\\n            }\\n            else {\\n                ct++;j++;\\n            }\\n        }\\n        \\n        ct+=(\\'c\\'-s[(j-1)%3]);\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s = \"abc\";\\n        int j=0,ct=0;\\n        for(int i=0;i<word.size();){\\n            if(s[j%3]==word[i]){\\n                j++;i++;\\n            }\\n            else {\\n                ct++;j++;\\n            }\\n        }\\n        \\n        ct+=(\\'c\\'-s[(j-1)%3]);\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850898,
                "title": "understandable-java-solution-demonstrating-full-comprehension-of-ds-algo",
                "content": "Many other solutions floating around are correct but do not demonstrate a comprehensive understanding or mastery of the algorithms and data structures to a level that might be expected in an interview. They also suggest an approach or thought process that does not lead to any reliable way of solving such a problem cold in an interview.\\n# Intuition\\nRealize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\\nUsing your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of \\'localized\\' choices that might exhibit the Greedy Choice Property\\nObserve that every valid solution modifies the problem space to a string that begins with \\'abc\\', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one \\'choice\\' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at \\'abc\\'. Perform a quick \\'proof\\' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\\nRealize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\\n\\n# Approach\\nUsing the \\'choice\\' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) linear with respect to the number of characters in the word.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        LinkedList<Character> wordStack = new LinkedList<Character>();\\n        for (Character c : word.toCharArray()) {\\n            wordStack.add(c);\\n        }\\n        LinkedList<Character> abcStack = new LinkedList<Character>();\\n\\n        int j = 0;\\n        while (!wordStack.isEmpty()) {\\n            abcStack.add(\\'a\\');\\n            abcStack.add(\\'b\\');\\n            abcStack.add(\\'c\\');\\n\\n            while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\\n                char c = wordStack.remove(0).charValue();\\n                char i = abcStack.remove(0).charValue();\\n\\n                if (c != i) {\\n                    wordStack.add(0, c);\\n                    j++;\\n                }\\n            }\\n\\n        }\\n        return j + abcStack.size();\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        LinkedList<Character> wordStack = new LinkedList<Character>();\\n        for (Character c : word.toCharArray()) {\\n            wordStack.add(c);\\n        }\\n        LinkedList<Character> abcStack = new LinkedList<Character>();\\n\\n        int j = 0;\\n        while (!wordStack.isEmpty()) {\\n            abcStack.add(\\'a\\');\\n            abcStack.add(\\'b\\');\\n            abcStack.add(\\'c\\');\\n\\n            while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\\n                char c = wordStack.remove(0).charValue();\\n                char i = abcStack.remove(0).charValue();\\n\\n                if (c != i) {\\n                    wordStack.add(0, c);\\n                    j++;\\n                }\\n            }\\n\\n        }\\n        return j + abcStack.size();\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836083,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int n=word.length();\\n        int i=0;\\n        int leterRequre=0;\\n        while(i<n){\\n            int valid=0;\\n            if(word.charAt(i)==\\'a\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            if(i<n && word.charAt(i) ==\\'b\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            if(i<n && word.charAt(i)==\\'c\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            leterRequre +=3-valid;\\n        }\\n        return leterRequre;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int n=word.length();\\n        int i=0;\\n        int leterRequre=0;\\n        while(i<n){\\n            int valid=0;\\n            if(word.charAt(i)==\\'a\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            if(i<n && word.charAt(i) ==\\'b\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            if(i<n && word.charAt(i)==\\'c\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            leterRequre +=3-valid;\\n        }\\n        return leterRequre;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819083,
                "title": "greedy",
                "content": "```\\nint addMinimum(const string w)\\n{\\n\\tint out{};\\n\\tfor(int i{}; i<size(w); )\\n\\t\\tif(w[i+1]<=w[i])  \\n\\t\\t\\ti+=1, out+=2; \\n\\t\\telse if(w[i+2]<=w[i+1])  \\n\\t\\t\\ti+=2, out+=1;\\n\\t\\telse\\n\\t\\t\\ti+=3, out+=0;\\n\\treturn out;\\n}\\n```\\n||\\nHere `w[i+1]<=w[i]`\\n\\n![image](https://assets.leetcode.com/users/images/7535df7f-1c4f-4b84-914c-5efea6fc53d4_1690392467.1924953.png)\\n\\notherwise\\n\\n![image](https://assets.leetcode.com/users/images/3cc321cf-495f-4ffe-b837-0cf4dc7f3222_1690392987.6664252.png)\\n\\n```\\nint addMinimum(const string w)\\n{\\n\\tint n{};\\n\\tfor(int i{}; i<size(w); ++i)\\n\\t\\tn += w[i+1]<=w[i]; \\n\\treturn 3*n-size(w);\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint addMinimum(const string w)\\n{\\n\\tint out{};\\n\\tfor(int i{}; i<size(w); )\\n\\t\\tif(w[i+1]<=w[i])  \\n\\t\\t\\ti+=1, out+=2; \\n\\t\\telse if(w[i+2]<=w[i+1])  \\n\\t\\t\\ti+=2, out+=1;\\n\\t\\telse\\n\\t\\t\\ti+=3, out+=0;\\n\\treturn out;\\n}\\n```\n```\\nint addMinimum(const string w)\\n{\\n\\tint n{};\\n\\tfor(int i{}; i<size(w); ++i)\\n\\t\\tn += w[i+1]<=w[i]; \\n\\treturn 3*n-size(w);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817888,
                "title": "o-n-time-o-1-space-solution",
                "content": "# Intuition\\nkeep tracking two string, one is the word and the other is \"abc\".\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.length();\\n        int cur = 0, ans = 0;\\n        string temp = \"abc\";\\n        for(int i = 0; i< n; i++){\\n            if(word[i] == temp[cur])\\n                cur = (cur + 1)%3;\\n            else\\n            {\\n                if(word[i]<temp[cur]){\\n                    ans += 3 - (temp[cur] - word[i]); // word[i]<temp[cur]\\n                    cur = (cur + 3 - (temp[cur] - word[i]) + 1) %3;\\n                }\\n                else {\\n                // word[i]>temp[cur]\\n                ans += word[i] - temp[cur];\\n                cur = (cur + word[i] - temp[cur] + 1) %3;\\n                }\\n            }\\n        }\\n        \\n        if (word[n-1]!=\\'c\\') ans += \\'c\\' - word[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.length();\\n        int cur = 0, ans = 0;\\n        string temp = \"abc\";\\n        for(int i = 0; i< n; i++){\\n            if(word[i] == temp[cur])\\n                cur = (cur + 1)%3;\\n            else\\n            {\\n                if(word[i]<temp[cur]){\\n                    ans += 3 - (temp[cur] - word[i]); // word[i]<temp[cur]\\n                    cur = (cur + 3 - (temp[cur] - word[i]) + 1) %3;\\n                }\\n                else {\\n                // word[i]>temp[cur]\\n                ans += word[i] - temp[cur];\\n                cur = (cur + word[i] - temp[cur] + 1) %3;\\n                }\\n            }\\n        }\\n        \\n        if (word[n-1]!=\\'c\\') ans += \\'c\\' - word[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796634,
                "title": "using-stack-datastruture",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Stack datastructure .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nans=0\\n  Read each char from string \\n1 if char is \\'a\\' then \\n    if  stack is empty or top is \\'c\\'  then push \\'a\\' \\n    else if top is \\'b\\' then increment ans by 1 and push \\'c\\' and \\'a\\'.\\n    else if top is \\'a\\' then increment ans by 2 and push \\'b\\' and \\'c\\'.\\n\\n2 if char is \\'b\\' then\\n   if stack is empty or top is \\'c\\' then increnment ans by 1 push \\'a\\' and \\'b\\'.\\n    else if top is \\'a\\' then push \\'b\\'.\\n    else if top is \\'b\\' then increment ans by 2 and push \\'c\\'and \\'a\\'.\\n\\n3  if char is \\'c\\' then\\n    check similarly and increment the ans\\n \\nafter completion of loop (the last char should be ends with \\'c\\')\\n if top of the stack is a then increment the ans by 2 \\n else if top of the stack is b then increment the ans by 1\\n   \\nreturn ans;\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String s) {\\n        Stack<Character> st=new Stack<>();\\n        int max=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n            if(st.isEmpty()||st.peek()==\\'c\\')\\n            {\\n              st.push(s.charAt(i));\\n            }\\n            else if(st.peek()==\\'b\\')\\n            {\\n              max++;\\n                st.push(\\'c\\');\\n                st.push(s.charAt(i));\\n            }\\n            else if(st.peek()==\\'a\\')\\n            {\\n                max+=2;\\n                st.push(\\'b\\');\\n                st.push(\\'c\\');\\n                st.push(s.charAt(i));\\n            }\\n            }\\n            else if(s.charAt(i)==\\'b\\')\\n            {\\n                  if(st.isEmpty()||st.peek()==\\'c\\')\\n                  {\\n                      max++;\\n                      st.push(\\'a\\');\\n                    st.push(s.charAt(i));\\n                  }\\n                 else if(st.peek()==\\'a\\')\\n                  {\\n                    st.push(s.charAt(i));\\n                  }\\n                 else if(st.peek()==\\'b\\')\\n                 {\\n                    max+=2;\\n                    st.push(\\'c\\');\\n                    st.push(\\'a\\');\\n                   st.push(s.charAt(i));\\n                 }\\n            }\\n            else {\\n                 if(st.isEmpty()||st.peek()==\\'c\\')\\n                  {\\n                      max+=2;\\n                      st.push(\\'a\\');\\n                      st.push(\\'b\\');\\n                    st.push(s.charAt(i));\\n                   }\\n                  else if(st.peek()==\\'b\\')\\n                  {\\n                    st.push(s.charAt(i));\\n                   }\\n                  else if(st.peek()==\\'a\\')\\n                  {\\n                    max++;\\n                    st.push(\\'b\\');\\n                    st.push(s.charAt(i));\\n                  }\\n            }\\n        }\\n        if(st.peek()==\\'a\\')\\n        {\\n            max+=2;\\n            st.push(\\'b\\');\\n            st.push(\\'c\\');\\n        }\\n        else if(st.peek()==\\'b\\')\\n        {\\n            max++;\\n            st.push(\\'c\\');\\n        }\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String s) {\\n        Stack<Character> st=new Stack<>();\\n        int max=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n            if(st.isEmpty()||st.peek()==\\'c\\')\\n            {\\n              st.push(s.charAt(i));\\n            }\\n            else if(st.peek()==\\'b\\')\\n            {\\n              max++;\\n                st.push(\\'c\\');\\n                st.push(s.charAt(i));\\n            }\\n            else if(st.peek()==\\'a\\')\\n            {\\n                max+=2;\\n                st.push(\\'b\\');\\n                st.push(\\'c\\');\\n                st.push(s.charAt(i));\\n            }\\n            }\\n            else if(s.charAt(i)==\\'b\\')\\n            {\\n                  if(st.isEmpty()||st.peek()==\\'c\\')\\n                  {\\n                      max++;\\n                      st.push(\\'a\\');\\n                    st.push(s.charAt(i));\\n                  }\\n                 else if(st.peek()==\\'a\\')\\n                  {\\n                    st.push(s.charAt(i));\\n                  }\\n                 else if(st.peek()==\\'b\\')\\n                 {\\n                    max+=2;\\n                    st.push(\\'c\\');\\n                    st.push(\\'a\\');\\n                   st.push(s.charAt(i));\\n                 }\\n            }\\n            else {\\n                 if(st.isEmpty()||st.peek()==\\'c\\')\\n                  {\\n                      max+=2;\\n                      st.push(\\'a\\');\\n                      st.push(\\'b\\');\\n                    st.push(s.charAt(i));\\n                   }\\n                  else if(st.peek()==\\'b\\')\\n                  {\\n                    st.push(s.charAt(i));\\n                   }\\n                  else if(st.peek()==\\'a\\')\\n                  {\\n                    max++;\\n                    st.push(\\'b\\');\\n                    st.push(s.charAt(i));\\n                  }\\n            }\\n        }\\n        if(st.peek()==\\'a\\')\\n        {\\n            max+=2;\\n            st.push(\\'b\\');\\n            st.push(\\'c\\');\\n        }\\n        else if(st.peek()==\\'b\\')\\n        {\\n            max++;\\n            st.push(\\'c\\');\\n        }\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794486,
                "title": "beginner-friendly-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        \\n        \\'\\'\\'\\n        a -> a = 2\\n        b -> b = 2\\n        c -> c = 2\\n        a -> c = 1\\n        b -> a = 1\\n        c -> b = 1\\n        \\'\\'\\'\\n        st = []\\n        p = 0\\n        for i in range(len(word)):\\n            if st and ord(st[-1]) == ord(word[i]):\\n                p += 2 \\n            elif st and ord(st[-1]) == ord(word[i])-2:\\n                p += 1\\n            elif st and ord(st[-1])-1 == ord(word[i]):\\n                p += 1\\n            st.append(word[i])\\n           \\n        if word[0] == \\'b\\':\\n            p += 1\\n        elif word[0] == \\'c\\':\\n            p += 2\\n        if word[-1] == \\'a\\':\\n            p += 2\\n        elif word[-1] == \\'b\\':\\n            p += 1\\n        return p\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        \\n        \\'\\'\\'\\n        a -> a = 2\\n        b -> b = 2\\n        c -> c = 2\\n        a -> c = 1\\n        b -> a = 1\\n        c -> b = 1\\n        \\'\\'\\'\\n        st = []\\n        p = 0\\n        for i in range(len(word)):\\n            if st and ord(st[-1]) == ord(word[i]):\\n                p += 2 \\n            elif st and ord(st[-1]) == ord(word[i])-2:\\n                p += 1\\n            elif st and ord(st[-1])-1 == ord(word[i]):\\n                p += 1\\n            st.append(word[i])\\n           \\n        if word[0] == \\'b\\':\\n            p += 1\\n        elif word[0] == \\'c\\':\\n            p += 2\\n        if word[-1] == \\'a\\':\\n            p += 2\\n        elif word[-1] == \\'b\\':\\n            p += 1\\n        return p\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792582,
                "title": "six-if-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char prev = \\'c\\';\\n        int l = 0;\\n        int count = 0;\\n        while(!(l == word.size() && prev == \\'c\\')) {\\n            if (prev == \\'c\\' && word[l] != \\'a\\') {\\n                count++;\\n                prev = \\'a\\';\\n            } else if (prev == \\'a\\' && word[l] != \\'b\\') {\\n                count++;\\n                prev = \\'b\\';\\n            } else if (prev == \\'b\\' && word[l] != \\'c\\') {\\n                count++;\\n                prev = \\'c\\';\\n            } else if (prev == \\'c\\' && word[l] == \\'a\\') {\\n                l++;\\n                prev = \\'a\\';\\n            } else if (prev == \\'a\\' && word[l] == \\'b\\') {\\n                l++;\\n                prev = \\'b\\';\\n            } else if (prev == \\'b\\' && word[l] == \\'c\\') {\\n                l++;\\n                prev = \\'c\\';\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char prev = \\'c\\';\\n        int l = 0;\\n        int count = 0;\\n        while(!(l == word.size() && prev == \\'c\\')) {\\n            if (prev == \\'c\\' && word[l] != \\'a\\') {\\n                count++;\\n                prev = \\'a\\';\\n            } else if (prev == \\'a\\' && word[l] != \\'b\\') {\\n                count++;\\n                prev = \\'b\\';\\n            } else if (prev == \\'b\\' && word[l] != \\'c\\') {\\n                count++;\\n                prev = \\'c\\';\\n            } else if (prev == \\'c\\' && word[l] == \\'a\\') {\\n                l++;\\n                prev = \\'a\\';\\n            } else if (prev == \\'a\\' && word[l] == \\'b\\') {\\n                l++;\\n                prev = \\'b\\';\\n            } else if (prev == \\'b\\' && word[l] == \\'c\\') {\\n                l++;\\n                prev = \\'c\\';\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787888,
                "title": "easy-greedy-solution-linear-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int sum=int(word[0]-\\'0\\')-49,n=word.size();\\n         \\n        for(int i=1;i<n;i++)\\n        {\\n                //for each pair of sequential indices take their difference\\n            int diff=int(word[i-1]-\\'0\\')-int(word[i]-\\'0\\');\\n            //if difference is 0 then we have to add 2 characters \\n            //else if difference is 1 or -2 (i.e ba,cb,ac) add 1\\n           //charater in the gap \\n            if(!diff)\\n                sum+=2;\\n            else if(diff==1|| diff==-2)\\n                sum+=1;\\n\\n        }\\n        \\n        sum+=2-(int(word[n-1]-\\'0\\')-49);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int sum=int(word[0]-\\'0\\')-49,n=word.size();\\n         \\n        for(int i=1;i<n;i++)\\n        {\\n                //for each pair of sequential indices take their difference\\n            int diff=int(word[i-1]-\\'0\\')-int(word[i]-\\'0\\');\\n            //if difference is 0 then we have to add 2 characters \\n            //else if difference is 1 or -2 (i.e ba,cb,ac) add 1\\n           //charater in the gap \\n            if(!diff)\\n                sum+=2;\\n            else if(diff==1|| diff==-2)\\n                sum+=1;\\n\\n        }\\n        \\n        sum+=2-(int(word[n-1]-\\'0\\')-49);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779702,
                "title": "c-two-pointer-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s=\"abc\";\\n        int i=0,j=0;\\n        int ans=0;\\n        while(j<word.size()){\\n            if(s[i]==word[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i++;\\n            }\\n            i=i%3;\\n        }\\n        if(i!=0)\\n        ans=ans+(3-i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s=\"abc\";\\n        int i=0,j=0;\\n        int ans=0;\\n        while(j<word.size()){\\n            if(s[i]==word[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i++;\\n            }\\n            i=i%3;\\n        }\\n        if(i!=0)\\n        ans=ans+(3-i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768595,
                "title": "simple-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int cnt = 0;\\n        if(word[0]==\\'b\\') cnt+=1;\\n        if(word[0]==\\'c\\') cnt+=2;\\n        for(int i = 1;i<n;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i-1]==\\'a\\')\\n                    cnt+=2;\\n                else if(word[i-1]==\\'b\\')\\n                    cnt+=1;\\n                    \\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i-1]==\\'b\\')\\n                    cnt+=2;\\n                else if(word[i-1]==\\'c\\')\\n                    cnt+=1;\\n            }\\n            else\\n            {\\n                if(word[i-1]==\\'a\\')\\n                    cnt+=1;\\n                else if(word[i-1]==\\'c\\')\\n                    cnt+=2;\\n            }\\n                \\n        }\\n        \\n        if(word[n-1]==\\'a\\') return cnt+2;\\n        \\n        if(word[n-1]==\\'b\\') return cnt+1;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int cnt = 0;\\n        if(word[0]==\\'b\\') cnt+=1;\\n        if(word[0]==\\'c\\') cnt+=2;\\n        for(int i = 1;i<n;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i-1]==\\'a\\')\\n                    cnt+=2;\\n                else if(word[i-1]==\\'b\\')\\n                    cnt+=1;\\n                    \\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i-1]==\\'b\\')\\n                    cnt+=2;\\n                else if(word[i-1]==\\'c\\')\\n                    cnt+=1;\\n            }\\n            else\\n            {\\n                if(word[i-1]==\\'a\\')\\n                    cnt+=1;\\n                else if(word[i-1]==\\'c\\')\\n                    cnt+=2;\\n            }\\n                \\n        }\\n        \\n        if(word[n-1]==\\'a\\') return cnt+2;\\n        \\n        if(word[n-1]==\\'b\\') return cnt+1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757814,
                "title": "c-solution-one-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n\\n        for(int i = 0; i < word.length(); i++) {\\n            if(st.empty()) {\\n                if(word[i] == \\'a\\') {\\n                    st.push(\\'a\\');\\n                } else if (word[i] == \\'b\\') {\\n                    st.push(\\'a\\');\\n                    st.push(\\'b\\');\\n                } else {\\n                    st.push(\\'a\\');\\n                    st.push(\\'b\\');\\n                    st.push(\\'c\\');\\n                }\\n            } else {\\n                char chtop = st.top();\\n                if(chtop == \\'b\\') {\\n                    if(word[i] == \\'a\\') {\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                    } else if(word[i] == \\'b\\') {\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                    } else {\\n                        st.push(\\'c\\');\\n                    }\\n                } else if(chtop == \\'a\\') {\\n                    if(word[i] == \\'a\\') {\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                    } else if(word[i] == \\'b\\') {\\n                        st.push(\\'b\\');\\n                    } else {\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                } else if(chtop == \\'c\\') {\\n                    if(word[i] == \\'b\\') {\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                    } else if(word[i] == \\'a\\') {\\n                        st.push(\\'a\\');\\n                    } else {\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(st.top() == \\'a\\') {\\n            st.push(\\'b\\');\\n            st.push(\\'c\\');\\n        } else if(st.top() == \\'b\\') {\\n            st.push(\\'c\\');\\n        }\\n\\n        int size = st.size() - word.length();\\n        return size;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n\\n        for(int i = 0; i < word.length(); i++) {\\n            if(st.empty()) {\\n                if(word[i] == \\'a\\') {\\n                    st.push(\\'a\\');\\n                } else if (word[i] == \\'b\\') {\\n                    st.push(\\'a\\');\\n                    st.push(\\'b\\');\\n                } else {\\n                    st.push(\\'a\\');\\n                    st.push(\\'b\\');\\n                    st.push(\\'c\\');\\n                }\\n            } else {\\n                char chtop = st.top();\\n                if(chtop == \\'b\\') {\\n                    if(word[i] == \\'a\\') {\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                    } else if(word[i] == \\'b\\') {\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                    } else {\\n                        st.push(\\'c\\');\\n                    }\\n                } else if(chtop == \\'a\\') {\\n                    if(word[i] == \\'a\\') {\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                    } else if(word[i] == \\'b\\') {\\n                        st.push(\\'b\\');\\n                    } else {\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                } else if(chtop == \\'c\\') {\\n                    if(word[i] == \\'b\\') {\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                    } else if(word[i] == \\'a\\') {\\n                        st.push(\\'a\\');\\n                    } else {\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(st.top() == \\'a\\') {\\n            st.push(\\'b\\');\\n            st.push(\\'c\\');\\n        } else if(st.top() == \\'b\\') {\\n            st.push(\\'c\\');\\n        }\\n\\n        int size = st.size() - word.length();\\n        return size;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745920,
                "title": "smartest-solution-available-mind-blown",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length();\\n        int ct=0,i=0;\\n        for(i=0;i<n-2;){\\n            if(word[i]==\\'a\\'){\\n                if(word[i+1]==\\'b\\' && word[i+2]==\\'c\\') i+=3;\\n                else if(word[i+1]==\\'b\\'){\\n                  ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'c\\'){\\n                    ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'a\\'){\\n                    ct+=2; i+=1;\\n                }\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(word[i+1]==\\'c\\'){\\n                    ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'a\\' || word[i+1]==\\'b\\'){\\n                    ct+=2; i+=1;\\n                }\\n            }\\n            else if(word[i]==\\'c\\'){\\n                ct+=2; i+=1;\\n            }\\n        }\\n        if(i>=n) return ct;\\n        else{\\n            if(i==n-2){\\n                if(word[i]==word[i+1]) ct+=4;\\n                else if(word[i]==\\'a\\' && (word[i+1]==\\'b\\' || word[i+1]==\\'c\\')) ct+=1;\\n                else if(word[i]==\\'b\\' && word[i+1]==\\'c\\') ct+=1;\\n                else if(word[i]==\\'b\\' && word[i+1]==\\'a\\') ct+=4;\\n                else if(word[i]==\\'c\\') ct+=4;\\n            }\\n            else{\\n                ct+=2;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length();\\n        int ct=0,i=0;\\n        for(i=0;i<n-2;){\\n            if(word[i]==\\'a\\'){\\n                if(word[i+1]==\\'b\\' && word[i+2]==\\'c\\') i+=3;\\n                else if(word[i+1]==\\'b\\'){\\n                  ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'c\\'){\\n                    ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'a\\'){\\n                    ct+=2; i+=1;\\n                }\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(word[i+1]==\\'c\\'){\\n                    ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'a\\' || word[i+1]==\\'b\\'){\\n                    ct+=2; i+=1;\\n                }\\n            }\\n            else if(word[i]==\\'c\\'){\\n                ct+=2; i+=1;\\n            }\\n        }\\n        if(i>=n) return ct;\\n        else{\\n            if(i==n-2){\\n                if(word[i]==word[i+1]) ct+=4;\\n                else if(word[i]==\\'a\\' && (word[i+1]==\\'b\\' || word[i+1]==\\'c\\')) ct+=1;\\n                else if(word[i]==\\'b\\' && word[i+1]==\\'c\\') ct+=1;\\n                else if(word[i]==\\'b\\' && word[i+1]==\\'a\\') ct+=4;\\n                else if(word[i]==\\'c\\') ct+=4;\\n            }\\n            else{\\n                ct+=2;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743394,
                "title": "simplest-c-ans-sooo-easy",
                "content": "# Intiuition\\nwe know that in the expected string the ans will always be of the format \"abcabc..\"\\nso our first letter should be \\'a\\' \\nif its \\'a\\' we can check the next letter\\nif its not \\'a\\' we can increase sum by 1 bcz we know in the word[0] position the expected string will be \\'a\\'\\n\\nsimilarly we know word[1]=\\'b\\' no matter what \\nif its \\'b\\' we can check the next letter\\nif its not we have to increment sum\\n\\n\\napply same logic for \\'c\\' as well\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int sum=0,n=word.length();\\n        for(int i=0;i<n;)\\n        {\\n            if(word[i]==\\'a\\') i++;\\n            else sum++;\\n            if(word[i]==\\'b\\') i++;\\n            else sum++;\\n            if(word[i]==\\'c\\') i++;\\n            else sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int sum=0,n=word.length();\\n        for(int i=0;i<n;)\\n        {\\n            if(word[i]==\\'a\\') i++;\\n            else sum++;\\n            if(word[i]==\\'b\\') i++;\\n            else sum++;\\n            if(word[i]==\\'c\\') i++;\\n            else sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740810,
                "title": "simple-java-solution-bruteforce-using-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        String s=\"\";\\n        for(int i=0;i<word.length();i++){\\n            if(!isSubsequence(word,s)){\\n                s+=\"abc\";\\n            }\\n        }\\n        return s.length()-word.length();\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n        int z=0;\\n        if(s.isEmpty()){\\n            return true;\\n        }\\n        for(int i=0;i<t.length() && z<s.length();i++){\\n            if(s.charAt(z)==t.charAt(i)){\\n                z++;\\n            }\\n            if(z==s.length()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        String s=\"\";\\n        for(int i=0;i<word.length();i++){\\n            if(!isSubsequence(word,s)){\\n                s+=\"abc\";\\n            }\\n        }\\n        return s.length()-word.length();\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n        int z=0;\\n        if(s.isEmpty()){\\n            return true;\\n        }\\n        for(int i=0;i<t.length() && z<s.length();i++){\\n            if(s.charAt(z)==t.charAt(i)){\\n                z++;\\n            }\\n            if(z==s.length()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729421,
                "title": "python-greedy-question-specific-and-generic-approach",
                "content": "# The Question Specific (and very bad) approach:\\nThis is DSA\\'s equivalent of hard coding in values and using \"magic numbers\". The solution is not scalable, and will fail at the smallest change of conditions. The values used here are specific to the constraints of this question, where the only three letters involved are \"a\", \"b\", \"c\". Even though solving for \"b\", \"c\", \"d\" should be the same, our solution will fail at it, or any other slightest change to the input type. \\n\\nThese relations have been attained by drawing all the possible test cases on a notebook, and noting down the answers themeselves.\\n\\n```\\ndef add_minimum(word: str) -> int:\\n    n = len(word)\\n    if (first := word[0]) == \"a\":\\n        ans = 0\\n    elif first == \"b\":\\n        ans = 1\\n    else:\\n        ans = 2\\n\\n    for i in range(1, n):\\n        if word[i] == word[i - 1]:\\n            ans += 2\\n        elif (word[i - 1], word[i]) in ((\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")):\\n            continue\\n        else:\\n            ans += 1\\n\\n    if word[-1] == \"a\":\\n        ans += 2\\n    elif word[-1] == \"b\":\\n        ans += 1\\n\\n    return ans\\n\\n```\\n\\n# Generic Approach:\\nThis is a better and more sturdy solution to this problem. It is scalable, and will provide correct answers for any number of letters, starting from wherever in the alphabet, as long as all of them are in increasing order. We can adjust ```base``` to modify the starting letter, and pass in the number of letters that the string may have.\\n\\nThese equations have been attained by writing the test cases on a notebook, and finding the *general relations* between the input and the output, instead of directly noting down the answers.\\n\\nWe can further improve scalability by allowing letters to loop around after \"Z\", but I\\'ll leave that as an exercise to you.\\n\\nEg- ```base = ord(\"a\")``` with ```n_letters = 3``` will cover ```(\"a\",\"b\",\"c\")```, whereas \\n```base = ord(\"m\")``` with ```n_letters = 5``` will cover ```(\"m\",\"n\",\"o\",\"p\",\"q\")``` and so on.\\n```\\ndef add_minimum_generic(word: str, base: str, n_letters: int) -> int:\\n    # Base is a mono-character string\\n\\n    n = len(word)\\n    base = ord(base)\\n\\n    ans = ord(word[0]) - base\\n    for i in range(1, n):\\n        if word[i] == word[i - 1]:\\n            ans += n_letters - 1\\n        else:\\n            ans += (ord(word[i]) + n_letters - ord(word[i - 1])) % n_letters - 1\\n\\n    ans += base + n_letters - ord(word[-1]) - 1\\n    return ans\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N), since we\\'re iterating through the word just once.\\n- Space complexity:\\nO(1), since we\\'re using constant space.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String",
                    "Greedy"
                ],
                "code": "```\\ndef add_minimum(word: str) -> int:\\n    n = len(word)\\n    if (first := word[0]) == \"a\":\\n        ans = 0\\n    elif first == \"b\":\\n        ans = 1\\n    else:\\n        ans = 2\\n\\n    for i in range(1, n):\\n        if word[i] == word[i - 1]:\\n            ans += 2\\n        elif (word[i - 1], word[i]) in ((\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")):\\n            continue\\n        else:\\n            ans += 1\\n\\n    if word[-1] == \"a\":\\n        ans += 2\\n    elif word[-1] == \"b\":\\n        ans += 1\\n\\n    return ans\\n\\n```\n```base```\n```base = ord(\"a\")```\n```n_letters = 3```\n```(\"a\",\"b\",\"c\")```\n```base = ord(\"m\")```\n```n_letters = 5```\n```(\"m\",\"n\",\"o\",\"p\",\"q\")```\n```\\ndef add_minimum_generic(word: str, base: str, n_letters: int) -> int:\\n    # Base is a mono-character string\\n\\n    n = len(word)\\n    base = ord(base)\\n\\n    ans = ord(word[0]) - base\\n    for i in range(1, n):\\n        if word[i] == word[i - 1]:\\n            ans += n_letters - 1\\n        else:\\n            ans += (ord(word[i]) + n_letters - ord(word[i - 1])) % n_letters - 1\\n\\n    ans += base + n_letters - ord(word[-1]) - 1\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3728680,
                "title": "masum-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char>st;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            st.push(word[i]);\\n        }\\n        int count=0;\\n        while(!st.empty())\\n        {\\n            if(!st.empty() && st.top()==\\'c\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(!st.empty() && st.top()==\\'b\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(!st.empty() && st.top()==\\'a\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n            if(st.empty())\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char>st;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            st.push(word[i]);\\n        }\\n        int count=0;\\n        while(!st.empty())\\n        {\\n            if(!st.empty() && st.top()==\\'c\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(!st.empty() && st.top()==\\'b\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(!st.empty() && st.top()==\\'a\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n            if(st.empty())\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711797,
                "title": "solved-using-easy-implementation-of-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count=0;\\n        stack<char>s;\\n        if(word[0]==\\'a\\'){\\n            s.push(word[0]);\\n        }\\n        else if(word[0]==\\'b\\'){\\n            count++;\\n            s.push(word[0]);\\n        }\\n        else if(word[0]==\\'c\\'){\\n            count += 2;\\n            s.push(word[0]);\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i]==\\'a\\'){\\n                if(s.top()==\\'b\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'a\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(s.top()==\\'c\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'b\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n            else if(word[i]==\\'c\\'){\\n                if(s.top()==\\'a\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'c\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n        }\\n        if(word[word.size()-1]==\\'b\\'){\\n            count++;\\n        }\\n        else if(word[word.size()-1]==\\'a\\'){\\n            count += 2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count=0;\\n        stack<char>s;\\n        if(word[0]==\\'a\\'){\\n            s.push(word[0]);\\n        }\\n        else if(word[0]==\\'b\\'){\\n            count++;\\n            s.push(word[0]);\\n        }\\n        else if(word[0]==\\'c\\'){\\n            count += 2;\\n            s.push(word[0]);\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i]==\\'a\\'){\\n                if(s.top()==\\'b\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'a\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(s.top()==\\'c\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'b\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n            else if(word[i]==\\'c\\'){\\n                if(s.top()==\\'a\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'c\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n        }\\n        if(word[word.size()-1]==\\'b\\'){\\n            count++;\\n        }\\n        else if(word[word.size()-1]==\\'a\\'){\\n            count += 2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700047,
                "title": "c-stack-usage",
                "content": "# Intuition\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n       stack<char>st;\\n       for(auto it:word){\\n           st.push(it);\\n       }\\n       int count=0;\\n       while(!st.empty()){\\n           if(!st.empty() && st.top()==\\'c\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(!st.empty() && st.top()==\\'b\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(!st.empty() && st.top()==\\'a\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(st.empty()){\\n               break;\\n           }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n       stack<char>st;\\n       for(auto it:word){\\n           st.push(it);\\n       }\\n       int count=0;\\n       while(!st.empty()){\\n           if(!st.empty() && st.top()==\\'c\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(!st.empty() && st.top()==\\'b\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(!st.empty() && st.top()==\\'a\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(st.empty()){\\n               break;\\n           }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697791,
                "title": "solution-for-idiots-like-me-stack-c-beats-96",
                "content": "# Intuition\\nPushing word to Stack, then popping every char increasing counter, depending on letter. \\n\\n# Approach\\n\\n# Complexity\\n\\n# Code\\n```\\npublic class Solution {\\n    public int AddMinimum(string word) {\\n        int counter = 0;\\n        Stack<char> abc = new Stack<char>();\\n        abc.Push(\\'a\\');\\n        abc.Push(\\'b\\');\\n        abc.Push(\\'c\\');\\n        foreach(char c in word){\\n            abc.Push(c);\\n        }\\n        if(abc.Peek() == \\'a\\'){\\n            abc.Push(\\'b\\');\\n            abc.Push(\\'c\\');\\n            counter += 2;\\n        }\\n        if(abc.Peek() == \\'b\\'){\\n            abc.Push(\\'c\\');\\n            counter ++;\\n        }\\n        while(abc.Count > 2){\\n            if(abc.Peek() == \\'c\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'a\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'c\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    continue;\\n                }\\n            }\\n            if(abc.Peek() == \\'b\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'a\\'){\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'c\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n            }\\n            if(abc.Peek() == \\'a\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'c\\'){\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'a\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n            }\\n        }\\n    return(counter);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int AddMinimum(string word) {\\n        int counter = 0;\\n        Stack<char> abc = new Stack<char>();\\n        abc.Push(\\'a\\');\\n        abc.Push(\\'b\\');\\n        abc.Push(\\'c\\');\\n        foreach(char c in word){\\n            abc.Push(c);\\n        }\\n        if(abc.Peek() == \\'a\\'){\\n            abc.Push(\\'b\\');\\n            abc.Push(\\'c\\');\\n            counter += 2;\\n        }\\n        if(abc.Peek() == \\'b\\'){\\n            abc.Push(\\'c\\');\\n            counter ++;\\n        }\\n        while(abc.Count > 2){\\n            if(abc.Peek() == \\'c\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'a\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'c\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    continue;\\n                }\\n            }\\n            if(abc.Peek() == \\'b\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'a\\'){\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'c\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n            }\\n            if(abc.Peek() == \\'a\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'c\\'){\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'a\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n            }\\n        }\\n    return(counter);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693055,
                "title": "best-solution-intuitive-t-c-o-n-spacecomplexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        char first=word.charAt(0);\\n        char last=word.charAt(word.length()-1);\\n        int count=0;\\n        if (first==\\'c\\'){\\n            count=count+2;\\n        }\\n        else if(first==\\'b\\'){\\n            count=count+1;\\n        }\\n        for(int i=1;i<word.length();i++){\\n            char s=word.charAt(i-1);\\n            char t=word.charAt(i);\\n            if(t==\\'a\\'){\\n                if(s==\\'a\\'){\\n                    count=count+2;\\n                }\\n                else if(s==\\'b\\'){\\n                    count=count+1;\\n                }\\n            }\\n            else if(t==\\'b\\'){\\n                if(s==\\'b\\'){\\n                    count=count+2;\\n                }\\n                else if(s==\\'c\\'){\\n                    count=count+1;\\n                }\\n            }\\n            else{\\n                if(s==\\'a\\'){\\n                    count=count+1;\\n                }\\n                else if(s==\\'c\\'){\\n                    count=count+2;\\n                }\\n            }\\n        }\\n        if(last==\\'a\\'){\\n            count=count+2;\\n        }\\n        else if(last==\\'b\\'){\\n            count=count+1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        char first=word.charAt(0);\\n        char last=word.charAt(word.length()-1);\\n        int count=0;\\n        if (first==\\'c\\'){\\n            count=count+2;\\n        }\\n        else if(first==\\'b\\'){\\n            count=count+1;\\n        }\\n        for(int i=1;i<word.length();i++){\\n            char s=word.charAt(i-1);\\n            char t=word.charAt(i);\\n            if(t==\\'a\\'){\\n                if(s==\\'a\\'){\\n                    count=count+2;\\n                }\\n                else if(s==\\'b\\'){\\n                    count=count+1;\\n                }\\n            }\\n            else if(t==\\'b\\'){\\n                if(s==\\'b\\'){\\n                    count=count+2;\\n                }\\n                else if(s==\\'c\\'){\\n                    count=count+1;\\n                }\\n            }\\n            else{\\n                if(s==\\'a\\'){\\n                    count=count+1;\\n                }\\n                else if(s==\\'c\\'){\\n                    count=count+2;\\n                }\\n            }\\n        }\\n        if(last==\\'a\\'){\\n            count=count+2;\\n        }\\n        else if(last==\\'b\\'){\\n            count=count+1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690371,
                "title": "java-paper-pen-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        for(int i =0; i < word.length();) {\\n            if(word.charAt(i) == \\'a\\') i++; else ans++;\\n            if(i < word.length() && word.charAt(i) == \\'b\\') i++; else ans++;\\n            if(i < word.length() && word.charAt(i) == \\'c\\') {\\n                 i++;\\n            }else {\\n                       ans++; \\n                    }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        for(int i =0; i < word.length();) {\\n            if(word.charAt(i) == \\'a\\') i++; else ans++;\\n            if(i < word.length() && word.charAt(i) == \\'b\\') i++; else ans++;\\n            if(i < word.length() && word.charAt(i) == \\'c\\') {\\n                 i++;\\n            }else {\\n                       ans++; \\n                    }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676988,
                "title": "c-simple-string-well-explained-solution-time-complexity-o-3-n-space-complexity-o-1",
                "content": "# UPVOTE IF YOU LIKE  ;)\\n\\n# Intuition\\nYou can observe one thing that we need to find minimum number of characters to be added to the given string to convert it into a smallest possible patern like --> abcabcabc.... \\n\\nSo one can also say that our given string \"word\" is actually a subsequence from our actual answer which is the smallest \" abcabcabc.... \" pattern needed.\\n\\nIMPORTANT--> try doing some dry run on your own to understand my approach and observe it\\'s working\\n\\n\\n# Approach\\nI rcreated a cursive function with two pointers \\'i\\' anf \\'j\\'\\n\\n\\'i\\' is for our give string \"word\" and j is to point towards any one of the characters among \\'a\\' , \\'b\\' and \\'c\\'.\\ni.e. if\\n\\nj==1, it is pointing to \\'a\\'\\nj==2, it is pointing to \\'b\\'\\nj==3, it is pointing to \\'c\\'\\n\\nvalues of j would move like 1 2 3 1 2 3 1 2 3... until \\'i\\' would traverse the string \"word\" completely \\n\\nand now our functions works like this-->\\n\\nif(word[i-1]==char by j)\\nthen we don\\'t need to add this character as it is already present in given string \"word\" at required position and do i=i+1 and j=j+1, but \\n\\nif(word[i-1]!=char by j)\\nthen this \"char by j\" is not present in string \"word\" at required position so we need to count it and then do j=j+1 to check for next character.\\n\\nSome Dry Runs-->\\nstring\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int min_addition(string& word, int i, int j)\\n    {\\n        if(j==4)\\n        {\\n            j=1;\\n        }\\n\\n        if(i>word.length())\\n        {\\n            int len=word.length();\\n            // if(word[len-1]==\\'c\\')\\n            // {\\n            //     return 0;\\n            // }\\n            // else if(word[len-1]==\\'b\\')\\n            // {\\n            //     return 1;\\n            // }\\n            // else if(word[len-1]==\\'a\\')\\n            // {\\n            //     return 2;\\n            // }\\n\\n            return \\'c\\' - word[len-1];\\n        }\\n\\n        char c1=word[i-1];\\n        char c2=\\'a\\'+(j-1);\\n\\n        if(c1==c2)\\n        {\\n           return min_addition(word, i+1, j+1);\\n        }\\n\\n        // if(c1 != c2)\\n\\n        return 1+min_addition(word, i, j+1);\\n    }\\n\\n    int addMinimum(string word) \\n    {\\n        return min_addition(word, 1, 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int min_addition(string& word, int i, int j)\\n    {\\n        if(j==4)\\n        {\\n            j=1;\\n        }\\n\\n        if(i>word.length())\\n        {\\n            int len=word.length();\\n            // if(word[len-1]==\\'c\\')\\n            // {\\n            //     return 0;\\n            // }\\n            // else if(word[len-1]==\\'b\\')\\n            // {\\n            //     return 1;\\n            // }\\n            // else if(word[len-1]==\\'a\\')\\n            // {\\n            //     return 2;\\n            // }\\n\\n            return \\'c\\' - word[len-1];\\n        }\\n\\n        char c1=word[i-1];\\n        char c2=\\'a\\'+(j-1);\\n\\n        if(c1==c2)\\n        {\\n           return min_addition(word, i+1, j+1);\\n        }\\n\\n        // if(c1 != c2)\\n\\n        return 1+min_addition(word, i, j+1);\\n    }\\n\\n    int addMinimum(string word) \\n    {\\n        return min_addition(word, 1, 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669327,
                "title": "simple-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String w) {\\n        int i=0;\\n        int res=0;\\n        while(i<w.length())\\n        {\\n            int c=0;\\n            if(w.charAt(i)==\\'a\\'){\\n            i++;\\n            c++;\\n            }\\n            if(i<w.length() && w.charAt(i)==\\'b\\'){\\n            i++;\\n            c++;\\n            }\\n            if(i<w.length() && w.charAt(i)==\\'c\\'){\\n            i++;\\n            c++;\\n            }\\n            \\n            res=res+3-c;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String w) {\\n        int i=0;\\n        int res=0;\\n        while(i<w.length())\\n        {\\n            int c=0;\\n            if(w.charAt(i)==\\'a\\'){\\n            i++;\\n            c++;\\n            }\\n            if(i<w.length() && w.charAt(i)==\\'b\\'){\\n            i++;\\n            c++;\\n            }\\n            if(i<w.length() && w.charAt(i)==\\'c\\'){\\n            i++;\\n            c++;\\n            }\\n            \\n            res=res+3-c;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658346,
                "title": "dp-solution-works-without-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[51][4];\\n    int find(string &word,int ind,int counter)\\n    {\\n        if(ind == word.size()) return 0;\\n        if(dp[ind][counter]!=-1) return dp[ind][counter];\\n        int a = 0;\\n        if(counter%3 == 1){\\n            if(word[ind] == \\'a\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        else if(counter%3 == 2){\\n            if(word[ind]==\\'b\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        else{\\n            if(word[ind] == \\'c\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        return dp[ind][counter]=a;\\n        \\n    }\\n    int addMinimum(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        int res = find(word,0,1);\\n        if(word.back() == \\'c\\')\\n            return res;\\n        else if(word.back() == \\'b\\')\\n            return res+1;\\n        else \\n            return res+2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][4];\\n    int find(string &word,int ind,int counter)\\n    {\\n        if(ind == word.size()) return 0;\\n        if(dp[ind][counter]!=-1) return dp[ind][counter];\\n        int a = 0;\\n        if(counter%3 == 1){\\n            if(word[ind] == \\'a\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        else if(counter%3 == 2){\\n            if(word[ind]==\\'b\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        else{\\n            if(word[ind] == \\'c\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        return dp[ind][counter]=a;\\n        \\n    }\\n    int addMinimum(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        int res = find(word,0,1);\\n        if(word.back() == \\'c\\')\\n            return res;\\n        else if(word.back() == \\'b\\')\\n            return res+1;\\n        else \\n            return res+2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641903,
                "title": "easy-java-with-sharan-insertion-a-b-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nProblem IS Simple: \\n\\nif a occur  count++;\\nif b occcur count++;\\nif c occur. count++;\\n\\nfor 1 loop ( we are subtarct count with  3): \\n   => that means \\n\\nfor every it will check 3 char . if how many char present i remove from 3.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        int i=0;\\n        while(i<word.length())\\n        {\\n            int count=0;;\\n            if(word.charAt(i) == \\'a\\' ){\\n                count++;\\n                i++;\\n            }\\n            if(i<word.length()  && word.charAt(i) == \\'b\\'){\\n                count++;\\n                i++;\\n            }\\n            if(i<word.length() && word.charAt(i) == \\'c\\'){\\n                count++;\\n                i++;\\n            }\\n            ans = ans + (3 - count);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        int i=0;\\n        while(i<word.length())\\n        {\\n            int count=0;;\\n            if(word.charAt(i) == \\'a\\' ){\\n                count++;\\n                i++;\\n            }\\n            if(i<word.length()  && word.charAt(i) == \\'b\\'){\\n                count++;\\n                i++;\\n            }\\n            if(i<word.length() && word.charAt(i) == \\'c\\'){\\n                count++;\\n                i++;\\n            }\\n            ans = ans + (3 - count);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617626,
                "title": "o-n-solution-observation-based-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s=\"\";\\n        int count=0;\\n        int n = word.size();\\n        if(word[0] == \\'b\\'){\\n            count+=1;\\n        }else if(word[0] ==  \\'c\\'){\\n            count+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i] == \\'a\\' && word[i-1] == \\'a\\') count+=2;\\n            if(word[i] == \\'a\\' && word[i-1] == \\'b\\') count+=1;\\n            if(word[i] == \\'b\\' && word[i-1] == \\'b\\') count+=2;\\n            if(word[i] == \\'b\\' && word[i-1] == \\'c\\') count+=1;\\n            if(word[i] == \\'c\\' && word[i-1] == \\'c\\') count+=2;\\n            if(word[i] == \\'c\\' && word[i-1] == \\'a\\') count+=1;\\n        }\\n        if(word[n-1] == \\'a\\'){\\n            count+=2;\\n        }else if(word[n-1] == \\'b\\'){\\n            count+=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s=\"\";\\n        int count=0;\\n        int n = word.size();\\n        if(word[0] == \\'b\\'){\\n            count+=1;\\n        }else if(word[0] ==  \\'c\\'){\\n            count+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i] == \\'a\\' && word[i-1] == \\'a\\') count+=2;\\n            if(word[i] == \\'a\\' && word[i-1] == \\'b\\') count+=1;\\n            if(word[i] == \\'b\\' && word[i-1] == \\'b\\') count+=2;\\n            if(word[i] == \\'b\\' && word[i-1] == \\'c\\') count+=1;\\n            if(word[i] == \\'c\\' && word[i-1] == \\'c\\') count+=2;\\n            if(word[i] == \\'c\\' && word[i-1] == \\'a\\') count+=1;\\n        }\\n        if(word[n-1] == \\'a\\'){\\n            count+=2;\\n        }else if(word[n-1] == \\'b\\'){\\n            count+=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604865,
                "title": "easy-to-understand-greedy-c-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // \\n    int addMinimum(string s) {\\n        int n = s.size();\\n        // map<char,int> mp;\\n        // int mx = 0;\\n        // for(auto it:s){\\n        //     mp[it]++;\\n        //     mx = max(mp[it],mx);\\n        // }\\n        // return 3*mx-n;\\n        int ans = 0,i=1;\\n        if(s[0]==\\'b\\') ans++;\\n        if(s[0]==\\'c\\') ans+=2;\\n        char prev = s[0];\\n        while(i<n){\\n            if(prev==\\'a\\'){\\n               if(s[i]!=\\'b\\'){\\n                   prev = \\'b\\';\\n                   ans++;\\n               }else prev=s[i],i++;\\n            }\\n            else if(prev==\\'b\\'){\\n                if(s[i]!=\\'c\\'){\\n                    prev=\\'c\\';\\n                    ans++;\\n                }else prev=s[i],i++;\\n            }\\n            else{\\n                if(s[i]!=\\'a\\'){\\n                    prev=\\'a\\';\\n                    ans++;\\n                }else prev=s[i],i++;\\n            }\\n        }\\n        if(s[n-1]==\\'a\\') ans+=2;\\n        if(s[n-1]==\\'b\\') ans+=1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // \\n    int addMinimum(string s) {\\n        int n = s.size();\\n        // map<char,int> mp;\\n        // int mx = 0;\\n        // for(auto it:s){\\n        //     mp[it]++;\\n        //     mx = max(mp[it],mx);\\n        // }\\n        // return 3*mx-n;\\n        int ans = 0,i=1;\\n        if(s[0]==\\'b\\') ans++;\\n        if(s[0]==\\'c\\') ans+=2;\\n        char prev = s[0];\\n        while(i<n){\\n            if(prev==\\'a\\'){\\n               if(s[i]!=\\'b\\'){\\n                   prev = \\'b\\';\\n                   ans++;\\n               }else prev=s[i],i++;\\n            }\\n            else if(prev==\\'b\\'){\\n                if(s[i]!=\\'c\\'){\\n                    prev=\\'c\\';\\n                    ans++;\\n                }else prev=s[i],i++;\\n            }\\n            else{\\n                if(s[i]!=\\'a\\'){\\n                    prev=\\'a\\';\\n                    ans++;\\n                }else prev=s[i],i++;\\n            }\\n        }\\n        if(s[n-1]==\\'a\\') ans+=2;\\n        if(s[n-1]==\\'b\\') ans+=1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592863,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int i = 0;\\n        int j = 0;\\n        char[] ch = new char[]{\\'a\\',\\'b\\',\\'c\\'};\\n        int ans = 0;\\n        while(i < word.length()){\\n            char expected = ch[j%3];\\n            if(word.charAt(i)==expected){\\n                i++;                \\n            }else{\\n                ans++;                \\n            }\\n            j++;\\n        }\\n        \\n        if(j%3!=0){\\n            ans += 3-j%3;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int i = 0;\\n        int j = 0;\\n        char[] ch = new char[]{\\'a\\',\\'b\\',\\'c\\'};\\n        int ans = 0;\\n        while(i < word.length()){\\n            char expected = ch[j%3];\\n            if(word.charAt(i)==expected){\\n                i++;                \\n            }else{\\n                ans++;                \\n            }\\n            j++;\\n        }\\n        \\n        if(j%3!=0){\\n            ans += 3-j%3;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583895,
                "title": "easy-python-code-with-time-complexity-o-n",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep track of the previous letter you saw and the current letter you\\'re on. Based on the differnce between the previous letter and the current letter, add the necessary number of changes to a variable named count. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n\\n        prev = \\'c\\'\\n        count = 0\\n\\n        for l in word:\\n            if l == prev: count+= 2\\n\\n            if l == \\'a\\':\\n                if prev == \\'b\\': count += 1\\n            if l == \\'b\\':\\n                if prev == \\'c\\': count += 1\\n            if l == \\'c\\':\\n                if prev == \\'a\\': count += 1\\n\\n            prev = l\\n\\n\\n        if word[len(word) - 1 ] == \\'a\\': count += 2\\n        if word[len(word) - 1 ] == \\'b\\': count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n\\n        prev = \\'c\\'\\n        count = 0\\n\\n        for l in word:\\n            if l == prev: count+= 2\\n\\n            if l == \\'a\\':\\n                if prev == \\'b\\': count += 1\\n            if l == \\'b\\':\\n                if prev == \\'c\\': count += 1\\n            if l == \\'c\\':\\n                if prev == \\'a\\': count += 1\\n\\n            prev = l\\n\\n\\n        if word[len(word) - 1 ] == \\'a\\': count += 2\\n        if word[len(word) - 1 ] == \\'b\\': count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583224,
                "title": "easy-simple-java-sol-2ms-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n       int count=0;\\n        if(word.length()==1)\\n        {\\n           return 2;\\n        }\\n          if(word.charAt(0)==\\'b\\')\\n                count+=1;\\n        else if(word.charAt(0)==\\'c\\')\\n                count+=2;\\n        for(int i=1;i<word.length();i++){\\n          \\n            \\n             if(word.charAt(i-1)==\\'a\\' && word.charAt(i)==\\'c\\')\\n                count++;\\n          else if(word.charAt(i-1)==\\'a\\' && word.charAt(i)==\\'a\\')\\n               count+=2;\\n            else if(word.charAt(i-1)==\\'b\\' && word.charAt(i)==\\'a\\')\\n                count+=1;\\n          else if(word.charAt(i-1)==\\'b\\' && word.charAt(i)==\\'b\\')\\n               count+=2;\\n            else if(word.charAt(i-1)==\\'c\\' && word.charAt(i)==\\'b\\')\\n                count+=1;\\n          else if(word.charAt(i-1)==\\'c\\' && word.charAt(i)==\\'c\\')\\n               count+=2;\\n            \\n        }\\n        if( word.charAt(word.length()-1)==\\'a\\')\\n                count+=2;\\n            else if( word.charAt(word.length()-1)==\\'b\\')\\n                count+=1;\\n        \\n        return count;\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n       int count=0;\\n        if(word.length()==1)\\n        {\\n           return 2;\\n        }\\n          if(word.charAt(0)==\\'b\\')\\n                count+=1;\\n        else if(word.charAt(0)==\\'c\\')\\n                count+=2;\\n        for(int i=1;i<word.length();i++){\\n          \\n            \\n             if(word.charAt(i-1)==\\'a\\' && word.charAt(i)==\\'c\\')\\n                count++;\\n          else if(word.charAt(i-1)==\\'a\\' && word.charAt(i)==\\'a\\')\\n               count+=2;\\n            else if(word.charAt(i-1)==\\'b\\' && word.charAt(i)==\\'a\\')\\n                count+=1;\\n          else if(word.charAt(i-1)==\\'b\\' && word.charAt(i)==\\'b\\')\\n               count+=2;\\n            else if(word.charAt(i-1)==\\'c\\' && word.charAt(i)==\\'b\\')\\n                count+=1;\\n          else if(word.charAt(i-1)==\\'c\\' && word.charAt(i)==\\'c\\')\\n               count+=2;\\n            \\n        }\\n        if( word.charAt(word.length()-1)==\\'a\\')\\n                count+=2;\\n            else if( word.charAt(word.length()-1)==\\'b\\')\\n                count+=1;\\n        \\n        return count;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581017,
                "title": "beats-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Linear scan the string and update i,ans accordingly\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) \\n    {\\n        int n=s.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(s[i]==\\'a\\')\\n          {\\n              if(i+1==n||s[i+1]==\\'a\\')\\n              ans+=2;\\n              else if(s[i+1]==\\'b\\')\\n              {\\n                  i++;\\n                 if(i+1==n)\\n                 ans+=1;\\n                 else if(s[i+1]==\\'c\\')\\n                 i++;\\n                 else ans+=1;\\n              }\\n              else if(s[i+1]==\\'c\\')\\n              {\\n                  ans+=1;\\n                  i++;\\n              }\\n          }\\n            else if(s[i]==\\'b\\')\\n            {\\n                if(i+1==n||s[i+1]==\\'a\\'||s[i+1]==\\'b\\')\\n                ans+=2;\\n                else if(s[i+1]==\\'c\\')\\n                {\\n                    ans+=1;\\n                    i++;\\n                }\\n            }\\n            else if(s[i]==\\'c\\')\\n            {\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) \\n    {\\n        int n=s.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(s[i]==\\'a\\')\\n          {\\n              if(i+1==n||s[i+1]==\\'a\\')\\n              ans+=2;\\n              else if(s[i+1]==\\'b\\')\\n              {\\n                  i++;\\n                 if(i+1==n)\\n                 ans+=1;\\n                 else if(s[i+1]==\\'c\\')\\n                 i++;\\n                 else ans+=1;\\n              }\\n              else if(s[i+1]==\\'c\\')\\n              {\\n                  ans+=1;\\n                  i++;\\n              }\\n          }\\n            else if(s[i]==\\'b\\')\\n            {\\n                if(i+1==n||s[i+1]==\\'a\\'||s[i+1]==\\'b\\')\\n                ans+=2;\\n                else if(s[i+1]==\\'c\\')\\n                {\\n                    ans+=1;\\n                    i++;\\n                }\\n            }\\n            else if(s[i]==\\'c\\')\\n            {\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579520,
                "title": "easy-two-pointer-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n         string s = \"abc\";\\n         int j = 0,i = 0,count = 0;\\n\\n        while(i < word.size()){\\n            if(s[j++] == word[i]) i++;\\n            else count++;\\n            j%=s.size();\\n        }\\n        \\n        if(word[i-1] == \\'a\\') count+=2;\\n        else if(word[i-1] == \\'b\\') count++;\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n         string s = \"abc\";\\n         int j = 0,i = 0,count = 0;\\n\\n        while(i < word.size()){\\n            if(s[j++] == word[i]) i++;\\n            else count++;\\n            j%=s.size();\\n        }\\n        \\n        if(word[i-1] == \\'a\\') count+=2;\\n        else if(word[i-1] == \\'b\\') count++;\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569953,
                "title": "c-beginner-friendly-beats-100-greedy",
                "content": "# Intuition\\nStore the last character of the iteration and calculate accordingly\\n\\n# Approach\\nGreedy approach \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ca=0;\\n        int cb=0;\\n        int cc=0;\\n        int s=0;\\n        char last=word[0];\\n        if(word.length()==1){\\n            return 2;\\n        }\\n        if(word[0]==\\'b\\'){\\n            s+=1;\\n        }\\n        if(word[0]==\\'c\\'){\\n            s+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(last==\\'a\\'){\\n                if(word[i]==\\'a\\'){\\n                   s+=2;\\n                   last=\\'a\\';\\n                }\\n                else if(word[i]==\\'c\\'){\\n                    s+=1;\\n                    last=\\'c\\';\\n                }\\n                else{\\n                    last=\\'b\\';\\n\\n                }\\n\\n            }\\n            else if(last==\\'b\\'){\\n\\n                if(word[i]==\\'a\\'){\\n                   s+=1;\\n                   last=\\'a\\';\\n                }\\n                else if(word[i]==\\'b\\'){\\n                    s+=2;\\n                    last=\\'b\\';\\n                }\\n                else{\\n                    last=\\'c\\';\\n\\n                }\\n\\n            }\\n            else{\\n\\n                if(word[i]==\\'b\\'){\\n                   s+=1;\\n                   last=\\'b\\';\\n                }\\n                else if(word[i]==\\'c\\'){\\n                    s+=2;\\n                    last=\\'c\\';\\n                }\\n                else{\\n                    last=\\'a\\';\\n\\n                }\\n\\n\\n            }\\n\\n\\n        }\\n        if(last==\\'a\\'){\\n            s+=2;\\n        }\\n        else if(last==\\'b\\'){\\n            s+=1;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ca=0;\\n        int cb=0;\\n        int cc=0;\\n        int s=0;\\n        char last=word[0];\\n        if(word.length()==1){\\n            return 2;\\n        }\\n        if(word[0]==\\'b\\'){\\n            s+=1;\\n        }\\n        if(word[0]==\\'c\\'){\\n            s+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(last==\\'a\\'){\\n                if(word[i]==\\'a\\'){\\n                   s+=2;\\n                   last=\\'a\\';\\n                }\\n                else if(word[i]==\\'c\\'){\\n                    s+=1;\\n                    last=\\'c\\';\\n                }\\n                else{\\n                    last=\\'b\\';\\n\\n                }\\n\\n            }\\n            else if(last==\\'b\\'){\\n\\n                if(word[i]==\\'a\\'){\\n                   s+=1;\\n                   last=\\'a\\';\\n                }\\n                else if(word[i]==\\'b\\'){\\n                    s+=2;\\n                    last=\\'b\\';\\n                }\\n                else{\\n                    last=\\'c\\';\\n\\n                }\\n\\n            }\\n            else{\\n\\n                if(word[i]==\\'b\\'){\\n                   s+=1;\\n                   last=\\'b\\';\\n                }\\n                else if(word[i]==\\'c\\'){\\n                    s+=2;\\n                    last=\\'c\\';\\n                }\\n                else{\\n                    last=\\'a\\';\\n\\n                }\\n\\n\\n            }\\n\\n\\n        }\\n        if(last==\\'a\\'){\\n            s+=2;\\n        }\\n        else if(last==\\'b\\'){\\n            s+=1;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565849,
                "title": "c-o-n-simple-easy-to-understand-beats-100-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int addMinimum(string word) {\\n        int ans=0;\\n        if(word[0]==\\'b\\'){\\n            ans+=1;\\n        }\\n        if(word[0]==\\'c\\'){\\n            ans+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i]==\\'a\\'){\\n                if(word[i-1]==\\'a\\'){\\n                    ans+=2;\\n                }\\n                if(word[i-1]==\\'b\\'){\\n                    ans+=1;\\n                }\\n            }\\n            if(word[i]==\\'b\\'){\\n                if(word[i-1]==\\'b\\'){\\n                    ans+=2;\\n                }\\n                if(word[i-1]==\\'c\\'){\\n                    ans+=1;\\n                }\\n            }\\n            if(word[i]==\\'c\\'){\\n                if(word[i-1]==\\'a\\'){\\n                    ans+=1;\\n                }\\n                if(word[i-1]==\\'c\\'){\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        if(word[word.size()-1]==\\'b\\'){\\n            ans+=1;\\n        }\\n        if(word[word.size()-1]==\\'a\\'){\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int addMinimum(string word) {\\n        int ans=0;\\n        if(word[0]==\\'b\\'){\\n            ans+=1;\\n        }\\n        if(word[0]==\\'c\\'){\\n            ans+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i]==\\'a\\'){\\n                if(word[i-1]==\\'a\\'){\\n                    ans+=2;\\n                }\\n                if(word[i-1]==\\'b\\'){\\n                    ans+=1;\\n                }\\n            }\\n            if(word[i]==\\'b\\'){\\n                if(word[i-1]==\\'b\\'){\\n                    ans+=2;\\n                }\\n                if(word[i-1]==\\'c\\'){\\n                    ans+=1;\\n                }\\n            }\\n            if(word[i]==\\'c\\'){\\n                if(word[i-1]==\\'a\\'){\\n                    ans+=1;\\n                }\\n                if(word[i-1]==\\'c\\'){\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        if(word[word.size()-1]==\\'b\\'){\\n            ans+=1;\\n        }\\n        if(word[word.size()-1]==\\'a\\'){\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561545,
                "title": "c-ugly-map-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        unordered_map<char, unordered_map<char, int>> m;\\n        m[\\'a\\'][\\'a\\'] = 2;\\n        m[\\'a\\'][\\'c\\'] = 1;\\n        m[\\'a\\'][\\'b\\'] = 0;\\n        m[\\'b\\'][\\'c\\'] = 0;\\n        m[\\'b\\'][\\'a\\'] = 1;\\n        m[\\'b\\'][\\'b\\'] = 2;\\n        m[\\'c\\'][\\'c\\'] = 2;\\n        m[\\'c\\'][\\'a\\'] = 0;\\n        m[\\'c\\'][\\'b\\'] = 1;\\n        int ans = word[0] == \\'a\\' ? 0 : word[0] == \\'b\\' ? 1 : 2;\\n        char prev = word[0];\\n        for (int i = 1; i < word.size(); ++i){\\n            ans += m[prev][word[i]];\\n            prev = word[i];\\n        }\\n        int add = prev == \\'c\\' ? 0 : prev == \\'b\\' ? 1 : 2;\\n        return ans + add;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        unordered_map<char, unordered_map<char, int>> m;\\n        m[\\'a\\'][\\'a\\'] = 2;\\n        m[\\'a\\'][\\'c\\'] = 1;\\n        m[\\'a\\'][\\'b\\'] = 0;\\n        m[\\'b\\'][\\'c\\'] = 0;\\n        m[\\'b\\'][\\'a\\'] = 1;\\n        m[\\'b\\'][\\'b\\'] = 2;\\n        m[\\'c\\'][\\'c\\'] = 2;\\n        m[\\'c\\'][\\'a\\'] = 0;\\n        m[\\'c\\'][\\'b\\'] = 1;\\n        int ans = word[0] == \\'a\\' ? 0 : word[0] == \\'b\\' ? 1 : 2;\\n        char prev = word[0];\\n        for (int i = 1; i < word.size(); ++i){\\n            ans += m[prev][word[i]];\\n            prev = word[i];\\n        }\\n        int add = prev == \\'c\\' ? 0 : prev == \\'b\\' ? 1 : 2;\\n        return ans + add;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561029,
                "title": "easy-simple-solution-o-1-space-o-n",
                "content": "# Approach\\n\\'abc\\' is the pattern that should be followed so after a ,b should come and after b, c and after c, a should come and if the order is not same then increase the count as per old and current character.\\n**The last character** should be \\'c\\' and if a ,b then count should be increase by 2 , 1 respectively. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int count=0;\\n        char old=\\'c\\';\\n        for(int t=0;t<word.length();t++){\\n            char ch=word.charAt(t);\\n            if(ch==\\'a\\'){\\n                if(old==\\'a\\')count+=2;\\n                if(old==\\'b\\')count++;\\n            }\\n             if(ch==\\'b\\'){\\n                if(old==\\'c\\')count+=1;\\n                if(old==\\'b\\')count+=2;\\n            }\\n             if(ch==\\'c\\'){\\n                if(old==\\'c\\')count+=2;\\n                if(old==\\'a\\')count++;\\n            }\\n            old=ch;\\n        }\\n        count+=(\\'c\\'-old);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int count=0;\\n        char old=\\'c\\';\\n        for(int t=0;t<word.length();t++){\\n            char ch=word.charAt(t);\\n            if(ch==\\'a\\'){\\n                if(old==\\'a\\')count+=2;\\n                if(old==\\'b\\')count++;\\n            }\\n             if(ch==\\'b\\'){\\n                if(old==\\'c\\')count+=1;\\n                if(old==\\'b\\')count+=2;\\n            }\\n             if(ch==\\'c\\'){\\n                if(old==\\'c\\')count+=2;\\n                if(old==\\'a\\')count++;\\n            }\\n            old=ch;\\n        }\\n        count+=(\\'c\\'-old);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554268,
                "title": "java-one-swipe-no-dp-with-explanation",
                "content": "# Intuition\\nWe need to repeat a pattern of \"abc\" in a given string by adding charecters .\\nAs we can only add charecters , to add the minimum number of them we will have to use those who partialy or completely fit the pattern and expand upon them .\\n\\n# Approach\\nIn the given solution we repeat a patten of 0 , 1 , 2 in the variable pattern\\n```\\n    int pattern = 0;\\n    .\\n    .\\n    .\\n    pattern = (pattern+1)%3;\\n```\\n and in turn repeating the pattern \\'a\\' , \\'b\\' , \\'c\\' in\\n```\\n    pattern+\\'a\\'\\n```\\nWe then iterate through the given string and check if the charecter at a give index matches or not .\\n\\n- If the pattern and charecter at index mathch then both move forword and there is no need to add extra charecters (no change in res)\\n- Otherwise we need to add new charecter (res ++) and pattern moves forword\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int res = 0 ;\\n        int index = 0;\\n        int pattern = 0;\\n        int len = word.length();\\n        while (index<len){\\n            if(word.charAt(index)==pattern+\\'a\\'){\\n                index++;\\n            }\\n            else{\\n                res++;\\n            }\\n            pattern = (pattern+1)%3;\\n        }\\n        return res + (\\'c\\'- word.charAt(len-1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    int pattern = 0;\\n    .\\n    .\\n    .\\n    pattern = (pattern+1)%3;\\n```\n```\\n    pattern+\\'a\\'\\n```\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int res = 0 ;\\n        int index = 0;\\n        int pattern = 0;\\n        int len = word.length();\\n        while (index<len){\\n            if(word.charAt(index)==pattern+\\'a\\'){\\n                index++;\\n            }\\n            else{\\n                res++;\\n            }\\n            pattern = (pattern+1)%3;\\n        }\\n        return res + (\\'c\\'- word.charAt(len-1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865764,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865557,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1964460,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864937,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864814,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864768,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2075372,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2022727,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1902740,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865638,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865764,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865557,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1964460,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864937,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864814,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864768,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2075372,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2022727,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1902740,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865638,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]