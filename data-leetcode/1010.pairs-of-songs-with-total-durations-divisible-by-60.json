[
    {
        "title": "Construct Binary Search Tree from Preorder Traversal",
        "question_content": "Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.\nIt is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.\nA binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val.\nA preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.\n&nbsp;\nExample 1:\nInput: preorder = [8,5,1,7,10,12]\nOutput: [8,5,10,1,7,null,12]\nExample 2:\nInput: preorder = [1,3]\nOutput: [1,null,3]\n&nbsp;\nConstraints:\n\t1 <= preorder.length <= 100\n\t1 <= preorder[i] <= 1000\n\tAll the values of preorder are unique.",
        "solutions": [
            {
                "id": 252232,
                "title": "java-c-python-o-n-solution",
                "content": "# **Intuition**:\\nFind the left part and right part,\\nthen recursively construct the tree.\\n<br>\\n\\n# **Solution 1**:\\nBinary search\\n\\n**Python, `O(N^2)`**\\n```py\\n    def bstFromPreorder(self, A):\\n        if not A: return None\\n        root = TreeNode(A[0])\\n        i = bisect.bisect(A, A[0])\\n        root.left = self.bstFromPreorder(A[1:i])\\n        root.right = self.bstFromPreorder(A[i:])\\n        return root\\n```\\n\\n**Python, `O(NlogN)`**\\n```py\\n    def bstFromPreorder(self, A):\\n        def helper(i, j):\\n            if i == j: return None\\n            root = TreeNode(A[i])\\n            mid = bisect.bisect(A, A[i], i + 1, j)\\n            root.left = helper(i + 1, mid)\\n            root.right = helper(mid, j)\\n            return root\\n        return helper(0, len(A))\\n```\\n<br>\\n\\n\\n# **Solution 2**\\n\\nGive the function a bound the maximum number it will handle.\\nThe left recursion will take the elements smaller than `node.val`\\nThe right recursion will take the remaining elements smaller than `bound`\\n\\n\\n**Complexity**\\n`bstFromPreorder` is called exactly `N` times.\\nIt\\'s same as a preorder traversal.\\nTime `O(N)`\\nSpace `O(H)`\\n\\n**Java**\\n```java\\n    int i = 0;\\n    public TreeNode bstFromPreorder(int[] A) {\\n        return bstFromPreorder(A, Integer.MAX_VALUE);\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] A, int bound) {\\n        if (i == A.length || A[i] > bound) return null;\\n        TreeNode root = new TreeNode(A[i++]);\\n        root.left = bstFromPreorder(A, root.val);\\n        root.right = bstFromPreorder(A, bound);\\n        return root;\\n    }\\n```\\n**C++**\\n```cpp\\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& A, int bound = INT_MAX) {\\n        if (i == A.size() || A[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(A[i++]);\\n        root->left = bstFromPreorder(A, root->val);\\n        root->right = bstFromPreorder(A, bound);\\n        return root;\\n    }\\n```\\n**Python**\\n```python\\n    i = 0\\n    def bstFromPreorder(self, A, bound=float(\\'inf\\')):\\n        if self.i == len(A) or A[self.i] > bound:\\n            return None\\n        root = TreeNode(A[self.i])\\n        self.i += 1\\n        root.left = self.bstFromPreorder(A, root.val)\\n        root.right = self.bstFromPreorder(A, bound)\\n        return root\\n```\\n<br>\\n\\n# Solution 2.1\\nSome may don\\'t like the global variable `i`.\\nWell, I first reused the function in python,\\nso I had to use it, making it a \"stateful\" function.\\n\\nI didn\\'t realize there would be people who care about it.\\nIf it\\'s really matters,\\nWe can discard the usage of global function.\\n\\n**C++**\\n```cpp\\n    TreeNode* bstFromPreorder(vector<int>& A) {\\n        int i = 0;\\n        return build(A, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& A, int& i, int bound) {\\n        if (i == A.size() || A[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(A[i++]);\\n        root->left = build(A, i, root->val);\\n        root->right = build(A, i, bound);\\n        return root;\\n    }\\n```\\n**Java**\\n```java\\n    public TreeNode bstFromPreorder(int[] A) {\\n        return bstFromPreorder(A, Integer.MAX_VALUE, new int[]{0});\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] A, int bound, int[] i) {\\n        if (i[0] == A.length || A[i[0]] > bound) return null;\\n        TreeNode root = new TreeNode(A[i[0]++]);\\n        root.left = bstFromPreorder(A, root.val, i);\\n        root.right = bstFromPreorder(A, bound, i);\\n        return root;\\n    }\\n```\\n**Python**\\n```python\\n    def bstFromPreorder(self, A):\\n        return self.buildTree(A[::-1], float(\\'inf\\'))\\n\\n    def buildTree(self, A, bound):\\n        if not A or A[-1] > bound: return None\\n        node = TreeNode(A.pop())\\n        node.left = self.buildTree(A, node.val)\\n        node.right = self.buildTree(A, bound)\\n        return node\\n```",
                "solutionTags": [],
                "code": "```py\\n    def bstFromPreorder(self, A):\\n        if not A: return None\\n        root = TreeNode(A[0])\\n        i = bisect.bisect(A, A[0])\\n        root.left = self.bstFromPreorder(A[1:i])\\n        root.right = self.bstFromPreorder(A[i:])\\n        return root\\n```\n```py\\n    def bstFromPreorder(self, A):\\n        def helper(i, j):\\n            if i == j: return None\\n            root = TreeNode(A[i])\\n            mid = bisect.bisect(A, A[i], i + 1, j)\\n            root.left = helper(i + 1, mid)\\n            root.right = helper(mid, j)\\n            return root\\n        return helper(0, len(A))\\n```\n```java\\n    int i = 0;\\n    public TreeNode bstFromPreorder(int[] A) {\\n        return bstFromPreorder(A, Integer.MAX_VALUE);\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] A, int bound) {\\n        if (i == A.length || A[i] > bound) return null;\\n        TreeNode root = new TreeNode(A[i++]);\\n        root.left = bstFromPreorder(A, root.val);\\n        root.right = bstFromPreorder(A, bound);\\n        return root;\\n    }\\n```\n```cpp\\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& A, int bound = INT_MAX) {\\n        if (i == A.size() || A[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(A[i++]);\\n        root->left = bstFromPreorder(A, root->val);\\n        root->right = bstFromPreorder(A, bound);\\n        return root;\\n    }\\n```\n```python\\n    i = 0\\n    def bstFromPreorder(self, A, bound=float(\\'inf\\')):\\n        if self.i == len(A) or A[self.i] > bound:\\n            return None\\n        root = TreeNode(A[self.i])\\n        self.i += 1\\n        root.left = self.bstFromPreorder(A, root.val)\\n        root.right = self.bstFromPreorder(A, bound)\\n        return root\\n```\n```cpp\\n    TreeNode* bstFromPreorder(vector<int>& A) {\\n        int i = 0;\\n        return build(A, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& A, int& i, int bound) {\\n        if (i == A.size() || A[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(A[i++]);\\n        root->left = build(A, i, root->val);\\n        root->right = build(A, i, bound);\\n        return root;\\n    }\\n```\n```java\\n    public TreeNode bstFromPreorder(int[] A) {\\n        return bstFromPreorder(A, Integer.MAX_VALUE, new int[]{0});\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] A, int bound, int[] i) {\\n        if (i[0] == A.length || A[i[0]] > bound) return null;\\n        TreeNode root = new TreeNode(A[i[0]++]);\\n        root.left = bstFromPreorder(A, root.val, i);\\n        root.right = bstFromPreorder(A, bound, i);\\n        return root;\\n    }\\n```\n```python\\n    def bstFromPreorder(self, A):\\n        return self.buildTree(A[::-1], float(\\'inf\\'))\\n\\n    def buildTree(self, A, bound):\\n        if not A or A[-1] > bound: return None\\n        node = TreeNode(A.pop())\\n        node.left = self.buildTree(A, node.val)\\n        node.right = self.buildTree(A, bound)\\n        return node\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 252722,
                "title": "python-stack-solution-beats-100-on-runtime-and-memory",
                "content": "* Idea is simple.\\n* First item in preorder list is the root to be considered.\\n* For next item in preorder list, there are 2 cases to consider:\\n\\t* If value is less than last item in stack, it is the left child of last item.\\n\\t* If value is greater than last item in stack, pop it.\\n\\t\\t* The last popped item will be the parent and the item will be the right child of the parent.\\n```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        for value in preorder[1:]:\\n            if value < stack[-1].val:\\n                stack[-1].left = TreeNode(value)\\n                stack.append(stack[-1].left)\\n            else:\\n                while stack and stack[-1].val < value:\\n                    last = stack.pop()\\n                last.right = TreeNode(value)\\n                stack.append(last.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        for value in preorder[1:]:\\n            if value < stack[-1].val:\\n                stack[-1].left = TreeNode(value)\\n                stack.append(stack[-1].left)\\n            else:\\n                while stack and stack[-1].val < value:\\n                    last = stack.pop()\\n                last.right = TreeNode(value)\\n                stack.append(last.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252273,
                "title": "c-o-n-log-n-and-o-n",
                "content": "The first element ```p[0]``` in the array corresponds to the root. Then, we find the split point ```i``` such as ```p[i] >= p[0]```. Subarray ```[1, i - 1]``` corresponds to the left subtree, ```[i, n - 1]``` - to the right one.\\n```\\nTreeNode* bstFromPreorder(vector<int> &p, int first = 0, int last = 0) {\\n    if (last == 0) last = p.size();\\n    if (first == last) return nullptr;\\n    auto split = find_if(begin(p) + first, begin(p) + last, [&](int val) { return val > p[first]; });\\n    auto root = new TreeNode(p[first]);\\n    root->left = bstFromPreorder(p, first + 1, split - begin(p));\\n    root->right = bstFromPreorder(p, split - begin(p), last);\\n    return root;\\n}\\n```\\n**Complexity Analysis**\\n- Runtime: *O(n * n)* worst case, *O(n log n)* average case. For each node (*n*), we search for the split point (*log n* average, *n* worst case).\\n- Memory: *O(n)* worst case, *O(h)* average case for the stack, where *h* is the height of the tree.\\n\\n#### O(n) Solution\\nIn the solution above, we are searching for a split point to divide the interval. Instead, we can pass the parent value to the recursive function to generate the left sub-tree. The generation will stop when the value in the `preorder` array exceeds the parent value. That will be our split point to start generating the right subtree.\\n```CPP\\nint idx = 0;\\nTreeNode* bstFromPreorder(vector<int>& preorder, int p_val = INT_MAX) {\\n    if (idx >= preorder.size() || preorder[idx] > p_val)\\n        return nullptr;\\n    auto n = new TreeNode(preorder[idx++]);\\n    n->left = bstFromPreorder(preorder, n->val);\\n    n->right = bstFromPreorder(preorder, p_val);\\n    return n;\\n}\\n```",
                "solutionTags": [],
                "code": "```p[0]```\n```i```\n```p[i] >= p[0]```\n```[1, i - 1]```\n```[i, n - 1]```\n```\\nTreeNode* bstFromPreorder(vector<int> &p, int first = 0, int last = 0) {\\n    if (last == 0) last = p.size();\\n    if (first == last) return nullptr;\\n    auto split = find_if(begin(p) + first, begin(p) + last, [&](int val) { return val > p[first]; });\\n    auto root = new TreeNode(p[first]);\\n    root->left = bstFromPreorder(p, first + 1, split - begin(p));\\n    root->right = bstFromPreorder(p, split - begin(p), last);\\n    return root;\\n}\\n```\n```CPP\\nint idx = 0;\\nTreeNode* bstFromPreorder(vector<int>& preorder, int p_val = INT_MAX) {\\n    if (idx >= preorder.size() || preorder[idx] > p_val)\\n        return nullptr;\\n    auto n = new TreeNode(preorder[idx++]);\\n    n->left = bstFromPreorder(preorder, n->val);\\n    n->right = bstFromPreorder(preorder, p_val);\\n    return n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252754,
                "title": "java-stack-iterative-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if (preorder == null || preorder.length == 0) {\\n            return null;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode root = new TreeNode(preorder[0]);\\n        stack.push(root);\\n        for (int i = 1; i < preorder.length; i++) {\\n            TreeNode node = new TreeNode(preorder[i]);\\n            if (preorder[i] < stack.peek().val) {                \\n                stack.peek().left = node;                \\n            } else {\\n                TreeNode parent = stack.peek();\\n                while (!stack.isEmpty() && preorder[i] > stack.peek().val) {\\n                    parent = stack.pop();\\n                }\\n                parent.right = node;\\n            }\\n            stack.push(node);            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if (preorder == null || preorder.length == 0) {\\n            return null;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode root = new TreeNode(preorder[0]);\\n        stack.push(root);\\n        for (int i = 1; i < preorder.length; i++) {\\n            TreeNode node = new TreeNode(preorder[i]);\\n            if (preorder[i] < stack.peek().val) {                \\n                stack.peek().left = node;                \\n            } else {\\n                TreeNode parent = stack.peek();\\n                while (!stack.isEmpty() && preorder[i] > stack.peek().val) {\\n                    parent = stack.pop();\\n                }\\n                parent.right = node;\\n            }\\n            stack.push(node);            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588589,
                "title": "python-3-recursive-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        i = 1\\n        while i<len(preorder) and  preorder[i] < root.val:\\n            i+=1\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        return root\\n```\\n\\nWork through with example `preorder = [8,5,1,7,10,12]`\\n- root = preorder[0] = 8\\n- root.left = [5,1,7]\\n\\t- root.left = 5\\n\\t- root.left.left = [1]\\n\\t\\t- root.left.left = 1\\n\\t- root.left.right = [7]\\n\\t\\t- root.left.right = 7\\n- root.right = [10,12]\\n\\t- root.right = 10\\n\\t- root.right.left = None\\n\\t- root.right.right = [12]\\n\\t\\t- root.right.right = 12\\n\\n\\n***\\nCheck on my [repo](https://github.com/zengtian006/LeetCode) to get Leetcode solution(Python) with classification: https://github.com/zengtian006/LeetCode\\n***\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        i = 1\\n        while i<len(preorder) and  preorder[i] < root.val:\\n            i+=1\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589059,
                "title": "java-easiest-solution-with-clear-explanation-of-logic",
                "content": "ok lets do this!!\\nso we are given an array which is the preorder traversal of the some tree!\\nwe are used to traverse a tree a but are not privy to reconstruct the tree from the array!!\\nanyways!!!\\nso we are given an array whose first element is the root of out tree!!(because of preorder traversal)!\\nNOTE:this is not a linear solution!i have posted linear solutions here https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/589801/JAVA-3-WAYS-TO-DO-THE-PROBLEM!-O(N)-APPROACH\\nBUT i strongly suggest you go through this soution below so that you can get the gist of the logic and then move on to the more complex linear solutions i posted!\\n\\nLETS DO THIS:\\n\\nso we follow  steps:\\n1>we create the node\\n2>we traverse the array for values which are less than the current node!-- these values will become our left subtree.we stop whenever we get a value larger than the current root of the subtree!\\n3>we take the rest of the array(values whuch are greater than the value of the current root)-these are the values which will make out right subtree!\\n\\nso we make a root!\\nmake the left subtree(recursively)\\nthen make right subtree(recursively)\\n\\n\\ncode here!!\\ndo a couple of dry runs!\\nu will get it!\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n     return helper(preorder, 0, preorder.length - 1);   \\n    }\\n    \\n    private TreeNode helper(int[] preorder, int start, int end) {\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[start]);\\n        int i;\\n        for(i=start;i<=end;i++) {\\n        if(preorder[i] > node.val)\\n            break;\\n        }\\n        \\n        node.left = helper(preorder, start+1, i-1);\\n        node.right = helper(preorder, i, end);\\n        return node;\\n        \\n        \\n        \\n    }\\n    \\n    \\n}\\n```\\n\\nhope it helps!!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n     return helper(preorder, 0, preorder.length - 1);   \\n    }\\n    \\n    private TreeNode helper(int[] preorder, int start, int end) {\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[start]);\\n        int i;\\n        for(i=start;i<=end;i++) {\\n        if(preorder[i] > node.val)\\n            break;\\n        }\\n        \\n        node.left = helper(preorder, start+1, i-1);\\n        node.right = helper(preorder, i, end);\\n        return node;\\n        \\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588642,
                "title": "explaining-the-o-n-approach-with-c-code-beats-100-solutions",
                "content": "The O(NlogN) approch which everybody tries is O(N\\\\*N). Lets say the case where array is sorted in decreasing order, there it will go quadratic. 5, 4, 3, 2, 1\\n\\nWe understand the given O(N) solution by:\\n1. It is preorder traversal that is all the nodes in left tree is encountered before the nodes of right so we can generate the temp nodes as soon as we visit them.\\n2. We see the split point by sending a variable parent_value which denotes the value of the parent, once the value at index idx becomes greater than parent value we can retuen NULL, we make sure that all the nodes are less than the parent value are inserted in left subtree.\\n3. Once a node is less than parent value is found we make that node as left subtree and call the function recursively, and when the left recursion is over( when all values becomes greater than the current node\\'s value) we will observe that the global idx will definately come to a point where the next node should be inserted to the right subtree\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int idx = 0;\\n    TreeNode *bstFromPreorder(vector<int> &preorder, int parent_value = INT_MAX)\\n    {\\n        if (idx == preorder.size() || preorder[idx] > parent_value)\\n            return NULL;\\n        int current_value = preorder[idx++];\\n        TreeNode *temp = new TreeNode(current_value);\\n        temp->left = bstFromPreorder(preorder, current_value);\\n        temp->right = bstFromPreorder(preorder, parent_value);\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int idx = 0;\\n    TreeNode *bstFromPreorder(vector<int> &preorder, int parent_value = INT_MAX)\\n    {\\n        if (idx == preorder.size() || preorder[idx] > parent_value)\\n            return NULL;\\n        int current_value = preorder[idx++];\\n        TreeNode *temp = new TreeNode(current_value);\\n        temp->left = bstFromPreorder(preorder, current_value);\\n        temp->right = bstFromPreorder(preorder, parent_value);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839651,
                "title": "simple-recusrsive-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1)\\n            return root;\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i=0;i<preorder.size();i++)\\n        {\\n            if(preorder[i]>preorder[0])\\n                right.push_back(preorder[i]);\\n            else if(preorder[i]<preorder[0])\\n                left.push_back(preorder[i]);\\n        }\\n        root->left=bstFromPreorder(left);\\n        root->right=bstFromPreorder(right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1)\\n            return root;\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i=0;i<preorder.size();i++)\\n        {\\n            if(preorder[i]>preorder[0])\\n                right.push_back(preorder[i]);\\n            else if(preorder[i]<preorder[0])\\n                left.push_back(preorder[i]);\\n        }\\n        root->left=bstFromPreorder(left);\\n        root->right=bstFromPreorder(right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589801,
                "title": "java-3-ways-to-do-the-problem-o-n-approach",
                "content": "THIS IS A CONTINUATION OF MY PREVIOUS POST!\\nWHICH HAD O(N^2) APPROACH!\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/589059/java-easiest-solution-with-clear-explanation-of-logic\\n\\n\\nAS A LOT OF PEOPLE ARE ASKING FOR LINEAR SOLUTONS HERE IT IS!\\n\\nAPPROACH 1-O(N)\\nJAVA-LOWER AND UPPER BOUND RECURSIVE\\n\\n```\\nclass Solution {\\n    int nodeIndex;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if(preorder == null) {\\n            return null;\\n        }\\n        nodeIndex = 0;\\n        return bstHelper(preorder, Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    private TreeNode bstHelper(int[] preorder, int start, int end) {\\n        if(nodeIndex == preorder.length || preorder[nodeIndex]<start || preorder[nodeIndex]>end) {\\n            return null;\\n        }\\n        int val = preorder[nodeIndex++];\\n        TreeNode node = new TreeNode(val);\\n        node.left = bstHelper(preorder, start, val);\\n        node.right = bstHelper(preorder, val, end);\\n        return node;   \\n    }   \\n} \\n```\\n\\nAPPROACH 2- O(N)!\\nJAVA ONLY UPPER BOUND- RECURSIVE\\nEXPLANATION-\\nEvery node has an upper bound.\\n\\nLeft node is bounded by the parent node\\'s value.\\nRight node is bounded by the ancestor\\'s bound.\\nUsing the example in the question:\\nThe nodes [5, 1, 7] are all bounded by 8.\\nThe node 1 is bounded by 5.\\n8 is the root node, but if you think deeper about it, it is bounded by  Integer.MAX_VALUE. i.e. imagine there is a root parent node Integer.MAX_VALUE with left node being 8.\\nThis also means that both 10 and 12 nodes, which are also right nodes, are also bounded by Integer.MAX_VALUE.\\nWe use a recursive function together with an outer index variable i to traverse and construct the tree. When we create a tree node, we increment i to process the next element in the preorder array.\\n\\nWe don\\'t need to care about lower bound. When we construct the tree, we try to create left node first. If the condition fails (i.e. current number is greater than the parent node value), then we try to create the right node which automatically satisfies the condition, hence no lower bound is needed\\n\\n\\n```\\nclass Solution {\\nint i = 0;\\n    public TreeNode bstFromPreorder(int[] arr) {\\n        return helper(arr, Integer.MAX_VALUE);\\n    }\\n\\n    public TreeNode helper(int[] arr, int bound) {\\n        if (i == arr.length || arr[i] > bound) return null;\\n        TreeNode root = new TreeNode(arr[i++]);\\n        root.left = helper(arr, root.val);\\n        root.right = helper(arr, bound);\\n        return root;\\n    }\\n\\t}\\n\\t```\\n\\t\\nEXPLANATON-\\n\"explanation- It is  possible to do this because when we construct the \" left child \" the upper bound will be the node value itself and no lower bound will be needed!\\n\\t-no lower bound is required for \"right child\" because we have arrived at this point of creating the right child only because these elements failed to satisfy the left subtree conditions!\"\\n\\t\\n \\n ```\\n APPROACH 3-IF YOU ARE NOT COMFORTABLE WITH RECURSION!\\n JAVA ITERATIVE APPROACH - \\n\\n```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        \\n        if(preorder == null){\\n            return null;\\n        }\\n        int size = preorder.length;\\n        if(size==0){\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[0]);\\n\\t\\t\\n        for(int i=1;i<size;i++){\\n             generateBST(preorder[i],root);\\n        }\\n        return root;\\n    }\\n    \\n    public void generateBST(int target, TreeNode tree){\\n        TreeNode root = tree;\\n        TreeNode node = new TreeNode(target);\\n            while(root!=null){\\n                if(target<root.val){\\n                    if(root.left==null){\\n                        root.left = node;\\n                        break;\\n                    }\\n                    else{\\n                         root=root.left;\\n                    }\\n                }else{\\n                    if(root.right==null){\\n                        root.right=node;\\n                        break;\\n                    }else{\\n                        root=root.right;\\n                    }\\n                }\\n            }\\n      }\\n}\\n\\n```\\n\\nHOPE IT HELPS!\\n\\t\\n\\t",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    int nodeIndex;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if(preorder == null) {\\n            return null;\\n        }\\n        nodeIndex = 0;\\n        return bstHelper(preorder, Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    private TreeNode bstHelper(int[] preorder, int start, int end) {\\n        if(nodeIndex == preorder.length || preorder[nodeIndex]<start || preorder[nodeIndex]>end) {\\n            return null;\\n        }\\n        int val = preorder[nodeIndex++];\\n        TreeNode node = new TreeNode(val);\\n        node.left = bstHelper(preorder, start, val);\\n        node.right = bstHelper(preorder, val, end);\\n        return node;   \\n    }   \\n} \\n```\n```\\nclass Solution {\\nint i = 0;\\n    public TreeNode bstFromPreorder(int[] arr) {\\n        return helper(arr, Integer.MAX_VALUE);\\n    }\\n\\n    public TreeNode helper(int[] arr, int bound) {\\n        if (i == arr.length || arr[i] > bound) return null;\\n        TreeNode root = new TreeNode(arr[i++]);\\n        root.left = helper(arr, root.val);\\n        root.right = helper(arr, bound);\\n        return root;\\n    }\\n\\t}\\n\\t```\n```\\n APPROACH 3-IF YOU ARE NOT COMFORTABLE WITH RECURSION!\\n JAVA ITERATIVE APPROACH - \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519094,
                "title": "c-simple-and-clean-recursive-solution-explained",
                "content": "**Idea:**\\nIn a preorder traversal, we visit the root first.\\nSo in each iteration, the first element - `preorder[i]` - is the root\\nthen we find the left and right subtrees and construct the tree recursively.\\nIn the left subtree, the maximum value is the current root.\\nIn the right subtree, the maximum value is the previous root.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int max_val = INT_MAX) {\\n        if (i == preorder.size() || preorder[i] > max_val) return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        \\n        root->left = bstFromPreorder(preorder, root->val);\\n        root->right = bstFromPreorder(preorder, max_val);\\n        \\n        return root;\\n    }\\n    \\nprivate:\\n    int i = 0;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int max_val = INT_MAX) {\\n        if (i == preorder.size() || preorder[i] > max_val) return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        \\n        root->left = bstFromPreorder(preorder, root->val);\\n        root->right = bstFromPreorder(preorder, max_val);\\n        \\n        return root;\\n    }\\n    \\nprivate:\\n    int i = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519096,
                "title": "python-two-o-n-solutions-explained",
                "content": "We can do in simple way: find index for left part, and for right part and do recursion with time complexity `O(n^2)` for skewed trees and average `O(n log n)`. There is smarter solution with `O(n)` time complexity, where we give the function a `bound` (or two bounds - up and down) the maximum number it will handle.\\nThe left recursion will take the elements smaller than `node.val` \\nThe right recursion will take the remaining elements smaller than `bound`. See also similar idea in problem **0109** Convert Sorted List to Binary Search Tree.\\n\\n#### Complexity\\nIt is `O(n)` for time and space.\\n\\n#### Code 1\\n```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n        def helper(down, up):\\n            if self.idx >= len(preorder): return None\\n            if not down <= preorder[self.idx] <= up: return None\\n            root = TreeNode(preorder[self.idx])\\n            self.idx += 1\\n            root.left = helper(down, root.val)\\n            root.right = helper(root.val, up)\\n            return root\\n        \\n        self.idx = 0\\n        return helper(-float(\"inf\"), float(\"inf\"))\\n```\\n\\n#### Code 2\\nThere is an alternative way to write it, without using global variable.\\n\\n```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n        def helper(down, up, idx):\\n            if idx >= len(preorder): return (idx, None)\\n            if not down <= preorder[idx] <= up: return (idx, None)\\n            root = TreeNode(preorder[idx])\\n            idx, root.left = helper(down, root.val, idx + 1)\\n            idx, root.right = helper(root.val, up, idx)\\n            return idx, root\\n        \\n        return helper(-float(\"inf\"), float(\"inf\"), 0)[1]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n        def helper(down, up):\\n            if self.idx >= len(preorder): return None\\n            if not down <= preorder[self.idx] <= up: return None\\n            root = TreeNode(preorder[self.idx])\\n            self.idx += 1\\n            root.left = helper(down, root.val)\\n            root.right = helper(root.val, up)\\n            return root\\n        \\n        self.idx = 0\\n        return helper(-float(\"inf\"), float(\"inf\"))\\n```\n```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n        def helper(down, up, idx):\\n            if idx >= len(preorder): return (idx, None)\\n            if not down <= preorder[idx] <= up: return (idx, None)\\n            root = TreeNode(preorder[idx])\\n            idx, root.left = helper(down, root.val, idx + 1)\\n            idx, root.right = helper(root.val, up, idx)\\n            return idx, root\\n        \\n        return helper(-float(\"inf\"), float(\"inf\"), 0)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650230,
                "title": "java-clean-code-solution-o-n-log-n-time-complexity-0-ms-time",
                "content": "class Solution {\\n \\n\\tprivate TreeNode insert(TreeNode root, int val) {\\n\\t\\t\\n\\t\\tif(root == null) return new TreeNode(val);\\n\\t\\telse if(root.val > val) root.left = insert(root.left, val);\\n\\t\\telse root.right = insert(root.right, val);\\n\\t\\treturn root;\\n\\t}\\n \\n\\tpublic TreeNode bstFromPreorder(int[] preorder) { \\n\\t\\t\\n\\t\\tTreeNode root = null;\\n\\t\\tfor(int val : preorder) root = insert(root, val);\\n\\t\\treturn root;\\n\\t}\\n}\\n \\nTime Complexity: O(N log N)\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "class Solution {\\n \\n\\tprivate TreeNode insert(TreeNode root, int val) {\\n\\t\\t\\n\\t\\tif(root == null) return new TreeNode(val);\\n\\t\\telse if(root.val > val) root.left = insert(root.left, val);\\n\\t\\telse root.right = insert(root.right, val);\\n\\t\\treturn root;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 324887,
                "title": "less-than-10-lines-c-beats-100",
                "content": "Even though the elements between begin and left are not sorted, we can still apply binary search on it. The reason is that comparing with the value of current root element, there is a point that all elements on the left side are smaller than root value, and all elements on the right side are larger.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return helper(preorder.begin(), preorder.end());\\n    }\\n    \\n    TreeNode * helper(vector<int>::iterator begin, vector<int>::iterator end) {\\n        if (begin == end) {\\n            return nullptr;\\n        }\\n        \\n        auto node = new TreeNode(*begin);\\n        auto right = upper_bound(begin + 1, end, *begin);\\n        \\n        node->left = helper(begin + 1, right);\\n        node->right = helper(right, end);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return helper(preorder.begin(), preorder.end());\\n    }\\n    \\n    TreeNode * helper(vector<int>::iterator begin, vector<int>::iterator end) {\\n        if (begin == end) {\\n            return nullptr;\\n        }\\n        \\n        auto node = new TreeNode(*begin);\\n        auto right = upper_bound(begin + 1, end, *begin);\\n        \\n        node->left = helper(begin + 1, right);\\n        node->right = helper(right, end);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589051,
                "title": "morris-algorithm-o-n-time-o-n-space",
                "content": "Hi there!\\nI have just solved that problem and started searching for the other solutions that might interest me. However, all users are solving it with the help of recursion or stack, and please do not get me wrong those are great solutions, I suggest you try Morris\\' algorithm.\\n\\n**Explanation:**\\nThat algorithm differs from others by not using additional data structures to navigate throughout the tree. That\\'s right! We use recursion or stack just for having the opportunity to return to the parent node. If you want to learn about that algorithm please check this [**YouTube video**](https://www.youtube.com/watch?v=wGXB9OWhPTg). I don\\'t know the author but he did an awesome job explaining the algorithm. Enjoy! \\uD83D\\uDE4C\\n\\n**Code:**\\n```\\nclass Solution:\\n    def bstFromPreorder(self, pre_order: List[int]) -> TreeNode:\\n        iterator = iter(pre_order)\\n        root = current = TreeNode(next(iterator))\\n        for val in iterator:\\n            node = TreeNode(val)\\n            if node.val < current.val:\\n                node.right = current\\n                current.left = current = node\\n            else:\\n                while current.right is not None and node.val > current.right.val:\\n                    current.right, current = None, current.right\\n\\n                node.right = current.right\\n                current.right = current = node\\n\\n        while current.right is not None:\\n            current.right, current = None, current.right\\n\\n        return root\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n).*\\n*Space complexity: O(n).*\\n\\n**Conclusion:**\\nEven though we don\\'t use recursion or stack, we still create a tree that takes n-space. But it is clean O(n) without dropped constants! Mention it to your interviewer.\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I hope you learned something and wish you an enjoyable time on LeetCode. \\uD83D\\uDE0A\\n\\n**\\uD83D\\uDE4F Special thanks for your comments:**\\n[**jeffwei**](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/589051/Morris\\'-algorithm-(O(n)-time-O(n)-space)/552601)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, pre_order: List[int]) -> TreeNode:\\n        iterator = iter(pre_order)\\n        root = current = TreeNode(next(iterator))\\n        for val in iterator:\\n            node = TreeNode(val)\\n            if node.val < current.val:\\n                node.right = current\\n                current.left = current = node\\n            else:\\n                while current.right is not None and node.val > current.right.val:\\n                    current.right, current = None, current.right\\n\\n                node.right = current.right\\n                current.right = current = node\\n\\n        while current.right is not None:\\n            current.right, current = None, current.right\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252719,
                "title": "c-iterative-o-n-solution-using-decreasing-stack",
                "content": "iterate the input array\\nfor each number x, we need to find the first number p less than x from the beginning of the array\\nx should be the right child of p\\nthus, we need to maintain a decreasing stack\\nfor each number x in the array, we try to find the first number p less than x in the stack and make x the right child of p\\nif such p does not exist, we make x the left child of the node on the stack top\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode dummy_root(INT_MAX);\\n        stack<TreeNode *> s({&dummy_root});\\n        for (int x : preorder) {\\n            auto n = new TreeNode(x);\\n            TreeNode *p = nullptr;\\n            while (s.top()->val < x) {\\n                p = s.top();\\n                s.pop();\\n            }\\n            if (p) {\\n                p->right = n;\\n            } else {\\n                s.top()->left = n;\\n            }\\n            s.push(n);\\n        }\\n        return dummy_root.left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode dummy_root(INT_MAX);\\n        stack<TreeNode *> s({&dummy_root});\\n        for (int x : preorder) {\\n            auto n = new TreeNode(x);\\n            TreeNode *p = nullptr;\\n            while (s.top()->val < x) {\\n                p = s.top();\\n                s.pop();\\n            }\\n            if (p) {\\n                p->right = n;\\n            } else {\\n                s.top()->left = n;\\n            }\\n            s.push(n);\\n        }\\n        return dummy_root.left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649061,
                "title": "a-morris-stype-method-summary-of-4-methods",
                "content": "# 1 morris algorithm\\n![image](https://assets.leetcode.com/users/newruanxy/image_1590308042.png)\\n\\nThis is in essence similar to the stack solution below, but use the dictionary to eliminate stack. The idea just came to me and I think the inspiration came from morris algorithm.\\n\\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        curr = dummy = TreeNode( float(\"Inf\") )\\n        latter = {}\\n        \\n        for value in preorder:\\n            if value < curr.val:\\n                curr.left = TreeNode(value)\\n                latter[curr.left] = curr\\n                curr = curr.left\\n            else:              \\n                while value > latter[curr].val:\\n                    curr = latter[curr]\\n                curr.right = TreeNode(value)\\n                latter[curr.right] = latter[curr]\\n                curr = curr.right\\n                \\n        return dummy.left\\n```\\n\\n\\n# 2 stack\\n`O(N)`\\uFF1Athere are two loops, but each node will be pushed in and out at most once, so it\\'s O(N).\\n\\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        root = TreeNode( preorder[0] )\\n        stack = [ root ]\\n        for value in preorder[1:]:\\n            node = TreeNode(value)\\n            if value < stack[-1].val:\\n                stack[-1].left = node\\n            else:\\n                while stack and value > stack[-1].val:\\n                    prev = stack.pop()\\n                prev.right = node\\n            stack.append(node)\\n            \\n        return root      \\n```\\n\\n\\n# 3 O(NlogN) recursion\\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        \\n        def subtree(lo, hi):\\n            if lo >= hi: return None\\n            rootval = preorder[lo] \\n            root = TreeNode( rootval )\\n            mi = bisect.bisect_left(preorder, rootval, lo+1, hi) # lo+1 !!!\\n            root.left = subtree(lo+1, mi)\\n            root.right = subtree(mi, hi)\\n            return root\\n        \\n        return subtree( 0, len(preorder) )\\n```\\n\\n# 4 a beautiful O(N) recursion\\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        self.index, N = 0, len(preorder)\\n        \\n        def helper(bound):\\n            if self.index >= N or preorder[self.index] >= bound:\\n                return None\\n            val = preorder[self.index]\\n            self.index += 1\\n            root = TreeNode( val )\\n            root.left = helper( val )\\n            root.right = helper( bound )\\n            return root\\n        \\n        return helper( float(\"Inf\") )\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        curr = dummy = TreeNode( float(\"Inf\") )\\n        latter = {}\\n        \\n        for value in preorder:\\n            if value < curr.val:\\n                curr.left = TreeNode(value)\\n                latter[curr.left] = curr\\n                curr = curr.left\\n            else:              \\n                while value > latter[curr].val:\\n                    curr = latter[curr]\\n                curr.right = TreeNode(value)\\n                latter[curr.right] = latter[curr]\\n                curr = curr.right\\n                \\n        return dummy.left\\n```\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        root = TreeNode( preorder[0] )\\n        stack = [ root ]\\n        for value in preorder[1:]:\\n            node = TreeNode(value)\\n            if value < stack[-1].val:\\n                stack[-1].left = node\\n            else:\\n                while stack and value > stack[-1].val:\\n                    prev = stack.pop()\\n                prev.right = node\\n            stack.append(node)\\n            \\n        return root      \\n```\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        \\n        def subtree(lo, hi):\\n            if lo >= hi: return None\\n            rootval = preorder[lo] \\n            root = TreeNode( rootval )\\n            mi = bisect.bisect_left(preorder, rootval, lo+1, hi) # lo+1 !!!\\n            root.left = subtree(lo+1, mi)\\n            root.right = subtree(mi, hi)\\n            return root\\n        \\n        return subtree( 0, len(preorder) )\\n```\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        self.index, N = 0, len(preorder)\\n        \\n        def helper(bound):\\n            if self.index >= N or preorder[self.index] >= bound:\\n                return None\\n            val = preorder[self.index]\\n            self.index += 1\\n            root = TreeNode( val )\\n            root.left = helper( val )\\n            root.right = helper( bound )\\n            return root\\n        \\n        return helper( float(\"Inf\") )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 273168,
                "title": "c-straightforward-iterative-approach-100-100",
                "content": "Here is my iterative approach to solving the problem. I hope this helps!\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if (preorder.size() == 0){  // If vector is empty, return NULL\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(preorder[0]); // Tree will start off with vector\\'s first value;\\n        \\n        for (int i = 1; i < preorder.size(); i++){  // Traversing the vector\\n            bool done = false;  // Marker to indicate when the vector value has been added to the tree\\n            TreeNode* current = root;   // Current is used to traverse the tree we\\'re creating\\n            \\n            while (done == false){\\n                if (preorder[i] < current->val){    // If the vector value is less than the current tree node\\'s value\\n                    if (current->left == NULL){ // Add the vector value to the tree if there is an available spot\\n                        current->left = new TreeNode(preorder[i]);\\n                        done = true;    // Vector value has been added, therefore done = true and break out of while loop\\n                    }\\n                    else{   // If there\\'s no available spot, keep traversing our tree\\n                        current = current->left;\\n                    }\\n                }\\n                else{   // If vector value is greater than current tree node\\'s value\\n                    if (current->right == NULL){ // Add the vector value to tree if spot is available\\n                        current->right = new TreeNode(preorder[i]);\\n                        done = true; // Vector value added, therefore break out of while loop\\n                    }\\n                    else{\\n                        current = current->right;   // No spot available, keep traversing tree\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if (preorder.size() == 0){  // If vector is empty, return NULL\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(preorder[0]); // Tree will start off with vector\\'s first value;\\n        \\n        for (int i = 1; i < preorder.size(); i++){  // Traversing the vector\\n            bool done = false;  // Marker to indicate when the vector value has been added to the tree\\n            TreeNode* current = root;   // Current is used to traverse the tree we\\'re creating\\n            \\n            while (done == false){\\n                if (preorder[i] < current->val){    // If the vector value is less than the current tree node\\'s value\\n                    if (current->left == NULL){ // Add the vector value to the tree if there is an available spot\\n                        current->left = new TreeNode(preorder[i]);\\n                        done = true;    // Vector value has been added, therefore done = true and break out of while loop\\n                    }\\n                    else{   // If there\\'s no available spot, keep traversing our tree\\n                        current = current->left;\\n                    }\\n                }\\n                else{   // If vector value is greater than current tree node\\'s value\\n                    if (current->right == NULL){ // Add the vector value to tree if spot is available\\n                        current->right = new TreeNode(preorder[i]);\\n                        done = true; // Vector value added, therefore break out of while loop\\n                    }\\n                    else{\\n                        current = current->right;   // No spot available, keep traversing tree\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589238,
                "title": "javascript-solution-inspired-by-lee215-with-explanation-o-n-time-o-h-space",
                "content": "## Solution Explanation\\n\\nThis solution is inspired by [this post](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/252232/JavaC%2B%2BPython-O(N)-Solution) written by [lee215](https://leetcode.com/lee215/).\\n\\nThe main takeaway points in this solutions are:\\n\\n1. Every node has an upper bound.\\n    - `Left` node is bounded by the parent node\\'s value.\\n    - `Right` node is bounded by the ancestor\\'s bound.\\n    - Using the example in the [question](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/):\\n        - The nodes `[5, 1, 7]` are all bounded by `8`.\\n        - The node `1` is bounded by `5`.\\n        - `8` is the root node, but if you think deeper about it, it is bounded by `Number.MAX_SAFE_INTEGER`. i.e. imagine there is a root parent node `Number.MAX_SAFE_INTEGER` with left node being `8`.\\n        - This also means that both `10` and `12` nodes, which are also `right` nodes, are also bounded by `Number.MAX_SAFE_INTEGER`.\\n\\n2. We use a recursive function together with an outer index variable `i` to traverse and construct the tree. When we create a tree node, we increment `i` to process the next element in the `preorder` array.\\n\\n3. We don\\'t need to care about lower bound. When we construct the tree, we try to create `left` node first. If the condition fails (i.e. current number is greater than the parent node value), then we try to create the `right` node which automatically satisfies the condition, hence no lower bound is needed.\\n\\n## Complexity Analysis\\n\\nTime complexity: O(n). We iterate through each element in `preorder` array only once.\\n\\nSpace complexity: O(h) where h is the height of the tree. Space cost is the recursive stack size.\\n\\n```javascript\\n/**\\n * Definition for a binary tree node.\\n */\\nfunction TreeNode (val) {\\n  this.val = val\\n  this.left = this.right = null\\n}\\n\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nconst bstFromPreorder = function (preorder) {\\n  let i = 0\\n  const process = (bound) => {\\n    if (i === preorder.length || preorder[i] > bound) {\\n      return null\\n    }\\n\\n    const num = preorder[i]\\n    const node = new TreeNode(num)\\n    i++\\n\\n    node.left = process(node.val)\\n    node.right = process(bound)\\n\\n    return node\\n  }\\n\\n  const root = process(Number.MAX_SAFE_INTEGER)\\n\\n  return root\\n}\\n\\nmodule.exports = bstFromPreorder\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n */\\nfunction TreeNode (val) {\\n  this.val = val\\n  this.left = this.right = null\\n}\\n\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nconst bstFromPreorder = function (preorder) {\\n  let i = 0\\n  const process = (bound) => {\\n    if (i === preorder.length || preorder[i] > bound) {\\n      return null\\n    }\\n\\n    const num = preorder[i]\\n    const node = new TreeNode(num)\\n    i++\\n\\n    node.left = process(node.val)\\n    node.right = process(bound)\\n\\n    return node\\n  }\\n\\n  const root = process(Number.MAX_SAFE_INTEGER)\\n\\n  return root\\n}\\n\\nmodule.exports = bstFromPreorder\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260549,
                "title": "python-beat-100",
                "content": "```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        root = TreeNode(preorder[0])\\n        i = 1\\n        while i < len(preorder):\\n            if preorder[i] < preorder[0]: i += 1\\n            else: break\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        return root\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        root = TreeNode(preorder[0])\\n        i = 1\\n        while i < len(preorder):\\n            if preorder[i] < preorder[0]: i += 1\\n            else: break\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715411,
                "title": "c-o-n-new-approach-no-need-to-figure-out-upper-bound-or-max-val",
                "content": "**OBSERVATION :**\\nFor any Tree, the Preorder traversal is of this type : \\n| root | left subtree | right subtree |\\n\\nSo, if we are able to identify the index of ending of left subtree in the given vector preorder.\\nThen, we can easily defferentiate the left subtree part with the right subtree part and build the rest of the tree using recursion.\\n\\nNow, for BSTs we know that the elements present on the left subtree are smaller than the root and elements present on the right subtree are greater than the root. And the 0th index is root itself.\\n\\nSo, if we find the last element in the preorder which is smaller than the 0th indexed element (say, \\'pos\\'). We can say that from 1th index to index \\'pos\\' lies the left subtree, from index \\'pos\\' to last index lies the right subtree and the 0th element is our root node.\\n\\n**INTUTION :**\\nTraversal through : int l , int r. Meaning left most index and right most index of vector preorder.\\nFirst element is root i.e. element on \\'l\\' index.\\nFind the last element in the whole vector which is smaller then the root value and store the index value in \\'pos\\'.\\nLet Recursion make the rest of the left subtree from index l+1 to pos.\\nLet Recursion make the rest of the left subtree from index pos+1 to r.\\nBASE CASE : if l crosses r, i.e. l>r then return NULL.\\n\\n**TIME COMPLEXITY : O(N)**\\n**SPACE COMPLEXITY : O(N) + O(N)** Consturcting the BST + Recursive Stack\\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& arr,int l,int r){\\n\\t\\t//BASE CASE\\n        if(l>r)\\n            return NULL;\\n\\t\\t\\n\\t\\t//First element is root itself\\n        TreeNode *root=new TreeNode(arr[l]);\\n\\t\\t\\n        int pos=l;     //For corner case that only 1 element is given it the array\\n        for(int i=l+1; i<=r; i++){   //Find the index of last element which is smaller than the root node\\n            if(arr[i]<root->val)\\n                pos=i;\\n            else\\n                break;\\n        }\\n        root->left=helper(arr,l+1,pos);  //Make left subtree\\n        root->right=helper(arr,pos+1,r); //Make right subtree\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int l=0;                  //Left most element of array\\n\\t\\tint r=preorder.size()-1;  //Right most element of the array\\n        return helper(preorder,l,r);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& arr,int l,int r){\\n\\t\\t//BASE CASE\\n        if(l>r)\\n            return NULL;\\n\\t\\t\\n\\t\\t//First element is root itself\\n        TreeNode *root=new TreeNode(arr[l]);\\n\\t\\t\\n        int pos=l;     //For corner case that only 1 element is given it the array\\n        for(int i=l+1; i<=r; i++){   //Find the index of last element which is smaller than the root node\\n            if(arr[i]<root->val)\\n                pos=i;\\n            else\\n                break;\\n        }\\n        root->left=helper(arr,l+1,pos);  //Make left subtree\\n        root->right=helper(arr,pos+1,r); //Make right subtree\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int l=0;                  //Left most element of array\\n\\t\\tint r=preorder.size()-1;  //Right most element of the array\\n        return helper(preorder,l,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649367,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if preorder:\\n            return TreeNode(preorder[0],\\n                            self.bstFromPreorder(tuple(takewhile(lambda x:x<preorder[0], preorder[1:]))),\\n                            self.bstFromPreorder(tuple(dropwhile(lambda x:x<preorder[0], preorder[1:]))))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if preorder:\\n            return TreeNode(preorder[0],\\n                            self.bstFromPreorder(tuple(takewhile(lambda x:x<preorder[0], preorder[1:]))),\\n                            self.bstFromPreorder(tuple(dropwhile(lambda x:x<preorder[0], preorder[1:]))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637408,
                "title": "c-easy-straight-forward-o-n-recursive-code",
                "content": "```\\n    TreeNode* bstFromPreorder1(vector<int>& preorder) {\\n        int pos =0;\\n        return bst(preorder, pos, INT_MAX, INT_MIN); \\n    }\\n    \\n    TreeNode*bst(vector<int>&preorder, int &pos, int max, int min){\\n        if (pos>=preorder.size()) return NULL;\\n        int val = preorder[pos];\\n        if (val > max || val <min) return NULL;\\n        ++pos;\\n        TreeNode* node = new TreeNode(val);\\n        node->left = bst(preorder, pos, val, min);\\n        node->right = bst(preorder, pos, max, val);\\n        return node;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    TreeNode* bstFromPreorder1(vector<int>& preorder) {\\n        int pos =0;\\n        return bst(preorder, pos, INT_MAX, INT_MIN); \\n    }\\n    \\n    TreeNode*bst(vector<int>&preorder, int &pos, int max, int min){\\n        if (pos>=preorder.size()) return NULL;\\n        int val = preorder[pos];\\n        if (val > max || val <min) return NULL;\\n        ++pos;\\n        TreeNode* node = new TreeNode(val);\\n        node->left = bst(preorder, pos, val, min);\\n        node->right = bst(preorder, pos, max, val);\\n        return node;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432979,
                "title": "java-simple-solution-to-place-the-nodes-to-tree-one-by-one-100-100",
                "content": "```\\nclass Solution {\\n    \\n    public void addToTree(TreeNode n, int val) {\\n        if (val < n.val) {\\n            if (n.left == null) {\\n                n.left = new TreeNode(val);                \\n            } else {\\n                addToTree(n.left, val);\\n            }\\n        } else {\\n            if (n.right == null) {\\n                n.right = new TreeNode(val);\\n            } else {\\n                addToTree(n.right, val);\\n            }\\n        }\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if (preorder == null || preorder.length == 0) { return null; }\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            addToTree(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void addToTree(TreeNode n, int val) {\\n        if (val < n.val) {\\n            if (n.left == null) {\\n                n.left = new TreeNode(val);                \\n            } else {\\n                addToTree(n.left, val);\\n            }\\n        } else {\\n            if (n.right == null) {\\n                n.right = new TreeNode(val);\\n            } else {\\n                addToTree(n.right, val);\\n            }\\n        }\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if (preorder == null || preorder.length == 0) { return null; }\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            addToTree(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590041,
                "title": "c-0ms-concise-solution-beats-100-time",
                "content": "```\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0) return NULL;\\n        TreeNode* root = NULL;\\n        for(int i : preorder)\\n            root = InsertBst(root, i);\\n        return root;\\n    }\\n    \\n    TreeNode* InsertBst(TreeNode* root, int i){\\n        if(!root) return new TreeNode(i);\\n        if(i < root->val) root->left = InsertBst(root->left, i);\\n        else root->right = InsertBst(root->right, i);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0) return NULL;\\n        TreeNode* root = NULL;\\n        for(int i : preorder)\\n            root = InsertBst(root, i);\\n        return root;\\n    }\\n    \\n    TreeNode* InsertBst(TreeNode* root, int i){\\n        if(!root) return new TreeNode(i);\\n        if(i < root->val) root->left = InsertBst(root->left, i);\\n        else root->right = InsertBst(root->right, i);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3427190,
                "title": "java-100-faster-solution-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/df043fc6-74e0-48fb-b84b-a1fa4cd299fc_1681740280.1020906.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        // call helper function with initial parameters\\n        return bstFromPreorder(preorder, Integer.MAX_VALUE, new int[]{0});\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] preorder, int bound, int[] i){\\n        // check if there are no more nodes to add or if current node value exceeds bound\\n        if(i[0] == preorder.length || preorder[i[0]] > bound){\\n            return null;\\n        }\\n\\n        // create new TreeNode with current node value\\n        TreeNode root = new TreeNode(preorder[i[0]++]);\\n\\n        // recursively call helper for left and right subtrees\\n        // left subtree bound: current node value\\n        root.left = bstFromPreorder(preorder, root.val, i);\\n        // right subtree bound: parent node bound\\n        root.right = bstFromPreorder(preorder, bound, i);\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        // call helper function with initial parameters\\n        return bstFromPreorder(preorder, Integer.MAX_VALUE, new int[]{0});\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] preorder, int bound, int[] i){\\n        // check if there are no more nodes to add or if current node value exceeds bound\\n        if(i[0] == preorder.length || preorder[i[0]] > bound){\\n            return null;\\n        }\\n\\n        // create new TreeNode with current node value\\n        TreeNode root = new TreeNode(preorder[i[0]++]);\\n\\n        // recursively call helper for left and right subtrees\\n        // left subtree bound: current node value\\n        root.left = bstFromPreorder(preorder, root.val, i);\\n        // right subtree bound: parent node bound\\n        root.right = bstFromPreorder(preorder, bound, i);\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494969,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Utilize the BST\\u2018s peculiarity, which is nodes in the left subtree is smaller than the root, and nodes in the right subtree is bigger than the root. Use this as a constraint, we can identify subtrees within the preorder array.\\n```\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    let recur = function(lower, upper) {\\n        if (preorder[0] < lower || preorder[0] > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    let recur = function(lower, upper) {\\n        if (preorder[0] < lower || preorder[0] > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 265834,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            insertIntoBSThelper(root, preorder[i]);\\n        }\\n        return root;\\n    }\\n    \\n    public static void insertIntoBSThelper(TreeNode root, int val) {\\n\\t\\tif (root.val < val) {\\n\\t\\t\\tif (root.right == null) {\\n\\t\\t\\t\\tTreeNode right = new TreeNode(val);\\n\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinsertIntoBSThelper(root.right, val);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (root.left == null) {\\n\\t\\t\\t\\tTreeNode left = new TreeNode(val);\\n\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinsertIntoBSThelper(root.left, val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            insertIntoBSThelper(root, preorder[i]);\\n        }\\n        return root;\\n    }\\n    \\n    public static void insertIntoBSThelper(TreeNode root, int val) {\\n\\t\\tif (root.val < val) {\\n\\t\\t\\tif (root.right == null) {\\n\\t\\t\\t\\tTreeNode right = new TreeNode(val);\\n\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinsertIntoBSThelper(root.right, val);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (root.left == null) {\\n\\t\\t\\t\\tTreeNode left = new TreeNode(val);\\n\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinsertIntoBSThelper(root.left, val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190033,
                "title": "c-pre-order-style-insertion-iterative-beats-100-90-22",
                "content": "This is an amazing solution involving stacks. \\n\\nAlgorithm:\\n\\n1) 1st create the 1st element as root and assign an iterator p to it.\\n2) Traverse the preorder array from index 1 to preorder.size() - 1 (as you\\'ve already created 1 node).\\n3) Now if the preorder[i] is smaller than p->val, it means this node will lie to the left of p. So we create a node to the left and add preorder[i] to it. Then we push p on stack and go left.\\n4) If not, then we need to know as to which node\\'s right position should we add preorder[i]. It could be current node\\'s right or one of the nodes pushed on stack.\\n    One thing is certain that if preorder[i] is less than both current node and the top node on stack, then definitely preorder[i] won\\'t be to the right of current, because then it\\'ll violate BST property for the node on stack.\\n\\nTake the example in the question : [8,5,1,7,10,12]\\nUptil 1, the tree looks like this:\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t8\\n\\t\\t\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t\\t\\t5\\n\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t1\\n```\\nNow 7 could come to the right of 1 or right of 5. Question is, where should it go?\\nIf I put 7 to the right of 1, it\\'ll violate property of BST on 5. And also, it won\\'t go to the right of 8 for obvious reasons. So it\\'ll go to 5\\'s right.\\nSay instead of 7, we\\'d have to insert 9. Now 9 could go to the right of 1, 5 or 8. But if we put it to the right of 1, then 5 and 8\\'s BST property is violated. And if we put 9 to the right of 5, then 8\\'s BST property is violated. And there\\'s no value beyond 8, so our only option is to put 9 to the right of 8.\\n\\nTo put it as an algorithm:\\n5) While stack is not empty, we keep checking whether val of node on stack is less than preorder[i]. If yes, we skip the current node p by popping the node on stack and assigning it to variable p. The moment stack top node\\'s val is greater than preorder[i], we know it\\'ll definitely go to the right of p, so make a right node from p with preorder[i] as val and move p to p->right.\\n6) And if stack is empty, then we\\'ll have no choice but to put it to the right of the current node p.\\n\\nAnd that\\'s all! It\\'ll automatically create the BST and finally we\\'ve to just return root.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {      \\n        TreeNode *root = new TreeNode(preorder[0]);\\n        TreeNode *p = root;\\n        stack<TreeNode*> S;\\n        int i = 1;\\n        while(i < preorder.size())\\n        {\\n            if(p->val > preorder[i])\\n            {\\n                p->left = new TreeNode(preorder[i]);\\n                S.push(p);\\n                p = p->left;\\n            }\\n            else\\n            {\\n                while(!S.empty() && S.top()->val < preorder[i])\\n                {\\n                    p = S.top();\\n                    S.pop();\\n                }\\n                p->right = new TreeNode(preorder[i]);\\n                p = p->right;\\n            }\\n            i++;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nIf there\\'s any questions, please let me know.",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t8\\n\\t\\t\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t\\t\\t5\\n\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t1\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {      \\n        TreeNode *root = new TreeNode(preorder[0]);\\n        TreeNode *p = root;\\n        stack<TreeNode*> S;\\n        int i = 1;\\n        while(i < preorder.size())\\n        {\\n            if(p->val > preorder[i])\\n            {\\n                p->left = new TreeNode(preorder[i]);\\n                S.push(p);\\n                p = p->left;\\n            }\\n            else\\n            {\\n                while(!S.empty() && S.top()->val < preorder[i])\\n                {\\n                    p = S.top();\\n                    S.pop();\\n                }\\n                p->right = new TreeNode(preorder[i]);\\n                p = p->right;\\n            }\\n            i++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519945,
                "title": "o-n-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return build(preorder,0,preorder.size() - 1);\\n        }\\n    \\n    TreeNode* build(vector<int> preorder , int start , int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n            \\n        TreeNode* root = new TreeNode(preorder[start]);\\n        \\n        int idx ;\\n        for(idx = start + 1 ; idx <= end ; idx++)\\n        {\\n            if(preorder[start] < preorder[idx])\\n            {\\n                break;\\n            }\\n        }\\n            \\n        root->left = build(preorder ,start + 1 , idx - 1);\\n        root->right = build(preorder , idx , end);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return build(preorder,0,preorder.size() - 1);\\n        }\\n    \\n    TreeNode* build(vector<int> preorder , int start , int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n            \\n        TreeNode* root = new TreeNode(preorder[start]);\\n        \\n        int idx ;\\n        for(idx = start + 1 ; idx <= end ; idx++)\\n        {\\n            if(preorder[start] < preorder[idx])\\n            {\\n                break;\\n            }\\n        }\\n            \\n        root->left = build(preorder ,start + 1 , idx - 1);\\n        root->right = build(preorder , idx , end);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574731,
                "title": "javascript-simple-recursive",
                "content": "```\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nconst bstFromPreorder = (preorder) => {\\n  // base cases\\n  if (preorder.length === 0) return null;\\n  if (preorder.length === 1) return new TreeNode(preorder[0]);\\n\\n  // result tree node\\n  var res = new TreeNode(preorder[0]);\\n\\n  // iterate from 1 to n\\n  for (let i = 1; i < preorder.length; i++) {\\n    // insert this num\\n    res = insert(res, preorder[i]);\\n  }\\n\\n  return res;\\n};\\n\\n/**\\n * recursive func to insert value into tree\\n * @param {TreeNode} root\\n * @param {number} val val to insert\\n * @return {TreeNode} altered node\\n */\\nconst insert = (root, val) => {\\n  // base\\n  if (root === null) return new TreeNode(val);\\n\\n  // compare value between val and root\\n  if (val < root.val) {\\n    // insert in left subtree\\n    root.left = insert(root.left, val);\\n  } else {\\n    // insert in right subtree\\n    root.right = insert(root.right, val);\\n  }\\n\\n  // return root w/ val inserted\\n  return root;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nconst bstFromPreorder = (preorder) => {\\n  // base cases\\n  if (preorder.length === 0) return null;\\n  if (preorder.length === 1) return new TreeNode(preorder[0]);\\n\\n  // result tree node\\n  var res = new TreeNode(preorder[0]);\\n\\n  // iterate from 1 to n\\n  for (let i = 1; i < preorder.length; i++) {\\n    // insert this num\\n    res = insert(res, preorder[i]);\\n  }\\n\\n  return res;\\n};\\n\\n/**\\n * recursive func to insert value into tree\\n * @param {TreeNode} root\\n * @param {number} val val to insert\\n * @return {TreeNode} altered node\\n */\\nconst insert = (root, val) => {\\n  // base\\n  if (root === null) return new TreeNode(val);\\n\\n  // compare value between val and root\\n  if (val < root.val) {\\n    // insert in left subtree\\n    root.left = insert(root.left, val);\\n  } else {\\n    // insert in right subtree\\n    root.right = insert(root.right, val);\\n  }\\n\\n  // return root w/ val inserted\\n  return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2650351,
                "title": "100-accepted-worst-to-best-approaches-with-explanation-easy-to-understand",
                "content": "**Read the below approaches to understand the logic.**\\n\\n***Please upvote if you like it***\\n\\n**Approach 1 : Create tree from given elements approach(Not optimised)**\\n* First approach could be just create build tree fucntion pass preorder elements one by one and set new node at correct possition by just passing tree node at each step.\\n**~Time complexity: (N*N)** for worst case.\\n**~space complexity:(1)**\\n\\t\\n**Approach 2 : create BST using inorder and preorder approach (Not optimised)**\\n* Second approach could be just create an inoreder vector by sort the given preorder and follow \"Create BST from given inorder and preorder\" approach **[(Link)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/2640357/100fastest-solution-with-explain-best-approach-easy-to-understand).**\\n**~Time complexity: o(NlogN)+o(N)** \"o(nlonn) because we are sorting preorder array.\\n**~space complexity:(N)** Because we are using inorede array.\\n\\n**Approach 3 : Using check BST or not Approach (Most optimised)**\\n1. Take an index variable as root element in preorder which is 0, define curent node lower bound as INT_MAX and upper bount as INT_MAX, then call BuildBST.\\n1. At each call create a new node which having value as index element of preorder . recursive call for left and right child, increment index by 1 at each call as well. ( return NULL if index became out of bound or preoreder index value is out of lower or upper bound )\\n\\ta. Call recursively for the left node, set upper bound as current node value and lower bound as it is.\\n\\tb. Call recursively for the right node, set lower bound as current node value and upper bound as it is.\\n1. return current node at each calls.\\n\\n**~Time complexity: O(3N)** You will visit single node trice at worst case.\\n**~Space Complexity: O(1)** We are\\'nt using any extra space.\\n\\n**Paper Dry run:**\\n\\n![image](https://assets.leetcode.com/users/images/951afee8-5f5e-426b-b8b7-41e556fa3397_1664703032.2590306.jpeg)\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(vector<int>& preorder,int& index,int lowerBound,int upperBound){\\n        if(index>=preorder.size()) return NULL;\\n        if(preorder[index]<lowerBound || preorder[index]>upperBound) return NULL;\\n        \\n        TreeNode* node=new TreeNode(preorder[index++]);\\n        node->left=buildBST(preorder,index,lowerBound,node->val);\\n        node->right=buildBST(preorder,index,node->val,upperBound);\\n        return node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int index=0;\\n        return buildBST(preorder,index,INT_MIN,INT_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(vector<int>& preorder,int& index,int lowerBound,int upperBound){\\n        if(index>=preorder.size()) return NULL;\\n        if(preorder[index]<lowerBound || preorder[index]>upperBound) return NULL;\\n        \\n        TreeNode* node=new TreeNode(preorder[index++]);\\n        node->left=buildBST(preorder,index,lowerBound,node->val);\\n        node->right=buildBST(preorder,index,node->val,upperBound);\\n        return node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int index=0;\\n        return buildBST(preorder,index,INT_MIN,INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689120,
                "title": "brute-better-optimal-for-interview",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n// BRUTE [T(O(N*N))] [S(O(1))]\\n    \\n    TreeNode* insertNode(TreeNode* root,int key)\\n    {\\n        if(!root) return new TreeNode(key);\\n        if(key>root->val)   root->right=insertNode(root->right,key);\\n        else    root->left=insertNode(root->left,key);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++)\\n            insertNode(root,preorder[i]);\\n        return root;   \\n    }\\n\\n// BETTER [T(O(N*logN))] [S(O(N))] [using inorder-preorder to bt technique]\\n    \\n    TreeNode* insertNodes(vector<int>& inorder, int inStart, int inEnd, vector<int>& preorder, int preStart, int preEnd, map<int,int>& inMap)\\n    {\\n        if(preStart>preEnd || inStart>inEnd) return NULL;\\n        TreeNode* root= new TreeNode(preorder[preStart]);\\n        int inRoot=inMap[preorder[preStart]];\\n        int nodeInLeft=inRoot-inStart;\\n        root->left=insertNodes(inorder,inStart,inRoot-1,preorder,preStart+1,preStart+nodeInLeft,inMap);\\n        root->right=insertNodes(inorder,inRoot+1,inEnd,preorder,preStart+nodeInLeft+1,preEnd,inMap);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       vector<int> inorder=preorder;\\n       sort(inorder.begin(),inorder.end());\\n       map<int,int>inMap;\\n       for(int i=0;i<preorder.size();i++)\\n            inMap[inorder[i]]=i;\\n       TreeNode* root=insertNodes(inorder,0,inorder.size()-1,preorder,0,preorder.size()-1,inMap);\\n       return root;\\n    }    \\n    \\n// OPTIMAL [T(O(3N ~ N)) as we trave one node at max 3 times to check] [S(O(1))]\\n    \\n    TreeNode* buildTree(vector<int>preorder, int& index, int bound)\\n    {\\n        if(index==preorder.size() || preorder[index]>bound) return NULL;\\n        TreeNode* root=new TreeNode (preorder[index++]);\\n        root->left=buildTree(preorder,index,root->val);\\n        root->right=buildTree(preorder,index,bound);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {        \\n        int index=0;\\n        return buildTree(preorder,index,INT_MAX);\\n    }\\n};\\n```\\n\\n## \\u2705\\uD83D\\uDEA9 *Do comment if you Understood/not understood and consider upvoting if it helped* \\u2705\\uD83D\\uDEA9",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n// BRUTE [T(O(N*N))] [S(O(1))]\\n    \\n    TreeNode* insertNode(TreeNode* root,int key)\\n    {\\n        if(!root) return new TreeNode(key);\\n        if(key>root->val)   root->right=insertNode(root->right,key);\\n        else    root->left=insertNode(root->left,key);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++)\\n            insertNode(root,preorder[i]);\\n        return root;   \\n    }\\n\\n// BETTER [T(O(N*logN))] [S(O(N))] [using inorder-preorder to bt technique]\\n    \\n    TreeNode* insertNodes(vector<int>& inorder, int inStart, int inEnd, vector<int>& preorder, int preStart, int preEnd, map<int,int>& inMap)\\n    {\\n        if(preStart>preEnd || inStart>inEnd) return NULL;\\n        TreeNode* root= new TreeNode(preorder[preStart]);\\n        int inRoot=inMap[preorder[preStart]];\\n        int nodeInLeft=inRoot-inStart;\\n        root->left=insertNodes(inorder,inStart,inRoot-1,preorder,preStart+1,preStart+nodeInLeft,inMap);\\n        root->right=insertNodes(inorder,inRoot+1,inEnd,preorder,preStart+nodeInLeft+1,preEnd,inMap);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       vector<int> inorder=preorder;\\n       sort(inorder.begin(),inorder.end());\\n       map<int,int>inMap;\\n       for(int i=0;i<preorder.size();i++)\\n            inMap[inorder[i]]=i;\\n       TreeNode* root=insertNodes(inorder,0,inorder.size()-1,preorder,0,preorder.size()-1,inMap);\\n       return root;\\n    }    \\n    \\n// OPTIMAL [T(O(3N ~ N)) as we trave one node at max 3 times to check] [S(O(1))]\\n    \\n    TreeNode* buildTree(vector<int>preorder, int& index, int bound)\\n    {\\n        if(index==preorder.size() || preorder[index]>bound) return NULL;\\n        TreeNode* root=new TreeNode (preorder[index++]);\\n        root->left=buildTree(preorder,index,root->val);\\n        root->right=buildTree(preorder,index,bound);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {        \\n        int index=0;\\n        return buildTree(preorder,index,INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588889,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        int n = preorder.length;\\n        if (n == 0) return null;\\n        TreeNode res = new TreeNode(preorder[0]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            res = insert(res, preorder[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private TreeNode insert(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n        if (val <= root.val) {\\n            root.left = insert(root.left, val);\\n        } else {\\n            root.right = insert(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        int n = preorder.length;\\n        if (n == 0) return null;\\n        TreeNode res = new TreeNode(preorder[0]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            res = insert(res, preorder[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private TreeNode insert(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n        if (val <= root.val) {\\n            root.left = insert(root.left, val);\\n        } else {\\n            root.right = insert(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588633,
                "title": "python-easy-to-understand-96-faster-iterative",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if len(preorder) == 0:\\n            return\\n    \\n        root = TreeNode(preorder[0])\\n        \\n        def insert(val, node):\\n            # we insert a single element using this function\\n            \\n            while True:\\n                # Here we check whether root\\'s value is greater than the given value.\\n                # If yes then try to insert it in the left sub-tree.\\n                if node.val > val:\\n                    # Here we check if the left child does not exist then we add a left child with value = val and break the loop\\n                    if not node.left:\\n                        node.left = TreeNode(val)\\n                        break\\n                     # Since the left child exists we move towards the left.\\n                    else:\\n                        node = node.left\\n                # This will work similar to the left child.\\n                else:\\n                    if not node.right:\\n                        node.right = TreeNode(val)\\n                        break\\n                    else:\\n                        node = node.right\\n        head = root       \\n        for i in range(1, len(preorder)):\\n            # Here we reset the head pointer so we are the top of the tree again.\\n            head = root\\n            insert(preorder[i], head)\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if len(preorder) == 0:\\n            return\\n    \\n        root = TreeNode(preorder[0])\\n        \\n        def insert(val, node):\\n            # we insert a single element using this function\\n            \\n            while True:\\n                # Here we check whether root\\'s value is greater than the given value.\\n                # If yes then try to insert it in the left sub-tree.\\n                if node.val > val:\\n                    # Here we check if the left child does not exist then we add a left child with value = val and break the loop\\n                    if not node.left:\\n                        node.left = TreeNode(val)\\n                        break\\n                     # Since the left child exists we move towards the left.\\n                    else:\\n                        node = node.left\\n                # This will work similar to the left child.\\n                else:\\n                    if not node.right:\\n                        node.right = TreeNode(val)\\n                        break\\n                    else:\\n                        node = node.right\\n        head = root       \\n        for i in range(1, len(preorder)):\\n            # Here we reset the head pointer so we are the top of the tree again.\\n            head = root\\n            insert(preorder[i], head)\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574897,
                "title": "c-easy-to-understand-solution-with-detail-approach",
                "content": "# Intuition\\nThe problem requires constructing a binary search tree (BST) from a given preorder traversal of its nodes. The code uses a recursive approach to build the BST by dividing the problem into smaller subproblems.\\n\\n# Approach\\n1. The bstFromPreorder function takes the given preorder traversal as input.\\n2. It creates a copy of the preorder traversal and sorts it to obtain the inorder traversal. This is done to determine the left and right subtrees of each node.\\n3. It initializes the start index for the preorder traversal as 0 and calls the build function.\\n4. The build function takes the preorder traversal, inorder traversal, start index, and the range of indices to process as input.\\n5. In the build function:\\n        - The base case checks if the start index exceeds the end index, indicating that there are no more nodes to process. In this case, it returns NULL.\\n        - It creates a new node with the value at the current start index.\\n        - It searches for the index of the current node\\'s value in the inorder traversal.\\n        - It increments the start index to process the next node in the preorder traversal.\\n        - It recursively builds the left and right subtrees by calling the build function with the appropriate ranges of indices.\\n        - Finally, it returns the root node of the constructed subtree.\\n6. The build function is called recursively to construct the entire binary search tree.\\n7. The constructed binary search tree is returned as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe overall time complexity is O(n log n + n) = O(n log n).\\n\\n- Space complexity:\\nThe overall space complexity is O(n + n) = O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Helper function to search for an element in the given vector\\n    int search(vector<int>& in, int t) {\\n        for (int i = 0; i < in.size(); i++) {\\n            if (in[i] == t)\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\n    // Recursive function to build a binary tree from preorder and inorder traversals\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int& start, int ins, int ine) {\\n        // Base case: When the start index exceeds the end index, there are no more nodes to process\\n        if (ins > ine)\\n            return NULL;\\n\\n        // Create a new node with the value at the current start index\\n        TreeNode* root = new TreeNode(pre[start]);\\n\\n        // Find the index of the current node in the inorder traversal\\n        int ind = search(in, pre[start]);\\n\\n        // Increment the start index to process the next node in the preorder traversal\\n        start++;\\n\\n        // Recursively build the left and right subtrees\\n        root->left = build(pre, in, start, ins, ind - 1);\\n        root->right = build(pre, in, start, ind + 1, ine);\\n\\n        // Return the root node of the binary tree\\n        return root;\\n    }\\n\\n    // Function to construct a binary search tree from a preorder traversal\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        // Create a copy of the preorder traversal\\n        vector<int> in = pre;\\n\\n        // Sort the copy to obtain the inorder traversal\\n        sort(in.begin(), in.end());\\n\\n        // Start index for the preorder traversal\\n        int start = 0;\\n\\n        // Build the binary tree recursively using the preorder and inorder traversals\\n        return build(pre, in, start, 0, in.size() - 1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to search for an element in the given vector\\n    int search(vector<int>& in, int t) {\\n        for (int i = 0; i < in.size(); i++) {\\n            if (in[i] == t)\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\n    // Recursive function to build a binary tree from preorder and inorder traversals\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int& start, int ins, int ine) {\\n        // Base case: When the start index exceeds the end index, there are no more nodes to process\\n        if (ins > ine)\\n            return NULL;\\n\\n        // Create a new node with the value at the current start index\\n        TreeNode* root = new TreeNode(pre[start]);\\n\\n        // Find the index of the current node in the inorder traversal\\n        int ind = search(in, pre[start]);\\n\\n        // Increment the start index to process the next node in the preorder traversal\\n        start++;\\n\\n        // Recursively build the left and right subtrees\\n        root->left = build(pre, in, start, ins, ind - 1);\\n        root->right = build(pre, in, start, ind + 1, ine);\\n\\n        // Return the root node of the binary tree\\n        return root;\\n    }\\n\\n    // Function to construct a binary search tree from a preorder traversal\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        // Create a copy of the preorder traversal\\n        vector<int> in = pre;\\n\\n        // Sort the copy to obtain the inorder traversal\\n        sort(in.begin(), in.end());\\n\\n        // Start index for the preorder traversal\\n        int start = 0;\\n\\n        // Build the binary tree recursively using the preorder and inorder traversals\\n        return build(pre, in, start, 0, in.size() - 1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649010,
                "title": "clean-python-recursion-binary-search-solution-w-explanation-beats-87",
                "content": "Recursion solution\\n```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        if len(preorder) == 1:\\n            return root\\n\\n\\t\\t# binary search to find the start of right subtree\\n        left, right = 1, len(preorder) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if preorder[mid] < root.val:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n\\t\\tif preorder[left] < root.val: # right subtree not found -> connect all elements as left subtree\\n            root.left = self.bstFromPreorder(preorder[1:])\\n        else: # connect left & right subtree\\n            root.right = self.bstFromPreorder(preorder[left:])\\n            root.left = self.bstFromPreorder(preorder[1:left])\\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        if len(preorder) == 1:\\n            return root\\n\\n\\t\\t# binary search to find the start of right subtree\\n        left, right = 1, len(preorder) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if preorder[mid] < root.val:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n\\t\\tif preorder[left] < root.val: # right subtree not found -> connect all elements as left subtree\\n            root.left = self.bstFromPreorder(preorder[1:])\\n        else: # connect left & right subtree\\n            root.right = self.bstFromPreorder(preorder[left:])\\n            root.left = self.bstFromPreorder(preorder[1:left])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589389,
                "title": "python-concise-solution",
                "content": "You pop the first value in the list and make it into node. Next you split the list of values to less than the node as left and larger than the node has right. Continue on untill there\\'s no numbers to use. **Note**, you have to set the `index` variable to the length of the list for the case that there\\'s no number larger than the node. \\n\\n```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        \\n        node = TreeNode(preorder.pop(0))\\n        \\n        index = len(preorder)\\n        for i, val in enumerate(preorder):\\n            if val > node.val:\\n                index = i\\n                break\\n                \\n        node.left = self.bstFromPreorder(preorder[:index])\\n        node.right = self.bstFromPreorder(preorder[index:])\\n        \\n        return node\\n```\\n\\n**Time:** `O(n*log(n))`\\n**Space:**`O(n)`",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        \\n        node = TreeNode(preorder.pop(0))\\n        \\n        index = len(preorder)\\n        for i, val in enumerate(preorder):\\n            if val > node.val:\\n                index = i\\n                break\\n                \\n        node.left = self.bstFromPreorder(preorder[:index])\\n        node.right = self.bstFromPreorder(preorder[index:])\\n        \\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589180,
                "title": "js-easy-to-read-preorder-traversal-92-runtime-80-space",
                "content": "```\\nvar bstFromPreorder = function(preorder) {\\n    let root = new TreeNode(preorder[0])\\n    for (let i = 1; i < preorder.length; i++) {\\n        appendToTreeNode(root, preorder[i])\\n    }\\n    return root\\n};\\n\\nfunction appendToTreeNode(root, val) {\\n    if (val <= root.val) {\\n        if (root.left) appendToTreeNode(root.left,val);\\n        else root.left = new TreeNode(val);\\n    } else {\\n        if (root.right) appendToTreeNode(root.right,val);\\n        else root.right = new TreeNode(val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar bstFromPreorder = function(preorder) {\\n    let root = new TreeNode(preorder[0])\\n    for (let i = 1; i < preorder.length; i++) {\\n        appendToTreeNode(root, preorder[i])\\n    }\\n    return root\\n};\\n\\nfunction appendToTreeNode(root, val) {\\n    if (val <= root.val) {\\n        if (root.left) appendToTreeNode(root.left,val);\\n        else root.left = new TreeNode(val);\\n    } else {\\n        if (root.right) appendToTreeNode(root.right,val);\\n        else root.right = new TreeNode(val);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588733,
                "title": "simple-recursive-insert-in-bst-in-cpp",
                "content": "```\\nTreeNode* Insert(TreeNode* root,int data){\\n        if(root == NULL){\\n            root = new TreeNode(data);\\n        }\\n        else if(root->val > data){\\n            root->left = Insert(root->left,data);\\n        }\\n        else{\\n            root->right = Insert(root->right,data);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = NULL;\\n        for(int x:preorder){\\n            //tree get modifies as builds,we need root node for further queries \\n            root = Insert(root,x);\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* Insert(TreeNode* root,int data){\\n        if(root == NULL){\\n            root = new TreeNode(data);\\n        }\\n        else if(root->val > data){\\n            root->left = Insert(root->left,data);\\n        }\\n        else{\\n            root->right = Insert(root->right,data);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = NULL;\\n        for(int x:preorder){\\n            //tree get modifies as builds,we need root node for further queries \\n            root = Insert(root,x);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 407518,
                "title": "python-o-n-stack-based-solution-beat-96",
                "content": "The basic idea is using a Stack to keep values, everytime you meet a new value smaller than the end of the stack, you know this new value should be left node of it; Otherwise keep popping the stack until you find the last node whose value is smaller than the new value, you know this new value should be right node of it.\\n\\n```\\nif not preorder:\\n\\treturn None\\nroot = TreeNode(preorder[0])\\nstack = [root]\\nfor num in preorder[1:]:\\n\\tcur_node = TreeNode(num)\\n\\tif stack[-1].val > num:\\n\\t\\tstack[-1].left = cur_node\\n\\t\\tstack.append(cur_node)\\n\\telse:\\n\\t\\twhile True:\\n\\t\\t\\tprev_node = stack.pop()\\n\\t\\t\\tif len(stack) == 0 or stack[-1].val > num:\\n\\t\\t\\t\\tbreak\\n\\t\\tprev_node.right = cur_node\\n\\t\\tstack.append(cur_node)\\n\\nreturn root\\n```",
                "solutionTags": [],
                "code": "```\\nif not preorder:\\n\\treturn None\\nroot = TreeNode(preorder[0])\\nstack = [root]\\nfor num in preorder[1:]:\\n\\tcur_node = TreeNode(num)\\n\\tif stack[-1].val > num:\\n\\t\\tstack[-1].left = cur_node\\n\\t\\tstack.append(cur_node)\\n\\telse:\\n\\t\\twhile True:\\n\\t\\t\\tprev_node = stack.pop()\\n\\t\\t\\tif len(stack) == 0 or stack[-1].val > num:\\n\\t\\t\\t\\tbreak\\n\\t\\tprev_node.right = cur_node\\n\\t\\tstack.append(cur_node)\\n\\nreturn root\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323194,
                "title": "6-lines-javascript-solution",
                "content": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    if (!preorder.length) return null\\n    \\n    const [root, ...rest] = preorder\\n    \\n    const rootNode = new TreeNode(root)\\n    rootNode.left = bstFromPreorder(rest.filter(n => n < root))\\n    rootNode.right = bstFromPreorder(rest.filter(n => n > root))\\n    \\n    return rootNode\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    if (!preorder.length) return null\\n    \\n    const [root, ...rest] = preorder\\n    \\n    const rootNode = new TreeNode(root)\\n    rootNode.left = bstFromPreorder(rest.filter(n => n < root))\\n    rootNode.right = bstFromPreorder(rest.filter(n => n > root))\\n    \\n    return rootNode\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2506260,
                "title": "c-all-tree-construction-based-questions-at-a-single-place-2-approaches-of-each",
                "content": "***\\n### Table of Content :\\n***\\n* Construct **BST** from **Preorder** Traversal\\n\\t* Recursive Approach\\n\\t* Iterative Approach using Stack\\n* Construct **BST** from **Postorder** Traversal\\n\\t* Iterative Approach using Stack\\n\\t* Recursive ( using sorted Inorder property of BST )\\n* Construct **Binary Tree** using **inorder** and **preorder**\\n\\t* Recursive Approach\\n\\t* Iterative Approach\\n* Construct **Binary Tree** using **inorder** and **postorder**\\n\\t* Recursive Approach\\n\\n----\\n\\u2714 ***All codes are running successfully !***\\n\\n----\\n```\\n\\n Definition for a binary tree node.\\n  struct TreeNode {\\n      int val;\\n      TreeNode *left;\\n      TreeNode *right;\\n      TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n  };\\n```\\n\\n----\\n**1. Construct BST from Preorder Traversal**\\n* Recursive Approach\\n* Iterative Approach using Stack\\n\\n----\\n> **Recursive Approach :**\\n\\n**Time Complexity : `O(N)`** ( Traversing all node values )\\n**Space Complexity : `O(1)`** ( ignore new nodes that i have created for construction of tree ) + ( ignore Recursion stack space ) \\n```\\nclass Solution {\\npublic:\\n    \\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& pre, int max_val = INT_MAX) // default Argument\\n    {\\n        if (i == pre.size() || pre[i] > max_val) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[i++]);\\n        \\n        root->left = bstFromPreorder(pre, root->val);\\n        root->right = bstFromPreorder(pre, max_val); \\n        // cout<<max_val<<endl;\\n        return root;\\n    }\\n};\\n```\\n\\n----\\n> **Iterative Approach : Stack Solution**  \\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( Extra Stack ) + ( ignore new nodes that i have created for construction of tree ) \\n**Note :** It is same as Iterative traversal of preorder.\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder){\\n        \\n        TreeNode *root = new TreeNode(preorder[0]);\\n        stack<TreeNode*>st;\\n        st.push(root);\\n        \\n        for (int i = 1; i < preorder.size(); i++) \\n        {\\n            TreeNode *temp = new TreeNode(preorder[i]);\\n            if (temp->val < st.top()->val)\\n            {\\n                st.top()->left = temp;\\n                st.push(temp);            // push\\n            }   \\n            else \\n            {\\n                TreeNode *prev;\\n                while (!st.empty() and st.top()->val < temp->val) \\n                {  \\n                    // sabse chhota chahiye\\n                    // isliye pop karte raho\\n                    prev = st.top(); // dry run this = pre = [8,5,4,1,7,10,12] , you will understand\\n                    st.pop();\\n                }\\n                prev->right = temp;        \\n                st.push(temp);            // push\\n            }   \\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n----\\n**2. Construct BST from Postorder Traversal**\\n* Iterative Approach Using Stack\\n* Recursive ( using sorted Inorder property of BST ) \\n\\n----\\n> **Iterative Approach :** **Using Stack**\\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( Extra Stack ) + ( ignore new nodes that i have created for construction of tree ) \\n```\\n// Whole code similar to construction of BST from preorder using Stack\\n//  DRY run on [1, 7, 5, 50, 40, 10] to understand better\\nNode* make_BST(vector<int>&post)\\n{\\n    int n=post.size();\\n    Node *root = new Node(post[n-1]);\\n    stack<Node*>st;\\n    st.push(root);\\n    \\n    for(int i=n-2;i>=0;i--)\\n    {\\n        Node* temp = new Node(post[i]);\\n        if(st.top()->data < temp->data)\\n        {\\n            st.top()->right = temp;\\n            st.push(temp);\\n        }\\n        else\\n        {\\n            Node* prev;\\n            while(!st.empty() and st.top()->data > temp->data){\\n                prev = st.top();\\n                st.pop();\\n            }\\n            prev->left = temp;\\n            st.push(temp);\\n        }\\n    }\\n    return root;\\n}\\n\\nNode *constructTree (int post[], int size)\\n{\\n    vector<int>pos(post, post+size);\\n    return make_BST(pos);\\n}\\n```\\n\\n----\\n> **Recursive ( using sorted Inorder property of BST )**\\n\\n**Time Complexity : `O(NLog(N)) + O(N)`** ( Sorting + Traversing all node values )\\n**Space Complexity : `O(N)`** ( vector for sorting ) + ( ignore new nodes that i have created for construction of tree ) + ( ignore Recursion stack space ) \\n```\\nNode* make_BST(vector<int>&in, int s, int e)\\n{\\n    if(s>e)\\n        return NULL;\\n    \\n    int mid = s+(e-s)/2;    \\n    Node* root = new Node(in[mid]);\\n    \\n    root->left = make_BST(in, s, mid-1);\\n    root->right = make_BST(in, mid+1, e);\\n    return root;\\n}\\n\\nNode *constructTree(int post[], int n)\\n{\\n    sort(post, post+n);\\n    vector<int>inorder(post, post+n); // inorder traversal\\n    \\n    return make_BST(inorder, 0, n-1);\\n}\\n```\\n\\n**OK, BST is end here !** \\uD83D\\uDC4F\\n\\n----\\n**Now comes to Binary trees only**\\n\\n----\\n**3. Construct Binary Tree using inorder and preorder**\\n\\n> **1. Recursive Approach :**\\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( map for inorder ) + ( ignore new nodes that i have created for construction of tree ) + ( ignore Recursion stack space )\\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    unordered_map<int, int> findIndex; // store index of every element present in inorder\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        for(int i = 0; i < inorder.size(); i++) \\n            findIndex[inorder[i]] = i;  \\n        return build(preorder, 0, inorder.size() - 1);\\n    }\\n    \\n    int i = 0;\\n    TreeNode* build(vector<int>& preorder, int start, int end)\\n    {        \\n        if(start > end) \\n            return NULL;    \\n        \\n        // when start <= end\\n        int idx = findIndex[preorder[i]];\\n        TreeNode *root = new TreeNode(preorder[i++]);\\n        \\n        root->left  = build(preorder, start, idx - 1); \\n        root->right = build(preorder, idx + 1, end);   \\n        return root;\\n    }\\n};\\n```\\n\\n----\\n> **2. Iterative Approach :**\\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( Extra Stack ) + ( ignore new nodes that i have created for construction of tree ) \\n```\\nclass Solution {\\npublic: \\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        int n = preorder.size();\\n        int pre_index=0, in_index=0, flag=0;\\n        \\n        stack<TreeNode*> st;\\n        TreeNode * root = new TreeNode(preorder[pre_index]);\\n        pre_index++;\\n        \\n        st.push(root);\\n        TreeNode *prev = root;\\n        \\n        while(pre_index <  n)\\n        {\\n            if(!st.empty() && inorder[in_index] == st.top()->val)\\n            {\\n                prev = st.top();\\n                st.pop();\\n                in_index++;\\n                flag = 1;\\n            }\\n            else\\n            {\\n                TreeNode * node = new TreeNode(preorder[pre_index]);\\n                if(flag == 0){\\n                    prev->left = node;\\n                    prev = prev->left;\\n                }\\n                else\\n                {\\n                    prev->right = node;\\n                    prev = prev->right;\\n                    flag = 0;\\n                }\\n                st.push(node);\\n                pre_index++;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n----\\n**4. Construct Binary Tree using inorder and postorder**\\n\\n> **Recursive Approach :**\\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( map for inorder ) + ( ignore new nodes that i have created for construction of tree ) + ( ignore Recursion stack space )\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) \\n    {\\n        int n = inorder.size();\\n        for(int i = 0; i < n; i++) \\n            mp[inorder[i]] = i;\\n        \\n        int postIdx = n-1;\\n        return build(inorder, postorder, 0, n-1, postIdx);\\n    }\\n\\n    TreeNode* build(vector<int>& in, vector<int>& post, int inStart, int inEnd, int& postIdx) \\n    {\\n        if(inStart > inEnd) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(post[postIdx--]);\\n        int inIdx = mp[root -> val];\\n        \\n        root -> right = build(in, post, inIdx+1, inEnd, postIdx);\\n        root -> left  = build(in, post, inStart, inIdx-1, postIdx);\\n        return root;\\n    }\\n};\\n```\\n\\n----\\n***Thanks for Upvoting!***\\nYour Upvotes motivates me a lot to write such type of simple and clean post for helping the Leetcode Community.\\n**Feel free to comment anything related to above questions !**\\n\\uD83D\\uDE42\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n\\n Definition for a binary tree node.\\n  struct TreeNode {\\n      int val;\\n      TreeNode *left;\\n      TreeNode *right;\\n      TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n  };\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& pre, int max_val = INT_MAX) // default Argument\\n    {\\n        if (i == pre.size() || pre[i] > max_val) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[i++]);\\n        \\n        root->left = bstFromPreorder(pre, root->val);\\n        root->right = bstFromPreorder(pre, max_val); \\n        // cout<<max_val<<endl;\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder){\\n        \\n        TreeNode *root = new TreeNode(preorder[0]);\\n        stack<TreeNode*>st;\\n        st.push(root);\\n        \\n        for (int i = 1; i < preorder.size(); i++) \\n        {\\n            TreeNode *temp = new TreeNode(preorder[i]);\\n            if (temp->val < st.top()->val)\\n            {\\n                st.top()->left = temp;\\n                st.push(temp);            // push\\n            }   \\n            else \\n            {\\n                TreeNode *prev;\\n                while (!st.empty() and st.top()->val < temp->val) \\n                {  \\n                    // sabse chhota chahiye\\n                    // isliye pop karte raho\\n                    prev = st.top(); // dry run this = pre = [8,5,4,1,7,10,12] , you will understand\\n                    st.pop();\\n                }\\n                prev->right = temp;        \\n                st.push(temp);            // push\\n            }   \\n        }\\n        return root;\\n    }\\n};\\n```\n```\\n// Whole code similar to construction of BST from preorder using Stack\\n//  DRY run on [1, 7, 5, 50, 40, 10] to understand better\\nNode* make_BST(vector<int>&post)\\n{\\n    int n=post.size();\\n    Node *root = new Node(post[n-1]);\\n    stack<Node*>st;\\n    st.push(root);\\n    \\n    for(int i=n-2;i>=0;i--)\\n    {\\n        Node* temp = new Node(post[i]);\\n        if(st.top()->data < temp->data)\\n        {\\n            st.top()->right = temp;\\n            st.push(temp);\\n        }\\n        else\\n        {\\n            Node* prev;\\n            while(!st.empty() and st.top()->data > temp->data){\\n                prev = st.top();\\n                st.pop();\\n            }\\n            prev->left = temp;\\n            st.push(temp);\\n        }\\n    }\\n    return root;\\n}\\n\\nNode *constructTree (int post[], int size)\\n{\\n    vector<int>pos(post, post+size);\\n    return make_BST(pos);\\n}\\n```\n```\\nNode* make_BST(vector<int>&in, int s, int e)\\n{\\n    if(s>e)\\n        return NULL;\\n    \\n    int mid = s+(e-s)/2;    \\n    Node* root = new Node(in[mid]);\\n    \\n    root->left = make_BST(in, s, mid-1);\\n    root->right = make_BST(in, mid+1, e);\\n    return root;\\n}\\n\\nNode *constructTree(int post[], int n)\\n{\\n    sort(post, post+n);\\n    vector<int>inorder(post, post+n); // inorder traversal\\n    \\n    return make_BST(inorder, 0, n-1);\\n}\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    unordered_map<int, int> findIndex; // store index of every element present in inorder\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        for(int i = 0; i < inorder.size(); i++) \\n            findIndex[inorder[i]] = i;  \\n        return build(preorder, 0, inorder.size() - 1);\\n    }\\n    \\n    int i = 0;\\n    TreeNode* build(vector<int>& preorder, int start, int end)\\n    {        \\n        if(start > end) \\n            return NULL;    \\n        \\n        // when start <= end\\n        int idx = findIndex[preorder[i]];\\n        TreeNode *root = new TreeNode(preorder[i++]);\\n        \\n        root->left  = build(preorder, start, idx - 1); \\n        root->right = build(preorder, idx + 1, end);   \\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        int n = preorder.size();\\n        int pre_index=0, in_index=0, flag=0;\\n        \\n        stack<TreeNode*> st;\\n        TreeNode * root = new TreeNode(preorder[pre_index]);\\n        pre_index++;\\n        \\n        st.push(root);\\n        TreeNode *prev = root;\\n        \\n        while(pre_index <  n)\\n        {\\n            if(!st.empty() && inorder[in_index] == st.top()->val)\\n            {\\n                prev = st.top();\\n                st.pop();\\n                in_index++;\\n                flag = 1;\\n            }\\n            else\\n            {\\n                TreeNode * node = new TreeNode(preorder[pre_index]);\\n                if(flag == 0){\\n                    prev->left = node;\\n                    prev = prev->left;\\n                }\\n                else\\n                {\\n                    prev->right = node;\\n                    prev = prev->right;\\n                    flag = 0;\\n                }\\n                st.push(node);\\n                pre_index++;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) \\n    {\\n        int n = inorder.size();\\n        for(int i = 0; i < n; i++) \\n            mp[inorder[i]] = i;\\n        \\n        int postIdx = n-1;\\n        return build(inorder, postorder, 0, n-1, postIdx);\\n    }\\n\\n    TreeNode* build(vector<int>& in, vector<int>& post, int inStart, int inEnd, int& postIdx) \\n    {\\n        if(inStart > inEnd) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(post[postIdx--]);\\n        int inIdx = mp[root -> val];\\n        \\n        root -> right = build(in, post, inIdx+1, inEnd, postIdx);\\n        root -> left  = build(in, post, inStart, inIdx-1, postIdx);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2102683,
                "title": "python3-o-n-time-solution-2-approaches-using-stack-and-sorted-preorder",
                "content": "Approach 1 - **BST from Preorder and Inorder(Sorted Preorder) arrays**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        inorder = sorted(preorder)\\n        inorderIndexDic = {ch : i for i, ch in enumerate(inorder)}\\n        self.rootIndex = 0\\n        \\n        def solve(l, r):\\n            if l > r: return None\\n            root = TreeNode(preorder[self.rootIndex])\\n            self.rootIndex += 1\\n            \\n            i = inorderIndexDic[root.val]\\n            root.left = solve(l, i-1)\\n            root.right = solve(i+1, r)\\n            return root\\n        \\n        return solve(0, len(inorder)-1)\\n\\t\\t\\n# Time: O(N log(N))\\n# Space: O(N)\\n```\\n\\nApproach 2 - **Using Stack**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        parent = root\\n        stack = [parent]\\n        \\n        for v in preorder[1:]:\\n            newNode = TreeNode(v)\\n            if stack and newNode.val < parent.val:\\n                parent.left = newNode\\n                stack.append(newNode)\\n                parent = newNode\\n            else:\\n                while stack and stack[-1].val < newNode.val:\\n                    parent = stack.pop()\\n                parent.right = newNode\\n                stack.append(newNode)\\n                parent = newNode\\n        \\n        return root\\n    \\n    \\n# Time: O(N)\\n# Space: O(N)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Stack",
                    "Binary Search Tree",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        inorder = sorted(preorder)\\n        inorderIndexDic = {ch : i for i, ch in enumerate(inorder)}\\n        self.rootIndex = 0\\n        \\n        def solve(l, r):\\n            if l > r: return None\\n            root = TreeNode(preorder[self.rootIndex])\\n            self.rootIndex += 1\\n            \\n            i = inorderIndexDic[root.val]\\n            root.left = solve(l, i-1)\\n            root.right = solve(i+1, r)\\n            return root\\n        \\n        return solve(0, len(inorder)-1)\\n\\t\\t\\n# Time: O(N log(N))\\n# Space: O(N)\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        parent = root\\n        stack = [parent]\\n        \\n        for v in preorder[1:]:\\n            newNode = TreeNode(v)\\n            if stack and newNode.val < parent.val:\\n                parent.left = newNode\\n                stack.append(newNode)\\n                parent = newNode\\n            else:\\n                while stack and stack[-1].val < newNode.val:\\n                    parent = stack.pop()\\n                parent.right = newNode\\n                stack.append(newNode)\\n                parent = newNode\\n        \\n        return root\\n    \\n    \\n# Time: O(N)\\n# Space: O(N)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740094,
                "title": "c-recursive-solution-short-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* builtTree(vector<int>& preorder, int &prevIndex, int &boundaryVal)\\n    {\\n        if(prevIndex>=preorder.size() || preorder[prevIndex]>=boundaryVal)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[prevIndex]);\\n        prevIndex++;\\n        root->left=builtTree(preorder, prevIndex, root->val);\\n        root->right=builtTree(preorder, prevIndex, boundaryVal);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int prevIndex=0, boundaryVal=1001;\\n        return builtTree(preorder, prevIndex, boundaryVal);\\n    }\\n};\\n```\\n**Upvote it if you find helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* builtTree(vector<int>& preorder, int &prevIndex, int &boundaryVal)\\n    {\\n        if(prevIndex>=preorder.size() || preorder[prevIndex]>=boundaryVal)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[prevIndex]);\\n        prevIndex++;\\n        root->left=builtTree(preorder, prevIndex, root->val);\\n        root->right=builtTree(preorder, prevIndex, boundaryVal);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int prevIndex=0, boundaryVal=1001;\\n        return builtTree(preorder, prevIndex, boundaryVal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585911,
                "title": "java-monotonic-stack-solution-converting-medium-to-easy-problem",
                "content": "Below solution uses monotonic stack technique.\\n\\n*  *Inserting Left node*: If the current node is smaller than the node in top of the stack, then it is guarenteed that node lies in left half of BST.\\n*  *Inserting Right node*: It gets little tricky in this situtation but if you are aware of the monotonic stack concept, this problem becomes trivial.\\nOur current node cannot be directly inserted to the right of node which is in top of the stack, we need to find the node which is **lesser than our current node but greater than it\\'s parent**.  So keep removing nodes from the stack until you find that element in the stack. \\n\\t\\n```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        \\n        // Since first element of a preorder will always be a root\\n        TreeNode root = new TreeNode(preorder[0]); \\n        stk.push(root);\\n        \\n        // Iterating through the elements after the root\\n        for(int i=1;i<preorder.length;i++){\\n            TreeNode node = new TreeNode(preorder[i]);\\n            \\n            // If a given element is smaller than the top of the stack, it will always be its left child\\n            if(node.val < stk.peek().val){\\n                stk.peek().left = node;\\n                stk.push(node);\\n            }else{\\n                // Popping elements until the first lowest element after current node\\'s greatest element is found\\n                TreeNode temp = null;\\n                while(stk.size() != 0 && stk.peek().val < node.val){\\n                    temp = stk.pop();\\n                }\\n                \\n                // Joining current node to it\\'s first lowest element from the root\\n                temp.right = node;\\n                stk.push(node);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        \\n        // Since first element of a preorder will always be a root\\n        TreeNode root = new TreeNode(preorder[0]); \\n        stk.push(root);\\n        \\n        // Iterating through the elements after the root\\n        for(int i=1;i<preorder.length;i++){\\n            TreeNode node = new TreeNode(preorder[i]);\\n            \\n            // If a given element is smaller than the top of the stack, it will always be its left child\\n            if(node.val < stk.peek().val){\\n                stk.peek().left = node;\\n                stk.push(node);\\n            }else{\\n                // Popping elements until the first lowest element after current node\\'s greatest element is found\\n                TreeNode temp = null;\\n                while(stk.size() != 0 && stk.peek().val < node.val){\\n                    temp = stk.pop();\\n                }\\n                \\n                // Joining current node to it\\'s first lowest element from the root\\n                temp.right = node;\\n                stk.push(node);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365563,
                "title": "java-easy-approach-with-explanation-recursive-postorder",
                "content": "```\\nclass Solution \\n{\\n    public TreeNode bstFromPreorder(int[] preorder) \\n    {\\n        if(root == null)//base case when we are provide with the null graph \\n            return null;\\n        \\n        return constructBST(preorder, 0, preorder.length-1);//it returns the address of the new root of the BST, with all the references of its children \\n    }\\n    public TreeNode constructBST(int[] preorder, int start, int end)\\n    {//we are doing the postorder traversal, in order to know the child first and then the parent  //divide and conqure approach is used\\n        \\n        if(start > end)//base case of recursion when we reach the wrong index(null node)\\n            return null;\\n         \\n        int data= preorder[start];//current root, we first deal witth its child \\n        \\n        int index;//global index in order to find  wheere the actual break happened \\n        \\n        for(index= start; index <= end; index++)\\n        {//we want to find the next greater of root, because preorder which is provided to us is for a BST\\n        //as we know that the right side of BST contains value greater than the root \\n            \\n            if(preorder[index] > preorder[start])//finding the starting index of right subtree \\n                break;\\n        }\\n        \\n        //storing the reference for the root, to creates its node with sufficient data of child \\n        \\n        TreeNode left= constructBST(preorder, start+1, index - 1);//recurssively traversing the left subtree in search of child//data of child must be less than root\\n        \\n        TreeNode right= constructBST(preorder, index, end);//recurssively traversing the right subtree in search of child//data of child must be greater than root//storing the reference for the root \\n        \\n        TreeNode node= new TreeNode(data, left, right);//creating the node after nowing the status of left and right children \\n        return node;//returning the node in order to maintain the backward link\\n    }\\n}//please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public TreeNode bstFromPreorder(int[] preorder) \\n    {\\n        if(root == null)//base case when we are provide with the null graph \\n            return null;\\n        \\n        return constructBST(preorder, 0, preorder.length-1);//it returns the address of the new root of the BST, with all the references of its children \\n    }\\n    public TreeNode constructBST(int[] preorder, int start, int end)\\n    {//we are doing the postorder traversal, in order to know the child first and then the parent  //divide and conqure approach is used\\n        \\n        if(start > end)//base case of recursion when we reach the wrong index(null node)\\n            return null;\\n         \\n        int data= preorder[start];//current root, we first deal witth its child \\n        \\n        int index;//global index in order to find  wheere the actual break happened \\n        \\n        for(index= start; index <= end; index++)\\n        {//we want to find the next greater of root, because preorder which is provided to us is for a BST\\n        //as we know that the right side of BST contains value greater than the root \\n            \\n            if(preorder[index] > preorder[start])//finding the starting index of right subtree \\n                break;\\n        }\\n        \\n        //storing the reference for the root, to creates its node with sufficient data of child \\n        \\n        TreeNode left= constructBST(preorder, start+1, index - 1);//recurssively traversing the left subtree in search of child//data of child must be less than root\\n        \\n        TreeNode right= constructBST(preorder, index, end);//recurssively traversing the right subtree in search of child//data of child must be greater than root//storing the reference for the root \\n        \\n        TreeNode node= new TreeNode(data, left, right);//creating the node after nowing the status of left and right children \\n        return node;//returning the node in order to maintain the backward link\\n    }\\n}//please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203305,
                "title": "easy-recursive-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insert(TreeNode* root, int value)\\n    {\\n        if(root==NULL)\\n            return new TreeNode(value);\\n        if(value<root->val)\\n            root->left=insert(root->left,value);\\n        if(value>root->val)\\n            root->right=insert(root->right,value);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root=NULL;   \\n        for(int i=0;i<preorder.size();i++)\\n            root=insert(root,preorder[i]);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insert(TreeNode* root, int value)\\n    {\\n        if(root==NULL)\\n            return new TreeNode(value);\\n        if(value<root->val)\\n            root->left=insert(root->left,value);\\n        if(value>root->val)\\n            root->right=insert(root->right,value);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root=NULL;   \\n        for(int i=0;i<preorder.size();i++)\\n            root=insert(root,preorder[i]);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649549,
                "title": "simple-c-solution-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertBST(TreeNode* root,int key)\\n    {\\n        if(root==NULL)\\n        {\\n            return new TreeNode(key);\\n        }\\n        \\n        if(key<root->val)\\n        {\\n            root->left = insertBST(root->left,key);\\n        }\\n        else if(key>root->val)\\n        {\\n            root->right = insertBST(root->right,key);\\n        }\\n        \\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root = new TreeNode();\\n        root=NULL;\\n        \\n        for(auto i=preorder.begin();i!=preorder.end();i++)\\n        {\\n            root=insertBST(root,*i);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertBST(TreeNode* root,int key)\\n    {\\n        if(root==NULL)\\n        {\\n            return new TreeNode(key);\\n        }\\n        \\n        if(key<root->val)\\n        {\\n            root->left = insertBST(root->left,key);\\n        }\\n        else if(key>root->val)\\n        {\\n            root->right = insertBST(root->right,key);\\n        }\\n        \\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root = new TreeNode();\\n        root=NULL;\\n        \\n        for(auto i=preorder.begin();i!=preorder.end();i++)\\n        {\\n            root=insertBST(root,*i);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589354,
                "title": "python3-simple-clean-and-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n      root = None\\n      \\n      for e in preorder:\\n        root = self.insert(root, e)\\n      \\n      return root\\n\\n    \\n    def insert(self, node, val):\\n      if node is None:\\n        return TreeNode(val) \\n      \\n      if val < node.val:\\n          node.left = self.insert(node.left, val)\\n      else:\\n          node.right = self.insert(node.right, val)\\n          \\n      return node",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n      root = None\\n      \\n      for e in preorder:\\n        root = self.insert(root, e)\\n      \\n      return root\\n\\n    \\n    def insert(self, node, val):\\n      if node is None:\\n        return TreeNode(val) \\n      \\n      if val < node.val:\\n          node.left = self.insert(node.left, val)\\n      else:\\n          node.right = self.insert(node.right, val)\\n          \\n      return node",
                "codeTag": "Java"
            },
            {
                "id": 254002,
                "title": "js-recursive",
                "content": "```javascript\\nfunction TreeNode(val) {\\n        this.val = val;\\n        this.left = this.right = null;\\n}\\nvar bstFromPreorder = function (preorder) {\\n        if (preorder.length === 0) return null\\n        if (preorder.length === 1) return new TreeNode(preorder[0])\\n        let root = new TreeNode(preorder[0])\\n        let left = bstFromPreorder(preorder.slice(1).filter(each => each < preorder[0]))\\n        let right = bstFromPreorder(preorder.slice(1).filter(each => each > preorder[0]))\\n        if (root) root.left = left;\\n        if (root) root.right = right;\\n        return root\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nfunction TreeNode(val) {\\n        this.val = val;\\n        this.left = this.right = null;\\n}\\nvar bstFromPreorder = function (preorder) {\\n        if (preorder.length === 0) return null\\n        if (preorder.length === 1) return new TreeNode(preorder[0])\\n        let root = new TreeNode(preorder[0])\\n        let left = bstFromPreorder(preorder.slice(1).filter(each => each < preorder[0]))\\n        let right = bstFromPreorder(preorder.slice(1).filter(each => each > preorder[0]))\\n        if (root) root.left = left;\\n        if (root) root.right = right;\\n        return root\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749242,
                "title": "superb-logic",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        inorder=sorted(preorder)\\n        def build(preorder,inorder):\\n            if not preorder or not inorder:\\n                return \\n            root=TreeNode(preorder[0])\\n            mid=inorder.index(preorder[0])\\n            root.left=build(preorder[1:mid+1],inorder[:mid])\\n            root.right=build(preorder[mid+1:],inorder[mid+1:])\\n            return root\\n        return build(preorder,inorder)\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        inorder=sorted(preorder)\\n        def build(preorder,inorder):\\n            if not preorder or not inorder:\\n                return \\n            root=TreeNode(preorder[0])\\n            mid=inorder.index(preorder[0])\\n            root.left=build(preorder[1:mid+1],inorder[:mid])\\n            root.right=build(preorder[mid+1:],inorder[mid+1:])\\n            return root\\n        return build(preorder,inorder)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275584,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        TreeNode* curr;\\n        for (int i = 1; i < preorder.size(); i++) {\\n            curr = root;\\n            for (int j = 0; j < i; j++) {\\n                if (preorder[i] < curr->val) {\\n                    if (curr->left != NULL) {\\n                        curr = curr->left;\\n                    } else {\\n                        TreeNode* node = new TreeNode(preorder[i]);\\n                        curr->left = node;\\n                        break;\\n                    }\\n                } else {\\n                    if (curr->right != NULL) {\\n                        curr = curr->right;\\n                    } else {\\n                        TreeNode* node = new TreeNode(preorder[i]);\\n                        curr->right = node; \\n                        break;\\n                    }\\n                }       \\n            }      \\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n# Approach 2\\nRecursive\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return build(preorder, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int& i, int bound) {\\n        if (i == preorder.size() || preorder[i] > bound)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = build(preorder, i, root->val);\\n        root->right = build(preorder, i, bound);\\n        return root;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        TreeNode* curr;\\n        for (int i = 1; i < preorder.size(); i++) {\\n            curr = root;\\n            for (int j = 0; j < i; j++) {\\n                if (preorder[i] < curr->val) {\\n                    if (curr->left != NULL) {\\n                        curr = curr->left;\\n                    } else {\\n                        TreeNode* node = new TreeNode(preorder[i]);\\n                        curr->left = node;\\n                        break;\\n                    }\\n                } else {\\n                    if (curr->right != NULL) {\\n                        curr = curr->right;\\n                    } else {\\n                        TreeNode* node = new TreeNode(preorder[i]);\\n                        curr->right = node; \\n                        break;\\n                    }\\n                }       \\n            }      \\n        }\\n        return root;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return build(preorder, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int& i, int bound) {\\n        if (i == preorder.size() || preorder[i] > bound)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = build(preorder, i, root->val);\\n        root->right = build(preorder, i, bound);\\n        return root;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247793,
                "title": "simple-approach-beats-100-in-tc-and-90-in-sc-easy-to-understand",
                "content": "# Intuition\\nFirst Elementr of PreOrder Traversal Array will be root always.\\n\\n# Approach\\nSimply insert the elemnt of given array by comparing if it is greater or not ,\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //Function to insert in the BST\\n    void insert(TreeNode * &root , int key){\\n        if(root == nullptr){\\n           root = new TreeNode(key);\\n           return ;\\n        }\\n        //if key is greater than root then insert to the right\\n        if(key > root->val){\\n           insert(root->right,key);\\n        }\\n        else{ //if key is smaller than root then insert to the left\\n            insert(root->left,key);\\n        }\\n\\n    }\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root ;\\n        //Iterating over Node Values and sending to the insert function\\n        for(auto key : preorder){\\n            insert(root,key);\\n        }\\n        return root;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    //Function to insert in the BST\\n    void insert(TreeNode * &root , int key){\\n        if(root == nullptr){\\n           root = new TreeNode(key);\\n           return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2774853,
                "title": "1008-construct-binary-search-tree-from-preorder-traversal-most-easy-sol-java",
                "content": "// a very clever solution\\n// one loop\\n// fx call and check\\n// see take an indivisual element and then call the fx for placing it \\n// if you like the sol then pls upvote :)\\n```\\nclass Solution {\\n public TreeNode bstFromPreorder(int[] preorder) \\n {\\n     TreeNode root= new TreeNode(preorder[0]);\\n     for(int i: preorder)\\n     {\\n         helper(i,root);\\n     }\\n     return root ;\\n }\\n    public TreeNode helper(int i, TreeNode root)\\n    { \\n        if(root==null){\\n root =new TreeNode (i);\\n        return root;\\n        }\\n     if(i<root.val){\\n         root.left= helper(i,root.left);\\n     }\\n     if(i>root.val){\\n         root.right=helper(i, root.right);\\n     }\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n public TreeNode bstFromPreorder(int[] preorder) \\n {\\n     TreeNode root= new TreeNode(preorder[0]);\\n     for(int i: preorder)\\n     {\\n         helper(i,root);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2439774,
                "title": "c-two-different-approach-optimised-solution-with-0ms",
                "content": "```\\nclass Solution {\\n    \\n    TreeNode * Solve(vector<int>& preorder, int start ,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        \\n        TreeNode * root = new TreeNode(preorder[start]);\\n        \\n        int i = start+1;\\n        for(; i<=end ; i++)\\n        {\\n            if(preorder[start]<preorder[i])\\n                break;\\n        }\\n        \\n        root->left = Solve(preorder, start+1 , i-1);\\n        root->right = Solve(preorder , i, end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode * SolveOptimised(vector<int>& preorder, int &index, TreeNode* p , TreeNode * q )\\n    {\\n        if(index >= preorder.size())\\n            return NULL;\\n        \\n        if((p && p->val > preorder[index]) || (q && q->val < preorder[index]) )\\n            return NULL;\\n        \\n        TreeNode * root = new TreeNode (preorder[index++]);\\n        \\n        root->left = SolveOptimised(preorder , index , p, root);\\n        root->right = SolveOptimised(preorder , index , root , q);\\n        \\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        // Methos 1 , TC :O(n square)\\n        return Solve(preorder, 0 , preorder.size()-1);\\n        \\n        // Methos 2 , TC :O(n)\\n        \\n        int index = 0;\\n        return SolveOptimised(preorder , index , NULL, NULL);\\n        \\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f8abb61-88b6-4a75-b2f7-4e7f6c34179c_1660748548.307332.png)\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    \\n    TreeNode * Solve(vector<int>& preorder, int start ,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        \\n        TreeNode * root = new TreeNode(preorder[start]);\\n        \\n        int i = start+1;\\n        for(; i<=end ; i++)\\n        {\\n            if(preorder[start]<preorder[i])\\n                break;\\n        }\\n        \\n        root->left = Solve(preorder, start+1 , i-1);\\n        root->right = Solve(preorder , i, end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode * SolveOptimised(vector<int>& preorder, int &index, TreeNode* p , TreeNode * q )\\n    {\\n        if(index >= preorder.size())\\n            return NULL;\\n        \\n        if((p && p->val > preorder[index]) || (q && q->val < preorder[index]) )\\n            return NULL;\\n        \\n        TreeNode * root = new TreeNode (preorder[index++]);\\n        \\n        root->left = SolveOptimised(preorder , index , p, root);\\n        root->right = SolveOptimised(preorder , index , root , q);\\n        \\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        // Methos 1 , TC :O(n square)\\n        return Solve(preorder, 0 , preorder.size()-1);\\n        \\n        // Methos 2 , TC :O(n)\\n        \\n        int index = 0;\\n        return SolveOptimised(preorder , index , NULL, NULL);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080598,
                "title": "python-just-6-line-code-own-solution-o-n-time",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder)==0:\\n            return None\\n        root=TreeNode(preorder[0])\\n        root.left=self.bstFromPreorder([i for i in preorder if i<root.val])\\n        root.right=self.bstFromPreorder([i for i in preorder if i>root.val])\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder)==0:\\n            return None\\n        root=TreeNode(preorder[0])\\n        root.left=self.bstFromPreorder([i for i in preorder if i<root.val])\\n        root.right=self.bstFromPreorder([i for i in preorder if i>root.val])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909159,
                "title": "discussed-all-approach-in-notes-c-java",
                "content": "**Notes Link**  : https://github.com/rizonkumar/LeetCode-Notes/blob/main/1008.pdf\\n\\nJava Code\\n\\n```\\n\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return bstFromPreorder(preorder, Integer.MAX_VALUE, new int[] {0});\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder, int bound, int[] i){\\n        if(i[0] == preorder.length || preorder[i[0]] > bound) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[i[0]++]);\\n        root.left = bstFromPreorder(preorder, root.val, i);\\n        root.right = bstFromPreorder(preorder, bound, i);\\n        return root;\\n    }\\n}\\n```\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return build(preorder, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int& i, int bound) {\\n        if (i == preorder.size() || preorder[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = build(preorder, i, root->val);\\n        root->right = build(preorder, i, bound);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return bstFromPreorder(preorder, Integer.MAX_VALUE, new int[] {0});\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder, int bound, int[] i){\\n        if(i[0] == preorder.length || preorder[i[0]] > bound) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[i[0]++]);\\n        root.left = bstFromPreorder(preorder, root.val, i);\\n        root.right = bstFromPreorder(preorder, bound, i);\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return build(preorder, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int& i, int bound) {\\n        if (i == preorder.size() || preorder[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = build(preorder, i, root->val);\\n        root->right = build(preorder, i, bound);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863201,
                "title": "c-easy-efficient-solution-o-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* tt(vector<int>& p, int& i, int upperbound){\\n        if(i==p.size() || p[i]>upperbound) return NULL;\\n        TreeNode* root = new TreeNode(p[i++]);\\n        root->left = tt(p,i,root->val);\\n        root->right = tt(p,i,upperbound);\\n        \\n        return root;\\n         \\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& p) {\\n        int i = 0; \\n        return tt(p,i,INT_MAX);\\n    }\\n};\\n```\\n\\nif you find this solution usefull then do upvote and share.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* tt(vector<int>& p, int& i, int upperbound){\\n        if(i==p.size() || p[i]>upperbound) return NULL;\\n        TreeNode* root = new TreeNode(p[i++]);\\n        root->left = tt(p,i,root->val);\\n        root->right = tt(p,i,upperbound);\\n        \\n        return root;\\n         \\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& p) {\\n        int i = 0; \\n        return tt(p,i,INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519898,
                "title": "c-100-faster-o-n-recursive-solution",
                "content": "```\\n  TreeNode* build(vector<int> pre, int s, int e){\\n    if(s>e) return NULL;\\n    TreeNode* root = new TreeNode(pre[s]);\\n    int idx;\\n    for(int i=s+1; i<=e; i++){\\n      if(pre[i]>pre[s]){\\n        idx = i;\\n        break; }\\n\\t}\\n    root->left = build(pre, s+1, idx-1);\\n    root->right = build(pre, idx, e);\\n    return root;\\n  }\\n  \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n      TreeNode* newroot = build(preorder, 0, preorder.size()-1);\\n      return newroot;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  TreeNode* build(vector<int> pre, int s, int e){\\n    if(s>e) return NULL;\\n    TreeNode* root = new TreeNode(pre[s]);\\n    int idx;\\n    for(int i=s+1; i<=e; i++){\\n      if(pre[i]>pre[s]){\\n        idx = i;\\n        break; }\\n\\t}\\n    root->left = build(pre, s+1, idx-1);\\n    root->right = build(pre, idx, e);\\n    return root;\\n  }\\n  \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n      TreeNode* newroot = build(preorder, 0, preorder.size()-1);\\n      return newroot;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518958,
                "title": "c-recursive-and-stack-iterative-solutions",
                "content": "Recursive:\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& p) {\\n        int id = 0;\\n        return build(p, id, INT_MAX);\\n    }\\n    \\n    TreeNode* build(vector<int>& p, int& id, int limit) {\\n        if(id == p.size() || p[id] > limit)\\n            return NULL;\\n        int val = p[id++];\\n        TreeNode* root = new TreeNode(val);\\n        root->left = build(p, id, val);    //root->left must be less than the root\\n        root->right = build(p, id, limit); //root->right must be less than the previous root\\n        return root;\\n    }\\n};\\n```\\nIterative with Stack: \\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* bstFromPreorder(vector<int>& p) {\\n\\t\\tTreeNode* root = new TreeNode(p[0]), *cur = root;\\n        stack<TreeNode*> s({root}); //push the node with no children\\n\\t\\tfor(int i = 1; i < p.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(p[i] < s.top()->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur->left = new TreeNode(p[i]);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t\\ts.push(cur);\\n\\t\\t\\t}\\n            else\\n            {   //check the previous nodes for the best pos to insert\\n                while(!s.empty() && p[i] > s.top()->val)\\n                {\\n                    cur = s.top();\\n                    s.pop();\\n                }\\n                cur->right = new TreeNode(p[i]);\\n                cur = cur->right;\\n                s.push(cur);\\n            }\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& p) {\\n        int id = 0;\\n        return build(p, id, INT_MAX);\\n    }\\n    \\n    TreeNode* build(vector<int>& p, int& id, int limit) {\\n        if(id == p.size() || p[id] > limit)\\n            return NULL;\\n        int val = p[id++];\\n        TreeNode* root = new TreeNode(val);\\n        root->left = build(p, id, val);    //root->left must be less than the root\\n        root->right = build(p, id, limit); //root->right must be less than the previous root\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* bstFromPreorder(vector<int>& p) {\\n\\t\\tTreeNode* root = new TreeNode(p[0]), *cur = root;\\n        stack<TreeNode*> s({root}); //push the node with no children\\n\\t\\tfor(int i = 1; i < p.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(p[i] < s.top()->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur->left = new TreeNode(p[i]);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t\\ts.push(cur);\\n\\t\\t\\t}\\n            else\\n            {   //check the previous nodes for the best pos to insert\\n                while(!s.empty() && p[i] > s.top()->val)\\n                {\\n                    cur = s.top();\\n                    s.pop();\\n                }\\n                cur->right = new TreeNode(p[i]);\\n                cur = cur->right;\\n                s.push(cur);\\n            }\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518673,
                "title": "c-no-stack-only-recursive-calls-beats-100-runtime-and-memory",
                "content": "Make a function which will insert your elements from the preorder array into the binary search tree in the predefined form of the binary search tree.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode();\\n        \\n        root->val=preorder[0];\\n        \\n        for(int i=1;i<preorder.size();i++){\\n            my_push_back(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    void my_push_back(TreeNode* root, int val_to_insert){\\n        if(val_to_insert>root->val){\\n            if(root->right==NULL){\\n                root->right=new TreeNode(val_to_insert);\\n            }\\n            else{\\n                my_push_back(root->right, val_to_insert);\\n            }\\n        }\\n        else if(val_to_insert<root->val){\\n            if(root->left==NULL){\\n                root->left=new TreeNode(val_to_insert);\\n            }\\n            else{\\n                my_push_back(root->left, val_to_insert);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode();\\n        \\n        root->val=preorder[0];\\n        \\n        for(int i=1;i<preorder.size();i++){\\n            my_push_back(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    void my_push_back(TreeNode* root, int val_to_insert){\\n        if(val_to_insert>root->val){\\n            if(root->right==NULL){\\n                root->right=new TreeNode(val_to_insert);\\n            }\\n            else{\\n                my_push_back(root->right, val_to_insert);\\n            }\\n        }\\n        else if(val_to_insert<root->val){\\n            if(root->left==NULL){\\n                root->left=new TreeNode(val_to_insert);\\n            }\\n            else{\\n                my_push_back(root->left, val_to_insert);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518588,
                "title": "straightforward-recursive-solution-via-python",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if len(preorder) <= 0:\\n            return None\\n        \\n        root_val = preorder[0]\\n        right_start_idx = len(preorder)\\n        for i, v in enumerate(preorder[1:]):\\n            if v > root_val:\\n                right_start_idx = i+1\\n                break\\n        \\n        leftSubTree = self.bstFromPreorder(preorder[1:right_start_idx])\\n        rightSubTree = self.bstFromPreorder(preorder[right_start_idx:])\\n        \\n        return TreeNode(root_val, leftSubTree, rightSubTree)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if len(preorder) <= 0:\\n            return None\\n        \\n        root_val = preorder[0]\\n        right_start_idx = len(preorder)\\n        for i, v in enumerate(preorder[1:]):\\n            if v > root_val:\\n                right_start_idx = i+1\\n                break\\n        \\n        leftSubTree = self.bstFromPreorder(preorder[1:right_start_idx])\\n        rightSubTree = self.bstFromPreorder(preorder[right_start_idx:])\\n        \\n        return TreeNode(root_val, leftSubTree, rightSubTree)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406823,
                "title": "0ms-100-beats-self-explanatory-java-recursion",
                "content": "self explanatory code,\\njust make a node for each element and fit it into BST\\n\\n\\n\\n```\\npublic TreeNode bstFromPreorder(int[] preorder) \\n    {\\n        if(preorder.length==0) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i=1;i<preorder.length;i++)\\n        {\\n            TreeNode node = new TreeNode(preorder[i]);\\n            \\n            fitInBST(node,root);\\n        }\\n        \\n        return root;\\n    }\\n    void fitInBST(TreeNode node,TreeNode root)\\n    {\\n        if(node.val<root.val)\\n        {\\n            if(root.left == null) root.left = node;\\n            else fitInBST(node,root.left);\\n        }\\n        else if(node.val>root.val)\\n        {\\n            if(root.right == null) root.right = node;\\n            else fitInBST(node,root.right);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic TreeNode bstFromPreorder(int[] preorder) \\n    {\\n        if(preorder.length==0) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i=1;i<preorder.length;i++)\\n        {\\n            TreeNode node = new TreeNode(preorder[i]);\\n            \\n            fitInBST(node,root);\\n        }\\n        \\n        return root;\\n    }\\n    void fitInBST(TreeNode node,TreeNode root)\\n    {\\n        if(node.val<root.val)\\n        {\\n            if(root.left == null) root.left = node;\\n            else fitInBST(node,root.left);\\n        }\\n        else if(node.val>root.val)\\n        {\\n            if(root.right == null) root.right = node;\\n            else fitInBST(node,root.right);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1279784,
                "title": "java-easy-to-understand-beats-100-on-runtime-self-explanatory",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        \\n        if(preorder.length == 0){\\n            return new TreeNode();\\n        }\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i < preorder.length; i++){\\n           addChild(root, preorder[i]);\\n        }\\n        return root;\\n        \\n    }\\n    \\n    public void addChild(TreeNode root, int val){  \\n\\n        if(val < root.val){\\n            if(root.left != null){\\n            addChild(root.left, val);\\n            }\\n            else{\\n                root.left = new TreeNode(val);\\n            }\\n            \\n        }\\n        else{\\n           if(root.right != null){\\n            addChild(root.right, val);\\n            }\\n            else{\\n                root.right = new TreeNode(val);\\n            }\\n        }\\n        \\n    }\\n     \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        \\n        if(preorder.length == 0){\\n            return new TreeNode();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1170701,
                "title": "python-o-n-easy-recursive-using-bst-property-min-max",
                "content": "```\\nimport math\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        \\n        def construct(preorder,mn,mx):\\n            if preorder:\\n\\t\\t\\t\\t# Any node value violates bst property\\n                if preorder[0]<mn or preorder[0]>mx:\\n                    return None\\n                n=TreeNode(preorder.pop(0))\\n                n.left=construct(preorder,mn,n.val)\\n                n.right=construct(preorder,n.val,mx)\\n\\n                return n\\n        return construct(preorder,-math.inf, math.inf)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        \\n        def construct(preorder,mn,mx):\\n            if preorder:\\n\\t\\t\\t\\t# Any node value violates bst property\\n                if preorder[0]<mn or preorder[0]>mx:\\n                    return None\\n                n=TreeNode(preorder.pop(0))\\n                n.left=construct(preorder,mn,n.val)\\n                n.right=construct(preorder,n.val,mx)\\n\\n                return n\\n        return construct(preorder,-math.inf, math.inf)",
                "codeTag": "Java"
            },
            {
                "id": 961088,
                "title": "0-ms-faster-than-100-00-13-mb-less-than-90-67-c",
                "content": "```\\n/* first element is always the root. \\nIterate over the rest array elements & \\nperform bst insertion \\ntaking first element as root every time */\\n\\nclass Solution {\\nprivate:\\n    void insert(TreeNode* root,int val){\\n        TreeNode* ptr=root,*prev=NULL;\\n        while(ptr){\\n            if(val<ptr->val){\\n                prev=ptr;\\n                ptr=ptr->left;\\n            }\\n            else if(val>ptr->val){\\n                prev=ptr;\\n                ptr=ptr->right;\\n            }\\n        }\\n        if(val<prev->val){\\n            prev->left=new TreeNode(val);\\n        }\\n        else{\\n            prev->right=new TreeNode(val);\\n        }\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int n=preorder.size();\\n        if(n==0)return NULL;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<n;i++){\\n            insert(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\nprivate:\\n    void insert(TreeNode* root,int val){\\n        TreeNode* ptr=root,*prev=NULL;\\n        while(ptr){\\n            if(val<ptr->val){\\n                prev=ptr;\\n                ptr=ptr->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 649863,
                "title": "c-5-line-solution-time-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& pre, int upper=INT_MAX) {        \\n        if(i >= pre.size() || pre[i] > upper) return NULL;\\n        return new TreeNode(pre[i++], bstFromPreorder(pre, pre[i-1]), bstFromPreorder(pre, upper));        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& pre, int upper=INT_MAX) {        \\n        if(i >= pre.size() || pre[i] > upper) return NULL;\\n        return new TreeNode(pre[i++], bstFromPreorder(pre, pre[i-1]), bstFromPreorder(pre, upper));        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649369,
                "title": "python-no-recursion",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        node_stack = []\\n        node = root = TreeNode(preorder[0])\\n        for n in preorder[1:]:\\n            if n <= node.val:\\n                node.left = TreeNode(n)\\n                node_stack.append(node)\\n                node = node.left\\n            else:\\n                while node_stack and n > node_stack[-1].val:\\n                    node = node_stack.pop()\\n                node.right = TreeNode(n)\\n                node = node.right\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        node_stack = []\\n        node = root = TreeNode(preorder[0])\\n        for n in preorder[1:]:\\n            if n <= node.val:\\n                node.left = TreeNode(n)\\n                node_stack.append(node)\\n                node = node.left\\n            else:\\n                while node_stack and n > node_stack[-1].val:\\n                    node = node_stack.pop()\\n                node.right = TreeNode(n)\\n                node = node.right\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648955,
                "title": "c-recursive-100",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* tree(vector<int>& preorder, int i, int j) {\\n        if(i > j) {\\n            return NULL;\\n        }\\n        TreeNode* root = new TreeNode(preorder[i]);\\n        if(i == j) {\\n            return root;\\n        }\\n        int k = i+1;\\n        while(k <= j) {\\n            if(preorder[k] > preorder[i]) {\\n                break;\\n            }\\n            k++;\\n        }\\n        root->left  = tree(preorder,i+1,k-1);\\n        root->right = tree(preorder,k,j);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0) {\\n            return NULL;\\n        }\\n        return tree(preorder, 0, preorder.size()-1);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* tree(vector<int>& preorder, int i, int j) {\\n        if(i > j) {\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 594992,
                "title": "recursive-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            helper(root, new TreeNode(preorder[i]));\\n        }\\n        return root;\\n    }\\n\\n    private void helper(TreeNode root, TreeNode inserted) {\\n        if (root.val < inserted.val) {\\n            if (root.right == null) {\\n                root.right = inserted;\\n            } else {\\n                helper(root.right, inserted);\\n            }\\n        } else {\\n            if (root.left == null) {\\n                root.left = inserted;\\n            } else {\\n                helper(root.left, inserted);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            helper(root, new TreeNode(preorder[i]));\\n        }\\n        return root;\\n    }\\n\\n    private void helper(TreeNode root, TreeNode inserted) {\\n        if (root.val < inserted.val) {\\n            if (root.right == null) {\\n                root.right = inserted;\\n            } else {\\n                helper(root.right, inserted);\\n            }\\n        } else {\\n            if (root.left == null) {\\n                root.left = inserted;\\n            } else {\\n                helper(root.left, inserted);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588723,
                "title": "c-bst-insert",
                "content": "```C++\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:    \\n    TreeNode* BstInsert(TreeNode*& root, int val){\\n        if(!root){    \\n            root = new TreeNode(val);\\n        }else{  \\n            if(val < root->val)  \\n                root->left  = BstInsert(root->left, val);   \\n            else if(root->val < val)  \\n                root->right = BstInsert(root->right, val);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        TreeNode* root = NULL;\\n        \\n        for (auto val : preorder)\\n            BstInsert(root, val);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:    \\n    TreeNode* BstInsert(TreeNode*& root, int val){\\n        if(!root){    \\n            root = new TreeNode(val);\\n        }else{  \\n            if(val < root->val)  \\n                root->left  = BstInsert(root->left, val);   \\n            else if(root->val < val)  \\n                root->right = BstInsert(root->right, val);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        TreeNode* root = NULL;\\n        \\n        for (auto val : preorder)\\n            BstInsert(root, val);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315570,
                "title": "python-beats-99",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    def insert(self, root, val):\\n        if val <= root.val:\\n            if root.left != None:\\n                self.insert(root.left, val)\\n            else:\\n                root.left = TreeNode(val)\\n        elif root.right != None:\\n            self.insert(root.right, val)\\n        else:\\n            root.right = TreeNode(val)\\n    \\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        root = TreeNode(preorder[0])\\n        \\n        for i in range(1, len(preorder)):\\n            self.insert(root, preorder[i])\\n            \\n        return root\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    def insert(self, root, val):\\n        if val <= root.val:\\n            if root.left != None:\\n                self.insert(root.left, val)\\n            else:\\n                root.left = TreeNode(val)\\n        elif root.right != None:\\n            self.insert(root.right, val)\\n        else:\\n            root.right = TreeNode(val)\\n    \\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        root = TreeNode(preorder[0])\\n        \\n        for i in range(1, len(preorder)):\\n            self.insert(root, preorder[i])\\n            \\n        return root\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 299527,
                "title": "c-code-easy-to-understand",
                "content": "````\\n    public TreeNode BstFromPreorder(int[] preorder) {\\n        if(preorder == null)\\n            return null;\\n        // root node will always be first node in preorder traversal\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n         // If we simply just insert all nodes in array \\n        // using standard way of inserting node in BST it will give us original tree.\\n\\t\\t\\n        for(int x = 1; x<preorder.Length; x++)\\n            InsertInBST(root, preorder[x]);\\n        \\n        return root;\\n    }\\n    // standard BST insertion. \\n    private void InsertInBST(TreeNode root, int val)\\n    {\\n        TreeNode current = root;\\n        TreeNode parent = null;\\n        while(current!=null)\\n        {\\n            parent = current;\\n            current = current.val > val? current.left:current.right;\\n        }\\n        \\n        if(parent.val > val)\\n            parent.left = new TreeNode(val);\\n        else\\n            parent.right = new TreeNode(val);\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n    public TreeNode BstFromPreorder(int[] preorder) {\\n        if(preorder == null)\\n            return null;\\n        // root node will always be first node in preorder traversal\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n         // If we simply just insert all nodes in array \\n        // using standard way of inserting node in BST it will give us original tree.\\n\\t\\t\\n        for(int x = 1; x<preorder.Length; x++)\\n            InsertInBST(root, preorder[x]);\\n        \\n        return root;\\n    }\\n    // standard BST insertion. \\n    private void InsertInBST(TreeNode root, int val)\\n    {\\n        TreeNode current = root;\\n        TreeNode parent = null;\\n        while(current!=null)\\n        {\\n            parent = current;\\n            current = current.val > val? current.left:current.right;\\n        }\\n        \\n        if(parent.val > val)\\n            parent.left = new TreeNode(val);\\n        else\\n            parent.right = new TreeNode(val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254844,
                "title": "java-o-n-solution-with-range",
                "content": "```\\n\\nclass Solution {\\n    int nodeIdx;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if(preorder == null) {\\n            return null;\\n        }\\n        nodeIdx = 0;\\n        return bstHelper(preorder, Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    private TreeNode bstHelper(int[] preorder, int start, int end) {\\n        if(nodeIdx == preorder.length || preorder[nodeIdx]<start || preorder[nodeIdx]>end) {\\n            return null;\\n        }\\n        int val = preorder[nodeIdx++];\\n        TreeNode node = new TreeNode(val);\\n        node.left = bstHelper(preorder, start, val);\\n        node.right = bstHelper(preorder, val, end);\\n        return node;   \\n    }   \\n} \\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    int nodeIdx;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if(preorder == null) {\\n            return null;\\n        }\\n        nodeIdx = 0;\\n        return bstHelper(preorder, Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    private TreeNode bstHelper(int[] preorder, int start, int end) {\\n        if(nodeIdx == preorder.length || preorder[nodeIdx]<start || preorder[nodeIdx]>end) {\\n            return null;\\n        }\\n        int val = preorder[nodeIdx++];\\n        TreeNode node = new TreeNode(val);\\n        node.left = bstHelper(preorder, start, val);\\n        node.right = bstHelper(preorder, val, end);\\n        return node;   \\n    }   \\n} \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252870,
                "title": "java-c-recursive-solution-beats-100-with-clear-explanation",
                "content": "Thoughts: \\nThe input array is the preorder traversal of a BST. \\n1.preorder[0] is the root of BST\\n2.The sub array from preorder[0] to the first element that is bigger than preorder[0] is the preorder traversal of the left subtree.\\n  The sub array from element that is bigger than preorder[0] to the end of the array is the preorder traversal of the right subtree.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode BstFromPreorder(int[] preorder) {\\n        if(preorder == null || preorder.Length == 0) return null;\\n        return helper(preorder, 0, preorder.Length);\\n        \\n    }\\n    \\n    public TreeNode helper(int[] preorder, int rootindex, int right)\\n    {        \\n        if(rootindex >= right) return null;\\n        \\n        int value = preorder[rootindex];\\n        TreeNode root = new TreeNode(value);\\n        \\n        int i = rootindex+1;\\n\\t\\t// find the left subtree of current node\\n        while(i <= preorder.Length-1 && preorder[i] < value)\\n        {\\n            i++;\\n        }\\n        //do the same thing for left and right subtree.\\n        root.left = helper(preorder, rootindex+1, i);\\n        root.right = helper(preorder,i, right);\\n        \\n        return root;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode BstFromPreorder(int[] preorder) {\\n        if(preorder == null || preorder.Length == 0) return null;\\n        return helper(preorder, 0, preorder.Length);\\n        \\n    }\\n    \\n    public TreeNode helper(int[] preorder, int rootindex, int right)\\n    {        \\n        if(rootindex >= right) return null;\\n        \\n        int value = preorder[rootindex];\\n        TreeNode root = new TreeNode(value);\\n        \\n        int i = rootindex+1;\\n\\t\\t// find the left subtree of current node\\n        while(i <= preorder.Length-1 && preorder[i] < value)\\n        {\\n            i++;\\n        }\\n        //do the same thing for left and right subtree.\\n        root.left = helper(preorder, rootindex+1, i);\\n        root.right = helper(preorder,i, right);\\n        \\n        return root;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605719,
                "title": "easy-c-solution-2-solution-optimised-and-optimal-solution",
                "content": "# Intuition\\nOptimised -> Inorder Traversal is required along with preOrder to create a unique tree. We can get that after sorting preOrder array.\\n\\nOptimal -> Since for any BST : [Left < Root < Right ]\\nWe just to need keep adding nodes after comparing it with the root and its left and right subtree.\\n\\n# Approach\\nOptimised -> \\n    - Sort the array to get inOrder array.\\n    - Then create the BST using preOrder and inOrder array.\\n\\nOptimal -> \\n    - Create a upperBound to position elements in tree.\\n    - Create a new node using array element and increase count.\\n    - For node->left, Update upperBound to node->val.\\n    - For node->right, No changes.\\n    - BaseCase : (i > size(array)) && a[i] > bound   \\n\\n# Complexity\\n- Time complexity:\\nOptimised : $$O(n*logn)$$\\nOptimal : $$O(n)$$\\n\\n- Space complexity:\\n    Optimised : $$O(n)$$\\n    Optimal : $$O(1) + stack space$$\\n\\n# Code\\n**Optimised Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> inMap;\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        vector<int> in = pre;\\n        sort(in.begin(),in.end());\\n        int n = pre.size();\\n        for(int i=0; i<n; i++){\\n            inMap[in[i]] = i;\\n        }\\n        int preFirst = 0;\\n        return construct(pre,in, preFirst, 0, n-1);\\n    }\\n\\n    TreeNode* construct(vector<int>& pre, vector<int>& in, int &preFirst, int left, int right){\\n        if(left > right) return NULL;\\n        TreeNode* root = new TreeNode(pre[preFirst++]);\\n        int inIndex = inMap[root->val];\\n \\n        root->left = construct(pre, in, preFirst,  left, inIndex-1);\\n        root->right = construct(pre, in, preFirst, inIndex+1, right);\\n        return root;\\n    }\\n};\\n```\\n**Optimal Solution**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int idx = 0;\\n        return build(preorder,idx,INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& A, int& i, int upBound){\\n        if(i == A.size() || A[i] > upBound) return nullptr;\\n\\n        TreeNode* node = new TreeNode(A[i++]);\\n        node->left = build(A, i, node->val);\\n        node->right = build(A,i, upBound);\\n        return node; \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> inMap;\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        vector<int> in = pre;\\n        sort(in.begin(),in.end());\\n        int n = pre.size();\\n        for(int i=0; i<n; i++){\\n            inMap[in[i]] = i;\\n        }\\n        int preFirst = 0;\\n        return construct(pre,in, preFirst, 0, n-1);\\n    }\\n\\n    TreeNode* construct(vector<int>& pre, vector<int>& in, int &preFirst, int left, int right){\\n        if(left > right) return NULL;\\n        TreeNode* root = new TreeNode(pre[preFirst++]);\\n        int inIndex = inMap[root->val];\\n \\n        root->left = construct(pre, in, preFirst,  left, inIndex-1);\\n        root->right = construct(pre, in, preFirst, inIndex+1, right);\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int idx = 0;\\n        return build(preorder,idx,INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& A, int& i, int upBound){\\n        if(i == A.size() || A[i] > upBound) return nullptr;\\n\\n        TreeNode* node = new TreeNode(A[i++]);\\n        node->left = build(A, i, node->val);\\n        node->right = build(A,i, upBound);\\n        return node; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190190,
                "title": "beats-100-6-line-of-code-o-n-easiest-solution-ever",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* range(vector<int> &pre, int min, int max, int &i){\\n\\n        // Base case \\n        if((i>= pre.size()) || (min>pre[i] || pre[i] > max)) return NULL;\\n\\n        TreeNode* root = new TreeNode(pre[i++]);\\n        root->left = range(pre,min,root->val,i);\\n        root->right = range(pre,root->val,max,i);\\n        return root;\\n\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int i =0;\\n        return range(pre,INT_MIN,INT_MAX,i);\\n    }\\n};\\n```\\n# **\\uD83D\\uDE4FPlease Upvote if You find it Helpful\\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    TreeNode* range(vector<int> &pre, int min, int max, int &i){\\n\\n        // Base case \\n        if((i>= pre.size()) || (min>pre[i] || pre[i] > max)) return NULL;\\n\\n        TreeNode* root = new TreeNode(pre[i++]);\\n        root->left = range(pre,min,root->val,i);\\n        root->right = range(pre,root->val,max,i);\\n        return root;\\n\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int i =0;\\n        return range(pre,INT_MIN,INT_MAX,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801627,
                "title": "python-o-n-time-and-o-logn-space-solution",
                "content": "```\\ndef divideAndConquer(a,l,r,root):\\n    if l>r:\\n        return\\n    root.val=a[l]\\n    if l==r:\\n        return\\n    v=l\\n    for i in range(l+1,r+1):\\n        if a[i]<a[l]:\\n            v=i\\n        else:\\n            break\\n    if v<r:\\n        root.right=TreeNode()\\n        divideAndConquer(a,v+1,r,root.right)\\n    if v>l:\\n        root.left=TreeNode()\\n        divideAndConquer(a,l+1,v,root.left)\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root=TreeNode()\\n        divideAndConquer(preorder,0,len(preorder)-1,root)\\n        return root",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\ndef divideAndConquer(a,l,r,root):\\n    if l>r:\\n        return\\n    root.val=a[l]\\n    if l==r:\\n        return\\n    v=l\\n    for i in range(l+1,r+1):\\n        if a[i]<a[l]:\\n            v=i\\n        else:\\n            break\\n    if v<r:\\n        root.right=TreeNode()\\n        divideAndConquer(a,v+1,r,root.right)\\n    if v>l:\\n        root.left=TreeNode()\\n        divideAndConquer(a,l+1,v,root.left)\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root=TreeNode()\\n        divideAndConquer(preorder,0,len(preorder)-1,root)\\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 2741321,
                "title": "easy-java-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root= new TreeNode( preorder[0] );\\n        \\n        for(int i: preorder){\\n            createTree(i, root);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode createTree(int i, TreeNode root){\\n        if(root == null){\\n            root= new TreeNode(i);\\n            return root;\\n        }\\n        \\n        if(root.val > i){\\n            root.left= createTree(i, root.left);\\n        }\\n        \\n        if(root.val < i){\\n            root.right= createTree(i, root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root= new TreeNode( preorder[0] );\\n        \\n        for(int i: preorder){\\n            createTree(i, root);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode createTree(int i, TreeNode root){\\n        if(root == null){\\n            root= new TreeNode(i);\\n            return root;\\n        }\\n        \\n        if(root.val > i){\\n            root.left= createTree(i, root.left);\\n        }\\n        \\n        if(root.val < i){\\n            root.right= createTree(i, root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719623,
                "title": "c-bst-2-methods-easy-to-undersatand-striver-method",
                "content": "```\\n//--------------------------------1ST METHOD-----------------------------------------\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int>inorder=preorder;\\n        sort(inorder.begin(),inorder.end());\\n        map<int,int>m;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            m[inorder[i]]=i;\\n        }\\n        return constructBinaryTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\\n    }\\n    TreeNode* constructBinaryTree(vector<int>& preorder,int preStart,int preEnd,vector<int>& inorder,int inStart,int inEnd,map<int,int>&m)\\n    {\\n        if(preStart>preEnd||inStart>inEnd)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[preStart]);\\n        int inRoot=m[root->val];\\n        int numsleft=inRoot-inStart;\\n        root->left=constructBinaryTree(preorder,preStart+1,preStart+numsleft,inorder,inStart,inRoot-1,m);\\n          root->right=constructBinaryTree(preorder,preStart+numsleft+1,preEnd,inorder,inRoot+1,inEnd,m);\\n        return root;\\n    } \\n};\\n\\n//-------------------------------------2ND METHOD---------------------------------------------\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n   return   construction(preorder,i,INT_MAX);\\n     } \\n    TreeNode* construction(vector<int>& preorder,int &i,int bound) \\n    {\\n        if(i==preorder.size()||preorder[i]>bound)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[i++]);\\n        root->left=construction(preorder,i,root->val);\\n        root->right=construction(preorder,i,bound);\\n        return root;\\n    }\\n};\\n```\\n**if you found this helpful , please do upvote it**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n//--------------------------------1ST METHOD-----------------------------------------\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int>inorder=preorder;\\n        sort(inorder.begin(),inorder.end());\\n        map<int,int>m;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            m[inorder[i]]=i;\\n        }\\n        return constructBinaryTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\\n    }\\n    TreeNode* constructBinaryTree(vector<int>& preorder,int preStart,int preEnd,vector<int>& inorder,int inStart,int inEnd,map<int,int>&m)\\n    {\\n        if(preStart>preEnd||inStart>inEnd)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[preStart]);\\n        int inRoot=m[root->val];\\n        int numsleft=inRoot-inStart;\\n        root->left=constructBinaryTree(preorder,preStart+1,preStart+numsleft,inorder,inStart,inRoot-1,m);\\n          root->right=constructBinaryTree(preorder,preStart+numsleft+1,preEnd,inorder,inRoot+1,inEnd,m);\\n        return root;\\n    } \\n};\\n\\n//-------------------------------------2ND METHOD---------------------------------------------\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n   return   construction(preorder,i,INT_MAX);\\n     } \\n    TreeNode* construction(vector<int>& preorder,int &i,int bound) \\n    {\\n        if(i==preorder.size()||preorder[i]>bound)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[i++]);\\n        root->left=construction(preorder,i,root->val);\\n        root->right=construction(preorder,i,bound);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029567,
                "title": "constant-space-linear-time-easy-to-understand",
                "content": "In binary Search Tree an element can be inserted in left of the node if and only if it is less than it\\'s root\\'s value, and in right if it is greater than.\\n\\nSo, using above property we can maintain upperBound and lowerBound for each element, if element is not in range we can simply return null and backtrack.\\n\\nFirst element of PreOrder of any tree is root we start with -\\u267E\\uFE0Fas lowerBound and\\u267E\\uFE0Fas upperBound.\\nwe will keep on adding element to left till it is out of range,\\nyou can see how lowerbound and upperBound values are getting updated accordingly.\\n```\\nclass Solution {\\n    static int index;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        index = 0;\\n        return bstFromPreorder(preorder,Integer.MAX_VALUE,Integer.MIN_VALUE);\\n    }\\n    public TreeNode bstFromPreorder(int[] preorder,int upperBound,int lowerBound){\\n        \\n        if(index>=preorder.length || preorder[index]>upperBound || preorder[index]<lowerBound) return null;\\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        root.left = bstFromPreorder(preorder,root.val,lowerBound);\\n        root.right = bstFromPreorder(preorder,upperBound,root.val);\\n        return root;\\n            \\n    }\\n}\\n```\\nHappy LeetCoding",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int index;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        index = 0;\\n        return bstFromPreorder(preorder,Integer.MAX_VALUE,Integer.MIN_VALUE);\\n    }\\n    public TreeNode bstFromPreorder(int[] preorder,int upperBound,int lowerBound){\\n        \\n        if(index>=preorder.length || preorder[index]>upperBound || preorder[index]<lowerBound) return null;\\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        root.left = bstFromPreorder(preorder,root.val,lowerBound);\\n        root.right = bstFromPreorder(preorder,upperBound,root.val);\\n        return root;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927284,
                "title": "simple-js-solution-w-comments",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 60 ms, faster than 99.53% of JavaScript online submissions for Construct Binary Search Tree from Preorder Traversal.\\n// Memory Usage: 43.5 MB, less than 23.36% of JavaScript online submissions for Construct Binary Search Tree from Preorder Traversal.\\nconst bstFromPreorder = preorder => {\\n\\tif (!preorder.length) return null;\\n\\n\\tlet idx = 0;\\n\\tconst traverse = (L, R) => {\\n\\t\\t// exhasusted all elements\\n\\t\\tif (idx === preorder.length) return null;\\n\\t\\t\\n\\t\\t// invalid BST\\n\\t\\tif (preorder[idx] < L) return null;\\n\\t\\tif (preorder[idx] > R) return null;\\n\\t\\t\\n\\t\\t// create node\\n\\t\\tconst root = new TreeNode(preorder[idx++]);\\n\\n\\t\\t// add elements to Left then Right\\n\\t\\troot.left = traverse(L, root.val);\\n\\t\\troot.right = traverse(root.val, R);\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\t// set Left and Right boundary\\n\\treturn traverse(-Infinity, Infinity);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 60 ms, faster than 99.53% of JavaScript online submissions for Construct Binary Search Tree from Preorder Traversal.\\n// Memory Usage: 43.5 MB, less than 23.36% of JavaScript online submissions for Construct Binary Search Tree from Preorder Traversal.\\nconst bstFromPreorder = preorder => {\\n\\tif (!preorder.length) return null;\\n\\n\\tlet idx = 0;\\n\\tconst traverse = (L, R) => {\\n\\t\\t// exhasusted all elements\\n\\t\\tif (idx === preorder.length) return null;\\n\\t\\t\\n\\t\\t// invalid BST\\n\\t\\tif (preorder[idx] < L) return null;\\n\\t\\tif (preorder[idx] > R) return null;\\n\\t\\t\\n\\t\\t// create node\\n\\t\\tconst root = new TreeNode(preorder[idx++]);\\n\\n\\t\\t// add elements to Left then Right\\n\\t\\troot.left = traverse(L, root.val);\\n\\t\\troot.right = traverse(root.val, R);\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\t// set Left and Right boundary\\n\\treturn traverse(-Infinity, Infinity);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788572,
                "title": "c-clean-easy-o-n-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* bstFromPreorder(vector<int>& preorder) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\treturn build(preorder,i,INT_MAX);\\n\\t\\t}\\n\\t\\tTreeNode* build(vector<int> &preorder , int &i , int bound){\\n\\t\\t\\tif(i == preorder.size() || preorder[i] > bound)\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\tTreeNode* root = new TreeNode(preorder[i++]);\\n\\t\\t\\troot->left =build(preorder,i,root->val);\\n\\t\\t\\troot->right = build(preorder,i,bound);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\t\\n\\tTC: O(N)\\n\\tSC:O(1)\\n\\n\\tfeel free to ask your doubt :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* bstFromPreorder(vector<int>& preorder) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\treturn build(preorder,i,INT_MAX);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1346507,
                "title": "c-2-solutions-using-inorder-traversal-direct-solution",
                "content": "\\n**1st Solution: Using Inorder Traversal**\\nIn a BST, Inorder traversal is just a sorted array of elements in the BST. Therefore, sorting the Preorder Traversal will give us Inorder Traversal. Now, the problem reduces to finding Binary Tree from Inorder and Preorder Traversals.\\n\\n```\\nclass Solution {\\n    map<int, int> dict;\\npublic:\\n    TreeNode* BTreeFromPreIn(vector<int> &preorder, vector<int> &inorder, int &index, int low, int high){\\n        if(low > high){\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(preorder[index]);\\n        int idx = dict[preorder[index++]];\\n        \\n        root->left = BTreeFromPreIn(preorder, inorder, index, low, idx - 1);\\n        root->right = BTreeFromPreIn(preorder, inorder, index, idx + 1, high);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder(preorder);\\n        sort(inorder.begin(), inorder.end());\\n        int n = inorder.size();\\n        for(int i = 0; i < n; i++){\\n            dict[inorder[i]] = i;\\n        }\\n        int index = 0;\\n        return BTreeFromPreIn(preorder, inorder, index, 0, n - 1);\\n    }\\n};\\n```\\n\\n**2nd Solution: Direct from Preorder Traversal**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorderUtil(vector<int> &preorder, int &i, int bound){\\n        if(i == preorder.size() || preorder[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = bstFromPreorderUtil(preorder, i, root->val);\\n        root->right = bstFromPreorderUtil(preorder, i, bound);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return bstFromPreorderUtil(preorder, i, INT_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    map<int, int> dict;\\npublic:\\n    TreeNode* BTreeFromPreIn(vector<int> &preorder, vector<int> &inorder, int &index, int low, int high){\\n        if(low > high){\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(preorder[index]);\\n        int idx = dict[preorder[index++]];\\n        \\n        root->left = BTreeFromPreIn(preorder, inorder, index, low, idx - 1);\\n        root->right = BTreeFromPreIn(preorder, inorder, index, idx + 1, high);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder(preorder);\\n        sort(inorder.begin(), inorder.end());\\n        int n = inorder.size();\\n        for(int i = 0; i < n; i++){\\n            dict[inorder[i]] = i;\\n        }\\n        int index = 0;\\n        return BTreeFromPreIn(preorder, inorder, index, 0, n - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorderUtil(vector<int> &preorder, int &i, int bound){\\n        if(i == preorder.size() || preorder[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = bstFromPreorderUtil(preorder, i, root->val);\\n        root->right = bstFromPreorderUtil(preorder, i, bound);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return bstFromPreorderUtil(preorder, i, INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343345,
                "title": "simple-c-iterative-approach-for-inserting-element-into-tree-4ms",
                "content": "Before going to read, i just wanna give you hint that the problem is nothing but getting some value from the vector and then insert it into the tree. So first try out yourself & then thank me.\\n**Approach-**\\n\\t\\t1) So as to insert the value into tree there are basic two algo\\'s first one is recursion which is pretty straight forward.\\n\\n```\\nTreeNode* build(TreeNode* root,int val){\\n        if(root==NULL)\\n            root=new TreeNode(val);\\n        else if(val<=root->val)\\n            root->left=build(root->left,val);\\n        else if(val>root->val)\\n            root->right=build(root->right,val);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode *root=NULL;\\n        for(int i=0;i<preorder.size();i++){\\n            root=build(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n```\\n2) following is iterative approach\\n\\n```\\nTreeNode* build(TreeNode* root,int val){\\n        TreeNode *temp = new TreeNode(val);\\n        TreeNode *p=root,*prev=NULL;\\n        while(p!=NULL){\\n            prev=p;\\n            if(val<=p->val) p=p->left;\\n            else if(val>p->val) p=p->right;\\n        }\\n        if(root==NULL)\\n            return temp;\\n        if(prev->val>=val) prev->left=temp;\\n        else prev->right=temp;\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode *root=NULL;\\n        for(int i=0;i<preorder.size();i++){\\n            root=build(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n```\\nIf any doubt, feel free to ask, happy to help !!\\nIf you get value from this, then show some love by upvoting it !!!\\nHappy Coding \\uD83D\\uDE0A\\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nTreeNode* build(TreeNode* root,int val){\\n        if(root==NULL)\\n            root=new TreeNode(val);\\n        else if(val<=root->val)\\n            root->left=build(root->left,val);\\n        else if(val>root->val)\\n            root->right=build(root->right,val);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode *root=NULL;\\n        for(int i=0;i<preorder.size();i++){\\n            root=build(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n```\n```\\nTreeNode* build(TreeNode* root,int val){\\n        TreeNode *temp = new TreeNode(val);\\n        TreeNode *p=root,*prev=NULL;\\n        while(p!=NULL){\\n            prev=p;\\n            if(val<=p->val) p=p->left;\\n            else if(val>p->val) p=p->right;\\n        }\\n        if(root==NULL)\\n            return temp;\\n        if(prev->val>=val) prev->left=temp;\\n        else prev->right=temp;\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode *root=NULL;\\n        for(int i=0;i<preorder.size();i++){\\n            root=build(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1070095,
                "title": "simple-c-solution-recursive",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    TreeNode* solve(vector<int>& vec,int min,int max,int &curr){\\n        if(curr>=vec.size() || vec[curr]<min || vec[curr]>max) return NULL;\\n        int ele=vec[curr++];\\n        TreeNode *newnode=new TreeNode(ele);\\n        newnode->left=solve(vec,min,ele-1,curr);\\n        newnode->right=solve(vec,ele+1,max,curr);\\n        return newnode;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0) return NULL;\\n        int min=1,max=INT_MAX,curr=0;\\n        return solve(preorder,min,max,curr); \\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    TreeNode* solve(vector<int>& vec,int min,int max,int &curr){\\n        if(curr>=vec.size() || vec[curr]<min || vec[curr]>max) return NULL;\\n        int ele=vec[curr++];\\n        TreeNode *newnode=new TreeNode(ele);\\n        newnode->left=solve(vec,min,ele-1,curr);\\n        newnode->right=solve(vec,ele+1,max,curr);\\n        return newnode;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0) return NULL;\\n        int min=1,max=INT_MAX,curr=0;\\n        return solve(preorder,min,max,curr); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019189,
                "title": "fast-and-simple-c",
                "content": "```\\nTreeNode* dfs(vector<int>& preorder,int min,int max,int &i)\\n{\\n\\tif(i==preorder.size())\\n\\t\\treturn NULL;\\n\\tif(preorder[i]<min||preorder[i]>max)\\n\\t\\treturn NULL;\\n\\tTreeNode *root=new TreeNode(preorder[i]);\\n\\ti++;\\n\\troot->left=dfs(preorder,min,root->val-1,i);\\n\\troot->right=dfs(preorder,root->val+1,max,i);\\n\\treturn root;\\n}\\nTreeNode* bstFromPreorder(vector<int>& preorder) {\\n\\tint i=0;\\n\\treturn dfs(preorder,INT_MIN,INT_MAX,i);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* dfs(vector<int>& preorder,int min,int max,int &i)\\n{\\n\\tif(i==preorder.size())\\n\\t\\treturn NULL;\\n\\tif(preorder[i]<min||preorder[i]>max)\\n\\t\\treturn NULL;\\n\\tTreeNode *root=new TreeNode(preorder[i]);\\n\\ti++;\\n\\troot->left=dfs(preorder,min,root->val-1,i);\\n\\troot->right=dfs(preorder,root->val+1,max,i);\\n\\treturn root;\\n}\\nTreeNode* bstFromPreorder(vector<int>& preorder) {\\n\\tint i=0;\\n\\treturn dfs(preorder,INT_MIN,INT_MAX,i);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936907,
                "title": "c-simple-recursive-approach-with-runtime-4-ms-faster-than-88-44-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++){\\n            root=constructBST(root,preorder[i]);\\n        }\\n        cout<<root->val;\\n        return root;\\n    }\\n    TreeNode* constructBST(TreeNode* root,int val){\\n        if(root==NULL){\\n            \\n            return new TreeNode(val);\\n        }\\n        if(val<root->val)\\n            root->left=constructBST(root->left,val); \\n        if(val>root->val)\\n            root->right=constructBST(root->right,val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++){\\n            root=constructBST(root,preorder[i]);\\n        }\\n        cout<<root->val;\\n        return root;\\n    }\\n    TreeNode* constructBST(TreeNode* root,int val){\\n        if(root==NULL){\\n            \\n            return new TreeNode(val);\\n        }\\n        if(val<root->val)\\n            root->left=constructBST(root->left,val); \\n        if(val>root->val)\\n            root->right=constructBST(root->right,val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 791434,
                "title": "c-recursive-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0){\\n            return NULL;\\n        }\\n        int x=preorder[0];\\n        TreeNode* t=new TreeNode(x);\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]<x){\\n                left.push_back(preorder[i]);\\n            }\\n            else{\\n                right.push_back(preorder[i]);\\n            }\\n        }\\n        t->left=bstFromPreorder(left);\\n        t->right=bstFromPreorder(right);\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0){\\n            return NULL;\\n        }\\n        int x=preorder[0];\\n        TreeNode* t=new TreeNode(x);\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]<x){\\n                left.push_back(preorder[i]);\\n            }\\n            else{\\n                right.push_back(preorder[i]);\\n            }\\n        }\\n        t->left=bstFromPreorder(left);\\n        t->right=bstFromPreorder(right);\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756555,
                "title": "easy-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* func(vector<int>& arr, int min, int max)\\n    {\\n        if (arr.size() == 0)\\n            return nullptr;\\n        TreeNode* root = nullptr;\\n        if (arr.front() > min && arr.front() < max)\\n        {\\n            root = new TreeNode(arr.front());\\n            arr.erase(arr.begin());\\n            root->left = func(arr,min,root->val);\\n            root->right = func(arr,root->val,max);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& arr) \\n    {\\n        if (arr.size() == 0)\\n            return nullptr;\\n        return func(arr, INT_MIN, INT_MAX);      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* func(vector<int>& arr, int min, int max)\\n    {\\n        if (arr.size() == 0)\\n            return nullptr;\\n        TreeNode* root = nullptr;\\n        if (arr.front() > min && arr.front() < max)\\n        {\\n            root = new TreeNode(arr.front());\\n            arr.erase(arr.begin());\\n            root->left = func(arr,min,root->val);\\n            root->right = func(arr,root->val,max);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& arr) \\n    {\\n        if (arr.size() == 0)\\n            return nullptr;\\n        return func(arr, INT_MIN, INT_MAX);      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679856,
                "title": "javascript-recursion-clean-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    if(!preorder.length)return null\\n    let node = new TreeNode(preorder[0])\\n    node.left = bstFromPreorder(preorder.filter(el=>el<preorder[0]))\\n    node.right = bstFromPreorder(preorder.filter(el=>el>preorder[0]))\\n    return node\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    if(!preorder.length)return null\\n    let node = new TreeNode(preorder[0])\\n    node.left = bstFromPreorder(preorder.filter(el=>el<preorder[0]))\\n    node.right = bstFromPreorder(preorder.filter(el=>el>preorder[0]))\\n    return node\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615494,
                "title": "java-0ms-runtime-recursive",
                "content": "According to the question we know that the input array is actually given to us in preorder.  Therefore, we only need to convert the input array into a Tree.  \\n\\n\\n\\n```\\npublic TreeNode bstFromPreorder(int[] preorder) {\\n\\t\\t// index 0 is always root because input array is given in preorder\\n        TreeNode root = new TreeNode(preorder[0]); \\n        for (int i = 1; i < preorder.length; i++) { \\n            build(root, preorder[i]); \\n        }\\n        \\n        return root;\\n    }\\n    \\n    private TreeNode build(TreeNode root, int n) {\\n        if (root == null) { // when root is null we have found a spot to place n\\n            return new TreeNode(n);\\n        }\\n        \\n        if (root.val < n) {\\n           root.right = build(root.right, n);\\n        } else if (root.val > n) {\\n           root.left = build(root.left, n);\\n        }\\n        \\n        return root;\\n    }\\n",
                "solutionTags": [],
                "code": "According to the question we know that the input array is actually given to us in preorder.  Therefore, we only need to convert the input array into a Tree.  \\n\\n\\n\\n```\\npublic TreeNode bstFromPreorder(int[] preorder) {\\n\\t\\t// index 0 is always root because input array is given in preorder\\n        TreeNode root = new TreeNode(preorder[0]); \\n        for (int i = 1; i < preorder.length; i++) { \\n            build(root, preorder[i]); \\n        }\\n        \\n        return root;\\n    }\\n    \\n    private TreeNode build(TreeNode root, int n) {\\n        if (root == null) { // when root is null we have found a spot to place n\\n            return new TreeNode(n);\\n        }\\n        \\n        if (root.val < n) {\\n           root.right = build(root.right, n);\\n        } else if (root.val > n) {\\n           root.left = build(root.left, n);\\n        }\\n        \\n        return root;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 605869,
                "title": "c-iterative-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if (preorder.empty()) {\\n            return nullptr;\\n        }\\n        \\n        TreeNode* head = new TreeNode(preorder[0]);\\n        stack<TreeNode*> larger({head});\\n        for (int i = 1; i < preorder.size(); i++) {\\n            TreeNode* curNode = new TreeNode(preorder[i]);\\n            if (preorder[i] < larger.top()->val) {\\n                larger.top()->left = curNode;\\n                larger.push(curNode);\\n                continue;\\n            }\\n            \\n            TreeNode* lastPopped;\\n            while (!larger.empty() && larger.top()->val < preorder[i]) {\\n                lastPopped = larger.top();\\n                larger.pop();\\n            }\\n            \\n            lastPopped->right = curNode;\\n            larger.push(curNode);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if (preorder.empty()) {\\n            return nullptr;\\n        }\\n        \\n        TreeNode* head = new TreeNode(preorder[0]);\\n        stack<TreeNode*> larger({head});\\n        for (int i = 1; i < preorder.size(); i++) {\\n            TreeNode* curNode = new TreeNode(preorder[i]);\\n            if (preorder[i] < larger.top()->val) {\\n                larger.top()->left = curNode;\\n                larger.push(curNode);\\n                continue;\\n            }\\n            \\n            TreeNode* lastPopped;\\n            while (!larger.empty() && larger.top()->val < preorder[i]) {\\n                lastPopped = larger.top();\\n                larger.pop();\\n            }\\n            \\n            lastPopped->right = curNode;\\n            larger.push(curNode);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589269,
                "title": "c-shortest-and-fastest-solution",
                "content": "```\\nint i = 0;\\npublic TreeNode BstFromPreorder(int[] preorder, int max = int.MaxValue) {\\n    if (i >= preorder.Length || preorder[i] > max) return null;\\n    var val = preorder[i++];\\n    return new TreeNode(val) { left = BstFromPreorder(preorder, val), right = BstFromPreorder(preorder, max) };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint i = 0;\\npublic TreeNode BstFromPreorder(int[] preorder, int max = int.MaxValue) {\\n    if (i >= preorder.Length || preorder[i] > max) return null;\\n    var val = preorder[i++];\\n    return new TreeNode(val) { left = BstFromPreorder(preorder, val), right = BstFromPreorder(preorder, max) };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 589056,
                "title": "rust-recursive-solution",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn bst_from_preorder(preorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        Solution::helper(&preorder)\\n    }\\n    fn helper(v: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(first) = v.first() {\\n            let node = Rc::new(RefCell::new(TreeNode::new(*first)));\\n            let i = (1..v.len())\\n                .find(|&i| v[i] > v[0])\\n                .unwrap_or_else(|| v.len());\\n            node.borrow_mut().left = Solution::helper(&v[1..i]);\\n            node.borrow_mut().right = Solution::helper(&v[i..]);\\n            Some(node)\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn bst_from_preorder(preorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        Solution::helper(&preorder)\\n    }\\n    fn helper(v: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(first) = v.first() {\\n            let node = Rc::new(RefCell::new(TreeNode::new(*first)));\\n            let i = (1..v.len())\\n                .find(|&i| v[i] > v[0])\\n                .unwrap_or_else(|| v.len());\\n            node.borrow_mut().left = Solution::helper(&v[1..i]);\\n            node.borrow_mut().right = Solution::helper(&v[i..]);\\n            Some(node)\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392467,
                "title": "java-recursive-beats-100",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return buildTree(preorder, 0, preorder.length - 1);\\n    }\\n    \\n    private TreeNode buildTree(int[] preorder, int start, int end) {\\n        if (start > end) return null;\\n        TreeNode root = new TreeNode(preorder[start]);\\n        if (start == end) {\\n            return root;\\n        }\\n        int i = start;\\n        while (i <= end) {\\n            if (preorder[i] > root.val) break;\\n            i++;\\n        }\\n        root.left = buildTree(preorder, start + 1, i - 1);\\n        root.right = buildTree(preorder, i, end);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return buildTree(preorder, 0, preorder.length - 1);\\n    }\\n    \\n    private TreeNode buildTree(int[] preorder, int start, int end) {\\n        if (start > end) return null;\\n        TreeNode root = new TreeNode(preorder[start]);\\n        if (start == end) {\\n            return root;\\n        }\\n        int i = start;\\n        while (i <= end) {\\n            if (preorder[i] > root.val) break;\\n            i++;\\n        }\\n        root.left = buildTree(preorder, start + 1, i - 1);\\n        root.right = buildTree(preorder, i, end);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348372,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        def build(node, value):\\n            if not node: return TreeNode(value)\\n            if value < node.val: node.left = build(node.left, value)\\n            else: node.right = build(node.right, value)\\n            return node\\n        \\n        root = None\\n        for value in preorder:\\n            root = build(root, value)\\n            \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        def build(node, value):\\n            if not node: return TreeNode(value)\\n            if value < node.val: node.left = build(node.left, value)\\n            else: node.right = build(node.right, value)\\n            return node\\n        \\n        root = None\\n        for value in preorder:\\n            root = build(root, value)\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303683,
                "title": "simple-recursive-java-solution-that-beats-100-runtime-and-memory",
                "content": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    int index = 0;\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return getPreOrderNode(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    public TreeNode getPreOrderNode(int[] preorder, int min, int max) {\\n        if(index >= preorder.length) {\\n            return null;\\n        }\\n        \\n        if(preorder[index] < min || preorder[index] > max) {\\n            return null;\\n        }\\n        \\n        int val = preorder[index];\\n        TreeNode node = new TreeNode(val);\\n        \\n        index++;\\n        \\n        node.left = getPreOrderNode(preorder, min, val);\\n        node.right = getPreOrderNode(preorder, val, max);\\n        \\n        return node;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int index = 0;\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return getPreOrderNode(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 286165,
                "title": "fast-c-solution",
                "content": "Iterate through the given array and build the tree. In each iteration, traverse the tree starting from the root node to find a spot to insert the new node. There will not be any need to move any nodes later since the input is ordered.\\n\\n```\\nclass Solution {\\nprivate: \\n    void addToTree(TreeNode* r, TreeNode* n){\\n        if(n->val > r->val){\\n            if(!r->right) r->right = n;\\n            else addToTree(r->right, n);\\n        }\\n        else{\\n            if(!r->left) r->left = n;\\n            else addToTree(r->left, n);\\n        }\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(!preorder.size()) return NULL;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        for(int i=1; i<preorder.size(); i++)\\n            addToTree(root, new TreeNode(preorder[i]));\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate: \\n    void addToTree(TreeNode* r, TreeNode* n){\\n        if(n->val > r->val){\\n            if(!r->right) r->right = n;\\n            else addToTree(r->right, n);\\n        }\\n        else{\\n            if(!r->left) r->left = n;\\n            else addToTree(r->left, n);\\n        }\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(!preorder.size()) return NULL;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        for(int i=1; i<preorder.size(); i++)\\n            addToTree(root, new TreeNode(preorder[i]));\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273753,
                "title": "java-binary-search",
                "content": "```java\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return build(preorder, 0, preorder.length - 1);\\n    }\\n\\n    private TreeNode build(int[] preorder, int i, int j) {\\n        if (i > j) {\\n            return null;\\n        }\\n\\n        TreeNode node = new TreeNode(preorder[i]);\\n        int firstLarger =  firstLarger(preorder, i + 1, preorder.length - 1, preorder[i]);\\n        \\n        node.left = build(preorder, i + 1, firstLarger - 1);\\n        node.right = build(preorder, firstLarger, j);\\n        return node;\\n    }\\n\\n    private int firstLarger(int[] preorder, int start, int end, int target) {\\n        int i = start; // [start ... i-1] contains x < target\\n        int j = end; // [j+1 ... end] contains x > target\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (preorder[mid] > target) {\\n                j = mid - 1;\\n            } else {\\n                i = mid + 1;\\n            }\\n        }\\n        return j + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return build(preorder, 0, preorder.length - 1);\\n    }\\n\\n    private TreeNode build(int[] preorder, int i, int j) {\\n        if (i > j) {\\n            return null;\\n        }\\n\\n        TreeNode node = new TreeNode(preorder[i]);\\n        int firstLarger =  firstLarger(preorder, i + 1, preorder.length - 1, preorder[i]);\\n        \\n        node.left = build(preorder, i + 1, firstLarger - 1);\\n        node.right = build(preorder, firstLarger, j);\\n        return node;\\n    }\\n\\n    private int firstLarger(int[] preorder, int start, int end, int target) {\\n        int i = start; // [start ... i-1] contains x < target\\n        int j = end; // [j+1 ... end] contains x > target\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (preorder[mid] > target) {\\n                j = mid - 1;\\n            } else {\\n                i = mid + 1;\\n            }\\n        }\\n        return j + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256384,
                "title": "easy-javascript-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    let bst=null;\\n    for(let node of preorder)\\n        bst=addToBst(bst,node);\\n    return bst;  \\n};\\nfunction addToBst(bst,val){\\n    if(bst==null)\\n        return new TreeNode(val);        \\n    if(val<bst.val)\\n        bst.left=addToBst(bst.left,val);        \\n    else\\n        bst.right=addToBst(bst.right,val);\\n    return bst;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    let bst=null;\\n    for(let node of preorder)\\n        bst=addToBst(bst,node);\\n    return bst;  \\n};\\nfunction addToBst(bst,val){\\n    if(bst==null)\\n        return new TreeNode(val);        \\n    if(val<bst.val)\\n        bst.left=addToBst(bst.left,val);        \\n    else\\n        bst.right=addToBst(bst.right,val);\\n    return bst;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252566,
                "title": "python-iterative-o-n-time-using-stack",
                "content": "Keep a stack of node of decreasing value order. When met a bigger num than stack.peek(), we travel back along the stack and find its parent. It\\'s kinda similar to `255. Verify Preorder Sequence in Binary Search Tree`.\\n\\n\\tdef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        root = TreeNode(preorder[0])  # maybe cope with None input.\\n        stack = [root]\\n        for num in preorder[1:]:\\n            new_node = TreeNode(num)\\n            if num < stack[-1].val:\\n                stack[-1].left = new_node\\n            else:\\n                parent = None\\n                while stack and num > stack[-1].val:\\n                    parent = stack.pop()\\n                parent.right = new_node\\n            stack.append(new_node)\\n        return root",
                "solutionTags": [],
                "code": "Keep a stack of node of decreasing value order. When met a bigger num than stack.peek(), we travel back along the stack and find its parent. It\\'s kinda similar to `255. Verify Preorder Sequence in Binary Search Tree`.\\n\\n\\tdef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        root = TreeNode(preorder[0])  # maybe cope with None input.\\n        stack = [root]\\n        for num in preorder[1:]:\\n            new_node = TreeNode(num)\\n            if num < stack[-1].val:\\n                stack[-1].left = new_node\\n            else:\\n                parent = None\\n                while stack and num > stack[-1].val:\\n                    parent = stack.pop()\\n                parent.right = new_node\\n            stack.append(new_node)\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 252269,
                "title": "python-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not preorder:\\n            return None\\n        \\n        first = preorder.pop(0)\\n        node = TreeNode(first)\\n        \\n        i = 0\\n        n = len(preorder)\\n        while i < n and preorder[i] < first:\\n            i += 1\\n            \\n        node.left = self.bstFromPreorder(preorder[:i])\\n        node.right = self.bstFromPreorder(preorder[i:])\\n        \\n        return node\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not preorder:\\n            return None\\n        \\n        first = preorder.pop(0)\\n        node = TreeNode(first)\\n        \\n        i = 0\\n        n = len(preorder)\\n        while i < n and preorder[i] < first:\\n            i += 1\\n            \\n        node.left = self.bstFromPreorder(preorder[:i])\\n        node.right = self.bstFromPreorder(preorder[i:])\\n        \\n        return node\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 252236,
                "title": "a-few-solutions",
                "content": "Not very efficient, but straightforward and sufficient to build the max 100 node tree by inserting each value `x` of `A` into the tree by iteratively starting at the `root`, and recursively inserting the value into the proper tree node position.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun bstFromPreorder(A: IntArray): TreeNode? {\\n        fun go(root: TreeNode?, x: Int) {\\n            if (x < root?.`val`!!) {\\n                if (root?.left != null)\\n                    go(root?.left, x)\\n                else\\n                    root?.left = TreeNode(x)\\n            } else {\\n                if (root?.right != null)\\n                    go(root?.right, x)\\n                else\\n                    root?.right = TreeNode(x)\\n            }\\n        }\\n        var root = TreeNode(A[0])\\n        for (x in A.slice(1 until A.size))\\n            go(root, x)\\n        return root\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet bstFromPreorder = A => {\\n    let go = (root, x) => {\\n        if (x < root.val) {\\n            if (root.left)\\n                go(root.left, x);\\n            else\\n                root.left = new TreeNode(x);\\n        } else {\\n            if (root.right)\\n                go(root.right, x);\\n            else\\n                root.right = new TreeNode(x);\\n        }\\n    };\\n    let root = new TreeNode(A[0]);\\n    for (let x of A.slice(1))\\n        go(root, x);\\n    return root;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def bstFromPreorder(self, A: List[int]) -> Optional[TreeNode]:\\n        def go(node, x):\\n            if x < node.val:\\n                if node.left:\\n                    go(node.left, x)\\n                else:\\n                    node.left = TreeNode(x)\\n            else:\\n                if node.right:\\n                    go(node.right, x)\\n                else:\\n                    node.right = TreeNode(x)\\n        root = TreeNode(A[0])\\n        for x in A[1:]:\\n            go(root, x)\\n        return root\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<void(TreeNode*, int)>;\\n    TreeNode* bstFromPreorder(VI& A) {\\n        fun go = [&](auto root, auto x) {\\n            if (x < root->val) {\\n                if (root->left)\\n                    go(root->left, x);\\n                else\\n                    root->left = new TreeNode(x);\\n            } else {\\n                if (root->right)\\n                    go(root->right, x);\\n                else\\n                    root->right = new TreeNode(x);\\n            }\\n        };\\n        auto root = new TreeNode(A[0]);\\n        for (auto x: VI{ A.begin() + 1, A.end() })\\n            go(root, x);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun bstFromPreorder(A: IntArray): TreeNode? {\\n        fun go(root: TreeNode?, x: Int) {\\n            if (x < root?.`val`!!) {\\n                if (root?.left != null)\\n                    go(root?.left, x)\\n                else\\n                    root?.left = TreeNode(x)\\n            } else {\\n                if (root?.right != null)\\n                    go(root?.right, x)\\n                else\\n                    root?.right = TreeNode(x)\\n            }\\n        }\\n        var root = TreeNode(A[0])\\n        for (x in A.slice(1 until A.size))\\n            go(root, x)\\n        return root\\n    }\\n}\\n```\n```\\nlet bstFromPreorder = A => {\\n    let go = (root, x) => {\\n        if (x < root.val) {\\n            if (root.left)\\n                go(root.left, x);\\n            else\\n                root.left = new TreeNode(x);\\n        } else {\\n            if (root.right)\\n                go(root.right, x);\\n            else\\n                root.right = new TreeNode(x);\\n        }\\n    };\\n    let root = new TreeNode(A[0]);\\n    for (let x of A.slice(1))\\n        go(root, x);\\n    return root;\\n};\\n```\n```\\nclass Solution:\\n    def bstFromPreorder(self, A: List[int]) -> Optional[TreeNode]:\\n        def go(node, x):\\n            if x < node.val:\\n                if node.left:\\n                    go(node.left, x)\\n                else:\\n                    node.left = TreeNode(x)\\n            else:\\n                if node.right:\\n                    go(node.right, x)\\n                else:\\n                    node.right = TreeNode(x)\\n        root = TreeNode(A[0])\\n        for x in A[1:]:\\n            go(root, x)\\n        return root\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<void(TreeNode*, int)>;\\n    TreeNode* bstFromPreorder(VI& A) {\\n        fun go = [&](auto root, auto x) {\\n            if (x < root->val) {\\n                if (root->left)\\n                    go(root->left, x);\\n                else\\n                    root->left = new TreeNode(x);\\n            } else {\\n                if (root->right)\\n                    go(root->right, x);\\n                else\\n                    root->right = new TreeNode(x);\\n            }\\n        };\\n        auto root = new TreeNode(A[0]);\\n        for (auto x: VI{ A.begin() + 1, A.end() })\\n            go(root, x);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978619,
                "title": "3-best-c-solutions-using-int-max-recursive-and-iterative-approach-beast-100",
                "content": "# Code\\n```\\n// Solution 1 - Using max bound\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int i = 0;\\n        return build(pre, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& pre, int& i, int bound) {\\n        if (i == pre.size() || pre[i] > bound) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[i++]);\\n        root->left = build(pre, i, root->val);\\n        root->right = build(pre, i, bound);\\n        \\n        return root;\\n    }\\n};\\n\\n// Solution 2 - Recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[0]);\\n        if(preorder.size() == 1)\\n            return root;\\n        \\n        vector<int> left, right;\\n        for(int i=0; i<preorder.size(); i++){\\n            if(preorder[i] > preorder[0])\\n                right.push_back(preorder[i]);\\n            else if(preorder[i]<preorder[0])\\n                left.push_back(preorder[i]);\\n        }\\n\\n        root->left = bstFromPreorder(left);\\n        root->right = bstFromPreorder(right);\\n        \\n        return root;\\n    }\\n};\\n\\n// Solution 3 - Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[0]);\\n\\n        for(int i=1; i<preorder.size(); i++){ \\n            bool done = false; \\n            TreeNode* curr = root;\\n\\n            while(done == false){\\n                if(preorder[i] < curr->val){  \\n                    if (curr->left == NULL){ \\n                        curr->left = new TreeNode(preorder[i]);\\n                        done = true;    \\n                    }\\n                    else \\n                        curr = curr->left;\\n                }\\n                else{  \\n                    if(curr->right == NULL){ \\n                        curr->right = new TreeNode(preorder[i]);\\n                        done = true; \\n                    }\\n                    else\\n                        curr = curr->right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Tree",
                    "Binary Search Tree",
                    "Monotonic Stack",
                    "Binary Tree"
                ],
                "code": "```\\n// Solution 1 - Using max bound\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int i = 0;\\n        return build(pre, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& pre, int& i, int bound) {\\n        if (i == pre.size() || pre[i] > bound) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[i++]);\\n        root->left = build(pre, i, root->val);\\n        root->right = build(pre, i, bound);\\n        \\n        return root;\\n    }\\n};\\n\\n// Solution 2 - Recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[0]);\\n        if(preorder.size() == 1)\\n            return root;\\n        \\n        vector<int> left, right;\\n        for(int i=0; i<preorder.size(); i++){\\n            if(preorder[i] > preorder[0])\\n                right.push_back(preorder[i]);\\n            else if(preorder[i]<preorder[0])\\n                left.push_back(preorder[i]);\\n        }\\n\\n        root->left = bstFromPreorder(left);\\n        root->right = bstFromPreorder(right);\\n        \\n        return root;\\n    }\\n};\\n\\n// Solution 3 - Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[0]);\\n\\n        for(int i=1; i<preorder.size(); i++){ \\n            bool done = false; \\n            TreeNode* curr = root;\\n\\n            while(done == false){\\n                if(preorder[i] < curr->val){  \\n                    if (curr->left == NULL){ \\n                        curr->left = new TreeNode(preorder[i]);\\n                        done = true;    \\n                    }\\n                    else \\n                        curr = curr->left;\\n                }\\n                else{  \\n                    if(curr->right == NULL){ \\n                        curr->right = new TreeNode(preorder[i]);\\n                        done = true; \\n                    }\\n                    else\\n                        curr = curr->right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659327,
                "title": "c-simple-and-crisp-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int idx=0;\\n        return construct(idx,INT_MAX,pre);\\n    }\\n    TreeNode* construct(int &idx, int bound, vector<int> &pre){\\n        if(idx==pre.size()||pre[idx]>bound) return NULL;\\n        TreeNode* root=new TreeNode(pre[idx]);\\n        idx++;\\n        root->left=construct(idx,root->val,pre);\\n        root->right=construct(idx,bound,pre);\\n        return root;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int idx=0;\\n        return construct(idx,INT_MAX,pre);\\n    }\\n    TreeNode* construct(int &idx, int bound, vector<int> &pre){\\n        if(idx==pre.size()||pre[idx]>bound) return NULL;\\n        TreeNode* root=new TreeNode(pre[idx]);\\n        idx++;\\n        root->left=construct(idx,root->val,pre);\\n        root->right=construct(idx,bound,pre);\\n        return root;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610700,
                "title": "c-solution-using-0-n-complexity-using-only-preorder",
                "content": "\\n\\t class Solution {\\n\\t \\n        public:\\n\\t\\t\\n     TreeNode* solve(vector<int> &preorder , long mini , long maxi , int &i){\\n\\t\\n        if(i>=preorder.size()){\\n            return NULL ; \\n        }\\n        if(preorder[i] < mini || preorder[i] > maxi ){\\n            return NULL ;\\n        }\\n        TreeNode* newnode = new TreeNode(preorder[i++]);\\n        newnode->left = solve(preorder,mini,newnode->val,i);\\n        newnode->right = solve(preorder,newnode->val,maxi,i);\\n        return newnode ; \\n    }\\n    \\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        long mini = LONG_MIN;\\n        long maxi  = LONG_MAX ;\\n        return solve(preorder,mini,maxi,i);\\n\\t\\t\\n    }  };",
                "solutionTags": [],
                "code": "class Solution {\\n\\t \\n        public:\\n\\t\\t\\n     TreeNode* solve(vector<int> &preorder , long mini , long maxi , int &i){\\n\\t\\n        if(i>=preorder.size()){\\n            return NULL ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3610688,
                "title": "solution-c-nlogn-using-inorder-traversal",
                "content": "\\n        class Solution {\\n\\n       public:\\n   \\n    int posi(vector<int>& inorder , int element , int size){\\n\\t\\n        for(int i=0; i<size ; i++){\\n            if(inorder[i]==element){\\n                return i;\\n            }\\n        }\\n        return -1 ;\\n    }\\n    TreeNode* solve(vector<int> preorder,vector<int> &inorder,int &preorderindex,int inorderstart,int inorderend, int size ){\\n        if(preorderindex>=size || inorderstart>inorderend){\\n              return NULL ;\\n        }\\n        int element = preorder[preorderindex++];\\n        TreeNode* root = new TreeNode(element);\\n        int position = posi(inorder, element , size);\\n    root->left = solve(preorder,inorder,preorderindex,inorderstart,position-1,size);\\n     root->right = solve(preorder,inorder,preorderindex,position+1,inorderend,size);\\n        return root ; \\n        \\n    }\\n    \\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder = preorder ;\\n        sort(inorder.begin(),inorder.end());\\n        \\n        int preorderindex = 0 ; \\n        int inorderstart = 0 ; \\n        int inorderend = inorder.size()-1 ; \\n        int size = inorder.size();\\n        \\n     TreeNode* node=solve(preorder,inorder,preorderindex,inorderstart,inorderend,size);\\n         return node ; \\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n\\n       public:\\n   \\n    int posi(vector<int>& inorder , int element , int size){\\n\\t\\n        for(int i=0; i<size ; i++){\\n            if(inorder[i]==element){\\n                return i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3608510,
                "title": "python-easy-recursive-solution",
                "content": "```\\ndef bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        i=[0]\\n        def construct(preorder,i,bound):\\n            if i[0]==len(preorder) or preorder[i[0]]>bound:\\n                return None\\n            root=TreeNode(preorder[i[0]])\\n            i[0]+=1\\n            root.left=construct(preorder,i,root.val)\\n            root.right=construct(preorder,i,bound)\\n            return root                           \\n        return construct(preorder,i,float(\\'inf\\'))\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\ndef bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        i=[0]\\n        def construct(preorder,i,bound):\\n            if i[0]==len(preorder) or preorder[i[0]]>bound:\\n                return None\\n            root=TreeNode(preorder[i[0]])\\n            i[0]+=1\\n            root.left=construct(preorder,i,root.val)\\n            root.right=construct(preorder,i,bound)\\n            return root                           \\n        return construct(preorder,i,float(\\'inf\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3603424,
                "title": "c-optimal-approach",
                "content": "# Complexity\\n- Time complexity: $$O(3n)$$ = $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + h)$$ = $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    TreeNode* solve(vector<int> &preorder, int maxi, int &i) {\\n        // base case - 1\\n        if(i >= preorder.size())\\n            return NULL;\\n        \\n        // base case - 2\\n        if(preorder[i] > maxi) // = ki jaroorat nhi hai, as All the values of preorder are unique\\n            return NULL;\\n\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n\\n        // left aur right ke liye call kardo\\n        root->left = solve(preorder, root->val, i);\\n        root->right = solve(preorder, maxi, i);\\n\\n        // root ko return kardo\\n        return root;\\n    }\\n\\n    public:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return solve(preorder, INT_MAX, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode* solve(vector<int> &preorder, int maxi, int &i) {\\n        // base case - 1\\n        if(i >= preorder.size())\\n            return NULL;\\n        \\n        // base case - 2\\n        if(preorder[i] > maxi) // = ki jaroorat nhi hai, as All the values of preorder are unique\\n            return NULL;\\n\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n\\n        // left aur right ke liye call kardo\\n        root->left = solve(preorder, root->val, i);\\n        root->right = solve(preorder, maxi, i);\\n\\n        // root ko return kardo\\n        return root;\\n    }\\n\\n    public:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return solve(preorder, INT_MAX, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580003,
                "title": "python3-solution-recursive-approach-range-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck every node if it falls between max-min\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        counter = 0\\n        def buildTree(nums,upper_bound):\\n            nonlocal counter\\n            if counter == len(nums) or nums[counter] > upper_bound:\\n                return None\\n            node = TreeNode(nums[counter])\\n            counter+=1\\n            node.left = buildTree(nums,node.val)\\n            node.right = buildTree(nums,upper_bound)\\n            return node\\n        return buildTree(preorder,float(\\'inf\\'))\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        counter = 0\\n        def buildTree(nums,upper_bound):\\n            nonlocal counter\\n            if counter == len(nums) or nums[counter] > upper_bound:\\n                return None\\n            node = TreeNode(nums[counter])\\n            counter+=1\\n            node.left = buildTree(nums,node.val)\\n            node.right = buildTree(nums,upper_bound)\\n            return node\\n        return buildTree(preorder,float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550932,
                "title": "c-recursion-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return buildpre(preorder, 0,preorder.size()-1);\\n    }\\n\\n    TreeNode* buildpre(vector<int>& preorder, int ps, int pe)\\n    { int pos;\\n        if(ps>pe) return NULL;\\n        TreeNode* node= new TreeNode(preorder[ps]);\\n        for(int i=ps+1;i<=pe;i++)\\n        {\\n            if(preorder[i]>preorder[ps]) \\n                {pos=i;\\n                break;\\n                }\\n                \\n        }\\n        node->left=buildpre(preorder,ps+1 ,pos-1 );\\n        node->right=buildpre(preorder,pos ,pe );\\n        return node;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return buildpre(preorder, 0,preorder.size()-1);\\n    }\\n\\n    TreeNode* buildpre(vector<int>& preorder, int ps, int pe)\\n    { int pos;\\n        if(ps>pe) return NULL;\\n        TreeNode* node= new TreeNode(preorder[ps]);\\n        for(int i=ps+1;i<=pe;i++)\\n        {\\n            if(preorder[i]>preorder[ps]) \\n                {pos=i;\\n                break;\\n                }\\n                \\n        }\\n        node->left=buildpre(preorder,ps+1 ,pos-1 );\\n        node->right=buildpre(preorder,pos ,pe );\\n        return node;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544053,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void BST(TreeNode* root,int x){\\n        while(1){\\n            if(root->val<x){\\n                if(root->right==NULL){\\n                    TreeNode* new_node=new TreeNode(x);\\n                    root->right=new_node;\\n                    return;\\n                }\\n                else{\\n                    root=root->right;\\n                }\\n            }\\n            else{\\n                if(root->left==NULL){\\n                    TreeNode* new_node=new TreeNode(x);\\n                    root->left=new_node;\\n                    return;\\n                }\\n                else{\\n                    root=root->left;\\n                }\\n            }\\n        }\\n    }\\n    TreeNode* bstFromPreorder(vector<int> &preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        int n=preorder.size();\\n        for(int i=1;i<n;i++){\\n            BST(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    preorder_index = 0\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        for index, val in enumerate(preorder):\\n            if index == 0:\\n                continue\\n\\n            self.insert(root, val)\\n        return root\\n\\n    def insert(self, root, val):\\n        curr = root\\n        while curr:\\n            if curr.val > val:\\n                if curr.left is None:\\n                    curr.left = TreeNode(val)\\n                    break\\n                curr = curr.left\\n            if curr.val < val :\\n                if curr.right is None:\\n                    curr.right = TreeNode(val)\\n                    break\\n                curr = curr.right\\n```\\n\\n```Java []\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n     return helper(preorder, 0, preorder.length - 1);   \\n    }\\n    private TreeNode helper(int[] preorder, int start, int end) {\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[start]);\\n        int i;\\n        for(i=start;i<=end;i++) {\\n        if(preorder[i] > node.val)\\n            break;\\n        }\\n        node.left = helper(preorder, start+1, i-1);\\n        node.right = helper(preorder, i, end);\\n        return node;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void BST(TreeNode* root,int x){\\n        while(1){\\n            if(root->val<x){\\n                if(root->right==NULL){\\n                    TreeNode* new_node=new TreeNode(x);\\n                    root->right=new_node;\\n                    return;\\n                }\\n                else{\\n                    root=root->right;\\n                }\\n            }\\n            else{\\n                if(root->left==NULL){\\n                    TreeNode* new_node=new TreeNode(x);\\n                    root->left=new_node;\\n                    return;\\n                }\\n                else{\\n                    root=root->left;\\n                }\\n            }\\n        }\\n    }\\n    TreeNode* bstFromPreorder(vector<int> &preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        int n=preorder.size();\\n        for(int i=1;i<n;i++){\\n            BST(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    preorder_index = 0\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        for index, val in enumerate(preorder):\\n            if index == 0:\\n                continue\\n\\n            self.insert(root, val)\\n        return root\\n\\n    def insert(self, root, val):\\n        curr = root\\n        while curr:\\n            if curr.val > val:\\n                if curr.left is None:\\n                    curr.left = TreeNode(val)\\n                    break\\n                curr = curr.left\\n            if curr.val < val :\\n                if curr.right is None:\\n                    curr.right = TreeNode(val)\\n                    break\\n                curr = curr.right\\n```\n```Java []\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n     return helper(preorder, 0, preorder.length - 1);   \\n    }\\n    private TreeNode helper(int[] preorder, int start, int end) {\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[start]);\\n        int i;\\n        for(i=start;i<=end;i++) {\\n        if(preorder[i] > node.val)\\n            break;\\n        }\\n        node.left = helper(preorder, start+1, i-1);\\n        node.right = helper(preorder, i, end);\\n        return node;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541746,
                "title": "easy-cpp-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution\\n{\\npublic:\\n   \\n    TreeNode *solve(vector<int> &preorder, int start, int end){\\n        if (start > end) return NULL; // BASE CASE\\n     \\n        if (start == end){    // IF ONLY ONE NODE \\n            TreeNode *root = new TreeNode(preorder[start]);\\n            return root;\\n        }\\n\\n        // CREATE ROOT NODE \\n        TreeNode *root = new TreeNode(preorder[start]);\\n\\n        int left_indx = -1, right_indx = end+1,value = preorder[start] ;\\n         \\n         // SPLIT THE ARRAY INTO TWO PART \\n        // FIND GREATEST NODE && LOWEST NODE FROM THE ROOT NODE   \\n \\n        for(int i = start; i <= end; i++){\\n          if (preorder[i] > value && right_indx == end+1) right_indx = i;\\n          else if (preorder[i] < value && left_indx == -1) left_indx = i;\\n        }\\n\\n       // IF WE HAVE LOWEST NODE FROM THE ROOT NODE THEN SOLVE LEFT PART\\n        if (left_indx != -1) root->left = solve(preorder, left_indx, right_indx-1); \\n    \\n        // IF WE HAVE GREATER NODE FROM THE ROOT NODE THEN SOLVE RIGHT PART\\n        if (right_indx != end+1) root->right = solve(preorder, right_indx, end);   \\n\\n        return root; // RETURN ROOT\\n    }\\n    TreeNode *bstFromPreorder(vector<int> &preorder)\\n    {\\n        int n = preorder.size() - 1;\\n        return solve(preorder, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution\\n{\\npublic:\\n   \\n    TreeNode *solve(vector<int> &preorder, int start, int end){\\n        if (start > end) return NULL; // BASE CASE\\n     \\n        if (start == end){    // IF ONLY ONE NODE \\n            TreeNode *root = new TreeNode(preorder[start]);\\n            return root;\\n        }\\n\\n        // CREATE ROOT NODE \\n        TreeNode *root = new TreeNode(preorder[start]);\\n\\n        int left_indx = -1, right_indx = end+1,value = preorder[start] ;\\n         \\n         // SPLIT THE ARRAY INTO TWO PART \\n        // FIND GREATEST NODE && LOWEST NODE FROM THE ROOT NODE   \\n \\n        for(int i = start; i <= end; i++){\\n          if (preorder[i] > value && right_indx == end+1) right_indx = i;\\n          else if (preorder[i] < value && left_indx == -1) left_indx = i;\\n        }\\n\\n       // IF WE HAVE LOWEST NODE FROM THE ROOT NODE THEN SOLVE LEFT PART\\n        if (left_indx != -1) root->left = solve(preorder, left_indx, right_indx-1); \\n    \\n        // IF WE HAVE GREATER NODE FROM THE ROOT NODE THEN SOLVE RIGHT PART\\n        if (right_indx != end+1) root->right = solve(preorder, right_indx, end);   \\n\\n        return root; // RETURN ROOT\\n    }\\n    TreeNode *bstFromPreorder(vector<int> &preorder)\\n    {\\n        int n = preorder.size() - 1;\\n        return solve(preorder, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479948,
                "title": "easy-c-solution-using-recursion",
                "content": "# Intuition\\nFirst thought was to sort the preorder then create bst but then root was getting changed\\n\\n# Approach\\nRange of value will be inside [INT_MIN,INT_MAX]\\nSo if left most subtree then range will be btw [INT_MIN,data->val]\\n if left most subtree then range will be btw [data->val,INT_MAX]\\n\\nEvery node is traversed max 3 times \\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* fun(vector<int>& preorder,int min,int max,int &i)\\n       {\\n           if(i>=preorder.size())\\n           {\\n               return NULL;\\n           }\\n           if(preorder[i]<min ||preorder[i]>max)\\n           {\\n               return NULL;\\n           }\\n           TreeNode* root=new TreeNode(preorder[i++]);\\n           root->left=fun(preorder,min,root->val,i);\\n           root->right=fun(preorder,root->val,max,i);\\n           return root;\\n\\n       }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n       {\\n           int min=INT_MIN;\\n           int max=INT_MAX;\\n           int i =0;\\n           return fun(preorder,min,max,i);\\n       }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    TreeNode* fun(vector<int>& preorder,int min,int max,int &i)\\n       {\\n           if(i>=preorder.size())\\n           {\\n               return NULL;\\n           }\\n           if(preorder[i]<min ||preorder[i]>max)\\n           {\\n               return NULL;\\n           }\\n           TreeNode* root=new TreeNode(preorder[i++]);\\n           root->left=fun(preorder,min,root->val,i);\\n           root->right=fun(preorder,root->val,max,i);\\n           return root;\\n\\n       }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n       {\\n           int min=INT_MIN;\\n           int max=INT_MAX;\\n           int i =0;\\n           return fun(preorder,min,max,i);\\n       }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473829,
                "title": "easy-c-solution-using-recursion",
                "content": "\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nTreeNode* solvebst(vector<int>& preorder,int mini ,int maxi, int &i)\\n{\\n    if (i>=preorder.size())\\n    {\\n        return NULL;\\n    }\\n    if(preorder[i]>maxi||preorder[i]<mini)\\n    {\\n        return NULL;\\n    }\\n    TreeNode* root=new TreeNode(preorder[i++]);\\n    root->left=solvebst(preorder,mini,root->val,i);\\n    root->right=solvebst(preorder,root->val,maxi,i);\\n    return root;\\n}\\n\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        int i=0;\\n        int mini =INT_MIN;\\n        int maxi=INT_MAX;\\n        return solvebst(preorder,mini,maxi,i);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nTreeNode* solvebst(vector<int>& preorder,int mini ,int maxi, int &i)\\n{\\n    if (i>=preorder.size())\\n    {\\n        return NULL;\\n    }\\n    if(preorder[i]>maxi||preorder[i]<mini)\\n    {\\n        return NULL;\\n    }\\n    TreeNode* root=new TreeNode(preorder[i++]);\\n    root->left=solvebst(preorder,mini,root->val,i);\\n    root->right=solvebst(preorder,root->val,maxi,i);\\n    return root;\\n}\\n\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        int i=0;\\n        int mini =INT_MIN;\\n        int maxi=INT_MAX;\\n        return solvebst(preorder,mini,maxi,i);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409122,
                "title": "0ms-100-faster-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return ans(preorder,Integer.MAX_VALUE,new int[]{0});\\n    }\\n    public TreeNode ans(int[]pre,int max,int i[]){\\n        if(i[0]==pre.length || pre[i[0]]>max){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(pre[i[0]++]);\\n        root.left=ans(pre,root.val,i);\\n        root.right=ans(pre,max,i);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return ans(preorder,Integer.MAX_VALUE,new int[]{0});\\n    }\\n    public TreeNode ans(int[]pre,int max,int i[]){\\n        if(i[0]==pre.length || pre[i[0]]>max){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(pre[i[0]++]);\\n        root.left=ans(pre,root.val,i);\\n        root.right=ans(pre,max,i);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348771,
                "title": "python3-recursive-solution-with-explanation",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        #base case\\n        if not preorder: return\\n        if len(preorder) == 1: return TreeNode(preorder[0])\\n        #create root from preorder[0] value\\n        root = TreeNode(preorder[0])\\n        #iterate through array to find left end and right start\\n        i = 1\\n        for j in range(1, len(preorder)):\\n            if preorder[j] < preorder[0]:\\n                i += 1\\n        #recursively call on left and right to build the tree\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        #return root of the created binary search tree\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        #base case\\n        if not preorder: return\\n        if len(preorder) == 1: return TreeNode(preorder[0])\\n        #create root from preorder[0] value\\n        root = TreeNode(preorder[0])\\n        #iterate through array to find left end and right start\\n        i = 1\\n        for j in range(1, len(preorder)):\\n            if preorder[j] < preorder[0]:\\n                i += 1\\n        #recursively call on left and right to build the tree\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        #return root of the created binary search tree\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286716,
                "title": "0ms-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return constructBST(preorder,Integer.MAX_VALUE,new int[]{0});\\n    }\\n    public TreeNode constructBST(int[] preorder,int bound,int[]i) {\\n        if(i[0]==preorder.length ||preorder[i[0]]>bound) return null;\\n        TreeNode root=new TreeNode(preorder[i[0]++]);\\n        root.left=constructBST(preorder,root.val,i);\\n        root.right=constructBST(preorder,bound,i);\\n        return root;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return constructBST(preorder,Integer.MAX_VALUE,new int[]{0});\\n    }\\n    public TreeNode constructBST(int[] preorder,int bound,int[]i) {\\n        if(i[0]==preorder.length ||preorder[i[0]]>bound) return null;\\n        TreeNode root=new TreeNode(preorder[i[0]++]);\\n        root.left=constructBST(preorder,root.val,i);\\n        root.right=constructBST(preorder,bound,i);\\n        return root;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283877,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n    vector<int>inorder, v;\\n    v=preorder;\\n    sort(v.begin(), v.end());\\n    inorder=v;\\n    if(preorder.size()==0){return NULL;}\\n    map<int, int>m;\\n    for(int i=0; i<inorder.size(); i++){\\n        m[inorder[i]]=i;\\n    }\\n    TreeNode* root=formtree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, m);\\n    return root;\\n}\\nTreeNode* formtree(vector<int>& preorder, int pst, int pen, vector<int>& inorder, int inst, int inen, map<int, int>& m){\\n    if(pst>pen || inst>inen){return NULL;}\\n    TreeNode* root=new TreeNode(preorder[pst]);\\n    int pos=m[preorder[pst]];\\n    int lft=pos-inst;\\n    root->left=formtree(preorder, pst+1, pst+lft, inorder, inst, pos-1, m);\\n    root->right=formtree(preorder, pst+lft+1, pen, inorder, pos+1, inen, m);\\n    return root;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n    vector<int>inorder, v;\\n    v=preorder;\\n    sort(v.begin(), v.end());\\n    inorder=v;\\n    if(preorder.size()==0){return NULL;}\\n    map<int, int>m;\\n    for(int i=0; i<inorder.size(); i++){\\n        m[inorder[i]]=i;\\n    }\\n    TreeNode* root=formtree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, m);\\n    return root;\\n}\\nTreeNode* formtree(vector<int>& preorder, int pst, int pen, vector<int>& inorder, int inst, int inen, map<int, int>& m){\\n    if(pst>pen || inst>inen){return NULL;}\\n    TreeNode* root=new TreeNode(preorder[pst]);\\n    int pos=m[preorder[pst]];\\n    int lft=pos-inst;\\n    root->left=formtree(preorder, pst+1, pst+lft, inorder, inst, pos-1, m);\\n    root->right=formtree(preorder, pst+lft+1, pen, inorder, pos+1, inen, m);\\n    return root;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146226,
                "title": "c-o-n-using-recursion",
                "content": "```\\nclass Solution {\\nprivate:\\n    TreeNode* buildtree(int min, int max, vector<int>&preorder,int &i){\\n        if(i>=preorder.size() || preorder[i] < min || preorder[i] > max){\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left=buildtree(min,root->val,preorder,i);\\n        root->right=buildtree(root->val,max,preorder,i);\\n        return root;\\n    } \\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        return buildtree(INT_MIN,INT_MAX,preorder,i);\\n    }\\n};\\n```\\nUse Range property of BST (can google) .\\nAt max we are visiting a node 3 times.\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    TreeNode* buildtree(int min, int max, vector<int>&preorder,int &i){\\n        if(i>=preorder.size() || preorder[i] < min || preorder[i] > max){\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left=buildtree(min,root->val,preorder,i);\\n        root->right=buildtree(root->val,max,preorder,i);\\n        return root;\\n    } \\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        return buildtree(INT_MIN,INT_MAX,preorder,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057174,
                "title": "o-1-space-approach-simple-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int i=0;\\n    TreeNode* builtBST(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int curr=preorder[i];\\n        TreeNode* root=new TreeNode(preorder[i++]);\\n        int j;\\n        for(j=i;j<preorder.size();j++){\\n            if(preorder[j]>curr)break;\\n        }\\n        root->left=builtBST(preorder,i,j-1);\\n        root->right=builtBST(preorder,j,end);\\n        return  root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return builtBST(preorder,0,preorder.size()-1);       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int i=0;\\n    TreeNode* builtBST(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int curr=preorder[i];\\n        TreeNode* root=new TreeNode(preorder[i++]);\\n        int j;\\n        for(j=i;j<preorder.size();j++){\\n            if(preorder[j]>curr)break;\\n        }\\n        root->left=builtBST(preorder,i,j-1);\\n        root->right=builtBST(preorder,j,end);\\n        return  root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return builtBST(preorder,0,preorder.size()-1);       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053349,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // 1. check if root NULL then it create new node and make it new root;\\n    // 2. if the value is less or greater than current root value then it go to\\n// else if part which make link between root node and new node according to bst rule;\\n\\n    void insert(TreeNode* & root,int x){\\n        if(root==NULL){\\n            root= new TreeNode(x);\\n            return ;\\n        }\\n        else if(root->val<x){\\n          insert(root->right,x);\\n        }\\n        else if(root->val>x){\\n            insert(root->left,x);\\n        }\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        // 1.first create a node with the intial value of vector.\\n        // 2.make a temp pointer\\n        // 3.now add remaining value of vector by insert function according to bst rule;\\n        // 4. return root;\\n\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        TreeNode* temp=root;\\n        for(int i=1;i<preorder.size();i++){\\n            insert(temp,preorder[i]);\\n        }\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    // 1. check if root NULL then it create new node and make it new root;\\n    // 2. if the value is less or greater than current root value then it go to\\n// else if part which make link between root node and new node according to bst rule;\\n\\n    void insert(TreeNode* & root,int x){\\n        if(root==NULL){\\n            root= new TreeNode(x);\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2928434,
                "title": "simple-recursive-soln-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n           int i=0;\\n          return Builder(preorder,i,INT_MAX);\\n    }\\n    TreeNode* Builder(vector<int>& preorder,int & i,int bound){\\n            if(i==preorder.size() || preorder[i]>bound) return NULL; //Base condition\\n            TreeNode* node = new TreeNode(preorder[i++]); // Creating nodes\\n            node->left = Builder(preorder,i,node->val); // Values to the left are lesser than the node val\\n            node->right = Builder(preorder,i,bound); //Values to the right are lesser than the previous node val\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n           int i=0;\\n          return Builder(preorder,i,INT_MAX);\\n    }\\n    TreeNode* Builder(vector<int>& preorder,int & i,int bound){\\n            if(i==preorder.size() || preorder[i]>bound) return NULL; //Base condition\\n            TreeNode* node = new TreeNode(preorder[i++]); // Creating nodes\\n            node->left = Builder(preorder,i,node->val); // Values to the left are lesser than the node val\\n            node->right = Builder(preorder,i,bound); //Values to the right are lesser than the previous node val\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915020,
                "title": "easy-to-understand-recursion-cpp-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(H)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* func(vector<int>&p,int max,int &i,int min){\\n        if(i>=p.size()){\\n            return NULL;\\n        }\\n        cout<<p.size()<<\" \"<<i<<endl;\\n        if(p[i]<min || p[i]>max){\\n            return NULL;\\n        }\\n\\n        TreeNode* root=new TreeNode(p.at(i));\\n        i++;\\n        root->left=func(p,p.at(i-1),i,min);\\n        root->right=func(p,max,i,p.at(i-1));\\n        return root;\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int max=INT_MAX;\\n        int min=INT_MIN;\\n        int index=0;\\n        return func(preorder,max,index,min);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* func(vector<int>&p,int max,int &i,int min){\\n        if(i>=p.size()){\\n            return NULL;\\n        }\\n        cout<<p.size()<<\" \"<<i<<endl;\\n        if(p[i]<min || p[i]>max){\\n            return NULL;\\n        }\\n\\n        TreeNode* root=new TreeNode(p.at(i));\\n        i++;\\n        root->left=func(p,p.at(i-1),i,min);\\n        root->right=func(p,max,i,p.at(i-1));\\n        return root;\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int max=INT_MAX;\\n        int min=INT_MIN;\\n        int index=0;\\n        return func(preorder,max,index,min);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2796972,
                "title": "c-solution-construct-binary-search-tree-from-preorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder , int mini , int maxi , int &i){\\n        //base cases\\n        if(i >= preorder.size())\\n            return NULL;\\n        \\n        if(preorder[i] < mini || preorder[i] > maxi)\\n            return NULL;\\n        \\n        TreeNode* temp = new TreeNode(preorder[i++]);\\n        temp->left = solve(preorder , mini , temp->val , i);\\n        temp->right = solve(preorder , temp->val , maxi , i);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return solve(preorder , INT_MIN , INT_MAX , i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder , int mini , int maxi , int &i){\\n        //base cases\\n        if(i >= preorder.size())\\n            return NULL;\\n        \\n        if(preorder[i] < mini || preorder[i] > maxi)\\n            return NULL;\\n        \\n        TreeNode* temp = new TreeNode(preorder[i++]);\\n        temp->left = solve(preorder , mini , temp->val , i);\\n        temp->right = solve(preorder , temp->val , maxi , i);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return solve(preorder , INT_MIN , INT_MAX , i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682032,
                "title": "c-convert-pre-to-inorder-create-bst-easily-neat-n-clear-code",
                "content": "class Solution {\\npublic:\\n    \\n    TreeNode *solve(vector<int>&pre , vector<int> &in , int n , int &index , map<int , int> &mp , int inSt , int inEnd){\\n        \\n        if(index > n || inSt > inEnd) return NULL;\\n        \\n        int element = pre[index++];\\n        TreeNode *root = new TreeNode(element);\\n        \\n        int pos = mp[element];\\n        \\n        root->left  = solve(pre , in , n , index , mp , inSt , pos-1);\\n        root->right = solve(pre , in , n , index , mp , pos+1 , inEnd);\\n        \\n        return root;\\n        \\n    }\\n    \\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        vector<int> in=preorder;\\n        sort(in.begin() , in.end());\\n        \\n        int n = preorder.size();\\n        int preIND = 0;\\n        \\n        map<int , int> mp;\\n        for(int i=0 ; i<in.size() ; i++){\\n            mp[in[i]] = i;\\n        }\\n        \\n        return solve(preorder , in , n , preIND , mp , 0 , n-1);\\n        \\n\\t\\t}\\n\\t}\\n\\n# \\n# \\n# upvote",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode *solve(vector<int>&pre , vector<int> &in , int n , int &index , map<int , int> &mp , int inSt , int inEnd){\\n        \\n        if(index > n || inSt > inEnd) return NULL;\\n        \\n        int element = pre[index++];\\n        TreeNode *root = new TreeNode(element);\\n        \\n        int pos = mp[element];\\n        \\n        root->left  = solve(pre , in , n , index , mp , inSt , pos-1);\\n        root->right = solve(pre , in , n , index , mp , pos+1 , inEnd);\\n        \\n        return root;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2673447,
                "title": "simple-code-using-inorder-and-preorder",
                "content": "Steps-make inorder and solve taking preorder vector step by step \\n\\t\\t\\tand checking that element in inorder keeping that index and calling the function\\n\\t\\t\\tfor left and right.\\n\\t\\t\\t\\n```\\nint pre=0;\\n    TreeNode* bst(vector<int>v,vector<int>preorder,int s,int e)\\n    {\\n        if(s>e){\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[pre++]);\\n        int index;\\n        for(int i=s;i<=e;i++){\\n            if(v[i]==root->val){\\n                index=i;\\n                break;\\n            }\\n        }\\n        root->left=bst(v,preorder,s,index-1);\\n        root->right=bst(v,preorder,index+1,e);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        vector<int>v(preorder.begin(),preorder.end());\\n        sort(v.begin(),v.end());\\n        return bst(v,preorder,0,v.size()-1);\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nint pre=0;\\n    TreeNode* bst(vector<int>v,vector<int>preorder,int s,int e)\\n    {\\n        if(s>e){\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[pre++]);\\n        int index;\\n        for(int i=s;i<=e;i++){\\n            if(v[i]==root->val){\\n                index=i;\\n                break;\\n            }\\n        }\\n        root->left=bst(v,preorder,s,index-1);\\n        root->right=bst(v,preorder,index+1,e);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        vector<int>v(preorder.begin(),preorder.end());\\n        sort(v.begin(),v.end());\\n        return bst(v,preorder,0,v.size()-1);\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2623162,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&p, int s, int e){\\n        TreeNode *root = new TreeNode(p[s]);\\n        int m;\\n        for(m=s+1; m<=e; ++m)\\n            if(p[m]>p[s]) break;\\n        if(m<=e)\\n            root->right = solve(p,m,e);\\n        if(s<e and p[s+1]<p[s])\\n            root->left = solve(p,s+1,m-1);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return solve(preorder,0,preorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&p, int s, int e){\\n        TreeNode *root = new TreeNode(p[s]);\\n        int m;\\n        for(m=s+1; m<=e; ++m)\\n            if(p[m]>p[s]) break;\\n        if(m<=e)\\n            root->right = solve(p,m,e);\\n        if(s<e and p[s+1]<p[s])\\n            root->left = solve(p,s+1,m-1);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return solve(preorder,0,preorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600456,
                "title": "100-faster-most-easiest-java-simple",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = null;\\n        for(int i=0;i<preorder.length;i++){\\n            root = addNode(root, preorder[i]);\\n        }\\n        return root;\\n    }\\n    public TreeNode addNode(TreeNode root, int val){\\n        if(root == null)\\n            root = new TreeNode(val);\\n        else if(root.val > val)\\n            root.left = addNode(root.left,val);\\n        else if(root.val < val)\\n            root.right = addNode(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = null;\\n        for(int i=0;i<preorder.length;i++){\\n            root = addNode(root, preorder[i]);\\n        }\\n        return root;\\n    }\\n    public TreeNode addNode(TreeNode root, int val){\\n        if(root == null)\\n            root = new TreeNode(val);\\n        else if(root.val > val)\\n            root.left = addNode(root.left,val);\\n        else if(root.val < val)\\n            root.right = addNode(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542096,
                "title": "code-with-proper-explanation-c",
                "content": "**If you liked and understand the code, Please consider upvoting the Solution so that it helps others as well**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder, int &ptr, int bound)\\n    {\\n        //we return NULL in 2 cases\\n        // 1. If nodes are finished in preorder vector i.e ptr > size of preorder vector\\n        // 2. If preorder[ptr] > given bound, then it wont be part of that node subtrees\\n        //and have to move up to parent nodes.\\n        if(ptr == preorder.size() || preorder[ptr] > bound)\\n            return NULL;\\n        \\n        //preorder is root->left->right\\n        TreeNode* root = new TreeNode(preorder[ptr++]);\\n        root->left = build(preorder, ptr, root->val);\\n        root->right = build(preorder, ptr, bound);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        //have a universal pointer for traversing the preorder vector\\n        int ptr = 0;\\n        //build the tree and return its root\\n        return build(preorder, ptr, INT_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder, int &ptr, int bound)\\n    {\\n        //we return NULL in 2 cases\\n        // 1. If nodes are finished in preorder vector i.e ptr > size of preorder vector\\n        // 2. If preorder[ptr] > given bound, then it wont be part of that node subtrees\\n        //and have to move up to parent nodes.\\n        if(ptr == preorder.size() || preorder[ptr] > bound)\\n            return NULL;\\n        \\n        //preorder is root->left->right\\n        TreeNode* root = new TreeNode(preorder[ptr++]);\\n        root->left = build(preorder, ptr, root->val);\\n        root->right = build(preorder, ptr, bound);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        //have a universal pointer for traversing the preorder vector\\n        int ptr = 0;\\n        //build the tree and return its root\\n        return build(preorder, ptr, INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449100,
                "title": "c-o-n",
                "content": "```\\nTreeNode* solve(vector<int>& preorder,int &maxi,int n,int &i)\\n    {\\n        if(i==n || preorder[i]>maxi)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[i]);\\n        i++;\\n        root->left=solve(preorder,root->val,n,i);\\n        root->right=solve(preorder,maxi,n,i);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        int maxi=INT_MAX;\\n        int n=preorder.size();\\n        int i=0;\\n        return solve(preorder,maxi,n,i);\\n    }\\n",
                "solutionTags": [],
                "code": "```\\nTreeNode* solve(vector<int>& preorder,int &maxi,int n,int &i)\\n    {\\n        if(i==n || preorder[i]>maxi)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[i]);\\n        i++;\\n        root->left=solve(preorder,root->val,n,i);\\n        root->right=solve(preorder,maxi,n,i);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        int maxi=INT_MAX;\\n        int n=preorder.size();\\n        int i=0;\\n        return solve(preorder,maxi,n,i);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2427378,
                "title": "easy-java-solution-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    TreeNode constructTree(int leftEnd, int rightEnd, int[] preorder){\\n        if(leftEnd > rightEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[leftEnd]);\\n        int smallerTill = leftEnd + 1;\\n        \\n        while(smallerTill <= rightEnd && preorder[smallerTill] < preorder[leftEnd]){\\n            ++smallerTill;\\n        }\\n        \\n        root.left = constructTree(leftEnd + 1, smallerTill - 1, preorder);\\n        root.right = constructTree(smallerTill, rightEnd, preorder);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return constructTree(0, preorder.length - 1, preorder);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode constructTree(int leftEnd, int rightEnd, int[] preorder){\\n        if(leftEnd > rightEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[leftEnd]);\\n        int smallerTill = leftEnd + 1;\\n        \\n        while(smallerTill <= rightEnd && preorder[smallerTill] < preorder[leftEnd]){\\n            ++smallerTill;\\n        }\\n        \\n        root.left = constructTree(leftEnd + 1, smallerTill - 1, preorder);\\n        root.right = constructTree(smallerTill, rightEnd, preorder);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return constructTree(0, preorder.length - 1, preorder);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378208,
                "title": "c-easy-recursive",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\n\\tTreeNode* solve(vector<int>& preorder, int mini, int maxi ,int &i){\\n        if(i >= preorder.size() )\\n            return NULL;\\n        \\n        if( preorder[i] < mini || preorder[i] > maxi )\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[i]); \\n        i++;\\n        \\n        // change values of mini and maxi for left and right subtree\\n        root->left = solve(preorder , mini, root->val ,i);\\n        \\n        root->right = solve(preorder , root->val, maxi ,i);        \\n        \\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        \\n        int i=0; // to traverse over the array elements\\n        \\n        return solve(preorder,mini,maxi,i);\\n    }\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\n\\tTreeNode* solve(vector<int>& preorder, int mini, int maxi ,int &i){\\n        if(i >= preorder.size() )\\n            return NULL;\\n        \\n        if( preorder[i] < mini || preorder[i] > maxi )\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[i]); \\n        i++;\\n        \\n        // change values of mini and maxi for left and right subtree\\n        root->left = solve(preorder , mini, root->val ,i);\\n        \\n        root->right = solve(preorder , root->val, maxi ,i);        \\n        \\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        \\n        int i=0; // to traverse over the array elements\\n        \\n        return solve(preorder,mini,maxi,i);\\n    }\\n\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2352316,
                "title": "o-n-time-o-ht-of-tree-space-for-func-call-stack",
                "content": "```\\n//O(N) Time O(Ht of tree) Space\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        //preorder is root left right, so always we get the root at first\\n        \\n        int i=0; // to runthrough preorder vector\\n        TreeNode* root = Helper(preorder,i,INT_MAX); \\n        \\n        return root;\\n    }\\n    \\n    TreeNode* Helper(vector<int>& preorder, int &i, int UpperBound){\\n        if(i==preorder.size() || preorder[i]>UpperBound) return NULL;\\n        \\n        //create node \\n        TreeNode* root = new TreeNode(preorder[i]);\\n        i++; // next ele\\n        \\n        //left means - less than root\\n        root->left = Helper(preorder,i, root->val);\\n         //right means - more than root - so continues same\\n        //the guy with less than root is tackled above itself, so it wont come\\n        root->right = Helper(preorder,i, UpperBound);\\n        \\n        return root;\\n    }\\n    \\n    \\n};\\n```\\n\\n*The main useage of BST is the UpperBound part",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n//O(N) Time O(Ht of tree) Space\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        //preorder is root left right, so always we get the root at first\\n        \\n        int i=0; // to runthrough preorder vector\\n        TreeNode* root = Helper(preorder,i,INT_MAX); \\n        \\n        return root;\\n    }\\n    \\n    TreeNode* Helper(vector<int>& preorder, int &i, int UpperBound){\\n        if(i==preorder.size() || preorder[i]>UpperBound) return NULL;\\n        \\n        //create node \\n        TreeNode* root = new TreeNode(preorder[i]);\\n        i++; // next ele\\n        \\n        //left means - less than root\\n        root->left = Helper(preorder,i, root->val);\\n         //right means - more than root - so continues same\\n        //the guy with less than root is tackled above itself, so it wont come\\n        root->right = Helper(preorder,i, UpperBound);\\n        \\n        return root;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308889,
                "title": "c-easy-100-fast-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder, int mini, int maxi,int &i){\\n        if(i>=preorder.size())\\n            return NULL;\\n        if(preorder[i]<mini || preorder[i]>maxi)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left=solve(preorder,mini,root->val,i);\\n        root->right=solve(preorder,root->val,maxi,i);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int mini= INT_MIN;\\n        int maxi = INT_MAX;\\n        int i=0;\\n        return solve(preorder,mini,maxi,i);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder, int mini, int maxi,int &i){\\n        if(i>=preorder.size())\\n            return NULL;\\n        if(preorder[i]<mini || preorder[i]>maxi)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left=solve(preorder,mini,root->val,i);\\n        root->right=solve(preorder,root->val,maxi,i);\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2245221,
                "title": "java-0ms-100-faster-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i< preorder.length; i++) {\\n            root = bstInsertion(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode bstInsertion(TreeNode root, int data) {\\n        if(root == null) {\\n            root = new TreeNode(data);\\n            return root;\\n        }\\n        \\n        if(data < root.val)\\n            root.left = bstInsertion(root.left, data);\\n        else if (data > root.val)\\n            root.right = bstInsertion(root.right, data);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i< preorder.length; i++) {\\n            root = bstInsertion(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode bstInsertion(TreeNode root, int data) {\\n        if(root == null) {\\n            root = new TreeNode(data);\\n            return root;\\n        }\\n        \\n        if(data < root.val)\\n            root.left = bstInsertion(root.left, data);\\n        else if (data > root.val)\\n            root.right = bstInsertion(root.right, data);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182343,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tTreeNode* helper(vector<int>& preorder, int &i, int bound) {\\n\\t\\tif (i == preorder.size() || preorder[i] > bound) return NULL;\\n\\t\\tTreeNode * root = new TreeNode(preorder[i]);\\n        i++;\\n\\t\\troot->left = helper(preorder, i, root->val);\\n\\t\\troot->right = helper(preorder, i, bound);\\n\\t\\treturn root;\\n\\t}\\npublic:\\n\\tTreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i =0;\\n\\t\\treturn helper(preorder, i, INT_MAX);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tTreeNode* helper(vector<int>& preorder, int &i, int bound) {\\n\\t\\tif (i == preorder.size() || preorder[i] > bound) return NULL;\\n\\t\\tTreeNode * root = new TreeNode(preorder[i]);\\n        i++;\\n\\t\\troot->left = helper(preorder, i, root->val);\\n\\t\\troot->right = helper(preorder, i, bound);\\n\\t\\treturn root;\\n\\t}\\npublic:\\n\\tTreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i =0;\\n\\t\\treturn helper(preorder, i, INT_MAX);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146489,
                "title": "3-approach-brute-better-optimal",
                "content": ">Brute Approach :\\n* Inserting Node 1 by 1 to build complete tree.\\n``` \\n// Brute Approach\\nclass Solution {\\npublic:\\n    TreeNode* insertNode(TreeNode* root, int val) {\\n        if(!root)   return new TreeNode(val);\\n        if(val > root->val) root->right = insertNode(root->right,val);\\n        else    root->left = insertNode(root->left,val);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = NULL;\\n        for(int x:preorder)    root = insertNode(root,x);\\n        return root;\\n    }\\n};\\n```\\n* Time Complexity :- O(n*n) , worst case\\n* Space Complexity:- O(1)\\n* *Helpful Link* :- https://leetcode.com/problems/insert-into-a-binary-search-tree/\\n\\n\\n>Better Approach:\\n* As we know, tree is to be build in BST so it\\'s inorder is going to be in sorted order.\\n* Copy the elements of preorder array and sort it.\\n* Now build tree using preorder and inorder traversal.\\n```\\n// Better Approach\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp;\\n    int pos;\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder = preorder;\\n        sort(inorder.begin(), inorder.end());\\n        for(int i=0; i<preorder.size(); i++)    mpp[inorder[i]] = i;\\n        pos = 0;\\n        return build_tree(preorder,0,preorder.size()-1);        \\n    }\\n    \\n    TreeNode* build_tree(vector<int>& preorder, int lo, int hi) {\\n        if(lo>hi)   return NULL;\\n        int val = preorder[pos++];\\n        return new TreeNode(val,build_tree(preorder,lo,mpp[val]-1),build_tree(preorder,mpp[val]+1,hi));\\n    }\\n    \\n};\\n```\\n* Time Complexity:-O(nlog(n)) + O(n)\\n* Space Complexity:- O(n)\\n*  *Helpful Link*:- https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\\n\\n> Optimal Approach\\n* Use property that any node\\'s value in left-half of a node in tree will be in range \\n[-INT_MIN,node->val].\\n* If I am want to insert a node to left of current node, then I just need to consider whether that node\\'s value doesn\\'t exceed the current\\'s node value.\\n* So , for inserting node to the left, it\\'s upper bound will be current node\\'s value.\\n* If I want to insert node to the right of the current node, then it\\'s upper bound will be the bound of current node.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int pos = 0;\\n        return build(preorder, pos, 1001);\\n    }\\n    \\n    TreeNode* build(vector<int>& preorder, int& pos, int bound) {\\n        if(pos==preorder.size() || preorder[pos]>bound)   return NULL;\\n        TreeNode* node = new TreeNode(preorder[pos++]);\\n        node->left = build(preorder,pos,node->val);\\n        node->right = build(preorder,pos,bound);\\n        return node;\\n    }\\n    \\n};\\n```\\n* Time Complexity:- O(n)\\n* Space Complexity:- O(1)",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "``` \\n// Brute Approach\\nclass Solution {\\npublic:\\n    TreeNode* insertNode(TreeNode* root, int val) {\\n        if(!root)   return new TreeNode(val);\\n        if(val > root->val) root->right = insertNode(root->right,val);\\n        else    root->left = insertNode(root->left,val);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = NULL;\\n        for(int x:preorder)    root = insertNode(root,x);\\n        return root;\\n    }\\n};\\n```\n```\\n// Better Approach\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp;\\n    int pos;\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder = preorder;\\n        sort(inorder.begin(), inorder.end());\\n        for(int i=0; i<preorder.size(); i++)    mpp[inorder[i]] = i;\\n        pos = 0;\\n        return build_tree(preorder,0,preorder.size()-1);        \\n    }\\n    \\n    TreeNode* build_tree(vector<int>& preorder, int lo, int hi) {\\n        if(lo>hi)   return NULL;\\n        int val = preorder[pos++];\\n        return new TreeNode(val,build_tree(preorder,lo,mpp[val]-1),build_tree(preorder,mpp[val]+1,hi));\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int pos = 0;\\n        return build(preorder, pos, 1001);\\n    }\\n    \\n    TreeNode* build(vector<int>& preorder, int& pos, int bound) {\\n        if(pos==preorder.size() || preorder[pos]>bound)   return NULL;\\n        TreeNode* node = new TreeNode(preorder[pos++]);\\n        node->left = build(preorder,pos,node->val);\\n        node->right = build(preorder,pos,bound);\\n        return node;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090179,
                "title": "simple-dfs-easy-to-understand-for-beginners",
                "content": "**INTUTION:-**\\n1.WE KNOW THAT IN BINARY TREE ALL THE NODES TO THE LEFT OF ROOT HAVE LESSER VALUE THAN ROOT AND ALL THE RIGHT ELEMENT HAVE GREATER THAN ROOT VALUE. \\n2.IN THE QUESTION PREORDER TRAVERSAL IS GIVEN WHICH IS **ROOT LEFT RIGHT**  SO THE FIRST ELEMENT WILL BE ROOT OF THE TREE => preorder[0] is the root of given tree.  \\n     **preorder traversal list can be seen as =>    [root, left subtree values, right subtree values]** \\n\\t so when we iterate on the preorder list to see the left and right subtree, see where root value is lesser than preorder[i]. So here we got the index of start of right subtree and ending of the left subtree.\\n\\t **some special cases;-**\\n\\t *preorder list ->[root, left subtree, no right subtree] or [root, no left subtree, right subtree]*\\n\\t for this case we need to find the ending of the left subtree but \\n\\t ``for(int i = start; i < end; i++) {\\n            if(preorder[start] < preorder[i]) {\\n                leftend = i;\\n                break;\\n            }\\n        }``\\n\\t\\tthis loop can not find the leftend index for this case so we need to initaize the leftend index before this loop so after if we not find any right subtree we can directly get it. and if we found out right subtree than leftend will be changed by loop.\\n\\t\\twrite before the loop \\n\\t\\t`int leftend = end;`\\n**ALGORITHM AND FULL CODE:-**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& preorder, int start, int end) {\\n        if(start == end) {\\n            return NULL;\\n        }     \\n        TreeNode* root = new TreeNode(preorder[start], NULL, NULL);\\n        int leftend = end;\\n        for(int i = start; i < end; i++) {\\n            if(preorder[start] < preorder[i]) {\\n                leftend = i;\\n                break;\\n            }\\n        }\\n        root->left = helper(preorder, start+1,leftend);\\n        root->right = helper(preorder, leftend, end);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return helper(preorder, 0, preorder.size());\\n    }\\n};\\n```\\n# UPVOTE IF IT HELPS",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& preorder, int start, int end) {\\n        if(start == end) {\\n            return NULL;\\n        }     \\n        TreeNode* root = new TreeNode(preorder[start], NULL, NULL);\\n        int leftend = end;\\n        for(int i = start; i < end; i++) {\\n            if(preorder[start] < preorder[i]) {\\n                leftend = i;\\n                break;\\n            }\\n        }\\n        root->left = helper(preorder, start+1,leftend);\\n        root->right = helper(preorder, leftend, end);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return helper(preorder, 0, preorder.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671714,
                "title": "java-0-ms-easy-and-faster-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return helper(preorder,0,preorder.length-1);\\n    }\\n    public TreeNode helper(int []p,int l,int r)\\n    {\\n        if(l>r) return null;\\n        TreeNode root=new TreeNode(p[l]);\\n        int idx=l+1;\\n        while(idx<p.length && p[l]>p[idx])\\n        {\\n            idx++; \\n        }\\n        \\n        //idx-1 for left is beacuse we have already given idx=1 not 0\\n        root.left=helper(p,l+1,idx-1);\\n        root.right=helper(p,idx,r);\\n        return root;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return helper(preorder,0,preorder.length-1);\\n    }\\n    public TreeNode helper(int []p,int l,int r)\\n    {\\n        if(l>r) return null;\\n        TreeNode root=new TreeNode(p[l]);\\n        int idx=l+1;\\n        while(idx<p.length && p[l]>p[idx])\\n        {\\n            idx++; \\n        }\\n        \\n        //idx-1 for left is beacuse we have already given idx=1 not 0\\n        root.left=helper(p,l+1,idx-1);\\n        root.right=helper(p,idx,r);\\n        return root;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603891,
                "title": "c-construct-binary-search-tree-from-preorder-traversal",
                "content": "//T.C=O(3N)\\n//S.C=O(1)\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        return build(preorder,i,INT_MAX);\\n        \\n    }\\n    TreeNode*build(vector<int>&preorder,int &i,int bound)\\n    {\\n        if(i==preorder.size() || preorder[i]>bound)\\n        {\\n            return NULL;\\n        }\\n        TreeNode*root=new TreeNode(preorder[i++]);\\n        root->left=build(preorder,i,root->val);\\n        root->right=build(preorder,i,bound);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        return build(preorder,i,INT_MAX);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1529210,
                "title": "simple-c-solution-with-100-efficiency",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i< preorder.size();i++){\\n            TreeNode* temp = root;\\n            \\n            while(1){\\n                if(preorder[i] > temp->val){\\n                    if(!temp->right){\\n                        TreeNode* newNode = new TreeNode(preorder[i]);\\n                        temp->right = newNode;\\n                        break;\\n                    }\\n                    else{\\n                        temp = temp->right;\\n                    }\\n                }\\n                 if(preorder[i] < temp->val){\\n                    if(!temp->left){\\n                        TreeNode* newNode = new TreeNode(preorder[i]);\\n                        temp->left = newNode;\\n                        break;\\n                    }\\n                    else{\\n                        temp = temp->left;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i< preorder.size();i++){\\n            TreeNode* temp = root;\\n            \\n            while(1){\\n                if(preorder[i] > temp->val){\\n                    if(!temp->right){\\n                        TreeNode* newNode = new TreeNode(preorder[i]);\\n                        temp->right = newNode;\\n                        break;\\n                    }\\n                    else{\\n                        temp = temp->right;\\n                    }\\n                }\\n                 if(preorder[i] < temp->val){\\n                    if(!temp->left){\\n                        TreeNode* newNode = new TreeNode(preorder[i]);\\n                        temp->left = newNode;\\n                        break;\\n                    }\\n                    else{\\n                        temp = temp->left;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521509,
                "title": "c-linear-vs-bs-recursive-solutions-compared-and-explained-100-time-50-space",
                "content": "Nice one that we can do with the quick reminder that items in a BST go so that the smaller ones go on the left, the bigger ones all on the right.\\n\\nWe will then add a few extra parameters to our function signature to help us with recursion:\\n* `st` is where we we will be start considering values in `preorder`, defaulted to `0`;\\n* `ed` is where we we will be stop considering values in `preorder (excluded)`, defaulted to `-1`.\\n\\nInside our function, we will:\\n* correct `ed` when it equals `-1`, setting it to be `preorder.size()` (ie: past the last element);\\n* have a base case for our recursion - when `st >= ed`, we will just `return` `NULL`;\\n* compute the proper value of `md`, setting it to be the first element that is `> preorder[st]`)\\n* finally, return a `TreeNode` with\\n\\t* value equal to `root->val`;\\n\\t* a `left` node equal to a recursive call to  `bstFromPreorder` moving from `st + 1` to `md`;\\n\\t* a `right` node equal to a recursive call to  `bstFromPreorder` moving from `md` to `ed`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int st = 0, int ed = -1) {\\n        // updating ed for the first run\\n        if (ed == -1) ed = preorder.size();\\n        // end case\\n        if (st >= ed) return NULL;\\n        // support variables\\n        int md = st;\\n        while (md < ed && preorder[st] >= preorder[md]) md++;\\n        return new TreeNode(preorder[st++], bstFromPreorder(preorder, st, md), bstFromPreorder(preorder, md, ed));\\n    }\\n};\\n```\\n\\nToo expensive to find `md` in linear time? Fear not, we can just use binary search in a reduced section of `preorder` and it works just fine :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int st = 0, int ed = -1) {\\n        // updating ed for the first run\\n        if (ed == -1) ed = preorder.size();\\n        // end case\\n        if (st >= ed) return NULL;\\n        // support variables\\n        int md = upper_bound(begin(preorder) + st, begin(preorder) + ed, preorder[st]) - begin(preorder);\\n        return new TreeNode(preorder[st++], bstFromPreorder(preorder, st, md), bstFromPreorder(preorder, md, ed));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int st = 0, int ed = -1) {\\n        // updating ed for the first run\\n        if (ed == -1) ed = preorder.size();\\n        // end case\\n        if (st >= ed) return NULL;\\n        // support variables\\n        int md = st;\\n        while (md < ed && preorder[st] >= preorder[md]) md++;\\n        return new TreeNode(preorder[st++], bstFromPreorder(preorder, st, md), bstFromPreorder(preorder, md, ed));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int st = 0, int ed = -1) {\\n        // updating ed for the first run\\n        if (ed == -1) ed = preorder.size();\\n        // end case\\n        if (st >= ed) return NULL;\\n        // support variables\\n        int md = upper_bound(begin(preorder) + st, begin(preorder) + ed, preorder[st]) - begin(preorder);\\n        return new TreeNode(preorder[st++], bstFromPreorder(preorder, st, md), bstFromPreorder(preorder, md, ed));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519410,
                "title": "10-lines-of-code-typescript-recursion-pointer-without-helper-functions",
                "content": "First find the right node and childern in array and stroe positon in pointer.\\nThen create node with .left child and .right child the same way as root.\\n```\\nfunction bstFromPreorder(preorder: number[]): TreeNode | null {\\n    if(preorder.length === 0) return null\\n    let point = 1\\n\\t//find right child with it\\'s children\\n    while(preorder[0] > preorder[point]) point++\\n    const head = new TreeNode(preorder[0],\\n\\t\\t\\t//create left node with lower values\\n            bstFromPreorder(preorder.slice(1, point)),\\n\\t\\t\\t//create right node with higher values\\n            bstFromPreorder(preorder.slice(point))\\n            )\\n    return head\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nfunction bstFromPreorder(preorder: number[]): TreeNode | null {\\n    if(preorder.length === 0) return null\\n    let point = 1\\n\\t//find right child with it\\'s children\\n    while(preorder[0] > preorder[point]) point++\\n    const head = new TreeNode(preorder[0],\\n\\t\\t\\t//create left node with lower values\\n            bstFromPreorder(preorder.slice(1, point)),\\n\\t\\t\\t//create right node with higher values\\n            bstFromPreorder(preorder.slice(point))\\n            )\\n    return head\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519282,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    TreeNode root;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        for(int n : preorder){\\n            add(n);\\n        }\\n        return root;\\n    }\\n    void add(int n){\\n        root = add(root,n);\\n    }\\n    private TreeNode add(TreeNode root, int n){\\n        if(root == null){\\n            return new TreeNode(n);\\n        }\\n        if(root.val > n){\\n            root.left = add(root.left, n);\\n        }\\n        if(root.val < n){\\n             root.right = add(root.right, n);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode root;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        for(int n : preorder){\\n            add(n);\\n        }\\n        return root;\\n    }\\n    void add(int n){\\n        root = add(root,n);\\n    }\\n    private TreeNode add(TreeNode root, int n){\\n        if(root == null){\\n            return new TreeNode(n);\\n        }\\n        if(root.val > n){\\n            root.left = add(root.left, n);\\n        }\\n        if(root.val < n){\\n             root.right = add(root.right, n);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519126,
                "title": "python-o-nlogn-and-o-n-time-simple-solutions",
                "content": "## Solution 1 - O(nlogn)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binarySearch(self, nums, target):\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        \\n    def createBST(self, preorder, inorder):\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        # We need to calculate root\\'s index in order so that we can classify the left and right subtree of root. Since inorder is sorted so we can use binary search.\\n        # Once we get the index of root, we can define the left subtree from preorder as the number of nodes before the root index in inorder will be the left subtree.\\n        # Similarly we can calculate right subtree\\n        rootIndex = self.binarySearch(inorder, preorder[0])\\n        root.left = self.createBST(preorder[1:rootIndex+1], inorder[:rootIndex]) \\n        root.right = self.createBST(preorder[rootIndex+1:], inorder[rootIndex+1:])\\n        return root\\n    \\n    \\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        # Inorder Traversal of BST will always be a sorted array.\\n        inorder = sorted(preorder)\\n        return self.createBST(preorder, inorder)\\n        \\n```\\n\\n## Solution 2 - O(n)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n        \\n    def createBST(self, preorder, maxVal):\\n        if not preorder or preorder[-1] > maxVal:\\n            return None\\n        root = TreeNode(preorder.pop())\\n        root.left = self.createBST(preorder, root.val)\\n        root.right = self.createBST(preorder, maxVal)\\n        return root\\n    \\n    \\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        \"\"\"\\n            Since it is a BST therefore, the value of root would always be greater than its left child.\\n            By the above fact, we can divide the preorder array into three parts-\\n            1. Root -> 0th index would be the root\\n            2. Left Subtree -> From 1st index of preorder till the index of last element which is less then the root.\\n            3. Right Subtree -> From the index of first element which is greater than root till end.\\n\\n\\n            We can use the above logic and keep slicing the array by recursion to get the left and right subtree for each node. \\n\\t\\t\\tIf at any point the value becomes greater than the root value we can return None as that can\\'t be the part of left subtree and then it will go in right subtree.\\n        \"\"\"\\n        return self.createBST(preorder[::-1], sys.maxsize)\\n        \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binarySearch(self, nums, target):\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        \\n    def createBST(self, preorder, inorder):\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        # We need to calculate root\\'s index in order so that we can classify the left and right subtree of root. Since inorder is sorted so we can use binary search.\\n        # Once we get the index of root, we can define the left subtree from preorder as the number of nodes before the root index in inorder will be the left subtree.\\n        # Similarly we can calculate right subtree\\n        rootIndex = self.binarySearch(inorder, preorder[0])\\n        root.left = self.createBST(preorder[1:rootIndex+1], inorder[:rootIndex]) \\n        root.right = self.createBST(preorder[rootIndex+1:], inorder[rootIndex+1:])\\n        return root\\n    \\n    \\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        # Inorder Traversal of BST will always be a sorted array.\\n        inorder = sorted(preorder)\\n        return self.createBST(preorder, inorder)\\n        \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n        \\n    def createBST(self, preorder, maxVal):\\n        if not preorder or preorder[-1] > maxVal:\\n            return None\\n        root = TreeNode(preorder.pop())\\n        root.left = self.createBST(preorder, root.val)\\n        root.right = self.createBST(preorder, maxVal)\\n        return root\\n    \\n    \\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        \"\"\"\\n            Since it is a BST therefore, the value of root would always be greater than its left child.\\n            By the above fact, we can divide the preorder array into three parts-\\n            1. Root -> 0th index would be the root\\n            2. Left Subtree -> From 1st index of preorder till the index of last element which is less then the root.\\n            3. Right Subtree -> From the index of first element which is greater than root till end.\\n\\n\\n            We can use the above logic and keep slicing the array by recursion to get the left and right subtree for each node. \\n\\t\\t\\tIf at any point the value becomes greater than the root value we can return None as that can\\'t be the part of left subtree and then it will go in right subtree.\\n        \"\"\"\\n        return self.createBST(preorder[::-1], sys.maxsize)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518972,
                "title": "c-1008-using-upper-bound-recursive",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return buildtree(preorder, 0, preorder.size());\\n    }\\nprivate:\\n    TreeNode* buildtree(vector<int>& preorder, int start, int end) {\\n        if (start >= end) {\\n            return nullptr;\\n        }\\n\\t\\t\\n        auto middle = upper_bound(preorder.begin() + start + 1, \\n                                  preorder.begin() + end, \\n                                  preorder[start]) - preorder.begin();\\n        return new TreeNode(preorder[start], buildtree(preorder, start + 1, middle), buildtree(preorder, middle, end));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return buildtree(preorder, 0, preorder.size());\\n    }\\nprivate:\\n    TreeNode* buildtree(vector<int>& preorder, int start, int end) {\\n        if (start >= end) {\\n            return nullptr;\\n        }\\n\\t\\t\\n        auto middle = upper_bound(preorder.begin() + start + 1, \\n                                  preorder.begin() + end, \\n                                  preorder[start]) - preorder.begin();\\n        return new TreeNode(preorder[start], buildtree(preorder, start + 1, middle), buildtree(preorder, middle, end));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518789,
                "title": "c-recursive-solution-o-n",
                "content": "```\\nTreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        TreeNode * root = helper(preorder, i,INT_MAX);\\n        return root;\\n    }\\n    TreeNode* helper(vector<int>& a, int& i, int bound){\\n        if(i==a.size() || a[i]>bound) return NULL;\\n        TreeNode* root = new TreeNode(a[i]);\\n        i++;\\n        root->left = helper(a, i, root->val);\\n        root->right = helper(a, i, bound);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        TreeNode * root = helper(preorder, i,INT_MAX);\\n        return root;\\n    }\\n    TreeNode* helper(vector<int>& a, int& i, int bound){\\n        if(i==a.size() || a[i]>bound) return NULL;\\n        TreeNode* root = new TreeNode(a[i]);\\n        i++;\\n        root->left = helper(a, i, root->val);\\n        root->right = helper(a, i, bound);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1496585,
                "title": "c-recursion-faster-than-100-0-ms",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n          \\n           \\nclass Solution\\n{\\n    public:\\n    void dfs(TreeNode* root,vector<int>& preorder, int index)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(preorder[index]<root->val)\\n        {\\n            if(root->left==NULL)\\n            {\\n                root->left=new TreeNode(preorder[index]);\\n                return;\\n            }\\n                dfs(root->left,preorder,index);\\n        }\\n        else\\n        {\\n            if(root->right==NULL)\\n            {\\n                root->right=new TreeNode(preorder[index]);\\n                return;\\n            }\\n            dfs(root->right,preorder,index);\\n        }\\n        \\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++)\\n        {\\n            dfs(root,preorder,i);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n          \\n           \\nclass Solution\\n{\\n    public:\\n    void dfs(TreeNode* root,vector<int>& preorder, int index)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(preorder[index]<root->val)\\n        {\\n            if(root->left==NULL)\\n            {\\n                root->left=new TreeNode(preorder[index]);\\n                return;\\n            }\\n                dfs(root->left,preorder,index);\\n        }\\n        else\\n        {\\n            if(root->right==NULL)\\n            {\\n                root->right=new TreeNode(preorder[index]);\\n                return;\\n            }\\n            dfs(root->right,preorder,index);\\n        }\\n        \\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++)\\n        {\\n            dfs(root,preorder,i);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1958826,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 2029849,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1938707,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 2019509,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1973428,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1932435,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1845374,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1828935,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1827302,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1804609,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1958826,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 2029849,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1938707,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 2019509,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1973428,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1932435,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1845374,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1828935,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1827302,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1804609,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Complement of Base 10 Integer",
        "question_content": "<p>The <strong>complement</strong> of an integer is the integer you get when you flip all the <code>0</code>&#39;s to <code>1</code>&#39;s and all the <code>1</code>&#39;s to <code>0</code>&#39;s in its binary representation.</p>\n\n<ul>\n\t<li>For example, The integer <code>5</code> is <code>&quot;101&quot;</code> in binary and its <strong>complement</strong> is <code>&quot;010&quot;</code> which is the integer <code>2</code>.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>its complement</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 5 is &quot;101&quot; in binary, with complement &quot;010&quot; in binary, which is 2 in base-10.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 7\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> 7 is &quot;111&quot; in binary, with complement &quot;000&quot; in binary, which is 0 in base-10.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> 10 is &quot;1010&quot; in binary, with complement &quot;0101&quot; in binary, which is 5 in base-10.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt; 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 476: <a href=\"https://leetcode.com/problems/number-complement/\" target=\"_blank\">https://leetcode.com/problems/number-complement/</a></p>\n",
        "solutions": [
            {
                "id": 3544067,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int bitwiseComplement(int N) {\\n    int mask = 1;\\n\\n    while (mask < N)\\n      mask = (mask << 1) + 1;\\n\\n    return mask ^ N;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        cnt=0\\n        ans=0\\n        if n==0:\\n            return 1\\n        while n>0:\\n            if n&1:\\n                cnt+=1\\n            else:\\n                ans =ans +(2**cnt)\\n                cnt+=1\\n            n=n>>1\\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0) return 1;\\n        int res = 0;\\n        int fac = 1;\\n        \\n        while(n != 0){\\n            res += fac * (n % 2 == 0 ? 1 : 0);\\n            fac *= 2;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int bitwiseComplement(int N) {\\n    int mask = 1;\\n\\n    while (mask < N)\\n      mask = (mask << 1) + 1;\\n\\n    return mask ^ N;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        cnt=0\\n        ans=0\\n        if n==0:\\n            return 1\\n        while n>0:\\n            if n&1:\\n                cnt+=1\\n            else:\\n                ans =ans +(2**cnt)\\n                cnt+=1\\n            n=n>>1\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0) return 1;\\n        int res = 0;\\n        int fac = 1;\\n        \\n        while(n != 0){\\n            res += fac * (n % 2 == 0 ? 1 : 0);\\n            fac *= 2;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256740,
                "title": "java-c-python-find-111-1111-n",
                "content": "## **Hints**\\n1. what is the relationship between input and output\\n2. input + output = 111....11 in binary format\\n3. Is there any corner case?\\n4. 0 is a corner case expecting 1, output > input\\n\\n\\n## **Intuition**\\nLet\\'s find the first number `X` that `X = 1111....1 > N`\\nAnd also, it has to be noticed that,\\n`N = 0` is a corner case expecting`1` as result.\\n\\n<br>\\n\\n## **Solution 1**:\\n`N + bitwiseComplement(N) = 11....11 = X`\\nThen `bitwiseComplement(N) = X - N`\\n\\n**Java:**\\n```\\n    public int bitwiseComplement(int N) {\\n        int X = 1;\\n        while (N > X) X = X * 2 + 1;\\n        return X - N;\\n    }\\n```\\n\\n**C++:**\\n```\\n    int bitwiseComplement(int N) {\\n        int X = 1;\\n        while (N > X) X = X * 2 + 1;\\n        return X - N;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def bitwiseComplement(self, N):\\n        X = 1\\n        while N > X: X = X * 2 + 1\\n        return X - N\\n```\\n<br>\\n\\n## **Solution 2**:\\n`N ^ bitwiseComplement(N) = 11....11 = X`\\n`bitwiseComplement(N) = N ^ X`\\n\\n**Java:**\\n```\\n    public int bitwiseComplement(int N) {\\n        int X = 1;\\n        while (N > X) X = X * 2 + 1;\\n        return N ^ X;\\n    }\\n```\\n\\n**C++:**\\n```\\n    int bitwiseComplement(int N) {\\n        int X = 1;\\n        while (N > X) X = X * 2 + 1;\\n        return N ^ X;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def bitwiseComplement(self, N):\\n        X = 1\\n        while N > X: X = X * 2 + 1;\\n        return N ^ X\\n```\\n<br>\\n\\n## **Complexity**\\n`O(logN)` Time\\n`O(1)` Space\\n<br>\\n\\n## Python 1-lines\\nUse `bin`\\n```\\n    def bitwiseComplement(self, N):\\n        return (1 << len(bin(N)) >> 2) - N - 1\\n```\\nUse `translate`\\n```\\n    def bitwiseComplement(self, N):\\n        return int(bin(N)[2:].translate(string.maketrans(\\'01\\', \\'10\\')), 2)\\n```",
                "solutionTags": [],
                "code": "```\\n    public int bitwiseComplement(int N) {\\n        int X = 1;\\n        while (N > X) X = X * 2 + 1;\\n        return X - N;\\n    }\\n```\n```\\n    int bitwiseComplement(int N) {\\n        int X = 1;\\n        while (N > X) X = X * 2 + 1;\\n        return X - N;\\n    }\\n```\n```\\n    def bitwiseComplement(self, N):\\n        X = 1\\n        while N > X: X = X * 2 + 1\\n        return X - N\\n```\n```\\n    public int bitwiseComplement(int N) {\\n        int X = 1;\\n        while (N > X) X = X * 2 + 1;\\n        return N ^ X;\\n    }\\n```\n```\\n    int bitwiseComplement(int N) {\\n        int X = 1;\\n        while (N > X) X = X * 2 + 1;\\n        return N ^ X;\\n    }\\n```\n```\\n    def bitwiseComplement(self, N):\\n        X = 1\\n        while N > X: X = X * 2 + 1;\\n        return N ^ X\\n```\n```\\n    def bitwiseComplement(self, N):\\n        return (1 << len(bin(N)) >> 2) - N - 1\\n```\n```\\n    def bitwiseComplement(self, N):\\n        return int(bin(N)[2:].translate(string.maketrans(\\'01\\', \\'10\\')), 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 256713,
                "title": "c-2-lines-xor-mask",
                "content": "We construct a XOR mask from all ones until it\\'s larger or equal than the number. For example, for ```100101```, the mask will be ```111111```. And for ```1111```, the mask will be ```1111```.\\n\\nThe result is the XOR operation of the number and the mask.\\n```\\nint bitwiseComplement(int N, int c = 1) {\\n  while (c < N) c = (c << 1) + 1;\\n  return N ^ c;\\n}\\n```",
                "solutionTags": [],
                "code": "```100101```\n```111111```\n```1111```\n```1111```\n```\\nint bitwiseComplement(int N, int c = 1) {\\n  while (c < N) c = (c << 1) + 1;\\n  return N ^ c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 613118,
                "title": "4-approaches-bitwise-operation-math-formular-one-naive-simulation-and-bonus",
                "content": "Find the smallest binary number c that is all 1s, (e.g. \\u201C111\\u201D, \\u201C11111\\u201D) that is greater or equal to N.\\nans = C ^ N or C \\u2013 N\\n\\nMore details:\\n^: bitwise XOR operator\\n**Table 1. The truth table of bitwise XOR operator:**\\n**1^0 = 1\\n1^1 = 0**\\n0^0 = 0\\n0^1 = 1\\n**The upper two rows  of Table 1 is used in the problem.**\\n\\n\\n\\nTime complexity: O(log(n))\\nSpace complexity: O(1)\\n\\nSolution 1:  bit shift based solution\\n```\\nclass Solution {// bit shift based solution\\npublic:\\n  int bitwiseComplement(int N) {\\n    int c = 1; // c = pow(2, x) \\u2013 1; c is the smallest number >= N\\n    while (c < N) \\n      c = (c << 1) | 1;\\n      //c = c*2 + 1;  same as above\\n    return N ^ c;  \\n    //return c - N; // also ok  \\n  }\\n};\\n```\\n\\nSolution 2: math based solution: log2, pow\\n\\n```\\nclass Solution { //math based solution: log2, pow\\npublic:\\n    int bitwiseComplement(int N) {        \\n        if(N == 0) return 1;\\n        int exponenet = (int)log2(N)+1;\\n        int flipper = (int)pow(2, exponenet)-1;            \\n        return N ^ flipper;\\n    }\\n};\\n```\\n\\nWhat, the above two solution is still too anti-human?!\\nOf course, it is.\\nIf you are still not comfortable with the above two methods due to too much specific knowledge about bit operation,\\nyou might find the last solution might be more natural :\\n\\nSolution 3:  naive simulation: find each single digit, then flip it\\n```\\nclass Solution { // BEST1: find each single digit, then flip it\\npublic:\\n    int findComplement(int num) {\\n        int res = 0, ind = 0;\\n        while(num > 0){\\n            //find single digit from low to high significance\\n            int digit = num % 2; \\n            int flippedDigit = (digit == 1? 0 : 1); // flip digit\\n            res += (flippedDigit << ind);\\n            num /= 2;            \\n            ind++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\nThis is a bonus solution: \\n\\nSolution 4:  Get all-1 mask by spreading 1 from most significant to the rest\\n```\\nclass Solution { // Get all-1 mask by spreading 1 from most significant to the rest:\\npublic://Time/Space: O(1); O(1)\\n    int findComplement(int num) {\\n\\t    if(num ==0) return 1;\\n        int mask = num;\\n        mask |= mask >> 1;\\n        mask |= mask >> 2;\\n        mask |= mask >> 4;\\n        mask |= mask >> 8;\\n        mask |= mask >> 16;\\n        return num ^ mask;\\n    }\\n};\\n\\n```\\nExplanation: \\n\\nTo understand the solution, we need to go backwards. The aim is to xor the given number with a mask. The mask should contain all 1s in its rightmost bits. However, the number of rightmost bits is important. In the case of 5(101), for example, the number of rightmost bits must be 3, since 5 uses 3 rightmost bits. The mask must be 111 for 5(101). When we xor 111 with 101, we will get 010. As another example, the mask will be 111111 for 38(100110)\\n\\nSo the problem boils down to generating the mask. Let\\'s think about 8-bit numbers. We can later extend the same logic to 32-bit integers. I will count the bits from right to left, starting with 1.\\n\\nThe largest positive numbers represented by 8 bits will set 7th bit to be 1.\\nIn binary format, they should be like:\\n01ABCDEF\\nwhere A,B,C,D,E,and F might be 0 or 1 and doesn\\'t matter.\\n\\nThe first operation, mask |= mask>>1; will set the 6th bit. So, mask will become (011bcdef). Once again, we do not care the actual value of c,d,e,f.\\nNow, we know that the 7th and 6th bits are set, we can safely shift the mask to right by not 1 but 2 bits. mask |= mask>>2; will now set the 5th and 4th bits. \\nBy the same reason, we can now shift the mask to right by not 1, 2 or 3 but 4 bits. \\nThat is the threshold for 8-bit numbers. We do not need to shift more.\\n\\nThe following is a detailed illustration with an example:\\n\\n```\\nNote1: 8-bit: 2^7-1, the large number is: 127\\nNote2: the first few positive numbers in 8-bit, must be in the format like: 01ABCDEF, where A,B,C,D,E,F belongs to [0,1]\\nFor example: \\n127 is: 01111111\\n126 is: 01111110\\n125 is: 01111101\\n..\\n\\n\\nLet\\'s assume: num = 64 to make our point:\\nmask =  num;  // this ensure the highest significance digit is same as that of num.\\n\\n01ABCDEF  (mask, we do not the value of A,B,C,D,E,F)         \\n\\nIllustration of operation: mask |= mask >> 1;\\n01ABCDEF\\n 01ABCDE\\n---------- OR\\n011?????\\n\\nIllustration of operation: mask |= mask >> 2;\\n011?????\\n  011???\\n---------- OR\\n01111???\\n\\nIllustration of operation: mask |= mask >> 4;\\n01111???\\n    0111\\n---------- OR\\n01111111\\n\\nWe found our goal: \\n01111111\\n\\n```\\n\\n\\n\\n\\nFor 32-bit integers, the shift operations should continue until reaching to 16. For 64-bit longs, that will be 32.\\n\\n\\nReference/Credit:\\nhttps://leetcode.com/problems/number-complement/discuss/96103/maybe-fewest-operations\\n",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\nclass Solution {// bit shift based solution\\npublic:\\n  int bitwiseComplement(int N) {\\n    int c = 1; // c = pow(2, x) \\u2013 1; c is the smallest number >= N\\n    while (c < N) \\n      c = (c << 1) | 1;\\n      //c = c*2 + 1;  same as above\\n    return N ^ c;  \\n    //return c - N; // also ok  \\n  }\\n};\\n```\n```\\nclass Solution { //math based solution: log2, pow\\npublic:\\n    int bitwiseComplement(int N) {        \\n        if(N == 0) return 1;\\n        int exponenet = (int)log2(N)+1;\\n        int flipper = (int)pow(2, exponenet)-1;            \\n        return N ^ flipper;\\n    }\\n};\\n```\n```\\nclass Solution { // BEST1: find each single digit, then flip it\\npublic:\\n    int findComplement(int num) {\\n        int res = 0, ind = 0;\\n        while(num > 0){\\n            //find single digit from low to high significance\\n            int digit = num % 2; \\n            int flippedDigit = (digit == 1? 0 : 1); // flip digit\\n            res += (flippedDigit << ind);\\n            num /= 2;            \\n            ind++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\n```\\nclass Solution { // Get all-1 mask by spreading 1 from most significant to the rest:\\npublic://Time/Space: O(1); O(1)\\n    int findComplement(int num) {\\n\\t    if(num ==0) return 1;\\n        int mask = num;\\n        mask |= mask >> 1;\\n        mask |= mask >> 2;\\n        mask |= mask >> 4;\\n        mask |= mask >> 8;\\n        mask |= mask >> 16;\\n        return num ^ mask;\\n    }\\n};\\n\\n```\n```\\nNote1: 8-bit: 2^7-1, the large number is: 127\\nNote2: the first few positive numbers in 8-bit, must be in the format like: 01ABCDEF, where A,B,C,D,E,F belongs to [0,1]\\nFor example: \\n127 is: 01111111\\n126 is: 01111110\\n125 is: 01111101\\n..\\n\\n\\nLet\\'s assume: num = 64 to make our point:\\nmask =  num;  // this ensure the highest significance digit is same as that of num.\\n\\n01ABCDEF  (mask, we do not the value of A,B,C,D,E,F)         \\n\\nIllustration of operation: mask |= mask >> 1;\\n01ABCDEF\\n 01ABCDE\\n---------- OR\\n011?????\\n\\nIllustration of operation: mask |= mask >> 2;\\n011?????\\n  011???\\n---------- OR\\n01111???\\n\\nIllustration of operation: mask |= mask >> 4;\\n01111???\\n    0111\\n---------- OR\\n01111111\\n\\nWe found our goal: \\n01111111\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665399,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanation-and-dry-run",
                "content": "Given a positive integer, output its **complement number**. The complement strategy is to flip the bits of its binary representation i.e if it\\'s **101** =Complement=> **010**\\n\\n**Intuition:-**\\nThere is not much of a intuition in this question as the question is loud and clear about it\\'s use of bit manipulation .\\n\\nTo make things a bit more interesting let\\'s do this question with and wihout bit manipulation \\n***\\n***\\n**Using Bit Manipulations:-**\\n***\\n**Bit masking can be summarized with this image (^_^)**\\n![image](https://assets.leetcode.com/users/images/d478c8d2-3fbb-49fd-956a-ae31a014a926_1640579005.4899502.jpeg) \\nThus, we can conclude that masking means to keep/change/remove a desired part of information.\\n***\\n**Dry run of bitmasking:-**\\n![image](https://assets.leetcode.com/users/images/face3402-7526-4282-becd-7564dc8b4a95_1640574890.4955626.png)\\n***\\n**Code[Using bitmasking]:-**\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int num) {\\n\\t\\t    //base case\\n        if(num == 0) return 1;\\n        unsigned mask = ~0;\\n        while( mask & num ) mask = mask << 1;\\n        return ~num ^ mask;\\n    }\\n};\\n```\\n**Time Complexity:** *`O(log(num))`*\\n**Space Complexity:** *`O(1)`*\\n***\\n***\\n**Using XOR**\\nBasic idea is to find the smallest power of 2 that is larger than the `input number num`, and output the difference between `powerof2s` and `num` . \\n\\n**Dry run of XOR:-**\\n```\\nFor example :-\\nInput: num = 5(101) ,\\nThus the smallest power of 2 (and just larger than 5) is 8 (1000)\\nThe output should be 8 - 5 - 1 = 2 (010).\\n```\\n**Code [using XOR]:-**\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int num) {\\n        int powerof2s = 2, temp = num;\\n        \\n        while(temp>>1) {\\n            temp >>= 1;\\n            powerof2s <<= 1;\\n        }\\n        \\n        return powerof2s - num - 1;\\n    }\\n};\\n```\\n\\n***\\n***\\n**Without using Bit manipulation:-**\\n***\\n**Algorithm:-**\\n1. At start convert convert the decimal number to its binary representation \\n2. Then start overriding the bits with 1 as 0 and 0 with 1 .\\n3. Then again start converting the binary representation back to decimal representation .\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int num) {\\n        //base case\\n        if(num==0) return 1;\\n        vector<int> temp; \\n\\t\\t// convert to binary representation\\n        while( num != 0 ){\\n            temp.push_back( num % 2 );\\n            num /= 2;\\n        } \\n\\t\\t// make complement\\n        for(int i=0; i<temp.size(); i++){\\n            if( temp[i] == 1 ) temp[i] = 0;\\n            else if( temp[i] == 0 ) temp[i] = 1;\\n        } int res = 0;\\n\\t\\t//Again convert them back to decimal representation \\n        for(int i=temp.size()-1; i>-1; i--) res = res * 2 + temp[i];\\n        return res;\\n    }\\n};\\n```\\n**An optmization of the above code:- #Credit goes to @bakar7**\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n\\n        int answer = 0;\\n        int power = 1;\\n        while (n) {\\n            answer += ((1 - (n % 2)) * power);\\n            n /= 2;\\n            power *= 2;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n***\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n***\\n**If you have some doubts feel free to bug me anytime or If you understood than don\\'t forget to *upvote*;)**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int num) {\\n\\t\\t    //base case\\n        if(num == 0) return 1;\\n        unsigned mask = ~0;\\n        while( mask & num ) mask = mask << 1;\\n        return ~num ^ mask;\\n    }\\n};\\n```\n```\\nFor example :-\\nInput: num = 5(101) ,\\nThus the smallest power of 2 (and just larger than 5) is 8 (1000)\\nThe output should be 8 - 5 - 1 = 2 (010).\\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int num) {\\n        int powerof2s = 2, temp = num;\\n        \\n        while(temp>>1) {\\n            temp >>= 1;\\n            powerof2s <<= 1;\\n        }\\n        \\n        return powerof2s - num - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int num) {\\n        //base case\\n        if(num==0) return 1;\\n        vector<int> temp; \\n\\t\\t// convert to binary representation\\n        while( num != 0 ){\\n            temp.push_back( num % 2 );\\n            num /= 2;\\n        } \\n\\t\\t// make complement\\n        for(int i=0; i<temp.size(); i++){\\n            if( temp[i] == 1 ) temp[i] = 0;\\n            else if( temp[i] == 0 ) temp[i] = 1;\\n        } int res = 0;\\n\\t\\t//Again convert them back to decimal representation \\n        for(int i=temp.size()-1; i>-1; i--) res = res * 2 + temp[i];\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n\\n        int answer = 0;\\n        int power = 1;\\n        while (n) {\\n            answer += ((1 - (n % 2)) * power);\\n            n /= 2;\\n            power *= 2;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665344,
                "title": "well-explained-java-c-2-approaches-easy-for-mind-to-accept-it",
                "content": "**Intitution**\\n```\\nWe have to convert 5 -----> 101 -----> 010 ------> 2\\nSteps:                   1           2           3\\n```\\n\\n\\n**Method - 1 :**\\n**Approach to use:**\\n```\\nNow we take modulo of 5 i.e.  % 2 ----> 1     ^\\n\\t\\t\\t\\t\\t\\t\\t\\t2 ----> 0     |\\n\\t\\t\\t\\t\\t\\t\\t\\t1 ----> 1     |\\n\\t\\tand finally it become\\'s 0 \\n\\nWhat I did is we take modulo of 5 i.e. 5 % 2 = 1 ;then divide by 2 i.e         5 / 2 = 2;\\nagain modulo of 2 i.e                  2 % 2 = 0 ;then again we divide by 2    2 / 2 = 1;\\n\\n\\ngoing from down to top, we will get 101, now by compliment we can convert 101 to 010\\n\\nNow for 010, taking least significant digit. we go from right to left\\ni.e. 0 * 2^0\\n    +1 * 2^1\\n    +0 * 2^2\\n    ---------\\n    =   2\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0) return 1; // Checking for base case\\n        int res = 0;\\n        int fac = 1; // keep for 2 basically\\n        \\n        while(n != 0){\\n            // first we need to check what is our bit in 2 by taking modulo\\n            res += fac * (n % 2 == 0 ? 1 : 0);\\n            // res is the number convert back to decimal + factor * n % 2 if comes 0 then we take 1 otherwise 0 this is our complement\\n            \\n            fac *= 2;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n == 0) return 1; // Checking for base case\\n        int res = 0;\\n        int fac = 1; // keep for 2 basically\\n        \\n        while(n != 0){\\n            // first we need to check what is our bit in 2 by taking modulo\\n            res += fac * (n % 2 == 0 ? 1 : 0);\\n            // res is the number convert back to decimal + factor * n % 2 if comes 0 then we take 1 otherwise 0 this is our complement\\n            \\n            fac *= 2;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n};\\n```\\nANALYSIS:-\\n* **Time Complexity :-** BigO(logN)\\n\\n* **Space Complexity :-** BigO(1)\\n![image](https://assets.leetcode.com/users/images/55231346-ad58-4695-9b4c-98e457c0b9a2_1641273713.176929.png)\\n**Method - 2 :**\\n**Approach to use:**\\n```\\n5 -> 101 ^ 010 -> 111 // taking XOR of it\\'s no and complement we get 111\\n\\n10 - > 1010 ^ 0101 -> 1111\\n\\nSo, looking at above example we can say that,\\n                    A ^ B = C\\nthen,                    \\n                    A ^ A ^ B = A ^ C\\nbut                 A ^ A is 0;\\ntherefore,          0 ^ B is B;\\nHence we can say    B = A ^ C\\n\\nSo, these property of XOR apply in our case\\n\\nLet say our no is \"N\" and no we have to find is \"X\"\\nlet say N ^ X gives [111....] something,\\nwhere 111 is length of our N\\nand X = [1111..] length is same as binary representation of N\\n\\nSo, from this the formula we get is :\\n        -----------------\\n        X = [1111...] ^ N\\n        -----------------\\n        \\nBut here thing is how we will get [1111...], in java we have method by taking Integer.toBinaryString(). \\nAfter taking length we will do first bitwise left shift of 1\\ni.e  1 << 3  gives   1000\\nand if i subtract      -1\\ngives                 111\\n\\nthis is what i need in case of N = 5, where the length of my binary representation is 3\\n\\nSo, that\\'s how we gonna do it.\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        return n == 0 ? 1 : ((1 << Integer.toBinaryString(n).length()) - 1) ^ n;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        return n>0? (int)((1ll<<((int)log2(n)+1))-1)^n : 1;\\n    }\\n};\\n\\n```\\nANALYSIS:-\\n* **Time Complexity :-** BigO(logN)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n*Guys, If you downvote. Please do let me know in comment section. What\\'s wrong with the code or explanation. So, that I can correct and improve it. \\nThanks (:*",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nWe have to convert 5 -----> 101 -----> 010 ------> 2\\nSteps:                   1           2           3\\n```\n```\\nNow we take modulo of 5 i.e.  % 2 ----> 1     ^\\n\\t\\t\\t\\t\\t\\t\\t\\t2 ----> 0     |\\n\\t\\t\\t\\t\\t\\t\\t\\t1 ----> 1     |\\n\\t\\tand finally it become\\'s 0 \\n\\nWhat I did is we take modulo of 5 i.e. 5 % 2 = 1 ;then divide by 2 i.e         5 / 2 = 2;\\nagain modulo of 2 i.e                  2 % 2 = 0 ;then again we divide by 2    2 / 2 = 1;\\n\\n\\ngoing from down to top, we will get 101, now by compliment we can convert 101 to 010\\n\\nNow for 010, taking least significant digit. we go from right to left\\ni.e. 0 * 2^0\\n    +1 * 2^1\\n    +0 * 2^2\\n    ---------\\n    =   2\\n```\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0) return 1; // Checking for base case\\n        int res = 0;\\n        int fac = 1; // keep for 2 basically\\n        \\n        while(n != 0){\\n            // first we need to check what is our bit in 2 by taking modulo\\n            res += fac * (n % 2 == 0 ? 1 : 0);\\n            // res is the number convert back to decimal + factor * n % 2 if comes 0 then we take 1 otherwise 0 this is our complement\\n            \\n            fac *= 2;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n == 0) return 1; // Checking for base case\\n        int res = 0;\\n        int fac = 1; // keep for 2 basically\\n        \\n        while(n != 0){\\n            // first we need to check what is our bit in 2 by taking modulo\\n            res += fac * (n % 2 == 0 ? 1 : 0);\\n            // res is the number convert back to decimal + factor * n % 2 if comes 0 then we take 1 otherwise 0 this is our complement\\n            \\n            fac *= 2;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n5 -> 101 ^ 010 -> 111 // taking XOR of it\\'s no and complement we get 111\\n\\n10 - > 1010 ^ 0101 -> 1111\\n\\nSo, looking at above example we can say that,\\n                    A ^ B = C\\nthen,                    \\n                    A ^ A ^ B = A ^ C\\nbut                 A ^ A is 0;\\ntherefore,          0 ^ B is B;\\nHence we can say    B = A ^ C\\n\\nSo, these property of XOR apply in our case\\n\\nLet say our no is \"N\" and no we have to find is \"X\"\\nlet say N ^ X gives [111....] something,\\nwhere 111 is length of our N\\nand X = [1111..] length is same as binary representation of N\\n\\nSo, from this the formula we get is :\\n        -----------------\\n        X = [1111...] ^ N\\n        -----------------\\n        \\nBut here thing is how we will get [1111...], in java we have method by taking Integer.toBinaryString(). \\nAfter taking length we will do first bitwise left shift of 1\\ni.e  1 << 3  gives   1000\\nand if i subtract      -1\\ngives                 111\\n\\nthis is what i need in case of N = 5, where the length of my binary representation is 3\\n\\nSo, that\\'s how we gonna do it.\\n```\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        return n == 0 ? 1 : ((1 << Integer.toBinaryString(n).length()) - 1) ^ n;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        return n>0? (int)((1ll<<((int)log2(n)+1))-1)^n : 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613984,
                "title": "c-0ms-solution-using-bitwise-operation",
                "content": "The idea is to find the bit length of N, construct a string of 1\\'s with the same length, and XOR with N.\\n\\nFor example, 5 in binary is 101. Notice that 101 ^ 111 = 010 (2 in decimal).\\n\\n    int bitwiseComplement(int N) {\\n        int comp = 1;\\n        while (comp < N) \\n            comp = (comp << 1) | 1;\\n        return N ^ comp;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "The idea is to find the bit length of N, construct a string of 1\\'s with the same length, and XOR with N.\\n\\nFor example, 5 in binary is 101. Notice that 101 ^ 111 = 010 (2 in decimal).\\n\\n    int bitwiseComplement(int N) {\\n        int comp = 1;\\n        while (comp < N) \\n            comp = (comp << 1) | 1;\\n        return N ^ comp;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3564754,
                "title": "c-100-beats-full-explanation-1009-complement-of-base-10-integer",
                "content": "![upvote.gif](https://assets.leetcode.com/users/images/433ee6d4-8078-4081-b1d2-2ece5867c239_1685109587.650445.gif)\\n\\n# \\u2B06\\uFE0FPlease Upvote If You Like the Solution :)\\n\\n# Approach\\n1. We know that we need to complement. For that we need to change `0` to `1` and `1` to `0`.\\n\\n2. We need to think, what can we use here from our bitwise operators `(i.e &, |, ^, ~)`.\\n\\n3. Suppose we have,\\n\\n```\\nEx. n = 10, binary-> 1010\\n    1 0 1 0\\n    x x x x\\n  -----------\\n    0 1 0 1\\n\\n```\\n4. Think if we `xor` the `n` with `1111 (mask)`, we will get our desired answer. Like, \\n\\n```\\n    1 0 1 0\\n    1 1 1 1   ==> mask\\n  ----------- ==> XOR\\n    0 1 0 1\\n```\\n\\n5. Now we just need to make `mask`, for that we can take `1` and do `(left shit + add one)` to make it `1111`. Like, \\n\\n```\\nmask -> 0 0 0 1 \\n        0 0 1 0 ==> left shift (mask << 1)\\n        0 0 1 1 ==> add 1 (mask + 1)\\n```\\n\\n6. we know that if we do `&` of `n` with `1111` then we will get that `n` itself.\\n\\n7. so we will do the `5th step` until `((mask & n) != n)`.\\n\\n8. At last we can able to make `1111 (mask)` and now return `(mask ^ n)`, see `4th step`. \\n\\n# Complexity\\n- Time complexity: O(ceil(log(n)))\\n- Space complexity: O(1)\\n\\n**Why Time complexity: O(ceil(log(n)))???**\\n\\n1. we are running the while loop for the number of bit of n. \\n n = 2^x ==> (x = number of bits).\\n Ex. n = 10, binary -> 1 0 1 0 (4 bits)\\n    10 = 2^x\\n    log2(10) = x\\n    ceil (log2(10)) = x, \\n\\n2. log2(10) == 3.322, but we represent 10 in 4 bits so take ceil value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int mask = 1;\\n        \\n        while((mask & n) != n){\\n            mask = mask << 1;\\n            mask += 1;\\n        }\\n        return mask ^ n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nEx. n = 10, binary-> 1010\\n    1 0 1 0\\n    x x x x\\n  -----------\\n    0 1 0 1\\n\\n```\n```\\n    1 0 1 0\\n    1 1 1 1   ==> mask\\n  ----------- ==> XOR\\n    0 1 0 1\\n```\n```\\nmask -> 0 0 0 1 \\n        0 0 1 0 ==> left shift (mask << 1)\\n        0 0 1 1 ==> add 1 (mask + 1)\\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int mask = 1;\\n        \\n        while((mask & n) != n){\\n            mask = mask << 1;\\n            mask += 1;\\n        }\\n        return mask ^ n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665646,
                "title": "c-python-java-1-line-o-1-log-and-bit-op-detailed-explanation",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* step 1: get the `mask` of all 1s with the number of binary digits equal to the number of binary digits of n\\n\\t* for example\\n\\t\\t* `n = 5 = 0b101` so the number of binary digits is `3` and we get `mask = 0b111 = 7`\\n\\t\\t* `n = 8 = 0b1000` so the number of binary digits is `4` and we get `mask = 0b1111 = 15`\\n\\t\\t* `n = 0 = 0b0` so the number of binary digits is `1` and we get `mask = 0b1 = 1`\\n\\t* `mask = (2 << int(log2(n))) - 1`\\n\\t\\t* for example: `n = 5` => `int(log2(n)) = 2` => `mask = (2 << 2) - 1 = (0b10 << 2) - 1 = 0b1000 - 1 = 0b111 = 7`\\n\\t\\t* **Note `n = 0` is an exception, we just add `max(n, 1)` to deal with it.**\\n* step 2: `return mask - n` or `return mask ^ n` or `return mask & (~n)`\\n\\t* since mask is all-one like `0b11...1` and with same number of binary digits of `n`, `mask - n` is the complement of n\\n\\t* for example\\n\\t\\t* `n = 5 = 0b101`  => `mask = 0b111 = 7` => `mask - n = 0b111 - 0b101 = 0b010 = 2`\\n\\t\\t* `n = 8 = 0b1000` => `mask = 0b1111 = 15` => `mask - n = 0b1111 - 0b1000 = 0b111 = 7`\\n\\n@pgthebigshot reminded me that `mask - n` also works, really smart!\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        return ((2 << int(log2(max(n, 1)))) - 1) - n;\\n\\t\\t// return ((2 << int(log2(max(n, 1)))) - 1) ^ n; // also work\\n        // return ((2 << int(log2(max(n, 1)))) - 1) & (~n); // also work\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n\\t\\treturn ((2 << (int)(Math.log(Math.max(n, 1)) / Math.log(2))) - 1) - n;\\n        // return ((2 << (int)(Math.log(Math.max(n, 1)) / Math.log(2))) - 1) ^ n; // also work\\n        // return ((2 << (int)(Math.log(Math.max(n, 1)) / Math.log(2))) - 1) & (~n); // also work\\n    }\\n}\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def bitwiseComplement(self, n):\\n\\t\\treturn ((2 << int(math.log(max(n, 1), 2))) - 1) - n\\n        # return ((2 << int(math.log(max(n, 1), 2))) - 1) ^ n  # also work\\n        # return ((2 << int(math.log(max(n, 1), 2))) - 1) & (~n)  # also work\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        return ((2 << int(log2(max(n, 1)))) - 1) - n;\\n\\t\\t// return ((2 << int(log2(max(n, 1)))) - 1) ^ n; // also work\\n        // return ((2 << int(log2(max(n, 1)))) - 1) & (~n); // also work\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n\\t\\treturn ((2 << (int)(Math.log(Math.max(n, 1)) / Math.log(2))) - 1) - n;\\n        // return ((2 << (int)(Math.log(Math.max(n, 1)) / Math.log(2))) - 1) ^ n; // also work\\n        // return ((2 << (int)(Math.log(Math.max(n, 1)) / Math.log(2))) - 1) & (~n); // also work\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def bitwiseComplement(self, n):\\n\\t\\treturn ((2 << int(math.log(max(n, 1), 2))) - 1) - n\\n        # return ((2 << int(math.log(max(n, 1), 2))) - 1) ^ n  # also work\\n        # return ((2 << int(math.log(max(n, 1), 2))) - 1) & (~n)  # also work\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665368,
                "title": "c-java-python-easy-solution-mask-xor-100",
                "content": "# C++ | Mask + XOR\\n**Logic:** In order to find the complement of an integer we have to flip all the ``0\\'s`` to ``1\\'s ``and all the ``1\\'s`` to ``0\\'s``. We know that XOR means one or the other is true but not both. So if we XOR our input with a mask ``11111...``, flipping will happen and we will get our the desired result (complement of that number).\\n\\n``N ^ bitwiseComplement(N) = 11....11 = Mask``\\n``bitwiseComplement(N) = N ^ Mask ``\\n\\n**Approach:** we will create a mask of all ones until it\\'s larger or equal to the number. For example, for ``1010``, the mask will be ``1111``. Once the mask is created, we will XOR it with Number to get the complement.\\n```\\n 1010\\n^1111\\n------\\n 0101\\n------\\n```\\n\\n**We have 2 Method based on ways of creating mask:**\\n\\n**Method 1:** \\n\\nCreating mask by using n<<2+1:\\n```\\n(number) => (how-number-is-derived)=>binary-string\\nn = 1 => 1 => 1\\nn = 3 => (2*1 + 1) => 11\\nn = 7 => (3*2 + 1) => 111\\nn = 15 => (7*2 + 1) => 1111\\n```\\n\\n*Complexity*\\nTime: O(logn) i.e, O(no of digits in n)\\nSpace: O(1)\\n\\n*Code*\\n<iframe src=\"https://leetcode.com/playground/YqGUiZuv/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>\\n\\n**Method 2:**\\nCreate mask by bits count:\\n```\\nfor example, if we take 1010\\n(int)(log2(n)+1=> total bits in n =>4\\n(int) pow(2, (int)(log2(n)+1) )-1=>  binary representation consist of (no of bits) ones=>1111\\n```\\n\\n*Complexity*\\nTime: O(log N) since log function has time complexity of log N. \\nSpace: O(1)\\n\\n*Code:*\\n```\\nint bitwiseComplement(int n) {\\n    return n ? n ^ (int) pow(2, (int)(log2(n)+1) )-1 : 1;\\n}\\n```\\n\\nPlease Upvote! if find helpful \\nGuys, if you downvote the post make sure to leave a reason so that I can correct those points, suggestion are welcomed :)\\nFind me on: https://coderaky.com\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n 1010\\n^1111\\n------\\n 0101\\n------\\n```\n```\\n(number) => (how-number-is-derived)=>binary-string\\nn = 1 => 1 => 1\\nn = 3 => (2*1 + 1) => 11\\nn = 7 => (3*2 + 1) => 111\\nn = 15 => (7*2 + 1) => 1111\\n```\n```\\nfor example, if we take 1010\\n(int)(log2(n)+1=> total bits in n =>4\\n(int) pow(2, (int)(log2(n)+1) )-1=>  binary representation consist of (no of bits) ones=>1111\\n```\n```\\nint bitwiseComplement(int n) {\\n    return n ? n ^ (int) pow(2, (int)(log2(n)+1) )-1 : 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880072,
                "title": "python-oneliner-explained",
                "content": "What we actually need to find in this problem is length of our number in bits: if we have `10 = 1010`, then complementary is `5 = 101`. Note, that `5 + 10 = 15 = 2^4 - 1`. So, let us just find length of our number in bits and subtract `N-1`.\\n\\n**Complexity** time complexity is `O(log N)` to find its length; space complexity is also `O(log N)` to keep binary representation of our number.\\n\\n```\\nclass Solution:\\n    def bitwiseComplement(self, N):\\n         return (1<<(len(bin(N)) - 2)) - 1 - N\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, N):\\n         return (1<<(len(bin(N)) - 2)) - 1 - N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292033,
                "title": "python-4-lines-faster-than-99-memory-less-than-100",
                "content": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        P = 2\\n        while P <= N:\\n            P *= 2\\n        return P - 1 - N\\n```\\nIf P is the smallest power of 2 larger than N, then N and its binary complement M satisfies N+M=P-1.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        P = 2\\n        while P <= N:\\n            P *= 2\\n        return P - 1 - N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258500,
                "title": "java-0ms-32mb-beats-100",
                "content": "**Intuition:**\\nWe want to XOR N\\'s binary with an array of 1\\'s of the same length.\\n**Approach:**\\nFind out how long N is (via while loop.... 2^y=N).\\nThen we subtract 1 from our number, and we will get an array of 1\\'s in binary.\\n(ie. if x=2^8, then x-1 in binary is \"1111 1111\").\\n\\n\\n\\n```\\nclass Solution {\\n    public int bitwiseComplement(int N) {\\n        if (N == 0) return 1;\\n        if (N == 1) return 0;\\n        int x = 1;\\n        while(x<= N){\\n             x = x << 1;  // equialently written as x*=2;\\n        }\\n        return N ^ (x-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int N) {\\n        if (N == 0) return 1;\\n        if (N == 1) return 0;\\n        int x = 1;\\n        while(x<= N){\\n             x = x << 1;  // equialently written as x*=2;\\n        }\\n        return N ^ (x-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666325,
                "title": "c-100-faster-beginner-friendly-simple-math",
                "content": "```\\nint bitwiseComplement(int n) {\\n        int i;\\n        for(i=0;i<=n;)\\n        {\\n            i=(i*2)+1;\\n            if(n<=i)\\n                break;\\n        }\\n        return i-n;    \\n    }\\n```\\t\\n\\n\\n**If you have some doubts feel free to ask me.**\\nIt\\'s my first post on leetcode.If you like it please upvote.",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint bitwiseComplement(int n) {\\n        int i;\\n        for(i=0;i<=n;)\\n        {\\n            i=(i*2)+1;\\n            if(n<=i)\\n                break;\\n        }\\n        return i-n;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1665492,
                "title": "java-detailed-explanation-of-intution-bit-masking-bit-flip-5-approach",
                "content": "*Intution:* Since we have to find the complement of a given decimal number in binary form, we will use the complement property which is N + Compliment(N) = 111....111.\\nFoe Example : \\n* N = 5 => N = 101 , Compliment(N) = 010 => 101 + 010 = 111\\n* N = 8 => N = 1000 , Compliment(N) = 0111 => 1000 + 0111 = 1111\\n* N = 17 => N = 10001, Compliment(N) = 01110 => 10001 + 01110 = 11111  and so on....\\n\\nSo we need to find out a number just greater than N having all 1 bits and then subtract N from it to get the complement.\\nExample : for N=5(101) => 111 is the number just greater than 5 having all 1s. So, 111 - 101 = 010 (Compliment)\\n\\n***Approach1: (1ms)***\\n*Explanation:* let n = 5 and i=0, j=0\\n* Iteration1 : (i=0 < n) =>  i = 0 + (2^0) = 1 (1) , j = 1\\n* Iteration2 : (i=1 < n) =>  i = 1 + (2^1) = 3  (11) , j = 2\\n* Iteration3 : (i=3 < n) =>  i = 3 + (2^2) = 7 (111) , j = 3\\n* Iteration4 : (i=7 > n) =>  loop breaks\\nCompliment = i -n => 111 - 101 = 010\\n```\\n\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i<n){\\n            i += Math.pow(2,j);\\n            j++;\\n        }\\n        \\n        return i-n;\\n    }\\n}\\n```\\n\\n\\n***Approach2: (0ms)***\\n*Explanation:* Just replace the arithmetical operation into bit manipulation as i += Math.pow(2^j) can be replaced with i<<n | 1.  Let n = 5 and i=0, j=0\\n* Iteration1 : (i=0 < n) =>  i =0<<1 | 1 = 1 | 1 = 1\\n* Iteration2 : (i=1 < n) =>  i = 1<<1 | 1 = 10 | 1 = 11 = 3\\n* Iteration3 : (i=3 < n) =>  i = 3<<1 | 1 = 11<<1 | 1 = 110 | 1 = 111 = 7\\n* Iteration4 : (i=7 > n) =>  loop breaks\\nCompliment = i -n => 111 - 101 = 010\\n\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        \\n        int i = 0;\\n        \\n        while(i<n){\\n            i = i<<1 | 1;\\n        }\\n        \\n        return i-n;\\n    }\\n}\\n```\\n\\n\\n***Approach3: (0ms)***\\n*Explanation:* let n = 10 and i=1, j=0\\n* Iteration1 : (i=1 < n) =>  i = 1 * 2 +1 = 3 (11)\\n* Iteration2 : (i=3 < n) =>  i = 3 * 2 + 1 = 7  (111) \\n* Iteration3 : (i=7 < n) =>  i = 7 * 2 + 1 = 15 (1111)\\n* Iteration4 : (i=15 > n) =>  loop breaks\\nCompliment = i -n => 1111 - 1010 = 0101 => 101 = 5\\n\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n               \\n        int i = 1;\\n        \\n        while(i<n){\\n            i = i*2 + 1;\\n        }\\n        \\n        return i-n;\\n    }\\n}\\n```\\n\\n\\n\\n*In every approach at last I am calculating compliment using i - n, which can also be done using **XOR* as *i ^n  will give the compliment*:\\n* i = 111 , n = 101 (5) => i ^ n = 111 ^ 101 = 010 (compliment)\\n* i = 1111, n = 1010 (10) => i ^ n = 1111 ^ 1010 = 0101 (compliment)\\n\\n\\n***Approach4: (0ms)*** : Using Xor Property\\n  In complement of n , every bit is opposite to n\\n* so at every place we have odd number of 1 so xor will be 1 at every place\\n* n^bitwiseComplement(n) =  111....1\\n\\n```\\nMath:\\na xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a\\n```\\n\\n* n^111....1 =  bitwiseComplement(n)\\n* FInd the upper bound Number which has all 1\\'s, Number just greater than n, will all bit 1\\n```\\n  Suppose N= 5\\n  X = 2+1   = 3 ,   6+1   = 7 \\n  X>N , X^N = 111^101 = 010\\n```\\n \\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\t     \\n      int X = 1;          \\n      while(X<n) X= X*2+1;\\n      return X^n;        \\n    }\\n}\\n```\\n\\n\\n***Approach5: (0ms)***  : Using Masking\\nConsider N =  10 ( 1010 )\\nWe will start processing from right most bit (LSB) , Using **i** Variable we will we track bit , if it is set then we will unset it or vice-versa.\\n\\n```\\ni=0 , intial bit position\\nif  n&1  == 0  means last bit is unset , so set it \\n   result += 1<<i;\\nand if set then it will set to unset \\n\\n\\t i++;// move to next bit position\\n\\tn >>= 1; // now move to second last bit or right shift to process next bit\\n```\\nfor 0 index , it is 0   bit set to 1\\nfor 2 index bit , it is 0 bit set to 1\\n**result =  1 + 100 =  0101**\\n\\n\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        \\n        int result = 0;\\n        int i = 0;        \\n        while(n>0){\\n            if((n&1) == 0){\\n                result += 1<<i;\\n            }\\n            i++;\\n            n >>= 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n  \\n\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i<n){\\n            i += Math.pow(2,j);\\n            j++;\\n        }\\n        \\n        return i-n;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        \\n        int i = 0;\\n        \\n        while(i<n){\\n            i = i<<1 | 1;\\n        }\\n        \\n        return i-n;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n               \\n        int i = 1;\\n        \\n        while(i<n){\\n            i = i*2 + 1;\\n        }\\n        \\n        return i-n;\\n    }\\n}\\n```\n```\\nMath:\\na xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a\\n```\n```\\n  Suppose N= 5\\n  X = 2+1   = 3 ,   6+1   = 7 \\n  X>N , X^N = 111^101 = 010\\n```\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\t     \\n      int X = 1;          \\n      while(X<n) X= X*2+1;\\n      return X^n;        \\n    }\\n}\\n```\n```\\ni=0 , intial bit position\\nif  n&1  == 0  means last bit is unset , so set it \\n   result += 1<<i;\\nand if set then it will set to unset \\n\\n\\t i++;// move to next bit position\\n\\tn >>= 1; // now move to second last bit or right shift to process next bit\\n```\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        \\n        int result = 0;\\n        int i = 0;        \\n        while(n>0){\\n            if((n&1) == 0){\\n                result += 1<<i;\\n            }\\n            i++;\\n            n >>= 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272344,
                "title": "c-100-faster-easy-to-understand-clean-and-efficient",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n       int sum=0,i=0;\\n        if(n==0)\\n          return 1;  \\n        while(n>0)\\n        {\\n            if(n%2==0)\\n            {\\n                sum+=1*pow(2,i);\\n                i++;\\n                n=n/2;\\n            }\\n            else\\n            {\\n                 i++;\\n                    n=n/2;\\n            }\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n       int sum=0,i=0;\\n        if(n==0)\\n          return 1;  \\n        while(n>0)\\n        {\\n            if(n%2==0)\\n            {\\n                sum+=1*pow(2,i);\\n                i++;\\n                n=n/2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1234885,
                "title": "solution-swift-complement-of-base-10-integer-test-cases",
                "content": "```swift\\nclass Solution {\\n    func bitwiseComplement(_ n: Int) -> Int {\\n        var s: Int = 1\\n        while s < n { s = (s << 1) | 1 }\\n        return s - n\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.005 (0.006) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// 5 is \"101\" in binary, with complement \"010\" in binary, which is 2 in base-10.\\n    func test1() {\\n        let value = solution.bitwiseComplement(5)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    /// 7 is \"111\" in binary, with complement \"000\" in binary, which is 0 in base-10.\\n    func test2() {\\n        let value = solution.bitwiseComplement(7)\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    /// 10 is \"1010\" in binary, with complement \"0101\" in binary, which is 5 in base-10.\\n    func test3() {\\n        let value = solution.bitwiseComplement(10)\\n        XCTAssertEqual(value, 5)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func bitwiseComplement(_ n: Int) -> Int {\\n        var s: Int = 1\\n        while s < n { s = (s << 1) | 1 }\\n        return s - n\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// 5 is \"101\" in binary, with complement \"010\" in binary, which is 2 in base-10.\\n    func test1() {\\n        let value = solution.bitwiseComplement(5)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    /// 7 is \"111\" in binary, with complement \"000\" in binary, which is 0 in base-10.\\n    func test2() {\\n        let value = solution.bitwiseComplement(7)\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    /// 10 is \"1010\" in binary, with complement \"0101\" in binary, which is 5 in base-10.\\n    func test3() {\\n        let value = solution.bitwiseComplement(10)\\n        XCTAssertEqual(value, 5)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612724,
                "title": "idiots-solution-for-python-3-100-no-loops-bit-manipulation",
                "content": "Take the next power of 2 that is bigger than N, then subtract 1 from it to get the number that has the same leftmost bit, but with all of the bits to the right filled. \\n\\nSubtract N from this number and you will get the bits to the right that are 0 converted to 1, which is what you are looking for, e.g. 010 as input, 011 as the number you calculate, 011-010 = 001. There is only one edge case for this solution at N == 0. \\n\\n    def bitwiseComplement(self, N: int) -> int:\\n        if N == 0: \\n            return 1\\n        else:\\n            return 2**(int(log2(N))+1)-1 - N",
                "solutionTags": [],
                "code": "Take the next power of 2 that is bigger than N, then subtract 1 from it to get the number that has the same leftmost bit, but with all of the bits to the right filled. \\n\\nSubtract N from this number and you will get the bits to the right that are 0 converted to 1, which is what you are looking for, e.g. 010 as input, 011 as the number you calculate, 011-010 = 001. There is only one edge case for this solution at N == 0. \\n\\n    def bitwiseComplement(self, N: int) -> int:\\n        if N == 0: \\n            return 1\\n        else:\\n            return 2**(int(log2(N))+1)-1 - N",
                "codeTag": "Python3"
            },
            {
                "id": 257022,
                "title": "java-simple-1-line-bit-manipulation-left-right-shifts-0ms",
                "content": "Just actually do the complement operation ~, after first shifting away all the leading zeroes, and then shift away all the trailing ones.\\n```\\n    public int bitwiseComplement(int N) {\\n        return (N==0) ? 1 : (~(N<<(N=Integer.numberOfLeadingZeros(N))))>>N;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int bitwiseComplement(int N) {\\n        return (N==0) ? 1 : (~(N<<(N=Integer.numberOfLeadingZeros(N))))>>N;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1665317,
                "title": "easy-python-solution",
                "content": "```\\ndef bitwiseComplement(self, n: int) -> int:\\n        x=\"\"\\n        for i in bin(n)[2:]:\\n            if i==\"1\":\\n                x+=\"0\"\\n            else:\\n                x+=\"1\"\\n        return int(x,2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef bitwiseComplement(self, n: int) -> int:\\n        x=\"\"\\n        for i in bin(n)[2:]:\\n            if i==\"1\":\\n                x+=\"0\"\\n            else:\\n                x+=\"1\"\\n        return int(x,2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 881423,
                "title": "c-1-liner-9-cpu-instructions-and-future-c-20-solution",
                "content": "> This is a complement of the other \"standard solutions\". If you haven\\'t yet, go read the solution or other posts first, please.\\n\\nSince this solution uses either a C++20 function `std::countl_zero()` (at this point of time, it seems even the latest GCC (10.2) hasn\\'t implement it, Microsoft added it in VS2019 version 16.8 preview 2 just last month!) or a built-in function, please read this post just for fun. Or maybe come back in two years :)\\n\\n----\\n### Version 1\\n\\nIf we have C++20:\\n```cpp\\n    return N ? ((1 << (32 - countl_zero(N))) - 1) ^ N : 1;\\n```\\nFor now (gcc9), below will work:\\n```cpp\\n    return N ? ((1 << (32 - __builtin_clz(N))) - 1) ^ N : 1;\\n```\\n\\nThis version was inspired by the approach 3 from the [solution](https://leetcode.com/problems/complement-of-base-10-integer/solution/):\\n```java\\n// Java\\nclass Solution {\\n    public int bitwiseComplement(int N) {\\n        return N == 0 ? 1 : (Integer.highestOneBit(N) << 1) - N - 1;\\n    }\\n}\\n```\\n\\nLater I realised that it can be better!\\n\\n### Version 2\\n\\n```cpp\\n    // C++20\\n    return N ? (0xFFFFFFFF >> countl_zero(N)) ^ N : 1;\\n    // GCC9\\n    return N ? (0xFFFFFFFF >> __builtin_clz(N)) ^ N : 1;\\n```\\n\\n### Version 3-beta\\n\\nNow, are we able to eliminate the `ifelse`/`?:` branching?\\nWhy not? We can just make the least significant/right most bit of the mask always 1. Easy!\\n```cpp\\n    // C++20\\n    return ((0xFFFFFFFF >> countl_zero(N)) | 1) ^ N;\\n    // GCC9 (won\\'t work on Leetcode! See note below)\\n    return ((0xFFFFFFFF >> __builtin_clz(N)) | 1) ^ N;\\n```\\nNote since LeetCode OJ compiles C++ with the `-fsanitize=undefined` flag, it will throw runtime error if passing 0 to `__builtin_clz()`\\nBut don\\'t worry! We can tweak the input!\\n\\n### Version 3\\n\\n```cpp\\n    // C++20\\n    return (0xFFFFFFFF >> countl_zero(N | 1)) ^ N;\\n    // GCC9\\n    return (0xFFFFFFFF >> __builtin_clz(N | 1)) ^ N;\\n```\\nExplain: for N > 1, changing the last bit will not effect the number of leading 0s, and for both 1 and 0 we use the same mask `0x1` (ie, `0xFFFFFFFF >> 31`).\\n\\n----\\n### Performance\\n\\nSo how much have we improved?\\nWe know approach 4 from the solution (for non-premium users who can\\'t read the solution, see reference below) is faster than any other approaches since it doesn\\'t have any loop or call any other functions like `log()` (Note `__builtin_clz()` is a builtin function that translates to **one single CPU instruction** `BSR` (bit scan reverse))\\nI counted number of lines in assembly code and CPU instructions the code compiled into (GCC 10.2):\\n\\n|                     | # Lines of assembly code | # CPU instructions |\\n| ------------- | ---------------------------- | -------------------- |\\n| Approach 4 |                                     25 |                           23 |\\n| Version 1     |                                     16 |                          14 |\\n| Version 2     |                                     14 |                          12 |\\n| Version 3     |                                       9 |                            9 |\\n\\nReference:\\nApproach 4:\\n```cpp\\nint bitwiseComplement(int N) {\\n    if (N == 0) return 1;\\n    int bitmask = N;\\n    bitmask |= (bitmask >> 1);\\n    bitmask |= (bitmask >> 2);\\n    bitmask |= (bitmask >> 4);\\n    bitmask |= (bitmask >> 8);\\n    bitmask |= (bitmask >> 16);\\n    return bitmask ^ N;\\n}\\n```\\n\\n----\\n## Further thoughts\\n\\nSince `std::countl_zero()` is a template, which can handle any type of integral values, can we do that as well?\\nBelow will do:\\n\\n```cpp\\ntemplate <class T>\\nint bitwiseComplement(T N) {\\n    return (numeric_limits<make_unsigned<T>::type>::max() >> countl_zero(N | 1)) ^ N;\\n}\\n```\\nNote this requires C++20.\\nSince `__builtin_clz()` is only for `int` (`__builtin__clzl()` for `long` and `__builtin__clzll()` for `long long`), it\\'ll be trickier to make it happen. That\\'ll be too far from the scope of this problem, so I\\'m stopping here.\\n\\nEnjoy :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    return N ? ((1 << (32 - countl_zero(N))) - 1) ^ N : 1;\\n```\n```cpp\\n    return N ? ((1 << (32 - __builtin_clz(N))) - 1) ^ N : 1;\\n```\n```java\\n// Java\\nclass Solution {\\n    public int bitwiseComplement(int N) {\\n        return N == 0 ? 1 : (Integer.highestOneBit(N) << 1) - N - 1;\\n    }\\n}\\n```\n```cpp\\n    // C++20\\n    return N ? (0xFFFFFFFF >> countl_zero(N)) ^ N : 1;\\n    // GCC9\\n    return N ? (0xFFFFFFFF >> __builtin_clz(N)) ^ N : 1;\\n```\n```cpp\\n    // C++20\\n    return ((0xFFFFFFFF >> countl_zero(N)) | 1) ^ N;\\n    // GCC9 (won\\'t work on Leetcode! See note below)\\n    return ((0xFFFFFFFF >> __builtin_clz(N)) | 1) ^ N;\\n```\n```cpp\\n    // C++20\\n    return (0xFFFFFFFF >> countl_zero(N | 1)) ^ N;\\n    // GCC9\\n    return (0xFFFFFFFF >> __builtin_clz(N | 1)) ^ N;\\n```\n```cpp\\nint bitwiseComplement(int N) {\\n    if (N == 0) return 1;\\n    int bitmask = N;\\n    bitmask |= (bitmask >> 1);\\n    bitmask |= (bitmask >> 2);\\n    bitmask |= (bitmask >> 4);\\n    bitmask |= (bitmask >> 8);\\n    bitmask |= (bitmask >> 16);\\n    return bitmask ^ N;\\n}\\n```\n```cpp\\ntemplate <class T>\\nint bitwiseComplement(T N) {\\n    return (numeric_limits<make_unsigned<T>::type>::max() >> countl_zero(N | 1)) ^ N;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665537,
                "title": "python-xor-masking-explained",
                "content": "*For easy writing num is written as n*\\n\\nSo the agenda of the question is to flip all the bits of given number. i.e., \\n` n = 4 (100) => 3 (011)`\\n\\nOne way of acheving it is **xor between the number and its mask**, i.e.,  `100 ^ 111 == 011`\\n\\n* **So now how to get its mask ?**\\n\\t* A simple way would be to initialize mask = 0 and keep flipping bits of it to 1 starting from the rightmost bit (LSB) till we reach the leftmost set bit of num.\\n\\n* **Now, how do we know that we reached the leftmost set bit in num?**\\n\\t* We use another variable temp = n. Each time, we will rightshift temp essentially removing the rightmost bit. When we remove the leftmost set bit from it, it will become 0. Thus, we loop till temp is not 0.\\n\\n* **What if initially n = 0?**\\n\\t* We handle that case in the start itself, so that there wont be any uncertainity.\\n\\n```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        if not n: return 1\\n        mask = 0\\n        temp = n\\n        while temp:\\n            mask = (mask << 1) | 1\\n            temp >>= 1\\n        return n ^ mask\\n```\\n*Time complexity : O(N) where N = length of bits\\nSpace complexity: O(1)*\\n\\n ***Upvote, if this helped.***\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        if not n: return 1\\n        mask = 0\\n        temp = n\\n        while temp:\\n            mask = (mask << 1) | 1\\n            temp >>= 1\\n        return n ^ mask\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650499,
                "title": "c-xor-simple-solution",
                "content": "Approach: \\n\\n- Find the first number which is greater than \"num\" and have all 1s (Eg: 1, 3(11), 7(111), 15(1111), ...)\\n- The relation b/w numbers with all 1s is 2x + 1, starting from x=1\\n- Finally xor the num with x.\\n- If num = 5(binary 101), x evaluates as 7 (binary 111) and (num^x) evaluates as 010 which is compliment of  5\\n\\n\\t\\n```\\nint bitwiseComplement(int num) {\\n\\tint x = 1;\\n\\twhile(x<num) x = 2*x + 1;\\n\\treturn num^x;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint bitwiseComplement(int num) {\\n\\tint x = 1;\\n\\twhile(x<num) x = 2*x + 1;\\n\\treturn num^x;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1319086,
                "title": "java-one-liner-100-faster-solution-explaination",
                "content": "\\n```\\nn                                =    10  decimal \\nn                                =    ...001010\\n~n                               =    ...110101\\nInteger.highestOneBit(n)         =    ...001000\\nInteger.highestOneBit(n)-1       =    ...000111\\n~n & Integer.highestOneBit(n)-1  =    ...000101\\n\\n```\\n\\n\\n\\n\\n**SOLUTION:**\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        return n==0?1: ~n & Integer.highestOneBit(n)-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nn                                =    10  decimal \\nn                                =    ...001010\\n~n                               =    ...110101\\nInteger.highestOneBit(n)         =    ...001000\\nInteger.highestOneBit(n)-1       =    ...000111\\n~n & Integer.highestOneBit(n)-1  =    ...000101\\n\\n```\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        return n==0?1: ~n & Integer.highestOneBit(n)-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540666,
                "title": "best-solution",
                "content": "# Approach\\nUsing Bitwise Operator\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int num = n;\\n        int mask = 0;\\n        if (n == 0)\\n            return 1;\\n        while (num != 0) {\\n            mask = (mask << 1) | 1;\\n            num = num >> 1;    \\n        }\\n        int ans = (~n) & mask;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int num = n;\\n        int mask = 0;\\n        if (n == 0)\\n            return 1;\\n        while (num != 0) {\\n            mask = (mask << 1) | 1;\\n            num = num >> 1;    \\n        }\\n        int ans = (~n) & mask;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903419,
                "title": "java-o-1-1-line-solution",
                "content": "1. I find the length of binary representation. For example, for 5 it will base-2 is \"101\" and length of this String is 3. \\n2. Then by doing 1 << 3, I will have \"1000\" which 8 in base-10. \\n3. Then I do 8 - 1 = 7, which is \"111\" in base-2.\\n4. By applying XOR operation I will have \"101\" XOR \"111\" = \"010\", which is 2 in base-10.\\n\\n# Code\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        return n ^ ((1 << Integer.toBinaryString(n).length()) - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        return n ^ ((1 << Integer.toBinaryString(n).length()) - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666811,
                "title": "python-simple-solution-with-detail-explanation-o-log-n",
                "content": "There are 3 steps to be performed in this question:\\n1. Convert Decimal (Base 10) number into to binary (Base 2)\\n\\t(We divide the number by `2` and write the remainders from bottom to top order)\\n\\t**Example:**\\n\\t![image](https://assets.leetcode.com/users/images/571a9862-382b-46be-bc26-75d55c7a466f_1641805033.2479856.png)\\n(Picture credit gfg)\\n\\n2. Take the complement of the binary number\\n\\t(Convert all **0 -> 1** and **1 -> 0**)\\n\\n3. Convert the complement number back into decimal (Base 10)\\n\\tEvery place in a number has its factors eg: one\\'s place(**2^0**), ten\\'s place(**2^1**) and so on.\\n\\t**Example:**\\n\\t![image](https://assets.leetcode.com/users/images/d2f9aa63-d858-4ae0-93e4-4624c72d0dab_1641804822.7457397.png)\\n(Picture credit ncalculators)\\t\\n\\t\\n**Base case:**\\nIf number (in decimal format) is `0` then it will be `0` (in binary format) and it\\'s complement will be `1`(in binary) and converting it again will be `1` (in decimal) \\n\\tSo we can directly **return `1` if n is `0`**\\n\\t\\n**Else part:**\\n    We take 2 variables, `result` which will store the final output and, \\n\\t`factor` which is basically every place factors **(2^0 = 1, 2^1 = 2, 2^2 = 4)** which is inshort multiplied by `2 `in every step.\\n    \\n`(1 if n%2 == 0 else 0) `\\nThis part is a mixture of step 1 and 2.\\n* If `n % 2` is `0` that means in division(step1) the remainder will come `0` and its complement is `1` so we return the complement (which is `1`) \\n* And similarly, is `n % 2` is `1` that means in division(step1) the remainder is `1` and its complement is `0` so we return the complement(which is `0`)\\n\\t\\nLet us understand how the code works with an example:\\n![image](https://assets.leetcode.com/users/images/bd32d94c-a1db-4671-a3ca-11d3e4acd1db_1641804675.0959334.jpeg)\\n\\n\\n**Code:**\\n```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        else:\\n            result = 0\\n            factor = 1\\n            \\n            while(n > 0):\\n                result += factor * (1 if n%2 == 0 else 0)\\n                factor *= 2\\n                n //= 2\\n            return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        else:\\n            result = 0\\n            factor = 1\\n            \\n            while(n > 0):\\n                result += factor * (1 if n%2 == 0 else 0)\\n                factor *= 2\\n                n //= 2\\n            return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665707,
                "title": "java-one-line-code-easy-explanation",
                "content": "**Idea**\\n\\nBInary Complement of 5(101) is 2(010)\\n\\nSee,\\nConvert all bits of 5(101) to ones i.e 111(5)\\nNow we know the answer i.e 7(111)-5(101) =2(010) \\n\\nSo, first find the size of bits of n i.e 3 in this case and pow(2,3)= 8 \\nTherefore the answer be like 8-1-5=2\\n\\n````\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        return (int)(Math.pow(2,Integer.toBinaryString(n).length())-1-n);\\n\\t\\t//return (int)(Math.pow(2,Integer.toBinaryString(n).length())-1-n) also work\\n\\t\\t//return ((2 << (int)(Math.log(Math.max(n, 1)) / Math.log(2))) - 1) - n; also work(0 ms)\\n    }\\n}\\n````\\n\\nI hope you get it!!!\\nPlease **upvote** if you liked the solution :))\\n\\nAll discussion are most welcomed!!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        return (int)(Math.pow(2,Integer.toBinaryString(n).length())-1-n);\\n\\t\\t//return (int)(Math.pow(2,Integer.toBinaryString(n).length())-1-n) also work\\n\\t\\t//return ((2 << (int)(Math.log(Math.max(n, 1)) / Math.log(2))) - 1) - n; also work(0 ms)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880144,
                "title": "c-simple-bitwise-solution-explained-100-time-25-space",
                "content": "A rather simple problem to tackle and the way to do it is rather straightforward itself, where you might just decide to do things differently mostly in terms of which bitwise trick to employ or not here.\\n\\nTo solve this challenge, I first of all created 2 support variables:\\n* `res` to store our own result;\\n* `i` to store the current power of 2 we are working with.\\n\\nWe are going to loop until we reach `n == 0` and please note that this approach is more efficient than a few others, constantly using 31 bits even for smaller numbers.\\n\\nAlso notice that we are using a `do`... `while` loop, since we want it to run at least once, in order to handle the edge case when we initially already have `n == 0`.\\n\\nInside the loop we will keep shaving off the right most (ie: less significant) bit with `2 & 1`, then reverse it with `^ 1` (althought you might just go for other tricks here, like using boolean negation: `!(n % 2)`, for example) and finally we multiply it by the current power of 2 we are treating at the moment.\\n\\nAfter that, we prepare the ground for the next iteration, specularly multiplying `i` by `2` (with the shift assignment operator `<<=`, because bitwise!) and dividing `n` by `2`.\\n\\nOnce we are done looping, time to return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        // support variables\\n        int res = 0, i = 1;\\n        // shaving off the least significant bit from n and adding its complement to res\\n        do {\\n            // updating res\\n\\t\\t\\tres += ((n & 1) ^ 1) * i;\\n            // preparing for the next iteration\\n\\t\\t\\ti <<= 1;\\n            n >>= 1;\\n        } while (n);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        // support variables\\n        int res = 0, i = 1;\\n        // shaving off the least significant bit from n and adding its complement to res\\n        do {\\n            // updating res\\n\\t\\t\\tres += ((n & 1) ^ 1) * i;\\n            // preparing for the next iteration\\n\\t\\t\\ti <<= 1;\\n            n >>= 1;\\n        } while (n);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257818,
                "title": "x86-assembly-six-instructions-no-branches-or-loops",
                "content": "Assuming input in `%edi`, output in `%eax`.\\n\\n```\\nmovl $31, %ecx\\nlzcntl  %edi, %eax\\ncmovbl  %ecx, %eax\\nnotl    %edi\\nshlxl   %eax, %edi, %ecx\\nshrxl   %eax, %ecx, %eax\\n```",
                "solutionTags": [],
                "code": "```\\nmovl $31, %ecx\\nlzcntl  %edi, %eax\\ncmovbl  %ecx, %eax\\nnotl    %edi\\nshlxl   %eax, %edi, %ecx\\nshrxl   %eax, %ecx, %eax\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744265,
                "title": "python-simple-solution-faster-than-99-49",
                "content": "\\t```\\n\\tclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        s=bin(n).replace(\\'0b\\',\\'\\')\\n        t=\\'\\'\\n        for i in s:\\n            if i==\\'0\\':\\n                t+=\\'1\\'\\n            else:\\n                t+=\\'0\\'\\n        return int(t,2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\tclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        s=bin(n).replace(\\'0b\\',\\'\\')\\n        t=\\'\\'\\n        for i in s:\\n            if i==\\'0\\':\\n                t+=\\'1\\'\\n            else:\\n                t+=\\'0\\'\\n        return int(t,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667070,
                "title": "easy-python-solution-o-1-t-o-1-s-explanation",
                "content": "The idea is to XOR the number with a mask. The mask should contain all 1\\'s in it\\'s rightmost bits. Here, the number of 1\\'s is important. For example: for the number 5 (101), the mask should be 7 (111) which contains only 3 1\\'s because the number 5 uses only 3 rightmost bits. Now when we XOR 5 and 7, we get 2:\\n101 -> 5\\n111 -> 7\\n---- (XOR)\\n010 -> 2\\n\\nIn positive integers, the rightmost bit is always set to 1. The idea is to use this bit to set all the other bits to 1. For example, if we take an 8-bit number 10000000, we can perform the following operations to generate the mask:\\n\\nStep 1 : mask |= mask >> 1\\n10000000\\n&nbsp;&nbsp;1000000 (OR)\\n\\\\------------\\n11000000\\n\\nStep 2 : mask |= mask >> 2\\n11000000\\n&nbsp;&nbsp;&nbsp;&nbsp;110000(OR)\\n\\\\------------\\n11110000\\n\\nStep 3 : mask |= mask >> 4\\n11110000\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1111(OR)\\n\\\\------------\\n11111111\\n\\nThe number (11111111) generated above is the mask. Now all we have to do is XOR this mask with the original number. This operation will invert all the bits in the original number.\\n\\nThe above number was 8 bit integer, therefore we got the mask in 3 steps. If the number was 32 bit, we would get the mask in the 5th step where we right-shift the number by 16.\\n\\n```\\ndef bitwiseComplement(self, N: int) -> int:\\n    if N == 0:\\n        return 1\\n        \\n    mask = N\\n    mask |= mask >> 1\\n    mask |= mask >> 2\\n    mask |= mask >> 4\\n    mask |= mask >> 8\\n    mask |= mask >> 16\\n        \\n    return N ^ mask\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\ndef bitwiseComplement(self, N: int) -> int:\\n    if N == 0:\\n        return 1\\n        \\n    mask = N\\n    mask |= mask >> 1\\n    mask |= mask >> 2\\n    mask |= mask >> 4\\n    mask |= mask >> 8\\n    mask |= mask >> 16\\n        \\n    return N ^ mask\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1666091,
                "title": "c-using-vector",
                "content": "```\\n#define ull unsigned long long\\nclass Solution {\\npublic:\\n    vector<int> binary(int n){\\n        vector<int> bin;\\n        int temp=0;\\n        while(n>0){\\n            int rem = n%2;\\n            bin.push_back(rem);\\n            n/=2;\\n        }\\n        reverse(bin.begin(),bin.end());\\n        return bin;\\n    }\\n    \\n    int bitwiseComplement(int n) {\\n        if(n==0) return 1;\\n        vector<int> bin = binary(n);\\n        for(auto &it:bin){\\n            if(it==0) it=1;\\n            else it=0;\\n        }\\n        int k = bin.size();\\n        ull sum=0;\\n        int l=k;\\n        for(int i=0;i<k;i++){\\n            sum+=pow(2,(l-1))*bin[i];\\n            l--;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> binary(int n){\\n        vector<int> bin;\\n        int temp=0;\\n        while(n>0){\\n            int rem = n%2;\\n            bin.push_back(rem);\\n            n/=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1665650,
                "title": "c-easy-to-understand-xor-masking",
                "content": "class Solution {\\npublic:\\n\\n    int bitwiseComplement(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n        int copy=n;\\n        int i=0;\\n        while(copy!=0){\\n            copy>>=1;\\n            n^=(1<<i);\\n            i++;\\n        }\\n        return n;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int bitwiseComplement(int n) {\\n        if(n==0){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 880027,
                "title": "java-simple-short-and-easy-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    int countDigits(int n) {\\n        if (n == 0)\\n            return 0;\\n        return 1 + countDigits(n>>1);\\n    }\\n    \\n    public int bitwiseComplement(int N) {\\n        if (N == 0) return 1;\\n        return (int)Math.pow(2, countDigits(N)) - 1 - N;\\n    }\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int countDigits(int n) {\\n        if (n == 0)\\n            return 0;\\n        return 1 + countDigits(n>>1);\\n    }\\n    \\n    public int bitwiseComplement(int N) {\\n        if (N == 0) return 1;\\n        return (int)Math.pow(2, countDigits(N)) - 1 - N;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880021,
                "title": "c-super-simple-short-and-easy-solution-0-ms-fatser-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigits(int n) {\\n        if (n == 0)\\n            return 0;\\n        return 1 + countDigits(n>>1);\\n    }\\n    \\n    int bitwiseComplement(int N) {\\n        if (N == 0) return 1;\\n        return pow(2, countDigits(N)) - 1 - N;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int n) {\\n        if (n == 0)\\n            return 0;\\n        return 1 + countDigits(n>>1);\\n    }\\n    \\n    int bitwiseComplement(int N) {\\n        if (N == 0) return 1;\\n        return pow(2, countDigits(N)) - 1 - N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855877,
                "title": "python-c-legendary-innovative-maverick-genius-solution-beats-100-o-1",
                "content": "We need to XOR the number with a mask having as many 1s as the minimum no. of bits needed to represent the original number.\\n\\nFor instance:\\n\\n10 in binary would be -> 1010\\nnotice that the no. of bits is  \"log2(10) + 1\" \\n\\nThis holds true in general, for any decimal number x, number of bits needed to represent it in binary would be log2(x) + 1.\\n\\nNow we know how long our mask needs to be, next up we need to create one with all bits set as 1, how do we do it???\\n\\nObserve!\\n\\nfor 10, mask needs to be 1111 (decimal 15) which is one less than 10000 (decimal 16), again, this holds in general.\\n\\nso we can simply create an integer mask = 2^(p+1) - 1, where p = log2(N) \\n\\nPython:\\n```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        if N==0:\\n            return 1\\n        p = int(log2(N))\\n        mask = int(2**(p+1) - 1)\\n        return N^mask\\n```\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n        if(N ==0 ){\\n            return 1;\\n        }\\n        int p = log2(N);\\n        int mask = pow(2,p+1) - 1;\\n        return N^mask;\\n    }\\n};\\n```\\n\\nTime Complexity: O(1)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        if N==0:\\n            return 1\\n        p = int(log2(N))\\n        mask = int(2**(p+1) - 1)\\n        return N^mask\\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n        if(N ==0 ){\\n            return 1;\\n        }\\n        int p = log2(N);\\n        int mask = pow(2,p+1) - 1;\\n        return N^mask;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848242,
                "title": "faster-than-100-00-c-easy-understanding",
                "content": "```\\n//1.\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n        if(N==0) \\n\\t\\t   return 1;\\n        int res=0,k=1;\\n        while(N){\\n            int d=N%2; //finding a bit\\n            res+=(d==1?0:1)*k;  //complement of bit and complement\\n            N/=2; \\n            k*=2;\\n        }\\n        return res;\\n        \\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n         if(N==0)\\n            return 1;\\n        int x=N;\\n        int highval=0;\\n\\t\\t// finding highest value of bit size of N\\n        while(N){\\n            highval=highval*2+1;\\n            N/=2;\\n        }\\n        return highval-x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n        if(N==0) \\n\\t\\t   return 1;\\n        int res=0,k=1;\\n        while(N){\\n            int d=N%2; //finding a bit\\n            res+=(d==1?0:1)*k;  //complement of bit and complement\\n            N/=2; \\n            k*=2;\\n        }\\n        return res;\\n        \\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n         if(N==0)\\n            return 1;\\n        int x=N;\\n        int highval=0;\\n\\t\\t// finding highest value of bit size of N\\n        while(N){\\n            highval=highval*2+1;\\n            N/=2;\\n        }\\n        return highval-x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602844,
                "title": "c-solution-using-bitwise-beats-100",
                "content": "XOR of any Number with a number having all bit 1 gives Binary complemented number.\\nEg- 101 ^ 111 = 010 \\n\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n \\n        if(N==0)\\n            return 1;\\n        int p=log2(N);\\n\\t\\t\\t\\tlong num=pow(2,p+1)-1;  //  num has all bit 1;\\n        \\n        return N^num;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n \\n        if(N==0)\\n            return 1;\\n        int p=log2(N);\\n\\t\\t\\t\\tlong num=pow(2,p+1)-1;  //  num has all bit 1;\\n        \\n        return N^num;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257830,
                "title": "python-5-lines-no-need-bit-manipulation-just-math",
                "content": "```\\ndigit, num = 1, N\\nwhile N > 1:\\n\\tdigit += 1\\n\\tN = N//2\\nreturn 2**digit - 1 - num\\n```",
                "solutionTags": [],
                "code": "```\\ndigit, num = 1, N\\nwhile N > 1:\\n\\tdigit += 1\\n\\tN = N//2\\nreturn 2**digit - 1 - num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2722107,
                "title": "easy-c-solution-beats-100-0ms-solution-o-log-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if (n == 0)\\n        return 1;\\n        int num = n;\\n        int mask = 0;\\n        while(num)\\n        {\\n            mask = mask<<1 | 1;\\n            num >>= 1;\\n        }\\n        return n ^ mask;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if (n == 0)\\n        return 1;\\n        int num = n;\\n        int mask = 0;\\n        while(num)\\n        {\\n            mask = mask<<1 | 1;\\n            num >>= 1;\\n        }\\n        return n ^ mask;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548460,
                "title": "3ms-c-easy-simple-time-o-position-of-mst-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int &n) {\\n        if(n==0)return 1;\\n        int ans = 0;\\n        int i = 0;\\n        while(n){\\n            ans += ((n%2)^1)<<i;\\n            i++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int &n) {\\n        if(n==0)return 1;\\n        int ans = 0;\\n        int i = 0;\\n        while(n){\\n            ans += ((n%2)^1)<<i;\\n            i++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078713,
                "title": "newest-approach-c-100-0-ms-without-converting-number-into-binary",
                "content": "```\\nclass Solution {\\npublic:\\n    int power_floor( int n)\\n    {\\n       \\n        if((n!=0) &&!(n & (n-1)))\\n        {\\n            return n;\\n        }\\n        int count=0;\\n        while(n!=0)\\n        {\\n            n>>=1;\\n            count+=1;\\n        }\\n        return 1<<count;\\n    }\\n    int bitwiseComplement(int n) {\\n if(n==0)\\n        {\\n            return 1;\\n        }\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n      int k = power_floor(n);\\n        if(k-n==0)\\n        {\\n            return k-1;\\n        }\\n        else\\n        {\\n            return k-n-1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int power_floor( int n)\\n    {\\n       \\n        if((n!=0) &&!(n & (n-1)))\\n        {\\n            return n;\\n        }\\n        int count=0;\\n        while(n!=0)\\n        {\\n            n>>=1;\\n            count+=1;\\n        }\\n        return 1<<count;\\n    }\\n    int bitwiseComplement(int n) {\\n if(n==0)\\n        {\\n            return 1;\\n        }\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n      int k = power_floor(n);\\n        if(k-n==0)\\n        {\\n            return k-1;\\n        }\\n        else\\n        {\\n            return k-n-1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932077,
                "title": "c-0-ms-one-line-solution-using-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n==0) return 1;\\n        \\n        return (int)(pow(2,(int)log2(n) + 1) - 1) ^ n ;\\n    }\\n};\\n```\\n\\nExplanation: we have to make ***0101*** from 1010.\\nwe observe, 1010 ^ *0101* = 1111\\nHence,\\nXOR with 1010 on both sides we get (we know that a^a = 0 and a^0 = a),\\n1010^*0101*^1010 = 1111^1010\\n=> ***0101*** = 1010^1111",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n==0) return 1;\\n        \\n        return (int)(pow(2,(int)log2(n) + 1) - 1) ^ n ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770771,
                "title": "easy-solution-faster-than-100-observation-based",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n==0)\\n            return 1;\\n        int i=1;\\n        while(i<=32){\\n            if(n-pow(2,i)<0)\\n                break;\\n            i++;\\n        }\\n        return pow(2,i)-n-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n==0)\\n            return 1;\\n        int i=1;\\n        while(i<=32){\\n            if(n-pow(2,i)<0)\\n                break;\\n            i++;\\n        }\\n        return pow(2,i)-n-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701839,
                "title": "python-3-50ms-beginner-naive-approach-string-join-replace",
                "content": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        t=(str(bin(n).replace(\"0b\", \"\")))\\n        a=\"\".join(\"1\" if x==\\'0\\' else \\'0\\' for x in t)\\n        return int(a,2)\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        t=(str(bin(n).replace(\"0b\", \"\")))\\n        a=\"\".join(\"1\" if x==\\'0\\' else \\'0\\' for x in t)\\n        return int(a,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667006,
                "title": "java-soln-if-you-don-t-know-bit-manipulation-just-like-me",
                "content": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        if(n ==0) return 1 ; //If we have 0, the complement will be 1\\n        \\n        // next = Just greater no. which is Power of 2\\n        //Using the formulae\\'loga b = log10 b / log10 a\\' we can calculate log to any base\\n        int next = (int)(Math.log(n)/Math.log(2)) ;\\n        \\n        /* Next now hold the just greater no. which is a power of 2 of te given no.\\n         *  Eg: if n = 14  than next = 16 which is 2^4 which is a power of 2 */ \\n            next = (int)Math.pow(2,next+1); \\n        \\n        /*  Now next = 16 and by OBSERVATION** we can say that the compliment of a no. \\n         *  is the difference between next and n. But we need to substract 1 from the\\n         *  result to get the ans */\\n        return next - n - 1;\\n        \\n    }\\n}\\n```\\n**OBSERVATION :**** If a binary no. is subtracted from a no. which has all digits as 1\\'s for eg: 111, 1111, 111111 etc it will give the complement of the no. So to get 111 (7 in decimal) we  need to substract 1 from 1000 (8 in decimal)  wich gives the previous all 1\\'s digit binary no. . Thus we are substracting 1 in the ans to get a no. just before the 2^n containing all 1\\'s digit.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        if(n ==0) return 1 ; //If we have 0, the complement will be 1\\n        \\n        // next = Just greater no. which is Power of 2\\n        //Using the formulae\\'loga b = log10 b / log10 a\\' we can calculate log to any base\\n        int next = (int)(Math.log(n)/Math.log(2)) ;\\n        \\n        /* Next now hold the just greater no. which is a power of 2 of te given no.\\n         *  Eg: if n = 14  than next = 16 which is 2^4 which is a power of 2 */ \\n            next = (int)Math.pow(2,next+1); \\n        \\n        /*  Now next = 16 and by OBSERVATION** we can say that the compliment of a no. \\n         *  is the difference between next and n. But we need to substract 1 from the\\n         *  result to get the ans */\\n        return next - n - 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666573,
                "title": "faster-than-100",
                "content": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n==0)\\n            return 1;\\n        int i=1;\\n        while(i<=32){\\n            if(n-pow(2,i)<0)\\n                break;\\n            i++;\\n        }\\n        return pow(2,i)-n-1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n==0)\\n            return 1;\\n        int i=1;\\n        while(i<=32){\\n            if(n-pow(2,i)<0)\\n                break;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1665645,
                "title": "the-sum-of-a-number-and-it-s-complement-is-all-111-s",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N)\\n    {\\n        if(N==0)return 1; \\n        int sum = (int)pow(2,1+(int)log2(N))-1;\\n        return sum-N;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int N)\\n    {\\n        if(N==0)return 1; \\n        int sum = (int)pow(2,1+(int)log2(N))-1;\\n        return sum-N;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1059496,
                "title": "go-solution-faster-than-100-bit-manuplation",
                "content": "```\\nfunc bitwiseComplement(N int) int {\\n\\tif N == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tres := 0\\n\\tg := 1\\n\\tfor N > 0 {\\n\\t\\tif N&1 == 0 {\\n\\t\\t\\tres += g\\n\\t\\t}\\n\\t\\tg <<= 1\\n\\t\\tN >>= 1\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc bitwiseComplement(N int) int {\\n\\tif N == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tres := 0\\n\\tg := 1\\n\\tfor N > 0 {\\n\\t\\tif N&1 == 0 {\\n\\t\\t\\tres += g\\n\\t\\t}\\n\\t\\tg <<= 1\\n\\t\\tN >>= 1\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880774,
                "title": "c-math-based-3-line-no-loop",
                "content": "# Math approach\\nThe sum of a number and it\\'s complement is all 111\\'s. For example :\\n4 + 3 = 7 (100 + 011= 111)\\nNow if we want to find complement we can simply subract our number from a number which has all 1\\'s from Most significant bit (MSB) to Least significant bit (LSB).\\nTo find the most significant bit of a binary number we can simply take log2() of the number. We need to construct a number such that it\\'s binary is all 1\\'s starting from the most significant bit to least of the number for which we are finding the complement. Consider this example:\\n4 in binary is 100\\nIn order to get compliment we have to get 111 (all 1\\'s from Most significant bit to least) and subract 100 (our number):\\n111-100=011 (3)-> Answer\\nlog2(4) is 2 in order to get all 1\\'s from MSB to LSB we can raise 2 to one power higher than Log2(our number) which would result in 8 for our example and subract 1 from it. Eg:\\n2^(log2(4)+1)= 8 in Binary is 1000\\nSubtract 1 from it 1000-1 = 0111 (Hence all 1\\'s from MSB to LSB)\\nNow to get compliment we just have to subtract our number from this and return it.\\n```cpp\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N)\\n    {\\n        if(N==0)return 1; //As Log(0) is -ve Infinity\\n        //calculate left-most-1 in binary number\\n        //create Binary number with all ones and subract N from it\\n        int sum = (int)pow(2, 1+(int)log2(N))-1;\\n        return sum - N;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N)\\n    {\\n        if(N==0)return 1; //As Log(0) is -ve Infinity\\n        //calculate left-most-1 in binary number\\n        //create Binary number with all ones and subract N from it\\n        int sum = (int)pow(2, 1+(int)log2(N))-1;\\n        return sum - N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880038,
                "title": "python-simplest-one-liner-solution",
                "content": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        return (2**len(bin(N)[2:]))-1-N if N != 0 else 1\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        return (2**len(bin(N)[2:]))-1-N if N != 0 else 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880010,
                "title": "python-super-simple-short-clean-solution",
                "content": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        if N==0:\\n            return 1\\n        \\n        def countDigits(n):\\n            if n == 0:\\n                return 0\\n            return 1 + countDigits(n>>1)\\n        \\n        return (2**countDigits(N))-1-N\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        if N==0:\\n            return 1\\n        \\n        def countDigits(n):\\n            if n == 0:\\n                return 0\\n            return 1 + countDigits(n>>1)\\n        \\n        return (2**countDigits(N))-1-N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796290,
                "title": "c-solution-beats-100-0ms-5mb",
                "content": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n        if(n==0)\\n            return 1;\\n        int countbits = floor(log2(n)) + 1;\\n        long long int temp = pow(2,countbits);\\n        temp--;\\n        long long int ans = n^temp;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n        if(n==0)\\n            return 1;\\n        int countbits = floor(log2(n)) + 1;\\n        long long int temp = pow(2,countbits);\\n        temp--;\\n        long long int ans = n^temp;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 612818,
                "title": "c-beats-100-time-and-100-space",
                "content": "My approach invloves working from the rightmost bit of the given number.\\nIf the rightmost bit is 1, we add 0. Otherwise, we add the power of two correspoding to the bit, which we keep track here using the variable \\'pow\\'. After each check we rightshift the number.\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n        int sum = 0;\\n        long pow=1;\\n\\t\\t// Do, while is used because if N is 0, then it has to add 1 and not go directly out of the loop.\\n        do{\\n            if(N%2==0) sum+=pow;\\n            N = (N>>1);\\n            pow*=2;\\n        }while(N);\\n        return sum;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n        int sum = 0;\\n        long pow=1;\\n\\t\\t// Do, while is used because if N is 0, then it has to add 1 and not go directly out of the loop.\\n        do{\\n            if(N%2==0) sum+=pow;\\n            N = (N>>1);\\n            pow*=2;\\n        }while(N);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376453,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar bitwiseComplement = function(N) {\\n    return ((1 << (N.toString(2).length)) - 1) ^ N;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar bitwiseComplement = function(N) {\\n    return ((1 << (N.toString(2).length)) - 1) ^ N;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 256741,
                "title": "simple-java-sol-xor",
                "content": "```\\npublic class ComplementBase10 {\\n\\n    public int bitwiseComplement(int N) {\\n        // Find number of bits in the given integer\\n        int bitCount = (int) Math.floor(Math.log(N)/Math.log(2))+1;\\n\\n        // XOR the given integer with math.pow(2,bitCount-1)\\n        return ((1 << bitCount) - 1) ^ N;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class ComplementBase10 {\\n\\n    public int bitwiseComplement(int N) {\\n        // Find number of bits in the given integer\\n        int bitCount = (int) Math.floor(Math.log(N)/Math.log(2))+1;\\n\\n        // XOR the given integer with math.pow(2,bitCount-1)\\n        return ((1 << bitCount) - 1) ^ N;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776885,
                "title": "java-code-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        // edge Case \\n        if(n == 0) return 1;\\n\\n        // ~n or can be said as NOT of n reverses all the bits of the number\\n        // we will write shift until our no. is not equal to zero so that we can find how many bits have our answer\\n        // to create mask so that all the 0 bits in left side which got 1 when we NOT them, must be done 0 again \\n        // and if we know how many bits have our answer than remaining bits can be AND with 0\\n        // Example:- 5 :- (representing in 16 bit) 0000000000000101\\n        // mask:- 3 digits, how to calculate:- use right shift until number is zero like\\n        // 0000000000000010 >> 1\\n        // 0000000000000001 >> 1\\n        // 0000000000000000\\n\\n        // so to make our final answer starting bit as zero we need\\n        // mask right most 3 bits to be 1 and remaining zero\\n        // 000000000000000 << 1 OR 1\\n        // 000000000000001 << 1 OR 1\\n        // 000000000000011 << 1 OR 1\\n        // 000000000000111, 3 time because we calculated masked digit to be 3 \\n        \\n        // and in last do AND with mask;\\n\\n        int m = n;\\n        int mask = 0;\\n\\n        while(m != 0){\\n            mask = (mask << 1) | 1; // calculating mask \\n            m = m >> 1; \\n        }\\n        int ans = ~n & mask;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        // edge Case \\n        if(n == 0) return 1;\\n\\n        // ~n or can be said as NOT of n reverses all the bits of the number\\n        // we will write shift until our no. is not equal to zero so that we can find how many bits have our answer\\n        // to create mask so that all the 0 bits in left side which got 1 when we NOT them, must be done 0 again \\n        // and if we know how many bits have our answer than remaining bits can be AND with 0\\n        // Example:- 5 :- (representing in 16 bit) 0000000000000101\\n        // mask:- 3 digits, how to calculate:- use right shift until number is zero like\\n        // 0000000000000010 >> 1\\n        // 0000000000000001 >> 1\\n        // 0000000000000000\\n\\n        // so to make our final answer starting bit as zero we need\\n        // mask right most 3 bits to be 1 and remaining zero\\n        // 000000000000000 << 1 OR 1\\n        // 000000000000001 << 1 OR 1\\n        // 000000000000011 << 1 OR 1\\n        // 000000000000111, 3 time because we calculated masked digit to be 3 \\n        \\n        // and in last do AND with mask;\\n\\n        int m = n;\\n        int mask = 0;\\n\\n        while(m != 0){\\n            mask = (mask << 1) | 1; // calculating mask \\n            m = m >> 1; \\n        }\\n        int ans = ~n & mask;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459308,
                "title": "easiest-solution-begineer-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n       // int ans=0;\\n       if(n==0) return 1;\\n        for(int i=1;i<=n;i=i*2){\\n            n=n^i;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n       // int ans=0;\\n       if(n==0) return 1;\\n        for(int i=1;i<=n;i=i*2){\\n            n=n^i;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376456,
                "title": "simple-soluion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        String res = \"\";\\n        for(char c :bin.toCharArray())\\n        {\\n            if( c == \\'1\\')\\n                res += \"0\";\\n            else\\n                res += \"1\";\\n        }\\n        return Integer.parseInt(res, 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        String res = \"\";\\n        for(char c :bin.toCharArray())\\n        {\\n            if( c == \\'1\\')\\n                res += \"0\";\\n            else\\n                res += \"1\";\\n        }\\n        return Integer.parseInt(res, 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306532,
                "title": "c-easy-and-shorter-solution-intuitive-approach-100-accepted",
                "content": "# Intuition\\n1. Straight formula based question.\\n\\n# Approach\\n1. Count the number of digits in the number.\\n2. Use the formula :- one complement of x is 2^n-x-1\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n\\n        //one complement of x is 2^n-x-1\\n\\n        if(n==0)\\n        return 1;\\n\\n        int count=0;\\n        int d;\\n        int m=n;\\n        while(n!=0)\\n        {\\n           // d=n%10;\\n            count++;\\n            n=n>>1;\\n        }\\n        int res = pow(2,count)-m-1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n\\n        //one complement of x is 2^n-x-1\\n\\n        if(n==0)\\n        return 1;\\n\\n        int count=0;\\n        int d;\\n        int m=n;\\n        while(n!=0)\\n        {\\n           // d=n%10;\\n            count++;\\n            n=n>>1;\\n        }\\n        int res = pow(2,count)-m-1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203100,
                "title": "c-solution-runtime-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n    int temp=n;\\n    int mask=0;\\n    int ans;\\n    if(n==0)\\n    {\\n        ans=1;\\n    }\\n    else\\n    {\\n        while(temp!=0)\\n        {\\n            mask= (mask<<1) | 1;\\n            temp=temp>>1;\\n        }\\n        ans=(~n) & mask;\\n    }\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n    int temp=n;\\n    int mask=0;\\n    int ans;\\n    if(n==0)\\n    {\\n        ans=1;\\n    }\\n    else\\n    {\\n        while(temp!=0)\\n        {\\n            mask= (mask<<1) | 1;\\n            temp=temp>>1;\\n        }\\n        ans=(~n) & mask;\\n    }\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997483,
                "title": "c-solution-faster-than-100-of-the-solutions",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m = n ; \\n        int mask = 0 ; \\n        \\n        while(m==0){\\n            return 1 ; \\n        }\\n        while(m!=0){\\n            mask = ( mask << 1 ) | 1 ;\\n            m = m >> 1 ; \\n        }\\n        int ans = (~n) & mask;\\n            return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m = n ; \\n        int mask = 0 ; \\n        \\n        while(m==0){\\n            return 1 ; \\n        }\\n        while(m!=0){\\n            mask = ( mask << 1 ) | 1 ;\\n            m = m >> 1 ; \\n        }\\n        int ans = (~n) & mask;\\n            return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972962,
                "title": "c-easy-solution-beats-100",
                "content": "# Intuition\\nMake a mask \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m = n ; \\n        int mask = 0 ; \\n        \\n        while(m==0){\\n            return 1 ; \\n        }\\n        while(m!=0){\\n            mask = ( mask << 1 ) | 1 ;\\n            m = m >> 1 ; \\n        }\\n        int ans = (~n) & mask;\\n            return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m = n ; \\n        int mask = 0 ; \\n        \\n        while(m==0){\\n            return 1 ; \\n        }\\n        while(m!=0){\\n            mask = ( mask << 1 ) | 1 ;\\n            m = m >> 1 ; \\n        }\\n        int ans = (~n) & mask;\\n            return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960963,
                "title": "easy-java-solution-using-bit-manipulation-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBit Manipulation\\n\\nHope this helps.\\nDo Upvote if you like it !!\\n\\nThanks :)\\n\\n# Code\\n```\\nclass Solution {\\n    public int bitwiseComplement(int num) {\\n        if(num==0){\\n            return 1;\\n        }\\n        int c=0;\\n        c=(int)(Math.log(num)/Math.log(2));\\n        num=~num;\\n        num =num & (int)((Math.pow(2,c))-1);\\n        return(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int num) {\\n        if(num==0){\\n            return 1;\\n        }\\n        int c=0;\\n        c=(int)(Math.log(num)/Math.log(2));\\n        num=~num;\\n        num =num & (int)((Math.pow(2,c))-1);\\n        return(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916645,
                "title": "python-5-line-faster-than-98-91-memory-beats-96-46",
                "content": "# Code\\n```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        b = bin(n)[2:]\\n        b = b.replace(\\'1\\', \\'_\\')\\n        b = b.replace(\\'0\\', \\'1\\')\\n        b = b.replace(\\'_\\', \\'0\\')\\n        return int(b, 2)\\n```\\n![image.png](https://assets.leetcode.com/users/images/e94d9b3b-e0d2-416f-a545-4cd958b81ef3_1671167402.1350152.png)\\n![image.png](https://assets.leetcode.com/users/images/2d830ee6-7485-45aa-a4c3-19a332292c2d_1671167378.0733662.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        b = bin(n)[2:]\\n        b = b.replace(\\'1\\', \\'_\\')\\n        b = b.replace(\\'0\\', \\'1\\')\\n        b = b.replace(\\'_\\', \\'0\\')\\n        return int(b, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904395,
                "title": "beats-100-in-time-complexities-in-cpp",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n \\n\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n ==0) return 1;\\n        int val = n; int ans =0;\\n        int i =0;\\n        while(val != 0)\\n        {\\n            int digit = val%2;\\n            val = val/2;\\n\\n            int ans_digit;\\n            if(digit == 0) ans_digit = 1;\\n            else ans_digit =0;\\n\\n            ans = ans + ans_digit*(pow(2,i));\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n \\n\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n ==0) return 1;\\n        int val = n; int ans =0;\\n        int i =0;\\n        while(val != 0)\\n        {\\n            int digit = val%2;\\n            val = val/2;\\n\\n            int ans_digit;\\n            if(digit == 0) ans_digit = 1;\\n            else ans_digit =0;\\n\\n            ans = ans + ans_digit*(pow(2,i));\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845867,
                "title": "easiest-solution-just-4-lines-code-using-mask-c-plus-plus-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int num) {\\n        if(num==0) return 1;\\n        unsigned mask = ~0;\\n        while( mask & num ) mask = mask << 1;\\n        return ~num ^ mask;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int num) {\\n        if(num==0) return 1;\\n        unsigned mask = ~0;\\n        while( mask & num ) mask = mask << 1;\\n        return ~num ^ mask;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561201,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) \\n    {\\n        String comp = \"\";\\n        String binary = Integer.toBinaryString(n);\\n        \\n        for(int i=0; i<binary.length();i++)\\n        {\\n            char ch = binary.charAt(i);\\n            \\n            if(ch == \\'0\\')\\n                comp += \\'1\\';\\n            else\\n                comp += \\'0\\';\\n        }\\n        \\n        return Integer.parseInt(comp,2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) \\n    {\\n        String comp = \"\";\\n        String binary = Integer.toBinaryString(n);\\n        \\n        for(int i=0; i<binary.length();i++)\\n        {\\n            char ch = binary.charAt(i);\\n            \\n            if(ch == \\'0\\')\\n                comp += \\'1\\';\\n            else\\n                comp += \\'0\\';\\n        }\\n        \\n        return Integer.parseInt(comp,2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029037,
                "title": "quite-simple-java-solution-in-1-line",
                "content": "Solution is simple:\\n- get all leadiing 0 in number (n) `floor(log2(x)) = 31 - numberOfLeadingZeros(x)`, \\n- change all 0 to 1 -> will be num with all 1 in all digits, \\n- implement XOR (each 1 of n will be changed to 0, each 0 will be changed to 1)\\n\\n```\\npublic class Solution {\\n\\n    public int bitwiseComplement(int n) {\\n        return n ^ ((1 << 1 + (int) Math.floor((Math.log(n) / Math.log(2)))) - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int bitwiseComplement(int n) {\\n        return n ^ ((1 << 1 + (int) Math.floor((Math.log(n) / Math.log(2)))) - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818471,
                "title": "easiest-bitwise-manipulation-c-code",
                "content": "```\\nint bitwiseComplement(int n){\\n    int m = n;\\n    int temp = 0;\\n    if(m==0)\\n    {\\n        return 1;\\n    }\\n    while(m)\\n    {\\n        temp = (temp << 1) | 1;\\n        m = m >> 1;\\n    }\\n    int ans = (~n)&temp;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nint bitwiseComplement(int n){\\n    int m = n;\\n    int temp = 0;\\n    if(m==0)\\n    {\\n        return 1;\\n    }\\n    while(m)\\n    {\\n        temp = (temp << 1) | 1;\\n        m = m >> 1;\\n    }\\n    int ans = (~n)&temp;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737044,
                "title": "easy-and-efficient-solution-ever",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n        int m = n ;\\n        int x = 0 ;\\n        if( n == 0 ){\\n            return 1 ;\\n        }\\n        while( m != 0 ){\\n            x = ( x << 1 ) | 1 ;\\n            m = m >> 1 ;\\n        }\\n        int ans = (~n) & x ;\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n        int m = n ;\\n        int x = 0 ;\\n        if( n == 0 ){\\n            return 1 ;\\n        }\\n        while( m != 0 ){\\n            x = ( x << 1 ) | 1 ;\\n            m = m >> 1 ;\\n        }\\n        int ans = (~n) & x ;\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672796,
                "title": "faster-than-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n        int size = 0;\\n        if (n == 0)\\n        {\\n            return 1;\\n        }\\n        if (n == 1)\\n        {\\n            return 0;\\n        }\\n        int num = n;\\n        while (n)\\n        {\\n            size += 1;\\n            n = n/2;\\n        }\\n        int compliment = 1;\\n        int multiplier = 0;\\n        \\n        while (size--)\\n        {\\n            multiplier += compliment;\\n            compliment *= 2;\\n        }\\n        \\n        return multiplier ^ num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n        int size = 0;\\n        if (n == 0)\\n        {\\n            return 1;\\n        }\\n        if (n == 1)\\n        {\\n            return 0;\\n        }\\n        int num = n;\\n        while (n)\\n        {\\n            size += 1;\\n            n = n/2;\\n        }\\n        int compliment = 1;\\n        int multiplier = 0;\\n        \\n        while (size--)\\n        {\\n            multiplier += compliment;\\n            compliment *= 2;\\n        }\\n        \\n        return multiplier ^ num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667086,
                "title": "easy-explanation-faster-than-100-c",
                "content": "Think carefully, 5\\'s complement(1\\'s complement) is 2. So, 5  is 101, and 2 is 010. So, think of XOR operation. XOR is non-equality detector, if two bits are not equal, XOR bit is 1, 0 when bits are equal. So if we do 5^7, we will get 2 (101^111==010). \\n\\n### Approach : \\n**Step1**:  we first need to find number of bits in 5(let say \\'num\\'), which can be easily found by [numOfBits = (int)log2(num)+1]. \\n**Step2**:  After this, we need to find number which represent 111..........numOfBits time (here we want 111 which is 7).\\n**Step3**: In order to find 7, we can do [ToXorWith= (2^numOfBits)-1], which can be effeciently done using binaryExponentiation.\\n**Step4**: now finally return 5^7 (i.e num^ToXorWith).\\n\\n\\n\\n```\\nlong long binaryExponentiation(long long base, long long power){\\n        if(power==0){ return 1; }\\n        \\n        long result=1;\\n        while(power>0){\\n            if(power%2==0){\\n                power/=2;\\n                base*=base;\\n            }\\n            else if(power%2==1){\\n                power--;\\n                result*=base;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    long long bitwiseComplement(long long n) {\\n        \\n        if(n==0){ return 1; }\\n        \\n        long long numOfBit = (long long)log2(n)+1;\\n        long long numToXorWith= (long long)binaryExponentiation(2,numOfBit)-1;\\n        return (n ^ numToXorWith);\\n    }\\n```\\n\\nThanks for your patient. If you find it useful, do upvote this post.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nlong long binaryExponentiation(long long base, long long power){\\n        if(power==0){ return 1; }\\n        \\n        long result=1;\\n        while(power>0){\\n            if(power%2==0){\\n                power/=2;\\n                base*=base;\\n            }\\n            else if(power%2==1){\\n                power--;\\n                result*=base;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    long long bitwiseComplement(long long n) {\\n        \\n        if(n==0){ return 1; }\\n        \\n        long long numOfBit = (long long)log2(n)+1;\\n        long long numToXorWith= (long long)binaryExponentiation(2,numOfBit)-1;\\n        return (n ^ numToXorWith);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1666333,
                "title": "c-beats-100",
                "content": "class Solution {\\npublic:\\n  \\n         vector<int> binary(int n){\\n        vector<int> bin;\\n        int temp=0;\\n        while(n>0){\\n            int rem = n%2;\\n            bin.push_back(rem);\\n            n/=2;\\n        }\\n        reverse(bin.begin(),bin.end());\\n        return bin;\\n    }\\n    \\n    int bitwiseComplement(int n) {\\n        if(n==0) return 1;\\n        vector<int> bin = binary(n);\\n        for(auto &it:bin){\\n            if(it==0) it=1;\\n            else it=0;\\n        }\\n        \\n        int k = bin.size();\\n        unsigned long long sum=0;\\n        int l=k;\\n        for(int i=0;i<k;i++){\\n            sum+=pow(2,(l-1))*bin[i];\\n            l--;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n  \\n         vector<int> binary(int n){\\n        vector<int> bin;\\n        int temp=0;\\n        while(n>0){\\n            int rem = n%2;\\n            bin.push_back(rem);\\n            n/=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1666168,
                "title": "easy-to-understand-javascript-solution",
                "content": "How to find an answer without the knowledge of bitwise operators?\\n\\nThe hint lies here: to find the complement number, we need to find the 111..111 number of N length, where N is the length of the input number in binary representation. That\\'s our sum of `n` and complement number. Then convert it to decimal and subtract between `sum` and input number `n`. \\nThat\\'s it! It will be easier to understand if we\\'ll go to the examples.\\n\\n***Example 1:***\\n**Input**: n = 5\\n**Explanation**: 5 is \"101\" in binary, so we create the number \"111\", find it decimal representation - that\\'s 7, and find out the subtract\\n**Output**: 7 - 5 = 2. The answer is **2**\\n\\n***Example 2:***\\n**Input**: n = 6435\\n**Explanation**: 6435 is \"\\'1100100100011\\'\" in binary,  the length of the binary is 13 so we create the number \"1111111111111\", find it decimal representation - that\\'s 8191, and find out the subtract\\n**Output**: 8191 - 6435 = 1756. The answer is **1756**\\n\\n***Example 3:***\\n**Input**: n = 0\\n**Explanation**: 0 is \"0\" in binary,  the length of the binary is 1 so we create the number \"1\", find it decimal representation - that\\'s 1, and find out the subtract\\n**Output**: 1 - 0 = 1. The answer is **1**\\n\\n\\n***Easy-to-read code:***\\n```\\nfunction bitwiseComplement(n: number): number {\\n\\tlet binary = n.toString(2);                        // we find our input in binary representation\\n\\tlet sum = parseInt(\\'1\\'.repeat(binary.length), 2);  // we find the sum in binary and convert in to decimal \\n    return sum - n;                                    //get the result in decimal \\n};\\n```\\n\\n***Good-looking oneliner:***\\n```\\nfunction bitwiseComplement(n: number): number {\\n    return parseInt(\\'1\\'.repeat((n >>> 0).toString(2).length), 2) - n;\\n};\\n```\\n\\nMemory Usage: 40.1 MB, less than 100.00% of TypeScript online submissions for Complement of Base 10 Integer.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction bitwiseComplement(n: number): number {\\n\\tlet binary = n.toString(2);                        // we find our input in binary representation\\n\\tlet sum = parseInt(\\'1\\'.repeat(binary.length), 2);  // we find the sum in binary and convert in to decimal \\n    return sum - n;                                    //get the result in decimal \\n};\\n```\n```\\nfunction bitwiseComplement(n: number): number {\\n    return parseInt(\\'1\\'.repeat((n >>> 0).toString(2).length), 2) - n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1666038,
                "title": "c-msb-simple-logic",
                "content": "```\\n  int bitwiseComplement(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n        //first find msb\\n        int msb=(int)log2(n);\\n        int sum=0;\\n        for(int i=msb;i>=0;i--){\\n            if(n&(1<<i)){\\n                continue;\\n            }\\n            sum+=pow(2,i);\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int bitwiseComplement(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n        //first find msb\\n        int msb=(int)log2(n);\\n        int sum=0;\\n        for(int i=msb;i>=0;i--){\\n            if(n&(1<<i)){\\n                continue;\\n            }\\n            sum+=pow(2,i);\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1665812,
                "title": "python3-solution-january-day-4-challenge",
                "content": "Explanation: \\n\\n1.  Firstly, when we add the given input value and it\\'s complement we will be getting a number with only ones in it (as there will be no leading zeroes). \\n2.   Now, when we consider binary numbers that only contains ones in them, they will look like 1, 3 (11), 7 (111), 15 (1111) and so on. In actual, the decimal values of them looks like \\n\\n1 = 2^0 = 1 (in binary)\\n3 = 2 * 1 + 1 \\n7 = 3 * 2 + 1 \\n15 = 7 * 2 + 1 \\nand so on for other values.\\n\\n3. The above kind of computation will be repeated until we find a value (this value would be the sum value)( sum value mentioned in point 1) which is greater than or equal to our input value. \\n4. Once the sum value is obtained, we will  subtract the input value from that sum value which gives the complement of the given value. \\n\\nEx : If given input N = 5, then upon iterations we will get a sum value of 7 (111 in binary representation without leading zeros). Atlast we will subtract the given input from sum value i.e., \\n\\n7 (111) - 5 (101) = 2 (010) -> which is the required complement. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        sum_ = 1\\n        \\n        while N > sum_:\\n            sum_ = sum_ * 2 + 1\\n        \\n        return sum_ - N\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        sum_ = 1\\n        \\n        while N > sum_:\\n            sum_ = sum_ * 2 + 1\\n        \\n        return sum_ - N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665689,
                "title": "o-1-no-xor-left-shift-1-1-i-bit-manipulation-c",
                "content": "******LEFT SHIFT 1**\\n \\n*let n=5(101);   101&001!=0 , 101&010==0 ,101&100!=0*\\n//001,010,100 is left shift of 1 by 0,1,2 and we take & with the number;\\n//if n&1(<<i)==0 it means that ith position in bit is 0 and complement of it is 1\\n//we keep res =res+pow(2,i);\\n//also keep total bits in a number by log2(n)+1;\\n\\nif(n==0)\\n            return 1;\\n       long int res=0;\\n        int count=log2(n)+1;\\n        for(int i=0;i<count;i++)\\n        {\\n            if(((1<<i)&n)==0)\\n            {\\n                res=res+(long int)(pow(2,i)+1e-9);\\n            }\\n        }\\n        return res;",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "******LEFT SHIFT 1**\\n \\n*let n=5(101);   101&001!=0 , 101&010==0 ,101&100!=0*\\n//001,010,100 is left shift of 1 by 0,1,2 and we take & with the number;\\n//if n&1(<<i)==0 it means that ith position in bit is 0 and complement of it is 1\\n//we keep res =res+pow(2,i);\\n//also keep total bits in a number by log2(n)+1;\\n\\nif(n==0)\\n            return 1;\\n       long int res=0;\\n        int count=log2(n)+1;\\n        for(int i=0;i<count;i++)\\n        {\\n            if(((1<<i)&n)==0)\\n            {\\n                res=res+(long int)(pow(2,i)+1e-9);\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 1665659,
                "title": "1-liner-cpp-log2",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        return n>0?(((1ll<<((int)log2(n)+1))-1)^n):1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        return n>0?(((1ll<<((int)log2(n)+1))-1)^n):1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665630,
                "title": "c-one-line-code-o-1-explanation",
                "content": "<br/>\\n\\n`XOR with 1 with any bit will complement it`\\n\\n**Complements:**\\n1 ^ 1 = 0\\n0 ^ 1 = 1\\n \\nSo, just xor the given num with a mask which contains all 1s till the leftmost set bit of num\\n**Example:** 5 = (29 zeros)101, so mask for 5 = (29 zeros)111\\n \\n**32 - builtin_clz** (count leading zeros) will give the position till which all bits should be 1 in the mask\\n(i.e. position of leftmost set bit in num)\\n\\nand any 2^x - 1 will make a mask like (some zeros)(all ones)\\n**Example:** 16 (10000), 15 (01111)\\n    \\n`So, (1 << (32 - __builtin_clz(num))) - 1) will be our mask, xoring that with num will complement all bits`\\n \\n**Example:**\\n``` \\nnum  = 000101101001\\nmask = 000111111111\\ncomp = 111010010110 \\n```\\n<br/>\\n<strong>C++ code:</strong>\\n\\n<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        return n ? n ^ ((1 << (32 - __builtin_clz(n))) - 1) : 1;\\n    }\\n};\\n```\\n\\n<br/>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "``` \\nnum  = 000101101001\\nmask = 000111111111\\ncomp = 111010010110 \\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        return n ? n ^ ((1 << (32 - __builtin_clz(n))) - 1) : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650279,
                "title": "c-100-faster-easiest-solution",
                "content": "![image](https://assets.leetcode.com/users/images/36f7e354-970f-44dc-acb9-27af4c82d2c3_1640600677.6249952.png)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long getNxtPowOf2(int n) {\\n        if((int)log2(n) == log2(n)) return n*2;\\n        long long pow = 1;\\n        while(pow<n) pow *= 2;\\n        return pow;\\n    }\\n            \\n    long long bitwiseComplement(int num) {\\n        if(num==0) return 1;\\n        return getNxtPowOf2(num) - num -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long getNxtPowOf2(int n) {\\n        if((int)log2(n) == log2(n)) return n*2;\\n        long long pow = 1;\\n        while(pow<n) pow *= 2;\\n        return pow;\\n    }\\n            \\n    long long bitwiseComplement(int num) {\\n        if(num==0) return 1;\\n        return getNxtPowOf2(num) - num -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585604,
                "title": "c-solution-faster-than-100",
                "content": "<img src=https://assets.leetcode.com/users/images/40d05eef-5e89-4ed8-9687-df2bcb3148de_1637291064.3202198.png alt=\"image\" width=\"400\"/>\\n\\nto understand the solution, we keep in mind that any thing ```xor``` 1 is it\\'s \"1\\'s complement\", so here just loop throught each bit of input n and **set** corresponding bit in output result to ```xor(n[bit])```.\\n\\n```\\n//Zhaoqin Li\\nint bitwiseComplement(int n){\\n    if(!n){\\n        return 1;\\n    }\\n    int result = 0;\\n    int i = 0;\\n    while(n){\\n        result |= ((n&1)^1)<<i;;\\n        n >>= 1;\\n        i += 1;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```xor```\n```xor(n[bit])```\n```\\n//Zhaoqin Li\\nint bitwiseComplement(int n){\\n    if(!n){\\n        return 1;\\n    }\\n    int result = 0;\\n    int i = 0;\\n    while(n){\\n        result |= ((n&1)^1)<<i;;\\n        n >>= 1;\\n        i += 1;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539725,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn bitwise_complement(n: i32) -> i32 {\\n        !n & ((n as u32).next_power_of_two() - 1).max(1) as i32         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn bitwise_complement(n: i32) -> i32 {\\n        !n & ((n as u32).next_power_of_two() - 1).max(1) as i32         \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1245083,
                "title": "go",
                "content": "```\\nfunc bitwiseComplement(n int) int {\\n    a := 2\\n    for a - 1 < n {\\n        a *= 2\\n    }\\n    return a - 1 - n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc bitwiseComplement(n int) int {\\n    a := 2\\n    for a - 1 < n {\\n        a *= 2\\n    }\\n    return a - 1 - n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883028,
                "title": "fastest-java",
                "content": "The idea behind this solution is first of all , I kept a count of how many bits are present in the numbers, then I ran my loop upto that count only and was just kept on using XOR to change the bits example:- number -10\\n10------> 1 0 1 0\\nso my count came out 4\\nnow my second loop would run 4 times and mask intially was 1\\nso now 1 0 1 ***0*** this zero would be XOR with mask so 1 ^ 0=1\\nand now 1 0 **1** 1 , this one would be XOR with mask= mask*2 i.e 2 and it\\'s representation in binary is  1 0\\nSo 1 ^ 1=0\\nSo now number became **1 0 0 1** and this process would continue \\nIf you got the solution upvote it :)\\n\\n\\n\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n         int mask=1;\\n        int nu=n;\\n        int co=0;\\n        if(n==0)\\n            return 1;\\n        while(n!=0)\\n        {\\n            co++;\\n            n=n>>1;\\n        }\\n        while(co-->0)\\n        {\\n            nu=nu^mask;\\n            mask=mask<<1;\\n        }\\n        return nu;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "class Solution {\\n    public int bitwiseComplement(int n) {\\n         int mask=1;\\n        int nu=n;\\n        int co=0;\\n        if(n==0)\\n            return 1;\\n        while(n!=0)\\n        {\\n            co++;\\n            n=n>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 881289,
                "title": "c-constant-time-no-loops",
                "content": "```\\nint bitwiseComplement(int N) {\\n    if (N == 0)\\n        return 1;\\n    const int shift = ceil(log2(N));\\n    const int mask = ((1 << shift) - 1);\\n        \\n    return ~N & mask;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint bitwiseComplement(int N) {\\n    if (N == 0)\\n        return 1;\\n    const int shift = ceil(log2(N));\\n    const int mask = ((1 << shift) - 1);\\n        \\n    return ~N & mask;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881211,
                "title": "java-one-line-code-with-explanation-xor-masking",
                "content": "The idea is to identify the number of `1`\\'s required as explained in the hint of the question. To identify that we can use an in-built `Integer.toBinaryString(number)`. This will return the binary form of the Integer without leading `0`\\'s. The length of this String is equal to the number of `1`\\'s that we required.\\n\\nSo, we\\'ll first identify the length of the binary string for the given Integer. Next we\\'ll form an integer which has only `1`\\'s for all the bits for the length that we required. To do that we\\'ll do left shift operation on `1` for the given length and we\\'ll subtract a `1` from it. \\n\\nFor example, let\\'s take `5` as our input. `Integer.toBinaryString(5)` will return `101`. The length is `3`. When we apply left shift operation with this length like `1<<3`, we\\'ll get `8`(`1000` in binary). Subtracting `1` from it will give us `7`(`111` in binary). As given in the question hint, we can do XOR operation of our number with this number to get the required complement.\\n\\n```\\nclass Solution {\\n\\tpublic int bitwiseComplement(int N) {\\n\\t\\treturn N^((1<<(Integer.toBinaryString(N).length()))-1);\\n\\t}\\n}\\n```\\n\\nDo upvote, if you find this helpful!",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int bitwiseComplement(int N) {\\n\\t\\treturn N^((1<<(Integer.toBinaryString(N).length()))-1);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880631,
                "title": "python-3-solution-explained-video-code-fastest",
                "content": "[](https://www.youtube.com/watch?v=VhkbNYDMmd0)\\nhttps://www.youtube.com/watch?v=VhkbNYDMmd0\\n```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        sum_ = 1\\n        \\n        while N > sum_:\\n            sum_ = sum_ * 2 + 1\\n        \\n        return sum_ - N\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        sum_ = 1\\n        \\n        while N > sum_:\\n            sum_ = sum_ * 2 + 1\\n        \\n        return sum_ - N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880383,
                "title": "swift-solution-with-explanation",
                "content": "**Explanation**\\nTo complement a binary number, we want to XOR each bit with `1`. Why? Because `1 ^ 1 = 0` and `0 ^ 1 = 1`. This means we can find the complement of a number by masking it with `111...1` where we have ones up to the leading bit of the number to mask. \\n\\nExamples \\n1. N = 5 is `101` XOR with `111` and get `010` = 2 \\n2. N = 10 is `1010` XOR with `1111` and get `0101` = 5\\n\\nSo how can this mask be created? Find the first number containing a single `1` bit that is strictly larger than `N`, then subtract one from it. This will cause all the bits below the set bit to become `1`. For example, `1000 - 1 = 0111` and `100 - 1 = 011`. This number can be found by starting with `10` and shifting it until the mask is strictly larger than the given number. \\n\\n**Full Example**\\n1. Given N = 10 = `1010`. \\n2. Start with mask = 2 = `10`. \\n\\t3. This is less than or equal to 10 so shift mask to 4 = `100`\\n\\t4. This is less than or equal to 10 so shift mask to 8 = `1000`\\n\\t5. This is less than or equal to 10 so shift mask to 16 = `10000`\\n\\t6. This is greater than 10 so stop shifting \\n7. Subtract 1 from the mask `10000 - 1 = 01111`\\n8. XOR the mask with the number `1010 ^ 1111 = 0101`\\n9. Return the answer 5 = `0101`\\n\\n**Solution**\\n```swift\\nfunc bitwiseComplement(_ N: Int) -> Int {\\n\\tvar mask = 2 // can also write \"0b10\"\\n\\twhile mask <= N {\\n\\t\\tmask <<= 1 \\n\\t}\\n\\treturn N ^ (mask - 1)\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc bitwiseComplement(_ N: Int) -> Int {\\n\\tvar mask = 2 // can also write \"0b10\"\\n\\twhile mask <= N {\\n\\t\\tmask <<= 1 \\n\\t}\\n\\treturn N ^ (mask - 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880055,
                "title": "c-one-line-solution-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) \\n    {\\n        return N == 0 ? 1 : N ^ (int)(pow(2, floor(log2(N)) + 1) - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) \\n    {\\n        return N == 0 ? 1 : N ^ (int)(pow(2, floor(log2(N)) + 1) - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879933,
                "title": "java-python-straightforward-bit-manipulation-clean-code-o-logn",
                "content": "**Complexity**\\n- Time: `O(logN)`\\n- Space: `O(1)`\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def bitwiseComplement(self, N):\\n        def setBit(x, k):\\n            return (1 << k) | x\\n        \\n        if N == 0: return 1\\n        i, ans = 0, 0\\n        while N > 0:\\n            if N % 2 == 0:\\n                ans = setBit(ans, i)\\n            i += 1\\n            N /= 2\\n        return ans\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int bitwiseComplement(int N) {\\n        if (N == 0) return 1;\\n        int ans = 0, i = 0;\\n        while (N > 0) {\\n            if (N % 2 == 0) \\n                ans = setBit(ans, i);\\n            i += 1;\\n            N /= 2;\\n        }\\n        return ans;\\n    }\\n    \\n    int setBit(int x, int k) {\\n        return (1 << k) | x;\\n    }\\n}\\n```\\n\\nFeel free to ask your question in the comments, help to **vote** if this post is useful to you.",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def bitwiseComplement(self, N):\\n        def setBit(x, k):\\n            return (1 << k) | x\\n        \\n        if N == 0: return 1\\n        i, ans = 0, 0\\n        while N > 0:\\n            if N % 2 == 0:\\n                ans = setBit(ans, i)\\n            i += 1\\n            N /= 2\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int bitwiseComplement(int N) {\\n        if (N == 0) return 1;\\n        int ans = 0, i = 0;\\n        while (N > 0) {\\n            if (N % 2 == 0) \\n                ans = setBit(ans, i);\\n            i += 1;\\n            N /= 2;\\n        }\\n        return ans;\\n    }\\n    \\n    int setBit(int x, int k) {\\n        return (1 << k) | x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879910,
                "title": "java-100-faster-solution-trick-to-find-2-digits-of-n-1-11111-and-subtract-n-from-it",
                "content": "**Example** -> N = 5                                    \\n  101   {5 in binary}  + \\n   010 {1s complement of 5 in binary -> }\\n =   111 {Addition of both as always for any N will be 111...1111}\\nHow to find how many 1s would be there for finding (111...111) value? -> just keep  on dividing N by 2 and keep a count of times you divide until N reaches 0. This will give you maximum digits+1 (so do 2^N and minus one) -> for 5 example (3 digits will be there - 2^3 (8) -1 = 7 (which is 111) to find faster value of 111). and then subtract N from 7. (7-5) -> 2 which is the right answer.\\n(as 5 is 101 and 2 is 010).\\n```\\npublic int bitwiseComplement(int N) {\\n        if(N==0) return 1;\\n\\t\\t//to count how many 1s (digits N has in binary format)\\n        int n=0;\\n        int temp = N;\\n\\t\\t//count n\\n        while(temp!=0){\\n            temp=temp/2;\\n            n++;\\n        }\\n\\t\\t//find the last max 1111 but taking 2^n-1 -> helps in finding the value of binary value in faster way\\n        int pow = (int) Math.pow(2,n) - 1;\\n        //return subtracted value of 1111-(N) (but in 10 base format)\\n        return pow-N;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "**Example** -> N = 5                                    \\n  101   {5 in binary}  + \\n   010 {1s complement of 5 in binary -> }\\n =   111 {Addition of both as always for any N will be 111...1111}\\nHow to find how many 1s would be there for finding (111...111) value? -> just keep  on dividing N by 2 and keep a count of times you divide until N reaches 0. This will give you maximum digits+1 (so do 2^N and minus one) -> for 5 example (3 digits will be there - 2^3 (8) -1 = 7 (which is 111) to find faster value of 111). and then subtract N from 7. (7-5) -> 2 which is the right answer.\\n(as 5 is 101 and 2 is 010).\\n```\\npublic int bitwiseComplement(int N) {\\n        if(N==0) return 1;\\n\\t\\t//to count how many 1s (digits N has in binary format)\\n        int n=0;\\n        int temp = N;\\n\\t\\t//count n\\n        while(temp!=0){\\n            temp=temp/2;\\n            n++;\\n        }\\n\\t\\t//find the last max 1111 but taking 2^n-1 -> helps in finding the value of binary value in faster way\\n        int pow = (int) Math.pow(2,n) - 1;\\n        //return subtracted value of 1111-(N) (but in 10 base format)\\n        return pow-N;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 875732,
                "title": "c-easy-to-understand-solution-with-explanation-xor-with-mask",
                "content": "# Code\\n```\\n/* 40ms, 80.85% percentile */\\npublic int BitwiseComplement(int N) \\n{\\n  int mask = (1 << GetBinaryLength(N)) - 1;\\n  return N ^ mask;\\n}\\n\\nprivate int GetBinaryLength(int x)\\n{\\n  int length = 0;\\n\\n  while (x > 0)\\n  {\\n    length++;\\n    x /= 2;\\n  }\\n\\n  return Math.Max(length, 1);\\n}\\n```\\n\\n# Explanation\\nLet\\'s say, we have a number which binary representation is \"11101011\" and we need to find its complement.\\n\\nIn order to get it\\'s complement number, we can just XOR it with binary mask with all 1 bits of the same length:\\n\\n```\\n    11101011\\nXOR 11111111\\n =  00010100\\n```\\n\\nSo, now the problem reduces to two problems:\\n- \"How do we get the length of the binary representation?\", and\\n- \"How do produce a number which binary representation is all 1s of length X?\"\\n\\n##### \"How do we get the length of the binary representation?\"\\nWe can simply find length of a binary number iteratively (there are other way to do this, but this one looks the most straightforward to me):\\n```\\nprivate int GetBinaryLength(int x)\\n{\\n  int length = 0;\\n    \\n  while (x > 0)\\n  {\\n    length++;\\n    x /= 2;\\n  }\\n    \\n  return Math.Max(length, 1); \\n}\\n```\\n\\n`Math.Max` with 1 is needed to return 1 if `x` is `0`. We return `1` so that mask is `1` and result is `0 ^ 1 = 1`\\n\\n##### \"How do produce a number which binary representation is all 1s of length X?\"\\nBinary `1111` (decimal 15) is just binary `10000` (decimal 16) minus 1 and 16 is just `2 ^ (BinaryLength - 1)`:\\n\\n```\\nint mask = (1 << GetBinaryLength(N)) - 1;\\n```\\n\\nFor example, if `N` is decimal 12345 (binary `11000000111001`), then `GetBinaryLength` will return `14`. \\nIn this case, `mask` will be equal to `2 ^ 15 - 1`, which is 32767 (binary `111111111111111`).\\n\\n##### Actually XOR it\\nNow, let\\'s just XOR it:\\n\\n```\\nreturn N ^ mask;\\n```",
                "solutionTags": [],
                "code": "```\\n/* 40ms, 80.85% percentile */\\npublic int BitwiseComplement(int N) \\n{\\n  int mask = (1 << GetBinaryLength(N)) - 1;\\n  return N ^ mask;\\n}\\n\\nprivate int GetBinaryLength(int x)\\n{\\n  int length = 0;\\n\\n  while (x > 0)\\n  {\\n    length++;\\n    x /= 2;\\n  }\\n\\n  return Math.Max(length, 1);\\n}\\n```\n```\\n    11101011\\nXOR 11111111\\n =  00010100\\n```\n```\\nprivate int GetBinaryLength(int x)\\n{\\n  int length = 0;\\n    \\n  while (x > 0)\\n  {\\n    length++;\\n    x /= 2;\\n  }\\n    \\n  return Math.Max(length, 1); \\n}\\n```\n```\\nint mask = (1 << GetBinaryLength(N)) - 1;\\n```\n```\\nreturn N ^ mask;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 718523,
                "title": "0-ms-beats-100-easily-understandable-c-solution",
                "content": "```\\n class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(!n)\\n            return 1;\\n        \\n        int power2=pow(2,ceil(log(n)/log(2)));\\n        if(power2==n)\\n            return n-1;\\n        return n^(power2-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(!n)\\n            return 1;\\n        \\n        int power2=pow(2,ceil(log(n)/log(2)));\\n        if(power2==n)\\n            return n-1;\\n        return n^(power2-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633203,
                "title": "javascript-1-line",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar bitwiseComplement = function(N) {\\n    return N ^ parseInt(\\'1\\'.repeat(N.toString(2).length), 2);\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar bitwiseComplement = function(N) {\\n    return N ^ parseInt(\\'1\\'.repeat(N.toString(2).length), 2);\\n};\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 614592,
                "title": "bitset-solution-and-bit-manipulation-solution",
                "content": "**Method 1** : we can use bit Manipulation to invert every bit in the number.\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n\\t// because log2 of 0 is undefined  we need to check this case on its own !\\n        if(N == 0){\\n            return 1;\\n        }\\n        int bitsCount = log2(N) + 1;\\n        \\n        for(int i = 0; i< bitsCount; i++){\\n            N = N^(1 << i);\\n        }\\n        \\n        return N;\\n    }\\n};\\n```\\n\\n**Method 2** : using bitset.\\nIn this approach i used the flip() of bitset to invert the bits of the number. \\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n\\t  if(N == 0){\\n            return 1;\\n        }\\n\\tint bitsCount = log2(N) + 1;\\n        \\n        bitset<32> bit(N);\\n        \\n        for(int i = 0; i< bitsCount; i++){\\n            bit.flip(i);\\n        }\\n        \\n        return bit.to_ulong();     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n\\t// because log2 of 0 is undefined  we need to check this case on its own !\\n        if(N == 0){\\n            return 1;\\n        }\\n        int bitsCount = log2(N) + 1;\\n        \\n        for(int i = 0; i< bitsCount; i++){\\n            N = N^(1 << i);\\n        }\\n        \\n        return N;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n\\t  if(N == 0){\\n            return 1;\\n        }\\n\\tint bitsCount = log2(N) + 1;\\n        \\n        bitset<32> bit(N);\\n        \\n        for(int i = 0; i< bitsCount; i++){\\n            bit.flip(i);\\n        }\\n        \\n        return bit.to_ulong();     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614590,
                "title": "easy-solution-c-modify-decimal-to-binary-conversion",
                "content": "This is the idea that complement is just raising index of the bits which are zero in the binary representation to power of 2 and adding them. Leave out the 1\\'s.\\nEg. 10 == 1010. 0 at index 0 and 2. (Reading from right->left). \\n      Raise and add 2^0 + 2^2 = 1+4 = 5 == 0101, i.e the complement. \\n\\nSo just modify the process of decimal to binary number conversion.\\nCode:\\n```\\n\\tint findComplement(int num) {\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(num){\\n\\t\\t\\t\\tif(num%2==0)ans+=pow(2,i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tnum/=2;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tint findComplement(int num) {\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(num){\\n\\t\\t\\t\\tif(num%2==0)ans+=pow(2,i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tnum/=2;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 614160,
                "title": "1-liner-in-rust",
                "content": "Original fn signature\\n```\\nuse std::cmp::max;\\n\\npub fn bitwise_complement(n: i32) -> i32 {\\n\\tmax((n as u32 + 1).next_power_of_two() as i32, 2) - n - 1 // max is necessary for the case n = 0;\\n}\\n```\\n\\nCorrect fn signature\\n```\\nuse std::cmp::max;\\n\\npub fn bitwise_complement(n: u32) -> u32 {\\n\\tmax((n + 1).next_power_of_two(), 2) - n - 1\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nuse std::cmp::max;\\n\\npub fn bitwise_complement(n: i32) -> i32 {\\n\\tmax((n as u32 + 1).next_power_of_two() as i32, 2) - n - 1 // max is necessary for the case n = 0;\\n}\\n```\n```\\nuse std::cmp::max;\\n\\npub fn bitwise_complement(n: u32) -> u32 {\\n\\tmax((n + 1).next_power_of_two(), 2) - n - 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 614065,
                "title": "java-0ms-no-bitwise-easy-to-understand",
                "content": "```\\npublic int findComplement(int num) {\\n\\n\\tint i = 0;\\n\\tint res = 0;\\n\\t\\n\\twhile (num > 0) {\\n\\t\\n\\t\\tif (num % 2 == 0)\\n\\t\\t\\tres += Math.pow(2, i);\\n\\t\\ti++;\\n\\t\\tnum /= 2;\\n\\t}\\n\\treturn res;\\n}\\n\\t",
                "solutionTags": [],
                "code": "```\\npublic int findComplement(int num) {\\n\\n\\tint i = 0;\\n\\tint res = 0;\\n\\t\\n\\twhile (num > 0) {\\n\\t\\n\\t\\tif (num % 2 == 0)\\n\\t\\t\\tres += Math.pow(2, i);\\n\\t\\ti++;\\n\\t\\tnum /= 2;\\n\\t}\\n\\treturn res;\\n}\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 613373,
                "title": "java-optimal-o-1-solution-debunked",
                "content": "```\\nclass Solution {\\n    public int bitwiseComplement(int num) {\\n        if(num==0)\\n            return 1;\\n        int x = (int)(Math.log(num) / Math.log(2));\\n        int k = (int)(Math.pow(2,x+1)-1);\\n        return k-num; // return num ^ k is also valid.. both are same.\\n    }\\n}\\n```\\nBasically Approach is to calculate, the number of bits required, and it will be ((log num base 2) + 1)\\nnow we just have to perform obtained number-actual number to get correct answer.\\n\\nIf you like the solution, upvote it, it will help others as well.\\n\\nI have started writing my blog, a month ago, and if you want detailed answer please check and share : https://worldofalgorithms.blogspot.com/2020/05/complement-of-base-10-integer.html",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int num) {\\n        if(num==0)\\n            return 1;\\n        int x = (int)(Math.log(num) / Math.log(2));\\n        int k = (int)(Math.pow(2,x+1)-1);\\n        return k-num; // return num ^ k is also valid.. both are same.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613061,
                "title": "a-few-solutions",
                "content": "**1-liners:**\\n\\nReturn the xor of each bit as a base-2 string parsed as base-10 integer.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var bitwiseComplement = { x: Int -> x.toString(2).map{ Character.getNumericValue(it) xor 1 }.joinToString(\"\").toInt(2) }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet bitwiseComplement = x => parseInt(x.toString(2).split(\\'\\').map(bit => bit == \\'1\\' ? \\'0\\' : \\'1\\').join(\\'\\'), 2);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def bitwiseComplement(self, x: int) -> int:\\n        return int(\\'\\'.join([\\'1\\' if bit == \\'0\\' else \\'0\\' for bit in bin(x)[2:]]), 2)\\n```\\n\\n---\\n\\n**Ones Compliment:**\\n\\nLet `i` be the smallest power of 2 which is greater-than-or-equal-to the input `x`.  Then subtract 1 from `i` to create a bitmask with the ones compliment of `x`.\\n\\n---\\n\\n*Javascript*\\n```\\nlet bitwiseComplement = (x, i = 1) => {\\n    while (i < x)\\n        i <<= 1;\\n    return !x ? !x : ~x & (i - 1);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def bitwiseComplement(self, x: int, i = 1) -> int:\\n        while i < x:\\n            i <<= 1;\\n        return 1 if not x else ~x & (i - 1)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int x, long i = 1) {\\n        while (i < x)\\n            i <<= 1;\\n        return !x ? !x : ~x & (i - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var bitwiseComplement = { x: Int -> x.toString(2).map{ Character.getNumericValue(it) xor 1 }.joinToString(\"\").toInt(2) }\\n}\\n```\n```\\nlet bitwiseComplement = x => parseInt(x.toString(2).split(\\'\\').map(bit => bit == \\'1\\' ? \\'0\\' : \\'1\\').join(\\'\\'), 2);\\n```\n```\\nclass Solution:\\n    def bitwiseComplement(self, x: int) -> int:\\n        return int(\\'\\'.join([\\'1\\' if bit == \\'0\\' else \\'0\\' for bit in bin(x)[2:]]), 2)\\n```\n```\\nlet bitwiseComplement = (x, i = 1) => {\\n    while (i < x)\\n        i <<= 1;\\n    return !x ? !x : ~x & (i - 1);\\n};\\n```\n```\\nclass Solution:\\n    def bitwiseComplement(self, x: int, i = 1) -> int:\\n        while i < x:\\n            i <<= 1;\\n        return 1 if not x else ~x & (i - 1)\\n```\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int x, long i = 1) {\\n        while (i < x)\\n            i <<= 1;\\n        return !x ? !x : ~x & (i - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612996,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public int findComplement(int num) {\\n        \\n        int totalBits = (int)(Math.floor(Math.log(num) / Math.log(2))) + 1; \\n        return (int)(Math.pow(2, totalBits)-1) ^ num; \\n        \\n    }\\n}\\n\\n\\nFor explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/number-complement.html",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findComplement(int num) {\\n        \\n        int totalBits = (int)(Math.floor(Math.log(num) / Math.log(2))) + 1; \\n        return (int)(Math.pow(2, totalBits)-1) ^ num; \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 612632,
                "title": "very-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        # k bits = bit number necessary for num representation\\n        # Find first complement = biggest number that can be made with k bits - num\\n        bitNum = len(bin(N)[2:])\\n        return 2 ** bitNum - 1 - N\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        # k bits = bit number necessary for num representation\\n        # Find first complement = biggest number that can be made with k bits - num\\n        bitNum = len(bin(N)[2:])\\n        return 2 ** bitNum - 1 - N\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425706,
                "title": "easy-c-solution-2-line-of-sol",
                "content": "class Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n        if(N==0)\\n            return 1;\\n        int nobits=floor(log2(N))+1;\\n        return ((1<<nobits)-1)^N;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int N) {\\n        if(N==0)\\n            return 1;\\n        int nobits=floor(log2(N))+1;\\n        return ((1<<nobits)-1)^N;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 395716,
                "title": "python-3-intuitive-lines-faster-than-88",
                "content": "Format number as string, flip 0s and 1s in the string, convert string back to number\\n\\n```\\nclass Solution(object):\\n    def bitwiseComplement(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        bit_n = \\'{:b}\\'.format(N)\\n        complement = \"\".join([\\'1\\' if c == \\'0\\' else \\'0\\' for c in bit_n])\\n        return int(complement, 2)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def bitwiseComplement(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        bit_n = \\'{:b}\\'.format(N)\\n        complement = \"\".join([\\'1\\' if c == \\'0\\' else \\'0\\' for c in bit_n])\\n        return int(complement, 2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 298803,
                "title": "kotlin-one-line-solution",
                "content": "```\\n    fun bitwiseComplement(N: Int): Int {\\n        return N.xor(1.shl(N.toString(2).length) - 1)\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    fun bitwiseComplement(N: Int): Int {\\n        return N.xor(1.shl(N.toString(2).length) - 1)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261733,
                "title": "rust-0ms-2-4mb",
                "content": "```\\nimpl Solution {\\n    pub fn bitwise_complement(n: i32) -> i32 {\\n        let n = n as i64;\\n        for i in 1..33 {\\n            let j = (1i64 << i) - 1;\\n            if j >= n {\\n                return (j - n) as i32;\\n            }\\n        }\\n        panic!()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn bitwise_complement(n: i32) -> i32 {\\n        let n = n as i64;\\n        for i in 1..33 {\\n            let j = (1i64 << i) - 1;\\n            if j >= n {\\n                return (j - n) as i32;\\n            }\\n        }\\n        panic!()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 257623,
                "title": "python-concise-xor-and-binary-method-1-liners",
                "content": "* Concise 1-liner cheat\\n```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        return int(\\'\\'.join(s == \\'1\\' and \\'0\\' or \\'1\\' for s in bin(N)[2:]), 2)\\n```\\n* 1-liner XOR\\n```\\nclass Solution:\\n    def bitwiseComplement(self, N: int, M = 0, m = 0) -> int:\\n        return N ^ M if M and M >= N else self.bitwiseComplement(N, M + 2 ** m, m + 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        return int(\\'\\'.join(s == \\'1\\' and \\'0\\' or \\'1\\' for s in bin(N)[2:]), 2)\\n```\n```\\nclass Solution:\\n    def bitwiseComplement(self, N: int, M = 0, m = 0) -> int:\\n        return N ^ M if M and M >= N else self.bitwiseComplement(N, M + 2 ** m, m + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257134,
                "title": "javascript-56ms-beats-100",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar bitwiseComplement = function(N) {\\n\\t// If N is 0 or 1 return the opposite.\\n    if (N === 0 || N === 1) {\\n        return (N ^ 1);\\n    }\\n\\t// Set mask to highest positive number.\\n    var mask = 1 << 30;\\n\\t// As long as mask and N is 0 and mask is greater than zero,\\n\\t// shift the mask 1 to the right.\\n    while ((mask & N) === 0 && mask > 0) {\\n        mask >>>= 1;\\n    }\\n\\t// Once the first 1 in N is encountered,\\n\\t// start flipping bits of N.\\n    while(mask > 0) {\\n        N ^= mask;\\n        mask >>>= 1;\\n    }\\n    return N;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar bitwiseComplement = function(N) {\\n\\t// If N is 0 or 1 return the opposite.\\n    if (N === 0 || N === 1) {\\n        return (N ^ 1);\\n    }\\n\\t// Set mask to highest positive number.\\n    var mask = 1 << 30;\\n\\t// As long as mask and N is 0 and mask is greater than zero,\\n\\t// shift the mask 1 to the right.\\n    while ((mask & N) === 0 && mask > 0) {\\n        mask >>>= 1;\\n    }\\n\\t// Once the first 1 in N is encountered,\\n\\t// start flipping bits of N.\\n    while(mask > 0) {\\n        N ^= mask;\\n        mask >>>= 1;\\n    }\\n    return N;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256715,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        temp = {\\'1\\':\\'0\\', \\'0\\':\\'1\\'}\\n        cache = list(\"{0:b}\".format(N))\\n        return int(\\'\\'.join([temp[x] for x in cache]), 2)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def bitwiseComplement(self, N: int) -> int:\\n        temp = {\\'1\\':\\'0\\', \\'0\\':\\'1\\'}",
                "codeTag": "Java"
            },
            {
                "id": 4083804,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n==0) return 1;\\n        int x = 0;\\n        int ans = 0;\\n\\n        while(n>0){\\n            int r = n%2;\\n            if(r==1){\\n                x++;\\n            }else{\\n                ans = ans + (int)Math.pow(2,x);\\n                x++;\\n            }\\n            n=n/2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n==0) return 1;\\n        int x = 0;\\n        int ans = 0;\\n\\n        while(n>0){\\n            int r = n%2;\\n            if(r==1){\\n                x++;\\n            }else{\\n                ans = ans + (int)Math.pow(2,x);\\n                x++;\\n            }\\n            n=n/2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076686,
                "title": "python-2-approach-97-96-beats",
                "content": "**If you got help from this,... Plz Upvote .. it encourage me**\\n# EXAMPLE , \\n        # N = 101  (5)\\n        # MASK WILL BE  111 (7)\\n        # COMPLEMENT MASK - N = 7-5 = 2 (010)\\n# Code\\n```\\n<!-- 1ST APPROACH -->\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n       \\n        if n == 0:\\n            return 1\\n\\n        mask = 0\\n        m = n\\n        while m != 0:\\n            mask = mask << 1 | 1\\n            m = m >> 1\\n        \\n        return mask - n\\n        # OR\\n        #return (~n) & mask \\n\\n<!-- ============================================================ -->\\n<!-- 2ND APPROACH -->\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        x = 1\\n        while n > x:\\n            x = x * 2 + 1\\n        return x - n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n<!-- 1ST APPROACH -->\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n       \\n        if n == 0:\\n            return 1\\n\\n        mask = 0\\n        m = n\\n        while m != 0:\\n            mask = mask << 1 | 1\\n            m = m >> 1\\n        \\n        return mask - n\\n        # OR\\n        #return (~n) & mask \\n\\n<!-- ============================================================ -->\\n<!-- 2ND APPROACH -->\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        x = 1\\n        while n > x:\\n            x = x * 2 + 1\\n        return x - n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048713,
                "title": "beginner-friendly-python-beats-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s assume a number, say 10. \\n\\n```\\nBinary version = 1010\\nComplement = 0101\\nInteger compelement = 5\\n```\\n\\n```\\nmask is initially 0,\\nTill m = 10 (1010) is not 0,\\n1. add a 1 (left shift 0 at the end + OR with 1), mask = 1\\n2. divide 10 by 2 or right shift by 1\\n3. now m = 5(101)\\n- Iteration 2: mask = 11, m = 2 (10)\\n- Iteration 3: mask = 111, m = 1 (1)\\n- Iteration 4: mask = 1111, m = 0\\n```\\n\\n\\n\\nTo do this using code, we follow these steps:\\n\\n1. First, we check if the given number is 0. If it is, the complement is 1, because flipping 0 gives us 1.\\n```\\nif n == 0:\\n    return 1\\n```\\n\\n2. To find the complement for any other number, we need to figure out how many bits it has. \\n\\n\\n3. Now, we create a \"mask,\" which is a pattern of bits. We set as many bits as our number has to 1. So, for 10, our mask is \\'1111\\' (4 ones in binary).\\n\\n```\\nmask is basically all ones. \\nfor example: \\nmask for 10 (1010) = 1111\\nmask for 5 (101) = 111\\nmask for 11 (1011) = 1111\\n```\\n```\\nmask is initially 0,\\nTill m = 10 (1010) is not 0,\\n- add a 1 (left shift 0 at the end + OR with 1), mask = 1\\n- divide 10 by 2 or right shift by 1\\n- now m = 5(101)\\n- Iteration 2: mask = 11, m = 2 (10)\\n- Iteration 3: mask = 111, m = 1 (1)\\n- Iteration 4: mask = 1111, m = 0\\n\\n```\\n\\n4. Take the complement of the original number (flipping the bits using \\'~\\' in code) and apply the mask to it (using \\'&\\' in code). This gives us the complement of the number.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        #generate a new number\\n        if n == 0:\\n            return 1\\n        m = n\\n        mask = 0\\n        while (m!=0):\\n            #generate a mask\\n            mask = (mask << 1) | 1\\n            m = m >> 1\\n        answer = (~n) & mask\\n        \\n        return answer\\n        \\n        \\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nBinary version = 1010\\nComplement = 0101\\nInteger compelement = 5\\n```\n```\\nmask is initially 0,\\nTill m = 10 (1010) is not 0,\\n1. add a 1 (left shift 0 at the end + OR with 1), mask = 1\\n2. divide 10 by 2 or right shift by 1\\n3. now m = 5(101)\\n- Iteration 2: mask = 11, m = 2 (10)\\n- Iteration 3: mask = 111, m = 1 (1)\\n- Iteration 4: mask = 1111, m = 0\\n```\n```\\nif n == 0:\\n    return 1\\n```\n```\\nmask is basically all ones. \\nfor example: \\nmask for 10 (1010) = 1111\\nmask for 5 (101) = 111\\nmask for 11 (1011) = 1111\\n```\n```\\nmask is initially 0,\\nTill m = 10 (1010) is not 0,\\n- add a 1 (left shift 0 at the end + OR with 1), mask = 1\\n- divide 10 by 2 or right shift by 1\\n- now m = 5(101)\\n- Iteration 2: mask = 11, m = 2 (10)\\n- Iteration 3: mask = 111, m = 1 (1)\\n- Iteration 4: mask = 1111, m = 0\\n\\n```\n```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        #generate a new number\\n        if n == 0:\\n            return 1\\n        m = n\\n        mask = 0\\n        while (m!=0):\\n            #generate a mask\\n            mask = (mask << 1) | 1\\n            m = m >> 1\\n        answer = (~n) & mask\\n        \\n        return answer\\n        \\n        \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404314,
                "title": "easy-bit-manipulation-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n      int m=n;\\n      int mask=0;\\n      if(n==0)\\n      return 1;\\n      while(m!=0){\\n          mask=(mask << 1)|1;\\n          m=m>>1;\\n      }\\n      int ans = (~n) & mask;\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n      int m=n;\\n      int mask=0;\\n      if(n==0)\\n      return 1;\\n      while(m!=0){\\n          mask=(mask << 1)|1;\\n          m=m>>1;\\n      }\\n      int ans = (~n) & mask;\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326564,
                "title": "2-solutions-one-liner-beat-90-93-26ms-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        return (int((bin(n)[2:]).replace(\\'1\\', \\'2\\').replace(\\'0\\',\\'1\\').replace(\\'2\\',\\'0\\'),2))\\n\\n        return (int((bin(n)[2:]).translate(str.maketrans(\"01\", \"10\")),2))\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        return (int((bin(n)[2:]).replace(\\'1\\', \\'2\\').replace(\\'0\\',\\'1\\').replace(\\'2\\',\\'0\\'),2))\\n\\n        return (int((bin(n)[2:]).translate(str.maketrans(\"01\", \"10\")),2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088828,
                "title": "c-100-faster-constant-space-using-mask",
                "content": "/*\\nApproach : Hit and Trail  (Bit Manipulation)\\n \\nTake Example \\n\\nInput :  n = 5   Binary Representation of 5 is   0 0 0 0 0 0 0 0 0 0  0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1\\n\\nOutput : ans = 2 Binary Representation of 2 is   0 0 0 0 0 0 0 0 0 0  0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0\\n\\nNow Observe Care fully , If we perform not ~ operation on 5 it binary representation looks like, \\n                                        \\n                                                 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0\\n                                                 \\nNow we obeserving that we partially got our answer just we have to ignore 1\\'s in above binary represeantion .\\n\\nNow Question arise that how to achieve that , So its simple just create  the mask such that it conatain 3  1\\'s in last in its binary presenation and rest are 0\\'s IAM TALKING ABOUT PARTUCULAR CASE (HERE INPUT IS 5).\\n\\nIts look like --->                              0 0 0 0 0 0 0 0 0 0  0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1  \\n                                                \\nAfter doing that just perform \\'&\\' operation on  :  ~n & mask\\n\\nFinale ans :  int ans =  (~n) & mask\\n   \\n                                                1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0\\n                                            &   \\n                                                0 0 0 0 0 0 0 0 0 0  0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 \\n                            -------------------------------------------------------------------------------------------------\\n           Ans :                                0 0 0 0 0 0 0 0 0 0  0 0 0 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0\\n           \\n          And it is binary representation of 2 \\n\\nHow to Find mask in General : \\n\\nIts easy to find mask :  \\n\\nstep 1 : Initialaize mask with 0 .\\nstep 2 : Now check input binary Representation where the last 1 present in from last it will help to know us how many 1\\'s should conatin last of mask in its binary representation (last  1\\'s position == no. of 1\\'s in mask at last ).\\n\\nstep 3 : for achiving that just left shift the mask once and or with 1 \\nstep 4 : perfrom until no. reduced to zero for that right shift the number unteel its become zero .\\n\\n  plz upvote solution if you like otherwise thank for look into solution \\n*/\\n ```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m = n;\\n        int mask = 0;\\n        if(n==0) return 1;\\n        while(m !=0){\\n            mask = (mask<<1) | 1;\\n            m = m>>1;\\n}\\n        int ans = (~n) & mask;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m = n;\\n        int mask = 0;\\n        if(n==0) return 1;\\n        while(m !=0){\\n            mask = (mask<<1) | 1;\\n            m = m>>1;\\n}\\n        int ans = (~n) & mask;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047806,
                "title": "1009-java-2-approach",
                "content": "# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats ..... : 100%\\n- Memory : 39.3 MB\\n- Beats ..... : 71.7%\\n\\n# Code\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0) return 1;\\n        int temp = 1 , total = 0;\\n        while(n != 0){\\n            if(n % 2 == 0) total += temp;\\n            n /= 2;\\n            temp += temp;\\n        }\\n        return total;\\n    }\\n}\\n```\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 8 ms\\n- Beats ..... : 5.34%\\n- Memory : 39.9 MB\\n- Beats ..... : 46.21%\\n\\n# Code\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0) return 1;\\n        String binary = \"\";\\n        while(n != 0){\\n            binary = n % 2 + binary;\\n            n /= 2;\\n        }\\n        int temp = 1 , total = 0;\\n        for(int i = binary.length()-1; i >= 0; i--){\\n            if(binary.charAt(i) == \\'0\\') total += temp;\\n            temp += temp;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0) return 1;\\n        int temp = 1 , total = 0;\\n        while(n != 0){\\n            if(n % 2 == 0) total += temp;\\n            n /= 2;\\n            temp += temp;\\n        }\\n        return total;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0) return 1;\\n        String binary = \"\";\\n        while(n != 0){\\n            binary = n % 2 + binary;\\n            n /= 2;\\n        }\\n        int temp = 1 , total = 0;\\n        for(int i = binary.length()-1; i >= 0; i--){\\n            if(binary.charAt(i) == \\'0\\') total += temp;\\n            temp += temp;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990035,
                "title": "c-3-lines-100-faster-o-1-space",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        auto cache = n; int bit = 1;\\n        do  {\\n            n = n ^ bit;\\n            bit = bit << 1;\\n            cache = cache >> 1;\\n        } while (cache);\\n        return n;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        auto cache = n; int bit = 1;\\n        do  {\\n            n = n ^ bit;\\n            bit = bit << 1;\\n            cache = cache >> 1;\\n        } while (cache);\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835992,
                "title": "c-solution-basic",
                "content": "Treat the case for n = 0 to simply return 1\\nLoop bit by bit until mask equal 0 or the first bit set to 1\\nLoop on the rest of the bits and if the bit equal 0 add the value of the mask to the result\\nThen return the result\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        unsigned int mask = 0x80000000;\\n        int res = 0;\\n        \\n        if (n == 0)\\n            return 1;\\n        for (; mask != 0; mask = mask >> 1)\\n            if (n & mask)\\n                break;\\n        for (; mask != 0; mask = mask >> 1) {\\n            if (!(n & mask))\\n                res += mask;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        unsigned int mask = 0x80000000;\\n        int res = 0;\\n        \\n        if (n == 0)\\n            return 1;\\n        for (; mask != 0; mask = mask >> 1)\\n            if (n & mask)\\n                break;\\n        for (; mask != 0; mask = mask >> 1) {\\n            if (!(n & mask))\\n                res += mask;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719062,
                "title": "complement-of-base-10-integer-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int k;\\n        if(n==0)\\n            k=1;\\n        else\\n         k=log2(n)+1;\\n        bitset<32> b(n);\\n        for(int i=0;i<k;++i)\\n        {\\n            b.flip(i);\\n        }\\n        return b.to_ulong();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int k;\\n        if(n==0)\\n            k=1;\\n        else\\n         k=log2(n)+1;\\n        bitset<32> b(n);\\n        for(int i=0;i<k;++i)\\n        {\\n            b.flip(i);\\n        }\\n        return b.to_ulong();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617576,
                "title": "c-easy-solution-100-faster",
                "content": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n      \\n\\t  if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 0;\\n        }\\n        int d=1;\\n        while(d<=n){\\n            d*=2;\\n        }\\n        return (d-n-1);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n      \\n\\t  if(n==0){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2614027,
                "title": "c-easy-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n     int m = n;\\n     int mask = 0;\\n     \\n     //Edge Case when n == 0 \\n     if(n==0)\\n         return 1;\\n     while(m!=0)\\n     {\\n         mask = (mask << 1)|1; // Left Shift Operator\\n         m = m >> 1; //Right Shift Operator\\n     }\\n        int ans =(~n) & mask;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n     int m = n;\\n     int mask = 0;\\n     \\n     //Edge Case when n == 0 \\n     if(n==0)\\n         return 1;\\n     while(m!=0)\\n     {\\n         mask = (mask << 1)|1; // Left Shift Operator\\n         m = m >> 1; //Right Shift Operator\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2606337,
                "title": "c-easy-100-fast-soln-and-beats-75-soln-in-terms-of-space",
                "content": "int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        int d=1;\\n        while(d<=n) d*=2;\\n        return (d-n-1);\\n        \\n    }",
                "solutionTags": [],
                "code": "int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        int d=1;\\n        while(d<=n) d*=2;\\n        return (d-n-1);\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2597850,
                "title": "c-faster-than-100-of-c-bit-manipulation",
                "content": "![image](https://assets.leetcode.com/users/images/ee864b8e-d409-4bba-92e1-f5f535919043_1663604078.5444117.png)\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n == 0) {\\n            return 1;\\n        }\\n        int position = 0;\\n        int temp = n;\\n        while(temp) {\\n            position++;\\n            temp = temp >> 1;\\n        }\\n        int mask = (1 << position) - 1;\\n        return (~n & mask);\\n    }\\n};\\n```\\n**TC : O(position of most significant set bit + 1)\\nSC : O(1)**",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n == 0) {\\n            return 1;\\n        }\\n        int position = 0;\\n        int temp = n;\\n        while(temp) {\\n            position++;\\n            temp = temp >> 1;\\n        }\\n        int mask = (1 << position) - 1;\\n        return (~n & mask);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562549,
                "title": "efficient-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int complement,count=0;\\n        int temp=n;\\n        \\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        \\n        //Calculating nearest complete binary number\\n        //number+complement=complete binary number\\n        //Eg: 110 + 001 = 111 (7 in decimal)\\n        while(temp!=0)\\n        {\\n            count++;\\n            temp=temp>>1;\\n        }\\n        \\n        temp=pow(2,count)-1;\\n        \\n        return temp-n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int complement,count=0;\\n        int temp=n;\\n        \\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        \\n        //Calculating nearest complete binary number\\n        //number+complement=complete binary number\\n        //Eg: 110 + 001 = 111 (7 in decimal)\\n        while(temp!=0)\\n        {\\n            count++;\\n            temp=temp>>1;\\n        }\\n        \\n        temp=pow(2,count)-1;\\n        \\n        return temp-n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532683,
                "title": "java-0-ms",
                "content": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        int m = n;\\n        int mask = 0;\\n        \\n        // edge case\\n        if(n==0) return 1;\\n        \\n        while(m!=0) {\\n            mask = (mask<<1) | 1;\\n            m= m>>1;\\n        }\\n        \\n        int answer = (~n) & mask;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        \\n        int m = n;\\n        int mask = 0;\\n        \\n        // edge case\\n        if(n==0) return 1;\\n        \\n        while(m!=0) {\\n            mask = (mask<<1) | 1;\\n            m= m>>1;\\n        }\\n        \\n        int answer = (~n) & mask;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524631,
                "title": "ans-in-c",
                "content": "# **simple answer c++**\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n       \\n     int m = n;\\n     int mask = 0;\\n        \\n     if(n == 0)\\n         \\n      return 1;\\n                \\n     while( m!=0 )   \\n    {\\n         mask = (mask << 1) | 1;\\n         m = m >> 1 ;\\n     }\\n       \\n     int ans = (~n) & mask; \\n       \\n       return ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n       \\n     int m = n;\\n     int mask = 0;\\n        \\n     if(n == 0)\\n         \\n      return 1;\\n                \\n     while( m!=0 )   \\n    {\\n         mask = (mask << 1) | 1;\\n         m = m >> 1 ;\\n     }\\n       \\n     int ans = (~n) & mask; \\n       \\n       return ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505332,
                "title": "c-with-bitwise-operation",
                "content": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if (n==0){return 1;}\\n        int m=n;\\n        int mask =0;\\n        \\n        while(m!=0){\\n            mask=(mask<<1) | 1;\\n            m=m>>1;\\n        }\\n        int ans= ~n & mask;\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if (n==0){return 1;}",
                "codeTag": "Java"
            },
            {
                "id": 2502006,
                "title": "python-guideline-for-bitwise-operations-and-solution-explanation",
                "content": "** The Logic**:\\nWe loop through the digits of the number and replace 0 to 1 and 1 to 0. Easy peasy :)\\nBut not everyone knows Python bitwise operations. I didn\\'t know also :)\\n* `n.bit_length()` - return number of digits in the `bin` representation.\\n* `n >> i` - moves `bin` representation `i` positions right. For example, `101010 >> 2` -> `1010`\\n* If we combine `n >> i`  and `&` we can take the `i-th` digit like this: `(n >> i) & 1` \\n* `n &= ~(1 << i)` or `n = n & ~(1 << i)` replaces `i-th` digit by 0\\n* ` n |= (1 << i)` or ` n = n (1 << i)` replaces `i-th` digit by 1\\n\\nGood luck!\\nIf you like it please upvote.\\n\\n```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        \\n        if n == 0:\\n            return 1\\n        \\n        for i in range(n.bit_length()):\\n            \\n            if (n >> i) & 1 == 1:\\n                n &= ~(1 << i)\\n            else:\\n                n |= (1 << i)\\n        return n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        \\n        if n == 0:\\n            return 1\\n        \\n        for i in range(n.bit_length()):\\n            \\n            if (n >> i) & 1 == 1:\\n                n &= ~(1 << i)\\n            else:\\n                n |= (1 << i)\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468427,
                "title": "java-100-0-ms-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        int bit=1;\\n        while(n>=bit)\\n        {\\n            n=n^bit;\\n            bit=bit<<1;\\n        }\\n        return n;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        int bit=1;\\n        while(n>=bit)\\n        {\\n            n=n^bit;\\n            bit=bit<<1;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399186,
                "title": "c-solution-faster-than-100-of-online-submissions-easy-understanding-basic-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int ans = 0;\\n        if (n == 0){\\n            return 1;\\n        }\\n        for (int i = 0; n > 0; i++){\\n            ans += !(n %2) * pow(2,i);\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int ans = 0;\\n        if (n == 0){\\n            return 1;\\n        }\\n        for (int i = 0; n > 0; i++){\\n            ans += !(n %2) * pow(2,i);\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397588,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0)\\n            return 1;\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans=(~n)&mask;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0)\\n            return 1;\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans=(~n)&mask;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346011,
                "title": "easiest-c-solution-bit-manupilation-beginner-friendly-easy",
                "content": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0)\\n            return 1;\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans=(~n)&mask;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0)\\n            return 1;\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2335595,
                "title": "complement-of-base-10-integer-100-fast-o-1",
                "content": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n        int l=(int)(Math.log(n)/Math.log(2));\\n        int xor= (int)Math.pow(2,l+1)-1;\\n        return (n^xor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n        int l=(int)(Math.log(n)/Math.log(2));\\n        int xor= (int)Math.pow(2,l+1)-1;\\n        return (n^xor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333246,
                "title": "brute-force-approach-100-fast-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int bitwiseComplement(int n) {\\n        if (n>=2) {\\n            int maxn=ceil(log2(n));\\n            if (maxn==log2(n)) {\\n                return pow(2, maxn+1)-n-1;\\n            }\\n            return pow(2, maxn)-n-1;\\n        } else if(n==1) {\\n            return 0;\\n        } else if (n==0) {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int bitwiseComplement(int n) {\\n        if (n>=2) {\\n            int maxn=ceil(log2(n));\\n            if (maxn==log2(n)) {\\n                return pow(2, maxn+1)-n-1;\\n            }\\n            return pow(2, maxn)-n-1;\\n        } else if(n==1) {\\n            return 0;\\n        } else if (n==0) {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325407,
                "title": "faster-than-100-and-0ms",
                "content": "**Please Upvote**\\n```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0)\\n            return 1;\\n        int pow = (int)(Math.log(n)/Math.log(2)) +1;\\n        int val = (int)(Math.pow(2,pow)) - 1;\\n        int ans = n ^ val;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0)\\n            return 1;\\n        int pow = (int)(Math.log(n)/Math.log(2)) +1;\\n        int val = (int)(Math.pow(2,pow)) - 1;\\n        int ans = n ^ val;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320666,
                "title": "complement-of-base-10-integer-c-very-easy-soltuon-simple-logic",
                "content": "Plz upvote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0)\\n            return 1;\\n        while(m!=0)\\n        {\\n            mask=(mask<<1) |1;\\n            m=m>>1;\\n        }\\n        int ans=(~n)&mask;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0)\\n            return 1;\\n        while(m!=0)\\n        {\\n            mask=(mask<<1) |1;\\n            m=m>>1;\\n        }\\n        int ans=(~n)&mask;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303572,
                "title": "c-very-easy-solution",
                "content": "//corner case\\n        if (n==0)\\n        {\\n            return 1;\\n        }\\n        // normal comparing the bit and if 0 then add else continue\\n        int ans=0;\\n        int i=0;\\n        while(n!=0)\\n        {\\n            int bitw=n&1;\\n            \\n            if(bitw==0)\\n            ans=ans+pow(2,i);\\n            n=n>>1;\\n            i++;\\n        }\\n        return ans;",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "//corner case\\n        if (n==0)\\n        {\\n            return 1;\\n        }\\n        // normal comparing the bit and if 0 then add else continue\\n        int ans=0;\\n        int i=0;\\n        while(n!=0)\\n        {\\n            int bitw=n&1;\\n            \\n            if(bitw==0)\\n            ans=ans+pow(2,i);\\n            n=n>>1;\\n            i++;\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2216486,
                "title": "simple-python-solution-bit-manipulation-xor",
                "content": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        \"\"\"\\n        Simple Formula:\\n        \\n        To Find complement of any base 10 integer we\\n        have to invert the bits,\\n        \\n        A simple way to achieve this is by performing XOR\\n        of the given number with a number where all the bits are set\\n        i.e. 5\\'s complement = 1 0 1 XOR 1 1 1(7) = 0 1 0(2)\\n        \\n        To do this, we have to figure out the number where all\\n        bits are set, we can achieve that by 2 steps:\\n            1. Count the number of bits in given number by performing right shift until numbr becomes 0\\n            2. 2 power the bitCount - 1 will give us the all bit set number\\n            \\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        tmp, bitCount = int(n), 0\\n        while tmp > 0:\\n            bitCount += 1\\n            tmp = tmp >> 1\\n        allBitSetNum = (2 ** bitCount) - 1\\n        return allBitSetNum ^ n\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        \"\"\"\\n        Simple Formula:\\n        \\n        To Find complement of any base 10 integer we\\n        have to invert the bits,\\n        \\n        A simple way to achieve this is by performing XOR\\n        of the given number with a number where all the bits are set\\n        i.e. 5\\'s complement = 1 0 1 XOR 1 1 1(7) = 0 1 0(2)\\n        \\n        To do this, we have to figure out the number where all\\n        bits are set, we can achieve that by 2 steps:\\n            1. Count the number of bits in given number by performing right shift until numbr becomes 0\\n            2. 2 power the bitCount - 1 will give us the all bit set number\\n            \\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        tmp, bitCount = int(n), 0\\n        while tmp > 0:\\n            bitCount += 1\\n            tmp = tmp >> 1\\n        allBitSetNum = (2 ** bitCount) - 1\\n        return allBitSetNum ^ n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215316,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n==0) return 1;\\n        else {\\n     int k,dec=0,b=1;\\n        string s,str;\\n        while(n!=0){\\n            if(n&1) s+=\\'1\\';\\n            else s+=\\'0\\';\\n            n=n>>1;\\n        }\\n        reverse(s.begin(),s.end());\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') str+=\\'0\\';\\n            else if(s[i]==\\'0\\') str+=\\'1\\';\\n        }\\n        //cout<<str<<endl;\\n        for(int j=str.size()-1;j>=0;j--){\\n            if(str[j]==\\'1\\') dec+=b;\\n            b*=2;\\n        }\\n        return dec;\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        if(n==0) return 1;\\n        else {\\n     int k,dec=0,b=1;\\n        string s,str;\\n        while(n!=0){\\n            if(n&1) s+=\\'1\\';\\n            else s+=\\'0\\';\\n            n=n>>1;\\n        }\\n        reverse(s.begin(),s.end());\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') str+=\\'0\\';\\n            else if(s[i]==\\'0\\') str+=\\'1\\';\\n        }\\n        //cout<<str<<endl;\\n        for(int j=str.size()-1;j>=0;j--){\\n            if(str[j]==\\'1\\') dec+=b;\\n            b*=2;\\n        }\\n        return dec;\\n    }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2194373,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n       if(n==0)return 1;\\n        return (1<<((int)log2(n) + 1)) - n -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n       if(n==0)return 1;\\n        return (1<<((int)log2(n) + 1)) - n -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192777,
                "title": "c-bitset-function-string",
                "content": "![image](https://assets.leetcode.com/users/images/7b11ac67-e7e7-425d-b2c4-1e9f7fe6c56b_1656104689.573992.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint bitwiseComplement(int n) {\\n\\t\\t\\tif(n==0)return 1;\\n\\t\\t\\tstring str=bitset<32>(n).to_string();\\n\\t\\t\\tint s;int ans=0;int k=0;\\n\\t\\t\\tfor(int i=0;i<32;i++){\\n\\t\\t\\t\\tif(str[i]==\\'1\\'){\\n\\t\\t\\t\\t\\ts=i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}    \\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=31;i>=s;i--){\\n\\t\\t\\t\\tif(str[i]==\\'0\\')ans+=pow(2,k);\\n\\t\\t\\t\\tk++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint bitwiseComplement(int n) {\\n\\t\\t\\tif(n==0)return 1;\\n\\t\\t\\tstring str=bitset<32>(n).to_string();\\n\\t\\t\\tint s;int ans=0;int k=0;\\n\\t\\t\\tfor(int i=0;i<32;i++){\\n\\t\\t\\t\\tif(str[i]==\\'1\\'){\\n\\t\\t\\t\\t\\ts=i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2156223,
                "title": "c-easy-fast-solution-0-ms-faster-than-100-using-loops",
                "content": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        \\n        int i=0,ans=0;\\n        \\n        while(n>0){\\n            \\n            if(n%2==0)\\n                ans+= pow(2,i)*1;\\n            \\n            i++;\\n            n/=2;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        \\n        if(n==0) return 1;\\n        \\n        int i=0,ans=0;\\n        \\n        while(n>0){\\n            \\n            if(n%2==0)\\n                ans+= pow(2,i)*1;\\n            \\n            i++;\\n            n/=2;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2032700,
                "title": "multiple-javascript-typescript-solutions-explained-with-timing",
                "content": "In order of speed:\\n\\n* **Array to Pre-Allocated Array:**\\n\\t* 65ms - 43.1MB (100%)\\n\\t* Explanation:\\n\\t\\t* Get the binary of the number using the unsigned right shift operator and running the `toString()` method with a radix parameter of `2` for binary and split it into an array\\n\\t\\t* Create a compliment array with pre-allocated space for the length of the binary string\\n\\t\\t* Run a native `for` loop over the the binary string as an array\\n\\t\\t\\t* Each itteration insert the compliment into the pre-allocated compliment array at the current index\\n\\t\\t* Run the `parseInt()` method with the joined pre-allocated compliment array and a radix of `2` to get the base10\\n\\n```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2).split(\\'\\');\\n  let res = new Array(bin.length);\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res[i] = (bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res.join(\\'\\'),\\n    2\\n  );\\n};\\n```\\n\\n* **String to Pre-Allocated Array:**\\n\\t* 68ms - 43.3MB\\n\\t* Explanation:\\n\\t\\t* Get the binary of the number using the unsigned right shift operator and running the `toString()` method with a radix parameter of `2` for binary\\n\\t\\t* Create an array with pre-allocated space for the length of the binary string\\n\\t\\t* Run a native `for` loop over the charecters of the binary\\n\\t\\t\\t* Each itteration insert the compliment into the pre-allocated compliment array at the current index\\n\\t\\t* Run the `parseInt()` method with the joined pre-allocated array and a radix of `2` to get the base10 \\n\\n```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2);\\n  let res = new Array(bin.length);\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res[i] = (bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res.join(\\'\\'),\\n    2\\n  );\\n};\\n```\\n\\n* **String to String Builder:**\\n\\t*  71ms - 43.2MB\\n\\t*  Explanation:\\n\\t\\t*  Get the binary of the number using the unsigned right shift operator and running the `toString()` method with a radix parameter of `2` for binary\\n\\t\\t*  Create an empty string to build out for the result\\n\\t\\t*  Run a native `for` loop over the charecters of the binary\\n\\t\\t\\t*  Each itteration continue to build the result string with each compliment\\n\\t\\t*  Run the `parseInt()` method with the compliment string and a radix of `2` to get the base10 \\n\\n```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2);\\n  let res = \\'\\';\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res += (bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res,\\n    2\\n  );\\n};\\n```\\n\\n* **String to Empty Array Insertion:**\\n\\t* 98ms - 42.9MB\\n\\t* Explanation:\\n\\t\\t* Get the binary of the number using the unsigned right shift operator and running the `toString()` method with a radix parameter of `2` for binary\\n\\t\\t* Create an empty array to build out the compliments\\n\\t\\t* Run a native `for` loop over the charecters of the binary\\n\\t\\t\\t* Each itteration determine the compliment and insert it into the empty compliment array at the current index\\n\\t\\t* Run the `parseInt()` method with the joined coompliment array and a radix of `2` to get the base10\\n\\n```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2);\\n  let res = [];\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res[i] = (bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res.join(\\'\\'),\\n    2\\n  );\\n};\\n```\\n\\n* **String to Empty Array Push:**\\n\\t* 99ms - 43MB\\n\\t* Explanation:\\n\\t\\t* Get the binary of the number using the unsigned right shift operator and running the `toString()` method with a radix parameter of `2` for binary\\n\\t\\t* Create an empty array to build out the compliments\\n\\t\\t* Run a native `for` loop over the charecters of the binary\\n\\t\\t\\t* Each itteration `push()` the compliment onto the empty compliment array\\n\\t\\t* Run the `parseInt()` method with the joined coompliment array and a radix of `2` to get the base10\\n\\n```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2).split(\\'\\');\\n  let res = [];\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res.push(bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res.join(\\'\\'),\\n    2\\n  );\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2).split(\\'\\');\\n  let res = new Array(bin.length);\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res[i] = (bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res.join(\\'\\'),\\n    2\\n  );\\n};\\n```\n```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2);\\n  let res = new Array(bin.length);\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res[i] = (bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res.join(\\'\\'),\\n    2\\n  );\\n};\\n```\n```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2);\\n  let res = \\'\\';\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res += (bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res,\\n    2\\n  );\\n};\\n```\n```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2);\\n  let res = [];\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res[i] = (bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res.join(\\'\\'),\\n    2\\n  );\\n};\\n```\n```\\nfunction bitwiseComplement(n: number): number {\\n  let bin = (n >>> 0).toString(2).split(\\'\\');\\n  let res = [];\\n  \\n  for (let i = 0; i < bin.length; i++) {\\n    res.push(bin[i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n  }\\n  \\n  return parseInt(\\n    res.join(\\'\\'),\\n    2\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978160,
                "title": "java-easy-approach",
                "content": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n          String s = Integer.toBinaryString(n);\\n        StringBuilder m = new StringBuilder();\\n        for (int i =0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'0\\'){\\n               m.append(\\'1\\');\\n            }\\n            else {\\n                m.append(\\'0\\');\\n            }\\n        }\\n\\n        int v = Integer.parseInt(m.toString(),2);\\n        return v;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int n) {\\n          String s = Integer.toBinaryString(n);\\n        StringBuilder m = new StringBuilder();\\n        for (int i =0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'0\\'){\\n               m.append(\\'1\\');\\n            }\\n            else {\\n                m.append(\\'0\\');\\n            }\\n        }\\n\\n        int v = Integer.parseInt(m.toString(),2);\\n        return v;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935241,
                "title": "complement-of-base-10-integer-solution-java",
                "content": "class Solution {\\n  public int bitwiseComplement(int N) {\\n    int mask = 1;\\n\\n    while (mask < N)\\n      mask = (mask << 1) + 1;\\n\\n    return mask ^ N;\\n  }\\n}\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n  public int bitwiseComplement(int N) {\\n    int mask = 1;\\n\\n    while (mask < N)\\n      mask = (mask << 1) + 1;\\n\\n    return mask ^ N;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1931633,
                "title": "javascript-solution-faster-than-96",
                "content": "```\\n    var bitwiseComplement = function(n) {\\n      return parseInt(\\n        [...n.toString(2)]\\n          .map((bin) => (bin === \\'0\\' ? (bin = \\'1\\') : (bin = \\'0\\')))\\n          .join(\\'\\'),\\n        2\\n      );\\n    };\\n```",
                "solutionTags": [],
                "code": "```\\n    var bitwiseComplement = function(n) {\\n      return parseInt(\\n        [...n.toString(2)]\\n          .map((bin) => (bin === \\'0\\' ? (bin = \\'1\\') : (bin = \\'0\\')))\\n          .join(\\'\\'),\\n        2\\n      );\\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916405,
                "title": "c-1-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n      return n ? n ^ ((1 << sizeof(n)*8 - __builtin_clz(n)) - 1) : 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n      return n ? n ^ ((1 << sizeof(n)*8 - __builtin_clz(n)) - 1) : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896224,
                "title": "python-easy-solution-using-built-in-function",
                "content": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        bin_n = bin(n)[2:]\\n        comp = \"0b\"\\n        for i in bin_n:\\n            if i == \"0\":\\n                comp += \"1\"\\n            else:\\n                comp += \"0\"\\n        return int(comp, 2)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        bin_n = bin(n)[2:]\\n        comp = \"0b\"\\n        for i in bin_n:\\n            if i == \"0\":\\n                comp += \"1\"\\n            else:\\n                comp += \"0\"\\n        return int(comp, 2)",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565515,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1565863,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1568196,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1566865,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1575211,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1789212,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1785121,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1572672,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2059790,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2035826,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1565515,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1565863,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1568196,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1566865,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1575211,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1789212,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1785121,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1572672,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2059790,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2035826,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/complement-of-base-10-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/number-complement/\\n"
                    },
                    {
                        "username": "pekras",
                        "content": "The operation requested (invert all bits up to the highest 1-bit) doesn\\'t really make sense for an input of 0, since there is no highest 1-bit.\\n\\nIf we do accept it though, there are 2 mostly reasonable outputs.  It should either be -1 (all bits inverted) or 0 (none of the bits inverted). I would argue that 0 makes much more sense here, but you can make a case for either.\\n\\nI can\\'t figure out the logic that led to 1 as the output."
                    },
                    {
                        "username": "lalib",
                        "content": "Aren\\'t Problem 1009 and 476 one and same? Should one of them be removed?"
                    },
                    {
                        "username": "VinayakGaikwad121",
                        "content": "No, let me earn free points"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var bitwiseComplement = function(N) {\\n   let binary = N.toString(2);\\n   return parseInt(binary.split(\"\").map(el=>el^1).join(\"\"), 2)\\n};"
                    },
                    {
                        "username": "Lokesh22kar",
                        "content": "complicated"
                    },
                    {
                        "username": "sauravkumargoswami530",
                        "content": "Hey friend, this is our code for this problem and this code is 0 ms run time use,\\n\\nclass Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int m=n;\\n        int mask=0;\\n        if(n==0){\\n            return 1;\\n        }\\n        while(m!=0){\\n            mask=(mask<<1)|1;\\n            m=m>>1;\\n        }\\n        int ans= (~n)&mask;\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "vacaw",
                        "content": "I think this is the same question as the: https://leetcode.com/problems/number-complement/ \\nThe only difference is that in this question the 0 is also allowed as an input."
                    },
                    {
                        "username": "Avanti9",
                        "content": "Do we not need to convert the integer to its binary format and then perform the steps and convert the binary bits to digit???? "
                    },
                    {
                        "username": "anasbz949",
                        "content": "I think this could be the best solution for C++ user-\\n\\n int m = n;\\n        int mask = 0;\\n        if(n == 0)\\n            return 1;\\n        while(m != 0){\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }\\n       int ans = (~n) & mask;\\n       return ans;\\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Pairs of Songs With Total Durations Divisible by 60",
        "question_content": "<p>You are given a list of songs where the <code>i<sup>th</sup></code> song has a duration of <code>time[i]</code> seconds.</p>\n\n<p>Return <em>the number of pairs of songs for which their total duration in seconds is divisible by</em> <code>60</code>. Formally, we want the number of indices <code>i</code>, <code>j</code> such that <code>i &lt; j</code> with <code>(time[i] + time[j]) % 60 == 0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> time = [30,20,150,100,40]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Three pairs have a total duration divisible by 60:\n(time[0] = 30, time[2] = 150): total duration 180\n(time[1] = 20, time[3] = 100): total duration 120\n(time[1] = 20, time[4] = 40): total duration 60\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> time = [60,60,60]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> All three pairs have a total duration of 120, which is divisible by 60.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= time.length &lt;= 6 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= time[i] &lt;= 500</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 256738,
                "title": "java-c-python-two-sum-with-k-60",
                "content": "## **Intuition**\\nCalculate the `time % 60` then it will be exactly same as two sum problem.\\n<br>\\n\\n## **Explanation**\\n`t % 60` gets the remainder from 0 to 59.\\nWe count the occurrence of each remainders in a array/hashmap `c`.\\n\\nwe want to know that, for each `t`, \\nhow many `x` satisfy `(t + x) % 60 = 0`.\\n\\nThe straight forward idea is to take `x % 60 = 60 - t % 60`,\\nwhich is valid for the most cases.\\nBut if `t % 60 = 0`, `x % 60 = 0` instead of 60.\\n\\nOne solution is to use `x % 60 = (60 - t % 60) % 60`,\\nthe other idea is to use `x % 60 = (600 - t) % 60`.\\nNot sure which one is more straight forward.\\n<br>\\n\\n**Java:**\\n```java\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int c[]  = new int[60], res = 0;\\n        for (int t : time) {\\n            res += c[(600 - t) % 60];\\n            c[t % 60] += 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> c(60);\\n        int res = 0;\\n        for (int t : time) {\\n            res += c[(600 - t) % 60];\\n            c[t % 60] += 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def numPairsDivisibleBy60(self, time):\\n        c = [0] * 60\\n        res = 0\\n        for t in time:\\n            res += c[-t % 60]\\n            c[t % 60] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int c[]  = new int[60], res = 0;\\n        for (int t : time) {\\n            res += c[(600 - t) % 60];\\n            c[t % 60] += 1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> c(60);\\n        int res = 0;\\n        for (int t : time) {\\n            res += c[(600 - t) % 60];\\n            c[t % 60] += 1;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def numPairsDivisibleBy60(self, time):\\n        c = [0] * 60\\n        res = 0\\n        for t in time:\\n            res += c[-t % 60]\\n            c[t % 60] += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1661803,
                "title": "easy-c-solution-with-explanation-and-intuition-in-detail",
                "content": "![image](https://assets.leetcode.com/users/images/14ca1b6d-6028-4999-ad7e-372e59a6fc1a_1641111702.0299387.jpeg)\\n \\n```\\n    int numPairsDivisibleBy60(vector<int>& time)\\n    {\\n        int count=0;\\n        vector<int>v(60,0);\\n        for(int i=0;i<time.size();i++)\\n        {\\n            int a=time[i]%60;\\n            if(a==0)\\n                count+=v[0];\\n            else\\n                count+=v[60-a];\\n            v[a]++;\\n        }\\n        return count;\\n    }\\n\\n\\n/*\\nLogic -\\nWhenever we consider any number time[i] we can have 2 possibilities :\\n\\n1) Number is divisible by 60.\\n2) Number is not divisible by 60.\\n\\nWe basically need to consider the time[i]%60 each time to know if it is==0 or not.\\n1) If modulo_val==0 we simply do count+=hash[modulo_val]\\n2) Else we need to find out how far is time[i] away from its next 60 multiple i.e 100 is 20 far from 120 which is a multiple of 60 so if we have a 20 alreay existing then (100,20) can make a valid pair.\\n3) To achieve this we first do time[i]%60 then subtract it from 60. Like 100 % 60=40 and 60-40=20. So count+=hash[20]\\n\\n*/",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/14ca1b6d-6028-4999-ad7e-372e59a6fc1a_1641111702.0299387.jpeg)\\n \\n```\\n    int numPairsDivisibleBy60(vector<int>& time)\\n    {\\n        int count=0;\\n        vector<int>v(60,0);\\n        for(int i=0;i<time.size();i++)\\n        {\\n            int a=time[i]%60;\\n            if(a==0)\\n                count+=v[0];\\n            else\\n                count+=v[60-a];\\n            v[a]++;\\n        }\\n        return count;\\n    }\\n\\n\\n/*\\nLogic -\\nWhenever we consider any number time[i] we can have 2 possibilities :\\n\\n1) Number is divisible by 60.\\n2) Number is not divisible by 60.\\n\\nWe basically need to consider the time[i]%60 each time to know if it is==0 or not.\\n1) If modulo_val==0 we simply do count+=hash[modulo_val]\\n2) Else we need to find out how far is time[i] away from its next 60 multiple i.e 100 is 20 far from 120 which is a multiple of 60 so if we have a 20 alreay existing then (100,20) can make a valid pair.\\n3) To achieve this we first do time[i]%60 then subtract it from 60. Like 100 % 60=40 and 60-40=20. So count+=hash[20]\\n\\n*/",
                "codeTag": "Unknown"
            },
            {
                "id": 256726,
                "title": "java-python-3-o-n-code-w-comment-similar-to-two-sum",
                "content": "Let `target` in Two Sum be `60` and each item in `time % 60`, then the two problems are very similar to each other. \\n\\nAny multiple of 60 will complement itself. Maps multiple of 60 to 0, `theOther` is 0, correspondingly. \\n\\n-- credit to **@crayola** for explanation and improvement of the readability of the code.\\n\\n\\n----\\n\\n**Explain the statement `theOther = (60 - t % 60) % 60;`**\\n\\nLet `theOther` be in the pair with `t`, then\\n\\n```\\n(t + theOther) % 60 == 0\\n```\\n\\nso we have\\n\\n```\\nt % 60 + theOther % 60 = 0 or 60\\n```\\n\\nthen\\n\\n```\\ntheOther % 60 + t % 60 = 0 \\nor\\ntheOther % 60 = 60 - t % 60\\n```\\n\\nNote that it is possible that `t % 60 == 0`, which results `60 - t % 60 == 60`,\\n\\ntherefore, we should have\\n\\n```\\ntheOther % 60 = (60 - t % 60) % 60\\n```\\nLet `0 <= theOther < 60`, therefore `thOther = theOther % 60`.\\nuse `theOther` to replace `theOther % 60`, we get \\n```\\ntheOther = (60 - t % 60) % 60;\\n```\\n\\n----\\n\\n**Code:**\\n```java\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int ans = 0;\\n        for (int t : time) {\\n            int reducedTime = t % 60;\\n            int theOther = (reducedTime == 0) ? 0 : 60 - reducedTime;\\n         // int theOther = (60 - t % 60) % 60;\\n            ans += count.getOrDefault(theOther, 0); // in current HashMap, get the number of songs that if adding t equals to a multiple of 60.\\n            count.put(t % 60, 1 + count.getOrDefault(t % 60, 0)); // update the number of t % 60.\\n        }\\n        return ans;\\n    }\\n```\\n\\n```python\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        ans, cnt = 0, collections.Counter()\\n        for t in time:\\n            theOther = -t % 60\\n            ans += cnt[theOther]\\n            cnt[t % 60] += 1\\n        return ans\\n```\\n\\n**Analysis:** - credit to **@since2020**\\'s space analysis correction.\\n\\nTime: O(n), space: O(60) (or O(1) if the time duration of 60 is regarded as a constant), where n = time.length.",
                "solutionTags": [],
                "code": "```\\n(t + theOther) % 60 == 0\\n```\n```\\nt % 60 + theOther % 60 = 0 or 60\\n```\n```\\ntheOther % 60 + t % 60 = 0 \\nor\\ntheOther % 60 = 60 - t % 60\\n```\n```\\ntheOther % 60 = (60 - t % 60) % 60\\n```\n```\\ntheOther = (60 - t % 60) % 60;\\n```\n```java\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int ans = 0;\\n        for (int t : time) {\\n            int reducedTime = t % 60;\\n            int theOther = (reducedTime == 0) ? 0 : 60 - reducedTime;\\n         // int theOther = (60 - t % 60) % 60;\\n            ans += count.getOrDefault(theOther, 0); // in current HashMap, get the number of songs that if adding t equals to a multiple of 60.\\n            count.put(t % 60, 1 + count.getOrDefault(t % 60, 0)); // update the number of t % 60.\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        ans, cnt = 0, collections.Counter()\\n        for t in time:\\n            theOther = -t % 60\\n            ans += cnt[theOther]\\n            cnt[t % 60] += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 296138,
                "title": "java-solution-from-combination-perspective-with-best-explanation",
                "content": "**Analysis**\\n\\nFrom combination perspective, we have:\\n`# pais to make up 60 = (# of time whose % 60 is i) * (# of time whose % 60 is 60 - i) ` for all possible `i`\\n\\nFor example: \\nIf we have `5` numbers who `% 60 = 20`, and  `7` numbers who `% 60 = 40`, then we can get **`5 * 7 = 35`** pairs to make up `60`.\\n\\nAbove all, if we represents the number of `time` whose `% 60 = i` as `map[i]`, then the result = \\n\\n```\\nmap[0]? + // why ? explain below\\nmap[1] * map[59] +\\nmap[2] * map[58] +\\nmap[3] * map[57] +\\n... +\\nmap[28] * map[32] +\\nmap[29] * map[31] +\\nmap[30]? // why ? explain below\\n```\\n\\nNotice that I put question mark `?` after `map[0]` and `map[30]` on the above formula. Because for `map[0]` and `map[30]`, they are **self-pairing** to make up `60`, so:\\n1. **`map[0]? = C(n, 2) = map[0] * (map[0] - 1)/2`**\\n2. **`map[30]? = C(n, 2) = map[30] * (map[30] - 1)/2`**\\n\\nThus, final formula:\\n\\n```\\nmap[0] * (map[0] - 1)/2 +\\nmap[1] * map[59] +\\nmap[2] * map[58] +\\nmap[3] * map[57] +\\n... +\\nmap[28] * map[32] +\\nmap[29] * map[31] +\\nmap[30] * (map[30] - 1)/2\\n```\\n---\\n\\n**Data structure**\\nWe create `int[] map` to store the `<remainder, frequency>` \\n\\nOf course, `Map<Integer, Integer>` also works, but clearly it is not as efficient as `int[] map`. Just like we prefer to use `int[] map = new int[26]` to keep track of `<letter, frequency>`\\n\\n---\\n**Strategy**\\n\\n1. Iterate each num in `time`, and populate `map`\\n2. Complete the formular above\\n\\n---\\n**Final code**\\n\\n**Map**\\n```java\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int cur : time){\\n            int remainder = cur % 60;\\n            map.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n        }\\n        \\n        int res = 0;\\n        for(int remainder : map.keySet()){\\n            if(remainder > 30) continue;\\n            if(remainder == 0 || remainder == 30){\\n                int size = map.get(remainder);\\n                res += size * (size - 1) / 2;\\n            }else{\\n                res += map.get(remainder) * map.getOrDefault(60 - remainder, 0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Array**\\n```java\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        if(time == null || time.length == 0) return 0;\\n        \\n        int n = time.length;\\n        int[] map = new int[60];\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int remainder = time[i] % 60;\\n            map[remainder]++;\\n        }\\n        \\n        res += map[0] * (map[0] - 1) / 2;\\n        res += map[30] * (map[30] - 1) / 2;\\n        for(int i = 1; i < 30; i++){\\n            res += map[i] * map[60 - i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n---\\n**Complexity Anayalsis**\\nTC(Time Complexity): `O(n)`\\nSC(Space Complexity): `O(60) = O(1)`\\n\\n---\\n**Edit - Overflow**\\nUpdated 2 ways code below based on above **Array** solution to resolve **Overflow** as LC has strengthed the test cases, given `10,000` values with the same time `60`, made `10,000 * (10,000 - 1)` is greater than `Integer.MAX_VALUE`\\n\\n**1. Use long in the middle**\\n```java\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        if(time == null || time.length == 0) return 0;\\n        \\n        int n = time.length;\\n        int[] map = new int[60];\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int remainder = time[i] % 60;\\n            map[remainder]++;\\n        }\\n        \\n        res += (int)((long)map[0] * (map[0] - 1) / 2);\\n        res += (int)((long)map[30] * (map[30] - 1) / 2);\\n        for(int i = 1; i < 30; i++){\\n            res += map[i] * map[60 - i];\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n```\\nOr you can change `res` type directly: `long res = 0`\\n\\n**2. Use math trick, get max of 2 choices**\\n```java\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        if(time == null || time.length == 0) return 0;\\n        \\n        int n = time.length;\\n        int[] map = new int[60];\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int remainder = time[i] % 60;\\n            map[remainder]++;\\n        }\\n        \\n        res += Math.max(map[0] / 2 * (map[0] - 1), map[0] * ((map[0] - 1) / 2));\\n        res += Math.max(map[30] / 2 * (map[30] - 1), map[30] * ((map[30] - 1) / 2));\\n        for(int i = 1; i < 30; i++){\\n            res += map[i] * map[60 - i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n---\\n**Last but not least**\\nIf you have any confusion or any opinion for where you think can be better described please leave a comment below, I will insist on updating it for **at least 100 years**.\\n",
                "solutionTags": [],
                "code": "```\\nmap[0]? + // why ? explain below\\nmap[1] * map[59] +\\nmap[2] * map[58] +\\nmap[3] * map[57] +\\n... +\\nmap[28] * map[32] +\\nmap[29] * map[31] +\\nmap[30]? // why ? explain below\\n```\n```\\nmap[0] * (map[0] - 1)/2 +\\nmap[1] * map[59] +\\nmap[2] * map[58] +\\nmap[3] * map[57] +\\n... +\\nmap[28] * map[32] +\\nmap[29] * map[31] +\\nmap[30] * (map[30] - 1)/2\\n```\n```java\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int cur : time){\\n            int remainder = cur % 60;\\n            map.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n        }\\n        \\n        int res = 0;\\n        for(int remainder : map.keySet()){\\n            if(remainder > 30) continue;\\n            if(remainder == 0 || remainder == 30){\\n                int size = map.get(remainder);\\n                res += size * (size - 1) / 2;\\n            }else{\\n                res += map.get(remainder) * map.getOrDefault(60 - remainder, 0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        if(time == null || time.length == 0) return 0;\\n        \\n        int n = time.length;\\n        int[] map = new int[60];\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int remainder = time[i] % 60;\\n            map[remainder]++;\\n        }\\n        \\n        res += map[0] * (map[0] - 1) / 2;\\n        res += map[30] * (map[30] - 1) / 2;\\n        for(int i = 1; i < 30; i++){\\n            res += map[i] * map[60 - i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        if(time == null || time.length == 0) return 0;\\n        \\n        int n = time.length;\\n        int[] map = new int[60];\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int remainder = time[i] % 60;\\n            map[remainder]++;\\n        }\\n        \\n        res += (int)((long)map[0] * (map[0] - 1) / 2);\\n        res += (int)((long)map[30] * (map[30] - 1) / 2);\\n        for(int i = 1; i < 30; i++){\\n            res += map[i] * map[60 - i];\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        if(time == null || time.length == 0) return 0;\\n        \\n        int n = time.length;\\n        int[] map = new int[60];\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int remainder = time[i] % 60;\\n            map[remainder]++;\\n        }\\n        \\n        res += Math.max(map[0] / 2 * (map[0] - 1), map[0] * ((map[0] - 1) / 2));\\n        res += Math.max(map[30] / 2 * (map[30] - 1), map[30] * ((map[30] - 1) / 2));\\n        for(int i = 1; i < 30; i++){\\n            res += map[i] * map[60 - i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661677,
                "title": "c-python-java-4-lines-o-n-modulo-and-count-detailed-explanation",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* First, we mod the duration of each song by 60 and count the number of different remainders\\n\\t* `for t in time: cnt[t % 60] += 1`\\n* If sum of 2 numbers divisible by 60, there are 3 possible situations\\n\\t* both are divisible by 60, so after mod 60 the remainders are both 0\\n\\t\\t* `cnt[0] * (cnt[0] - 1) // 2`\\n\\t\\t\\t* `cnt[0] - 1` because one cannot pair with itself\\n\\t\\t\\t* `// 2` because `(a, b)` and `(b, a)` are the same pair and we can only add once\\n\\t* both are left 30 after mod 60\\n\\t\\t* `cnt[30] * (cnt[30] - 1) // 2`\\n\\t\\t\\t* the same as `cnt[0]` above\\n\\t* their remainders are not the same, but the sum of remainders is equal to 60\\n\\t\\t* `for i in range(1, 30): ans += cnt[i] * cnt[60 - i]`\\n\\t\\t* we only loop from 1 to 29, because `60 - i` is in the range of `(31, 59)`. In this way, we enumerate all pairs and will not repeat like `(a, b)` and `(b, a)`.\\n\\n```\\nTime  Complexity: O(N) if we consider N is greater than 30\\nSpace Complexity: O(1)\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def numPairsDivisibleBy60(self, time):\\n        ans, cnt = 0, [0] * 60\\n        for t in time: cnt[t % 60] += 1\\n        for i in range(1, 30): ans += cnt[i] * cnt[60 - i]\\n        return ans + cnt[0] * (cnt[0] - 1) // 2 + cnt[30] * (cnt[30] - 1) // 2\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int ans = 0, cnt[] = new int[60];\\n        for (int i = 0; i < time.length; i ++) cnt[time[i] % 60] += 1;\\n        for (int i = 1; i< 30; i ++) ans += cnt[i] * cnt[60 - i];\\n        return ans + cnt[0] * (cnt[0] - 1) / 2 + cnt[30] * (cnt[30] - 1) / 2;\\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int ans = 0, cnt[60] = {0};\\n        for (int i = 0; i < time.size(); i ++) cnt[time[i] % 60] += 1;\\n        for (int i = 1; i< 30; i ++) ans += cnt[i] * cnt[60 - i];\\n        return ans + cnt[0] * (cnt[0] - 1) / 2 + cnt[30] * (cnt[30] - 1) / 2;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nTime  Complexity: O(N) if we consider N is greater than 30\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution(object):\\n    def numPairsDivisibleBy60(self, time):\\n        ans, cnt = 0, [0] * 60\\n        for t in time: cnt[t % 60] += 1\\n        for i in range(1, 30): ans += cnt[i] * cnt[60 - i]\\n        return ans + cnt[0] * (cnt[0] - 1) // 2 + cnt[30] * (cnt[30] - 1) // 2\\n```\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int ans = 0, cnt[] = new int[60];\\n        for (int i = 0; i < time.length; i ++) cnt[time[i] % 60] += 1;\\n        for (int i = 1; i< 30; i ++) ans += cnt[i] * cnt[60 - i];\\n        return ans + cnt[0] * (cnt[0] - 1) / 2 + cnt[30] * (cnt[30] - 1) / 2;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int ans = 0, cnt[60] = {0};\\n        for (int i = 0; i < time.size(); i ++) cnt[time[i] % 60] += 1;\\n        for (int i = 1; i< 30; i ++) ans += cnt[i] * cnt[60 - i];\\n        return ans + cnt[0] * (cnt[0] - 1) / 2 + cnt[30] * (cnt[30] - 1) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636651,
                "title": "java-simple-solution-with-with-a-crystal-clear-explanation-biginners-mindset-hashmap-in-o-n",
                "content": "Explanation:\\nreason for (60 - t % 60) % 60 expression: If the map already has 30, we need to look for the number is having remainder or not, this can be achieved\\xA0with 60 - t%60. Eg, if the number is 210. 60 - 210 % 60 returns 30. 30 is already in the list this can be paired up to form (30,210).\\n\\nReason for an extra % 60 over (60 - t % 60). if the t = 60, the expression 60 - t % 60 returns 60. this is beyond our remainers range (0,59)for 60. to make it with in the range in the case of 60 and multiples of 60, we are ufing an extra %60 on top of (60 - t % 60). this makes the remainder 0. which is with in the range of remainders for 60(0,59)\\n\\n\\nExplanation for map.put(t % 60, map.getOrDefault(t % 60, 0) + 1);\\nevery time you visit a new number add first and increment then. Eg: if I have 30,150,90when I read 30 map has 30,1 ... cntr(counter) is 0\\nwhen I read 150, counter increments(30,150) map has 30,2 ... cntr(counter) is 1The map should have 2, reasoningwhen I Read 90,this can form 2 pairs(90,30),90,150.\\nThis makes the counter will add by 2 ..... cntr = 1+2 == 3\\n\\n\\ncontinue thus until completion of array or times :)\\n\\nPlease vote if you like the solution and explanation\\n\\n\\n\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int cntr = 0;\\n        for (int t : time) {\\n            cntr += map.getOrDefault((60 - t % 60) % 60, 0);\\n            map.put(t % 60, map.getOrDefault(t % 60, 0) + 1);\\n        }\\n        return cntr;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int cntr = 0;\\n        for (int t : time) {\\n            cntr += map.getOrDefault((60 - t % 60) % 60, 0);\\n            map.put(t % 60, map.getOrDefault(t % 60, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1660888,
                "title": "c-python-easy-to-solve-beginner-friendly-with-detailed-explanation-with-dry-run",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t#Detailed Explanations with proofs\\n**Reframing the Question:-**\\nWe are given a time array with time duration a song has . we need to find different number of **pairs** of songs for whch their total duration in seconds is **divisible by 60 .**\\n***\\n**Intuition:-**\\n* A simple intuition can be that we need to **find the reminder** of the total duration of pairs which is divisible by 60 . In simple words we need to calculate `time % 60`\\n* Also come to think of it, the different pair combinations which can give us our result by finding their reminders can be stored with the **help of hashing.**\\n***\\n**Algorithm:-**\\n1. Let\\'s declare a map which keeps tracks of pairs which gives reminder from 0 to 59 . \\n`int map[60] = { }; ` and a `result` variable which will give us total number of pairs that can be formed that are divisible by 60\\n2. Now we need to check if the pairs are giving us the required result i.e the total duration of individual songs must be checked inside the `y = (60 - (x%60) ) %60; [Going to discuss below]` to find the reminder so that they can be stored wisely inside the map.\\n3. Now after getting reminders add them to the map table \\n4. At last return the `result`.\\n***\\n**Explanation behind the mystery of y = (60 - (x % 60) ) % 60  :-** \\n\\n![image](https://assets.leetcode.com/users/images/24b3ec8b-a8ba-4214-a5b5-ba8fed291166_1641093227.8334417.jpeg)\\n***\\n**Conclusion :-**\\nIn the end, the conclusion statement can be: we use an array to count occurrences of number % 60. For each number x , we add the count of complimenting numbers (60 - x % 60) % 60 to the result.\\n***\\n**C++ Code:-**\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int map[60] = {};\\n        int result = 0;\\n        for(auto x:time){\\n            int t = x % 60;\\n            int y = (60 - t)%60;\\n            result += map[y];\\n            map[t]++;\\n        }\\n        return result;\\n    }\\n};\\n```\\n***\\n**Python Code:-**\\n```\\nclass Solution(object):\\n    def numPairsDivisibleBy60(self, time):\\n        mapp = [0] * 60\\n        result = 0\\n        for x in time:\\n            result += mapp[-x % 60]\\n            mapp[x % 60] += 1\\n        return result\\n```\\n***\\n**Time Complexity :** *`O(n) (where n is the size of time)`*\\n**Space Complexity :** *`O(60) (Can be cconsidered O(1) if the time duration 60s is treated as constant )`* \\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n***\\n***\\n**Feel free to comment or upvote if you liked my post ^_^**\\n***\\n***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int map[60] = {};\\n        int result = 0;\\n        for(auto x:time){\\n            int t = x % 60;\\n            int y = (60 - t)%60;\\n            result += map[y];\\n            map[t]++;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def numPairsDivisibleBy60(self, time):\\n        mapp = [0] * 60\\n        result = 0\\n        for x in time:\\n            result += mapp[-x % 60]\\n            mapp[x % 60] += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256722,
                "title": "c-5-lines-two-sum",
                "content": "We use an array to count  occurrences of ```number % 60```. For each number ```t```, we add the count of complimenting numbers ```(60 - t % 60) % 60``` to the result.\\n```\\nint numPairsDivisibleBy60(vector<int>& time, int res = 0) {\\n  vector<int> m(60);\\n  for (auto t : time) {\\n    res += m[(60 - t % 60) % 60];\\n    ++m[t % 60];\\n  }\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```number % 60```\n```t```\n```(60 - t % 60) % 60```\n```\\nint numPairsDivisibleBy60(vector<int>& time, int res = 0) {\\n  vector<int> m(60);\\n  for (auto t : time) {\\n    res += m[(60 - t % 60) % 60];\\n    ++m[t % 60];\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663095,
                "title": "java-solution-based-on-hashmap",
                "content": "**Similar approach to Two Sum problem**\\n\\n* First we have to check wether the reminder is 0 or not or we can say that we are checking if the number is already divisible by 60 or not.\\n* after that we are finding the target element. Eg: if n = 140 then remider = 140%60 = 20 it means we have 20 unit extra or we can say we need 40(60-20) more units to get perfectly divisible by 60.\\n* So we find the target element in map and adds up in answer, if target element not found we store the current element(N%60) so that it can be used as target for others.\\n* But if remider is 0 we have to store that number only because it represents that the number is divisible by 60 and it needs the number that are already divisible by 60.\\n\\n**Here is the Java code for the above approach**\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int n = time.length, ans = 0;\\n        HashMap<Integer, Integer> len = new HashMap<>();\\n        for(int i  = 0; i < n; i++){\\n            int rem = time[i] % 60;\\n            int target = 60 - (rem);\\n            if(len.containsKey(target))\\n                ans += len.get(target);\\n            if(rem != 0)\\n                len.put(rem, len.getOrDefault(rem, 0) + 1);\\n            else\\n                len.put(60, len.getOrDefault(60, 0) + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int n = time.length, ans = 0;\\n        HashMap<Integer, Integer> len = new HashMap<>();\\n        for(int i  = 0; i < n; i++){\\n            int rem = time[i] % 60;\\n            int target = 60 - (rem);\\n            if(len.containsKey(target))\\n                ans += len.get(target);\\n            if(rem != 0)\\n                len.put(rem, len.getOrDefault(rem, 0) + 1);\\n            else\\n                len.put(60, len.getOrDefault(60, 0) + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259681,
                "title": "2ms-java-solution-easy-to-understand",
                "content": "```\\nclass Solution\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] mod = new int[60];\\n        for(int t : time) mod[t%60]++; //count the number of differnt modulation cases of divided by 60. \\n        int res = 0;\\n        for(int i = 0; i <= 30; i++){//sum to 30 to avoid double counting\\n            if(i == 0 || i == 30) res += (mod[i])*(mod[i]-1)/2; //special case: modulation is 0 or 30. \\n            else res += mod[i] * mod[60-i]; //general case\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] mod = new int[60];\\n        for(int t : time) mod[t%60]++; //count the number of differnt modulation cases of divided by 60. \\n        int res = 0;\\n        for(int i = 0; i <= 30; i++){//sum to 30 to avoid double counting\\n            if(i == 0 || i == 30) res += (mod[i])*(mod[i]-1)/2; //special case: modulation is 0 or 30. \\n            else res += mod[i] * mod[60-i]; //general case\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422213,
                "title": "python-o-n-6-lines-beats-86-time",
                "content": "```python\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        res  , count  = 0,  [0] * 60\\n        for one in range(len(time)):\\n            index = time[one] % 60\\n            res += count[(60 - index)%60] # %60 is for index==0\\n            count[index] += 1\\n        return res\\n```\\n\\n**If it helps you ,Please give me a star.\\nThanks**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        res  , count  = 0,  [0] * 60\\n        for one in range(len(time)):\\n            index = time[one] % 60\\n            res += count[(60 - index)%60] # %60 is for index==0\\n            count[index] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661610,
                "title": "python-modular-intuition-in-detail",
                "content": "This is problem is similar to the Two Sum problem, but with a slight modular twist.\\nSo, here we need to find a and b such that ```(a + b) % 60 == 0```. This can be also written as,\\n=> ```(a % 60) + (b % 60) == 60 ```\\n=> ```(a % 60)  == 60 - (b % 60) ```\\n\\nSo if both reminder ads up to 60 we can tell it is indeed a valid pair of songs. One, edge case which we have to keep in mind is, what if ```(a % 60) = 0  and (b % 60) = 0``` our result will be ```0 + 0 = 0```, this fails our intution. So to handle this case we can rewrite the equation as\\n=> ```(a % 60)  == (60 - (b % 60)) % 60 ```\\n\\nBTW, Talking is cheap, so here we go : ) \\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        # array which keep count of no of occurences of reminders\\n        dp = [0]*60\\n        res = 0\\n        for t in time:\\n            rem = t % 60\\n            target = (60 - rem) % 60\\n            res += dp[target]\\n            dp[rem] += 1\\n        return res\\n```\\n\\n***Upvote, if you like the post***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```(a + b) % 60 == 0```\n```(a % 60) + (b % 60) == 60 ```\n```(a % 60)  == 60 - (b % 60) ```\n```(a % 60) = 0  and (b % 60) = 0```\n```0 + 0 = 0```\n```(a % 60)  == (60 - (b % 60)) % 60 ```\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        # array which keep count of no of occurences of reminders\\n        dp = [0]*60\\n        res = 0\\n        for t in time:\\n            rem = t % 60\\n            target = (60 - rem) % 60\\n            res += dp[target]\\n            dp[rem] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257351,
                "title": "python-o-n-40-ms-solution",
                "content": "\\t\\tc = 0\\n        n = [0] * 60\\n        \\n        for i in time:\\n            n[i%60]+=1\\n        \\n        for i in range(0, 31):\\n            if n[i] == 0:\\n                continue\\n            if (i == 0 or i == 30):\\n                if n[i] > 1:\\n                    c+=(n[i]*(n[i]-1)/2)\\n            else:\\n\\t\\t\\t\\t c+=(n[i]*n[60-i])\\n        return c",
                "solutionTags": [],
                "code": "\\t\\tc = 0\\n        n = [0] * 60\\n        \\n        for i in time:\\n            n[i%60]+=1\\n        \\n        for i in range(0, 31):\\n            if n[i] == 0:\\n                continue\\n            if (i == 0 or i == 30):\\n                if n[i] > 1:\\n                    c+=(n[i]*(n[i]-1)/2)\\n            else:\\n\\t\\t\\t\\t c+=(n[i]*n[60-i])\\n        return c",
                "codeTag": "Unknown"
            },
            {
                "id": 1662512,
                "title": "python-hashmap-dictionary-complexity-o-n",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        HashMap = {}\\n        pairs = 0\\n        \\n        for t in time:\\n            numMod = t % 60\\n            \\n            if numMod == 0:\\n                if 0 in HashMap:\\n                    pairs += HashMap[0]\\n            elif (60 - numMod) in HashMap:\\n                pairs += HashMap[60 - numMod]\\n                \\n            if numMod in HashMap:\\n                HashMap[numMod] += 1\\n            else:\\n                HashMap[numMod] = 1\\n                \\n        return pairs\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        HashMap = {}\\n        pairs = 0\\n        \\n        for t in time:\\n            numMod = t % 60\\n            \\n            if numMod == 0:\\n                if 0 in HashMap:\\n                    pairs += HashMap[0]\\n            elif (60 - numMod) in HashMap:\\n                pairs += HashMap[60 - numMod]\\n                \\n            if numMod in HashMap:\\n                HashMap[numMod] += 1\\n            else:\\n                HashMap[numMod] = 1\\n                \\n        return pairs\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543795,
                "title": "multiple-c-solutions",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n# Methode 01:\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n= time.size();\\n        unordered_map<int, int>mp;\\n        int count=0;\\n        for(int i=0; i<n; i++){\\n            mp[time[i]%60]++;\\n            time[i]=time[i]%60;\\n        }\\n       \\n        for(int i=0; i<n; i++){\\n            if(time[i]!=0)\\n            { \\n                int x= abs(time[i]-60);\\n                mp[time[i]]--;\\n                if(mp.find(x)!= mp.end()){\\n                    count = count + mp[x];\\n                }\\n                mp[time[i]]++;\\n            }\\n            else{\\n                 mp[time[i]]--;\\n                 if(mp.find(0)!= mp.end()){\\n                    count = count + mp[0];\\n                }\\n                 mp[time[i]]++;\\n            }\\n        }\\n        \\n        return count/2;\\n    }\\n};\\n```\\n\\n# Method 02:\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n= time.size();\\n        vector<int>ans(60);\\n        for(auto x:time)\\n            ans[x%60] += 1;\\n        int count=0;\\n        count += ((ans[0]-1)*ans[0])/2;\\n        count += ((ans[30]-1)*ans[30])/2;\\n        \\n        for(int i=1; i<30; i++)\\n            count += ans[i]*ans[60-i];\\n        \\n        return count;\\n    }\\n};\\n```\\n---\\n***Please upvote if you find helpful! Thank you!***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n= time.size();\\n        unordered_map<int, int>mp;\\n        int count=0;\\n        for(int i=0; i<n; i++){\\n            mp[time[i]%60]++;\\n            time[i]=time[i]%60;\\n        }\\n       \\n        for(int i=0; i<n; i++){\\n            if(time[i]!=0)\\n            { \\n                int x= abs(time[i]-60);\\n                mp[time[i]]--;\\n                if(mp.find(x)!= mp.end()){\\n                    count = count + mp[x];\\n                }\\n                mp[time[i]]++;\\n            }\\n            else{\\n                 mp[time[i]]--;\\n                 if(mp.find(0)!= mp.end()){\\n                    count = count + mp[0];\\n                }\\n                 mp[time[i]]++;\\n            }\\n        }\\n        \\n        return count/2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n= time.size();\\n        vector<int>ans(60);\\n        for(auto x:time)\\n            ans[x%60] += 1;\\n        int count=0;\\n        count += ((ans[0]-1)*ans[0])/2;\\n        count += ((ans[30]-1)*ans[30])/2;\\n        \\n        for(int i=1; i<30; i++)\\n            count += ans[i]*ans[60-i];\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259073,
                "title": "super-simple-java-solution-9-lines",
                "content": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int ans = 0;\\n        if (time == null || time.length == 0) return ans;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < time.length; i++) {          \\n            int rem = time[i]%60;\\n            ans += map.getOrDefault((60-rem)%60, 0);\\n            map.put(rem, map.getOrDefault(rem, 0) + 1);\\n        }\\n        return ans;    \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int ans = 0;\\n        if (time == null || time.length == 0) return ans;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < time.length; i++) {          \\n            int rem = time[i]%60;\\n            ans += map.getOrDefault((60-rem)%60, 0);\\n            map.put(rem, map.getOrDefault(rem, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1662924,
                "title": "java-c-easy-and-detailed-explanation-intuitive",
                "content": "Let us first understand the logic through some observations.\\n\\n**Observation:**\\nHow do we know that it is a valid pair?\\n* We first take any (x,y) pairs.\\n* We add them and take the modulus with 60 and get the remainder as 0.\\n* Then, we will say that (x,y) are valid pairs.\\n\\nA simple approach would be to iterate using two nested for loops where we will add the i+j elements where, first (i loop) and second(j loop) and take the modulus with 60. Here, the time complexity is `O(N^2)` and will lead to TLE.\\n\\n**We will see an property to do this optimally :**\\n* Lets say we have two numbers (x,y) as a valid pair.\\n* We have x % 60 =R1 and y % 60=R2. \\n* Now, according to the modulus property we have range of R1 and R2 to be between 0 and 60. \\n* Range of R1+R2 will be 0<=R1+R2<120. For, (x+y) % 60 ==0, the possible values of R1+R2 are 0 or 60.\\n* We will use this remainder approach to decrease the time complexity.\\n\\n**Remainder Approach :**\\nWe will construct a remainder array to store the frequency of the remainder values .i.e., ``rem[time[i]%60]++``. The size of the array will be initialized as 60. Let\\'s understand this by an example.\\n\\n**Example:** We have 20 -> 2 times and 40 -> 3 times. Then the total pairs we can make whose sum is divisble by 60 are 6 (2 * 3). \\n\\nWe find out the frequency from rem array and then we just need to make pair of rem[i] & rem[60-i].\\n\\n**Here, we have two problems :**\\n1) We will have duplicates if we iterate the whole array. For example, If we are having 20, we will be looking for 40(60-20) as (20+40)%60==0. We will make a (20,40) pair. While looping through 40 we will search for 20 and make a (40,20) pair. Both of these pairs are same and we only need to consider one among them.\\n\\n2) We have remainders 0 and 30 as special cases, where just multiplying them won\\'t give us the result as they make pairs with themselves only.\\n\\n**Solutions to the problems:**\\n1) We only iterate through 60/2 i.e., 30 values as from 30 it acts as a mirror and we get the duplicates.\\n\\n2) We need to have more than 1 occurence of 0 and 30 to make a pair. This is given by a generalization as `(n * (n-1))/2.` For example, 5 occurences of 0 or 30 will lead to 10 pairs.\\n\\nNow, lets see the implementation part:\\n\\n**Java Code:**\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int n=time.length;\\n        int[] rem=new int[60];\\n        for(int i=0;i<n;i++)\\n        {\\n            rem[time[i]%60]++;\\n        }\\n        int count=0;\\n        count+=(rem[0]*(rem[0]-1))/2;\\n        count+=(rem[30]*(rem[30]-1))/2;\\n        for(int i=1;i<=29;i++)\\n        {\\n            count+=rem[i]*rem[60-i];\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        \\n        int n=time.size();\\n        int rem[60]={0};\\n        for(int i=0;i<n;i++)\\n        {\\n            rem[time[i]%60]++;\\n        }\\n        int count=0;\\n        count+=(rem[0]*(rem[0]-1))/2;\\n        count+=(rem[30]*(rem[30]-1))/2;\\n        for(int i=1;i<=29;i++)\\n        {\\n            count+=rem[i]*rem[60-i];\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(N)\\nwhere, N is the size of the time array\\n\\n**Space Complexity:** O(60) or O(1)\\n\\n**Please upvote this solution if you liked it!** \\uD83D\\uDE00\\u270C\\uFE0F",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int n=time.length;\\n        int[] rem=new int[60];\\n        for(int i=0;i<n;i++)\\n        {\\n            rem[time[i]%60]++;\\n        }\\n        int count=0;\\n        count+=(rem[0]*(rem[0]-1))/2;\\n        count+=(rem[30]*(rem[30]-1))/2;\\n        for(int i=1;i<=29;i++)\\n        {\\n            count+=rem[i]*rem[60-i];\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        \\n        int n=time.size();\\n        int rem[60]={0};\\n        for(int i=0;i<n;i++)\\n        {\\n            rem[time[i]%60]++;\\n        }\\n        int count=0;\\n        count+=(rem[0]*(rem[0]-1))/2;\\n        count+=(rem[30]*(rem[30]-1))/2;\\n        for(int i=1;i<=29;i++)\\n        {\\n            count+=rem[i]*rem[60-i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964319,
                "title": "python-modular-arithmetic-explained",
                "content": "If you are familiar with modular arithmetic, this problem will be very easy for you. So, we need to find number of pairs of songs, such that total duration in each pair is divisible by `60`: there can be several cases how it is possible. Imagine we have `2` songs `a` and `b`, then:\\n[1]. `a` and `b` have reminders `0`.\\n[2]. `a` has reminder `1` and `b` has reminder `59`.\\n[3]. `a` has reminder `2` and `b` has reminder `58`.\\n\\n[59]. `a` has reminder `58` and `b` has reminder `2`.\\n[60] `a` has reminder `59` and `b` has reminder `1`.\\n\\nSo, what we need to do now: for each reminder calculate how many number we have with this reminder and then evaluate sum of products: `a1*a59 + a2*a58 + ...`, where `a1` is number of numbers with reminder `1` and so on. Also we need to be careful with reminders `0` and `30`: for them we need to choose number of combinations.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(60) = O(1)`.\\n\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time):\\n        d, T = Counter(), 60\\n        for t in time: d[t%T] += 1\\n        ans = sum(d.get(i,0)*d.get(T-i,0) for i in range(1, T//2))\\n        q1, q2 = d.get(0,0), d.get(T//2, 0)\\n        return ans + q1*(q1-1)//2 + q2*(q2-1)//2\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time):\\n        d, T = Counter(), 60\\n        for t in time: d[t%T] += 1\\n        ans = sum(d.get(i,0)*d.get(T-i,0) for i in range(1, T//2))\\n        q1, q2 = d.get(0,0), d.get(T//2, 0)\\n        return ans + q1*(q1-1)//2 + q2*(q2-1)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964476,
                "title": "pairs-of-songs-c-very-easy-understanding-solution-explained",
                "content": "i hold the modulos in mods vector\\n```\\nvector<int> mods(60,0);\\n```\\nthey want (time[i] + time[j]) % 60 = 0\\nit means time[i]%60 + time[j]%60 is 0 or 60\\n```\\nfor(int i = 0;i < time.size();i++){\\n            ans += mods[(60  - (time[i]%60)) % 60];\\n            mods[time[i]%60]++;\\n        }\\n```\\n60 - (time[i]%60) = time[j]\\nthe next line i increase mods[time[i]%60] because we have them \\n\\nthe full code:\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> mods(60,0);\\n        int  ans = 0;\\n        for(int i = 0;i < time.size();i++){\\n            ans += mods[(60  - (time[i]%60)) % 60];\\n            mods[time[i]%60]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n(Sorry for my poor english)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> mods(60,0);\\n```\n```\\nfor(int i = 0;i < time.size();i++){\\n            ans += mods[(60  - (time[i]%60)) % 60];\\n            mods[time[i]%60]++;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> mods(60,0);\\n        int  ans = 0;\\n        for(int i = 0;i < time.size();i++){\\n            ans += mods[(60  - (time[i]%60)) % 60];\\n            mods[time[i]%60]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320240,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int m[60] = {};\\n        int ret = 0;\\n        for(auto x:time){\\n            int t = x % 60;\\n            int y = (60 - t)%60;\\n            ret += m[y];\\n            m[t]++;\\n        }\\n        return ret;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int m[60] = {};\\n        int ret = 0;\\n        for(auto x:time){\\n            int t = x % 60;\\n            int y = (60 - t)%60;\\n            ret += m[y];\\n            m[t]++;\\n        }\\n        return ret;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257104,
                "title": "javascript-solution",
                "content": "```js\\nconst numPairsDivisibleBy60 = (time) => {\\n    const appearDic = {};\\n    let ans = 0;\\n    time.forEach(el => {\\n        const mod = el % 60;\\n        const left = (60 - mod) % 60;\\n        ans += appearDic[left] ? appearDic[left] : 0;\\n        appearDic[mod] = appearDic[mod] ? appearDic[mod] + 1 : 1;\\n    });\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst numPairsDivisibleBy60 = (time) => {\\n    const appearDic = {};\\n    let ans = 0;\\n    time.forEach(el => {\\n        const mod = el % 60;\\n        const left = (60 - mod) % 60;\\n        ans += appearDic[left] ? appearDic[left] : 0;\\n        appearDic[mod] = appearDic[mod] ? appearDic[mod] + 1 : 1;\\n    });\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767381,
                "title": "intuitive-python-solution",
                "content": "Here\\'s an intuitive solution\\n\\n**Brute force**\\nWe iterate through all pairs of elements in `time`, which is `O(n^2)`. No good. \\n\\n**The fast solution**\\n\\tNotice that what we actually care about is not the sum of each pair, but the `sum % 60`. `sum%60` can result in 60 distinct values `0, 1, 2, ..., 59`. So we can keep build a mapping `mods` that maps each element from `0 ... 59` with the number of songs that fall in that value % 60.  That is, \\n```\\n for v in time:\\n\\tmods[v % 60] += 1\\n```\\n\\nNow to determine how many pairs are divisible by 60, we simply have to compute `mods[x] * mods[60-x]` across all values of x from `0 ... 30` (we handle the edge cases of x = 0 and x = 30 slightly differently to avoid drawing the same song twice). Here\\'s the full code:\\n\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def numPairsDivisibleBy60(self, time):\\n        mods = defaultdict(int)\\n        for v in time:\\n            mods[v % 60] += 1\\n        count = 0\\n        for i in range(1, 30):\\n            count += mods[i] * mods[60 - i]\\n        for i in [0, 30]:\\n            count += (mods[i] - 1) * mods[i] / 2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n for v in time:\\n\\tmods[v % 60] += 1\\n```\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def numPairsDivisibleBy60(self, time):\\n        mods = defaultdict(int)\\n        for v in time:\\n            mods[v % 60] += 1\\n        count = 0\\n        for i in range(1, 30):\\n            count += mods[i] * mods[60 - i]\\n        for i in [0, 30]:\\n            count += (mods[i] - 1) * mods[i] / 2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642553,
                "title": "python-o-n-with-simple-math-explanation",
                "content": "Didn\\'t know the optimal answer to this until I looked up one property of modulo, mainly.\\n\\n (a+b) % c = (a%c + b%c) % c\\n\\nSo we all know the brute force way which is to try every single pair, is there a way to find a pair quickly for each number ? I saw this answer get tossed around in discussions without proof and I didnt understand myself quite awhile, but here is my two cents.\\n\\nGiven number a, can we find b in O(1) using some modulo property and answer is yes.\\n1. We are given that (a+b) % c = (a%c + b%c) % c = 0\\n2. So, (a%c + b%c) = n*c where n is an integer multiple.\\n3. We know that (a%c + b%c) has max of c-1 + c-1 = 2c - 2 < 2c\\n4. But rhs says it has to be an integer multiple of c, and we are bounded by the fact that this has to be less than 2. so only option is either 0 or 1 (no negative cuz song durations arent negative)\\n5. So given a, we look for b%c = n*c - a%c, where n = 0 or 1.\\n6. Can do this easily with hashmap, for each number a, take modulo of it, look for that in the hashmap where it maps number of occurance of b%c. \\n7. Update answer and the hashmap accordingly.\\n\\nBelow is python code.\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        count = collections.defaultdict(int)\\n        ans = 0\\n        \\n        for t in time:\\n            t_mod = t%60\\n            \\n            find = 0 if t_mod == 0 else 60 - t_mod\\n            ans += count[find]\\n            count[t_mod]+=1 \\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        count = collections.defaultdict(int)\\n        ans = 0\\n        \\n        for t in time:\\n            t_mod = t%60\\n            \\n            find = 0 if t_mod == 0 else 60 - t_mod\\n            ans += count[find]\\n            count[t_mod]+=1 \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678199,
                "title": "c-solution-with-full-explanations-in-o-n-time-complexity",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- ***This will give TLE.***\\n- We used 2 loops and calculate the sum & then tried to find if that was divisible with 60.\\n- If divisible then increase count.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- As we\\u2019ve to find if the pair is divisible by 60, so we took an array of 60 size.\\n- The reminder will always be less than 60.\\n- Here we will find 2 cases:\\n    1. For any key we\\u2019ve to find (60-key) value, if that exist only then we\\u2019ll increase count value. Here multiple counts can occur. For 20 we can find a 40, Again while we\\u2019re in the 40 index then we also can find 20. So we only traverse half of the area to avoid duplicates.\\n    2. If the value is 30 or 0, then count of valid pair will be ***(n-1)*n/2.***\\n- So we count for the special case first than we\\u2019ll traverse from 1 to 29.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int count=0, n=time.size();\\n        \\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                int sum= time[i]+time[j];\\n                if(sum%60 == 0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n= time.size();\\n        vector<int>ans(60);\\n        \\n        for(auto x:time)\\n            ans[x%60] += 1;\\n        \\n        int count=0;\\n        count += ((ans[0]-1)*ans[0])/2;\\n        count += ((ans[30]-1)*ans[30])/2;\\n        \\n        for(int i=1; i<30; i++)\\n            count += ans[i]*ans[60-i];\\n        \\n        return count;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int count=0, n=time.size();\\n        \\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                int sum= time[i]+time[j];\\n                if(sum%60 == 0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n= time.size();\\n        vector<int>ans(60);\\n        \\n        for(auto x:time)\\n            ans[x%60] += 1;\\n        \\n        int count=0;\\n        count += ((ans[0]-1)*ans[0])/2;\\n        count += ((ans[30]-1)*ans[30])/2;\\n        \\n        for(int i=1; i<30; i++)\\n            count += ans[i]*ans[60-i];\\n        \\n        return count;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672153,
                "title": "java-general-solution-simple-and-clean",
                "content": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        return numsDivisibleByK(time, 60);\\n    }\\n    \\n    private int numsDivisibleByK(int[] nums, int k) {\\n        int answer = 0;\\n        int[] hash = new int[k];\\n        \\n        for (int num : nums) {\\n            int current = num % k;\\n            int opposite = (k - current) % k;\\n            \\n            answer += hash[opposite];\\n            hash[current]++;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        return numsDivisibleByK(time, 60);\\n    }\\n    \\n    private int numsDivisibleByK(int[] nums, int k) {\\n        int answer = 0;\\n        int[] hash = new int[k];\\n        \\n        for (int num : nums) {\\n            int current = num % k;\\n            int opposite = (k - current) % k;\\n            \\n            answer += hash[opposite];\\n            hash[current]++;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660754,
                "title": "python3-hashmap-explained",
                "content": "We can notice that to find a pair that is divisible by 60 we need to find two songs that have the sum of their modulo equal to 60 or 0. For example for 20 and 100 we have `20%60=20` and `100%60=40`, i.e. their modulo add up to 60, thus thees pair satisfy the condition. So we can create a hashmap where a key is `time[i]%60` and a value is the count of songs with the same reminder. For example, 40 and 100 have the same reminder 40, thus `hashmap[40] = 2`. In sum, we simply iterate over the `time`, and for every time look into the hashmap to determine how many pairs we can form.\\n\\nTime: **O(n)** - for scan\\nSpace: **O(1)** - maximum 60 key-value pairs in the hashmap\\n\\nRuntime: 236 ms, faster than **55.71%** of Python3 online submissions for Pairs of Songs With Total Durations Divisible by 60.\\nMemory Usage: 17.5 MB, less than **93.55%** of Python3 online submissions for Pairs of Songs With Total Durations Divisible by 60.\\n\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        hashmap = defaultdict(int)\\n        for t in time:\\n            hashmap[t%60] += 1\\n        \\n        res = 0\\n        for t in time:\\n            reminder = t%60\\n            hashmap[reminder] -= 1\\n                \\n            res += hashmap[0 if reminder == 0 else 60 - reminder]\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        hashmap = defaultdict(int)\\n        for t in time:\\n            hashmap[t%60] += 1\\n        \\n        res = 0\\n        for t in time:\\n            reminder = t%60\\n            hashmap[reminder] -= 1\\n                \\n            res += hashmap[0 if reminder == 0 else 60 - reminder]\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964469,
                "title": "c-linear-solution-explained-100-time-95-space",
                "content": "Really nice one - simple to understand, not trivial to execute in order to get top performance and thoroughly enjoyable.\\n\\nIn order to solve it, we go and create 2 support variables:\\n* `freqs` an array of `60` integers all set initially to `0`;\\n* `res`, our accumulator variable.\\n\\nWe then proceed and populate `freqs`, taking each time `t` in our input and increasing the matching cell of our frequancy map (`freqs[t % 60]`) by `1`, since we only care about how far each single time `t` is from `60`, while the initial value is inconsequantial to us: times of `41`, `221`, `461` or `10041` are all the same, since they can form a pair only with other times that have a remainder of `19` when divided by `60`, like `19`, `199`, `439` or `10019`.\\n\\nWe then have all that we need to go through our results and compute all the possible pairs, initially looping in the `1 - 29` range: if for example we encountered 10 songs such as `t % 60 == 13` and 5 songs such as `t % 60 == 47`, we will add `50` to `res`.\\n\\nOne peculiar exception is for frequencies `f` such as `t % 60 == 0` or `t % 60 == 30`, since they make couple with themselves and we need to avoid counting each couple more than once: in which case we will have to compute the number of matches as `f * (f - 1) / 2`. If for example we had 3 songs such as `t % 60 == 0`, as it is the case in one of the base examples, we will then have a total of `3 * (3 - 1) / 2 == 3` valid, not repeated matches.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        // support variables\\n        int freqs[60] = {}, res = 0;\\n        // populating freqs\\n        for (int t: time) freqs[t % 60]++;\\n        // computing the number of matches for most pairs\\n        for (int i = 1; i < 30; i++) res += freqs[i] * freqs[60 - i];\\n        // special cases - 0s and 30s\\n        res += freqs[0] * (freqs[0] - 1) / 2 + freqs[30] * (freqs[30] - 1) / 2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        // support variables\\n        int freqs[60] = {}, res = 0;\\n        // populating freqs\\n        for (int t: time) freqs[t % 60]++;\\n        // computing the number of matches for most pairs\\n        for (int i = 1; i < 30; i++) res += freqs[i] * freqs[60 - i];\\n        // special cases - 0s and 30s\\n        res += freqs[0] * (freqs[0] - 1) / 2 + freqs[30] * (freqs[30] - 1) / 2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242943,
                "title": "c-easy-to-understand-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numPairsDivisibleBy60(vector<int>& time) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tvector<int> t (60, 0);\\n\\t\\t\\tfor(int i = 0; i < time.size(); i++){\\n\\t\\t\\t\\tint p = time[i] % 60;\\n\\t\\t\\t\\tif(p == 0){\\n\\t\\t\\t\\t\\tcount += t[p];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tcount += t[60 - p];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tt[p]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numPairsDivisibleBy60(vector<int>& time) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tvector<int> t (60, 0);\\n\\t\\t\\tfor(int i = 0; i < time.size(); i++){\\n\\t\\t\\t\\tint p = time[i] % 60;\\n\\t\\t\\t\\tif(p == 0){\\n\\t\\t\\t\\t\\tcount += t[p];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 964386,
                "title": "python-js-go-c-o-n-by-hashmap-two-sum-w-hint",
                "content": "Python O(n) by remainder and dictionary\\n\\n---\\n\\n**Hint & abstract model**:\\n\\nThis one is similar to classical [**two-sum problem**](https://leetcode.com/problems/two-sum/). where math objective function is **x + y = target**\\n\\nThe difference is that what we want this time is **(x + y) % 60** = **target** = **0**\\n\\n---\\n\\n**Implementation**\\n\\nin **Python**:\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n        # key: remainder of mod 60\\n        # value: occurrence of remainder\\n        congruence_record = defaultdict(int)\\n        \\n        mod_60 = lambda x: x % 60\\n        \\n        pair_count = 0\\n        \\n\\n        for song_duration in map(mod_60, time):    \\n            \\n            complement = mod_60( 60 - song_duration )\\n            \\n            # update pair count\\n            pair_count += congruence_record.get(complement, 0)\\n            \\n            # update occurrence of remainder\\n            congruence_record[ song_duration ] += 1\\n            \\n            \\n        return pair_count\\n```\\n\\n---\\n\\nin **Javascipt**:\\n<details>\\n\\t<summary> Expand to show source code </summary>\\n\\n```\\nvar numPairsDivisibleBy60 = function(time) {\\n    \\n    var mod_60 = ( x => x % 60 );\\n    \\n    // key: remainder of mod 60\\n    // value: occurrence of remainder\\n    let congurenceDict = {}\\n    \\n    // counter of ( song i + song j ) % 60 == 0 \\n    let pairCount = 0\\n    \\n   \\n   for(const remainder of time.map( mod_60 ) ){     \\n       \\n        complement = mod_60( 60 - remainder );\\n        \\n        // update pair count with complement\\n        pairCount += congurenceDict[complement] || 0;\\n        \\n       // update occurrence of current remainder\\n        congurenceDict[remainder] = (congurenceDict[remainder] || 0) + 1;\\n        \\n    }\\n\\n    return pairCount;\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **Go**:\\n\\n<details>\\n\\t<summary> Expand to show source code </summary>\\n\\t\\n```\\nfunc numPairsDivisibleBy60(time []int) int {\\n    \\n    // key: remainder of mod 60\\n    // value: occurrence of remainder\\n    congruenceMap := make(map[int]int)\\n    \\n    piarCount := 0\\n    \\n    for _, number := range time{\\n        \\n        // Apply two-sum model with objective is (x + y) % 60 = 0\\n        \\n        remainder := number % 60\\n        complement := ( 60 - remainder ) % 60\\n        \\n        // update pair count\\n        piarCount += congruenceMap[complement]\\n        \\n        // update occurrence of current remainder\\n        congruenceMap[remainder] += 1\\n    }\\n    \\n    return piarCount\\n}\\n```\\n\\n</details>\\n\\n\\n---\\nin **C++**:\\n\\n<details>\\n\\t<summary> Expand to show source code </summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        \\n        auto mod_60 = [](int x) { return x % 60 ; };\\n        \\n        int pairCount = 0;\\n        \\n        for( int songDuration : time){\\n            \\n            // // Apply two-sum model with objective is (x + y) % 60 = 0\\n            \\n            int remainder = mod_60( songDuration);\\n            int complement = mod_60( 60 - remainder );\\n            \\n            // update pairCount with complement\\n            pairCount += remainderOcc[ complement ];\\n            \\n            // update occurrence of current remainder\\n            remainderOcc[ remainder ] += 1;\\n        }\\n        \\n        return pairCount;\\n    }\\n    \\nprivate:\\n    map<int, int> remainderOcc;\\n};\\n```\\n</details>\\n\\n---\\n\\nRelated Leetcode challenge:\\n\\n[Leetcode #1 Two Sum](https://leetcode.com/problems/two-sum/)\\n\\n[Leetcode #1865 Finding Pairs With a Certain Sum](https://leetcode.com/problems/finding-pairs-with-a-certain-sum/) \\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about dictionary](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)\\n\\n[2] [MDN: Javascript official docs about map & functional programming](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\\n\\n[3] [Go offical docs about map (i.e., the so-called dictionary)](https://go.dev/blog/maps)\\n\\n[4] [CPP Reference about lambda function](https://en.cppreference.com/w/cpp/language/lambda)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n        # key: remainder of mod 60\\n        # value: occurrence of remainder\\n        congruence_record = defaultdict(int)\\n        \\n        mod_60 = lambda x: x % 60\\n        \\n        pair_count = 0\\n        \\n\\n        for song_duration in map(mod_60, time):    \\n            \\n            complement = mod_60( 60 - song_duration )\\n            \\n            # update pair count\\n            pair_count += congruence_record.get(complement, 0)\\n            \\n            # update occurrence of remainder\\n            congruence_record[ song_duration ] += 1\\n            \\n            \\n        return pair_count\\n```\n```\\nvar numPairsDivisibleBy60 = function(time) {\\n    \\n    var mod_60 = ( x => x % 60 );\\n    \\n    // key: remainder of mod 60\\n    // value: occurrence of remainder\\n    let congurenceDict = {}\\n    \\n    // counter of ( song i + song j ) % 60 == 0 \\n    let pairCount = 0\\n    \\n   \\n   for(const remainder of time.map( mod_60 ) ){     \\n       \\n        complement = mod_60( 60 - remainder );\\n        \\n        // update pair count with complement\\n        pairCount += congurenceDict[complement] || 0;\\n        \\n       // update occurrence of current remainder\\n        congurenceDict[remainder] = (congurenceDict[remainder] || 0) + 1;\\n        \\n    }\\n\\n    return pairCount;\\n};\\n```\n```\\nfunc numPairsDivisibleBy60(time []int) int {\\n    \\n    // key: remainder of mod 60\\n    // value: occurrence of remainder\\n    congruenceMap := make(map[int]int)\\n    \\n    piarCount := 0\\n    \\n    for _, number := range time{\\n        \\n        // Apply two-sum model with objective is (x + y) % 60 = 0\\n        \\n        remainder := number % 60\\n        complement := ( 60 - remainder ) % 60\\n        \\n        // update pair count\\n        piarCount += congruenceMap[complement]\\n        \\n        // update occurrence of current remainder\\n        congruenceMap[remainder] += 1\\n    }\\n    \\n    return piarCount\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        \\n        auto mod_60 = [](int x) { return x % 60 ; };\\n        \\n        int pairCount = 0;\\n        \\n        for( int songDuration : time){\\n            \\n            // // Apply two-sum model with objective is (x + y) % 60 = 0\\n            \\n            int remainder = mod_60( songDuration);\\n            int complement = mod_60( 60 - remainder );\\n            \\n            // update pairCount with complement\\n            pairCount += remainderOcc[ complement ];\\n            \\n            // update occurrence of current remainder\\n            remainderOcc[ remainder ] += 1;\\n        }\\n        \\n        return pairCount;\\n    }\\n    \\nprivate:\\n    map<int, int> remainderOcc;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337813,
                "title": "easy-peasy-python-solution-similar-to-two-sum-with-a-little-change",
                "content": "\\t\\tres = 0\\n        mp = {}\\n        for tm in time:\\n            tm = tm % 60\\n            fnd = (60 - tm) % 60\\n            if fnd in mp:\\n                res += mp[fnd]\\n            mp[tm] = mp.get(tm, 0) + 1\\n        \\n        return res",
                "solutionTags": [],
                "code": "\\t\\tres = 0\\n        mp = {}\\n        for tm in time:\\n            tm = tm % 60\\n            fnd = (60 - tm) % 60\\n            if fnd in mp:\\n                res += mp[fnd]\\n            mp[tm] = mp.get(tm, 0) + 1\\n        \\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 257195,
                "title": "beats-100-c-unordered-map",
                "content": "class Solution {\\npublic:\\n\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        \\n        unordered_map<int, int>mp;\\n        int c = 0;\\n        \\n        for (int i = 0; i < time.size(); i++) {\\n            int d = time[i]%60;\\n            c += d == 0 ? mp[d] : mp[60-d];\\n            mp[d]++;\\n        }\\n        \\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        \\n        unordered_map<int, int>mp;\\n        int c = 0;\\n        \\n        for (int i = 0; i < time.size(); i++) {\\n            int d = time[i]%60;\\n            c += d == 0 ? mp[d] : mp[60-d];\\n            mp[d]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1662429,
                "title": "c-two-sum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int rem[60]={0};\\n        int ans = 0;\\n        for(int t : time){\\n            if(t%60==0) ans+=rem[0];\\n            else ans+=rem[60-t%60];\\n            rem[t%60]++;\\n        }\\n        return ans;\\n    }\\n};\\n//(a+b)%60=0\\n//(a%60 + b%60)%60 = 0;\\n//a%60 + b%60 = 60;\\n//a%60 = 60-b%60;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int rem[60]={0};\\n        int ans = 0;\\n        for(int t : time){\\n            if(t%60==0) ans+=rem[0];\\n            else ans+=rem[60-t%60];\\n            rem[t%60]++;\\n        }\\n        return ans;\\n    }\\n};\\n//(a+b)%60=0\\n//(a%60 + b%60)%60 = 0;\\n//a%60 + b%60 = 60;\\n//a%60 = 60-b%60;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085329,
                "title": "c-o-n-solution",
                "content": "**Intuition**\\nThere is distributive property of ```%``` operation: ```(a + b) % c = (a % c + b % c) % c```.\\nSo for a given time ```t```, we need to find the occurrence of ```x``` such at ```(t + x) % 60 = 0```.\\nAccording to the property, we will get ``` (t % 60 + x % 60) % 60 = 0```. \\nSo we can futher get either ```t % 60 + x % 60 = 0```, or ```t % 60 + x % 60 = 60```. Since ```t> 0```, so ```t % 60 + x % 60 = 0``` equals to ```t % 60 = 0``` and ```x % 60 = 0```. \\nWe can use Dictionary or Array to count the ocurrence of the remainders.\\n\\n**why t % 60 + x % 60 = 60?**\\n```\\n(a+ b) % c = a % c + b % c = r1 + r2 \\nr1 < c && r2 < c\\n=> r1 + r2 < 2c \\nIf we want (r1 + r2) % c = 0, then r1 + r2 = c, 2c, 3c.... Since r1 + r2 < 2c , so r1 + r2 = c \\n```\\n\\n\\n**Implemetation**\\n```\\npublic class Solution {\\n    public int NumPairsDivisibleBy60(int[] time) {\\n        \\n        if(time == null || time.Length == 0)\\n            return 0;\\n        \\n        int[] remainder = new int[60];\\n        int cnt = 0;\\n        foreach(int t in time)\\n        {\\n            if(t % 60 == 0)\\n                cnt += remainder[0];\\n            else\\n                cnt += remainder[60 - t % 60];\\n            \\n            remainder[t % 60]++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```%```\n```(a + b) % c = (a % c + b % c) % c```\n```t```\n```x```\n```(t + x) % 60 = 0```\n``` (t % 60 + x % 60) % 60 = 0```\n```t % 60 + x % 60 = 0```\n```t % 60 + x % 60 = 60```\n```t> 0```\n```t % 60 + x % 60 = 0```\n```t % 60 = 0```\n```x % 60 = 0```\n```\\n(a+ b) % c = a % c + b % c = r1 + r2 \\nr1 < c && r2 < c\\n=> r1 + r2 < 2c \\nIf we want (r1 + r2) % c = 0, then r1 + r2 = c, 2c, 3c.... Since r1 + r2 < 2c , so r1 + r2 = c \\n```\n```\\npublic class Solution {\\n    public int NumPairsDivisibleBy60(int[] time) {\\n        \\n        if(time == null || time.Length == 0)\\n            return 0;\\n        \\n        int[] remainder = new int[60];\\n        int cnt = 0;\\n        foreach(int t in time)\\n        {\\n            if(t % 60 == 0)\\n                cnt += remainder[0];\\n            else\\n                cnt += remainder[60 - t % 60];\\n            \\n            remainder[t % 60]++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964721,
                "title": "pair-of-songs-o-n-time-complexity-fastest-and-easiest-with-comments",
                "content": "**If you like the soln please upvote it ,really helpfull**\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int count=0;\\n        for(int i=0;i<time.length;i++){\\n            time[i]=time[i]%60;     //make all values in range 60\\n        }\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<time.length;i++){\\n            map.computeIfAbsent(time[i],key->0);\\n            map.compute(time[i],(key,val)->val+1);  //add them in map\\n        }\\n        for(int i=0;i<time.length;i++){\\n            int num=(60-time[i])%60; \\n            map.compute(time[i],(key,val)->val-1);  //delete the current element\\n            if(map.containsKey(num)){\\n                count+=map.get(num);//if element present in map, frequency greater then 0 then add to count \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int count=0;\\n        for(int i=0;i<time.length;i++){\\n            time[i]=time[i]%60;     //make all values in range 60\\n        }\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<time.length;i++){\\n            map.computeIfAbsent(time[i],key->0);\\n            map.compute(time[i],(key,val)->val+1);  //add them in map\\n        }\\n        for(int i=0;i<time.length;i++){\\n            int num=(60-time[i])%60; \\n            map.compute(time[i],(key,val)->val-1);  //delete the current element\\n            if(map.containsKey(num)){\\n                count+=map.get(num);//if element present in map, frequency greater then 0 then add to count \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964396,
                "title": "c-python-super-simple-and-short-efficient-solutions-o-n-time",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        for (auto song : time) {\\n            if (song % 60 == 0)\\n                res += m[0];\\n            else\\n                res += m[60 - song%60];\\n            m[song%60]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        d = defaultdict(int)\\n        res = 0\\n        for song in time:\\n            if song % 60 == 0:\\n                res += d[0]\\n            else:\\n                res += d[60 - song%60]\\n                \\n            d[song%60]+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        for (auto song : time) {\\n            if (song % 60 == 0)\\n                res += m[0];\\n            else\\n                res += m[60 - song%60];\\n            m[song%60]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        d = defaultdict(int)\\n        res = 0\\n        for song in time:\\n            if song % 60 == 0:\\n                res += d[0]\\n            else:\\n                res += d[60 - song%60]\\n                \\n            d[song%60]+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589219,
                "title": "simplest-o-n-solution-c-o-1-memory",
                "content": "The basic idea here is that: store the count of `time[i] % 60`.\\nfor every `w = num[i] % 60` add count of `60 - w` seen so far.\\n\\n````\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int count = 0;\\n        vector<int> s(60, 0);\\n        for(int i = 0; i < time.size(); i++)\\n        {\\n            int w = time[i] % 60;\\n            if(w == 0) count += s[w];\\n            else count += s[60 - w];\\n            s[w]++;\\n        }\\n        return count;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int count = 0;\\n        vector<int> s(60, 0);\\n        for(int i = 0; i < time.size(); i++)\\n        {\\n            int w = time[i] % 60;\\n            if(w == 0) count += s[w];\\n            else count += s[60 - w];\\n            s[w]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258912,
                "title": "javascript-clean-code-with-es6",
                "content": "```js\\nvar numPairsDivisibleBy60 = time => {\\n    let c = new Array(60).fill(0)\\n    return time.reduce((acc, cur) => {\\n        acc += c[(60 - cur % 60) % 60]\\n        c[cur % 60] += 1 \\n        return acc\\n    }, 0)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar numPairsDivisibleBy60 = time => {\\n    let c = new Array(60).fill(0)\\n    return time.reduce((acc, cur) => {\\n        acc += c[(60 - cur % 60) % 60]\\n        c[cur % 60] += 1 \\n        return acc\\n    }, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408436,
                "title": "java-o-n-using-arrays",
                "content": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        \\n        int []fmap = new int[60];\\n        int res = 0;\\n        \\n        for(int t : time){\\n            int val = t % 60;\\n            \\n            if(val == 0){\\n                res += fmap[0];\\n            }else{\\n                res += fmap[60-val];\\n            }\\n            \\n            fmap[val]++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        \\n        int []fmap = new int[60];\\n        int res = 0;\\n        \\n        for(int t : time){\\n            int val = t % 60;\\n            \\n            if(val == 0){\\n                res += fmap[0];\\n            }else{\\n                res += fmap[60-val];\\n            }\\n            \\n            fmap[val]++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661638,
                "title": "well-explained-3-approaches-easy-for-mind-to-accept-them",
                "content": "**Brute Force Solution** [Time Limit Exceeds]\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int pair = 0;\\n        for(int i = 0; i < time.length - 1; i++){\\n            for(int j = i + 1; j < time.length; j++){\\n                if((time[i] + time[j]) % 60 == 0){\\n                    pair++;\\n                }\\n            }\\n        }\\n        return pair;\\n    }\\n}\\n```\\nANALYSIS :- \\n* **Time Complexity :-**  BigO(N^2)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n**HashMap Solution**\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // 1st Integer Represent time duration % 60 of song & 2nd Integer will count the no of such songs\\n        \\n        int count = 0;\\n        \\n        for(int t : time){\\n            if(t % 60 == 0){ // if we have something like [60,60,60]\\n                count += map.getOrDefault(0, 0);\\n            }\\n            else{\\n                count += map.getOrDefault(60 - t % 60, 0); // [30,20,150,100,40] using this example 100\\n                // if we take moduls of 100 with 60 we get 40, then we look for 60 - 40 which is 20. And 20 is there in \"map\", we update our count. And update the entry of 40 in our \"map\" as well\\n            }\\n            map.put(t % 60, map.getOrDefault(t % 60, 0) + 1); // [30,20,150,100,40] using this example 150\\n            // 150 % 60 gives 30 and as we have already encountered 1 of the 30 previously. SO, we will update our count from 0 to 1\\n        }\\n        return count;\\n    }\\n} \\n```\\nANALYSIS :-\\n* **Time Complexity :-**  BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n\\n**Another Easy Way using the Help of ARRAYs**\\n```\\nclass Solution{\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] mod = new int[60];\\n        for(int t : time) mod[t%60]++; //count the number of differnt modulation cases of divided by 60. \\n        int res = 0;\\n        for(int i = 0; i <= 30; i++){//sum to 30 to avoid double counting\\n            if(i == 0 || i == 30) res += (mod[i])*(mod[i]-1)/2; //special case: modulation is 0 or 30. \\n            else res += mod[i] * mod[60-i]; //general case\\n        }\\n        return res;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-**  BigO(N)\\n\\n* **Space Complexity :-** BigO(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int pair = 0;\\n        for(int i = 0; i < time.length - 1; i++){\\n            for(int j = i + 1; j < time.length; j++){\\n                if((time[i] + time[j]) % 60 == 0){\\n                    pair++;\\n                }\\n            }\\n        }\\n        return pair;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // 1st Integer Represent time duration % 60 of song & 2nd Integer will count the no of such songs\\n        \\n        int count = 0;\\n        \\n        for(int t : time){\\n            if(t % 60 == 0){ // if we have something like [60,60,60]\\n                count += map.getOrDefault(0, 0);\\n            }\\n            else{\\n                count += map.getOrDefault(60 - t % 60, 0); // [30,20,150,100,40] using this example 100\\n                // if we take moduls of 100 with 60 we get 40, then we look for 60 - 40 which is 20. And 20 is there in \"map\", we update our count. And update the entry of 40 in our \"map\" as well\\n            }\\n            map.put(t % 60, map.getOrDefault(t % 60, 0) + 1); // [30,20,150,100,40] using this example 150\\n            // 150 % 60 gives 30 and as we have already encountered 1 of the 30 previously. SO, we will update our count from 0 to 1\\n        }\\n        return count;\\n    }\\n} \\n```\n```\\nclass Solution{\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] mod = new int[60];\\n        for(int t : time) mod[t%60]++; //count the number of differnt modulation cases of divided by 60. \\n        int res = 0;\\n        for(int i = 0; i <= 30; i++){//sum to 30 to avoid double counting\\n            if(i == 0 || i == 30) res += (mod[i])*(mod[i]-1)/2; //special case: modulation is 0 or 30. \\n            else res += mod[i] * mod[60-i]; //general case\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994066,
                "title": "java-simple-and-good-solution-99-7",
                "content": "This solution only use an array. Map is good alternative to solve but it may be not good performance.\\nTime complexity  : O(n)\\n\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int array[] = new int[60];\\n        int retVal = 0;\\n        for(int i : time) {\\n            int n = i % 60;\\n            retVal += array[n==0 ? 0 : 60-n];\\n            array[n]++;\\n        }\\n        return retVal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int array[] = new int[60];\\n        int retVal = 0;\\n        for(int i : time) {\\n            int n = i % 60;\\n            retVal += array[n==0 ? 0 : 60-n];\\n            array[n]++;\\n        }\\n        return retVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974797,
                "title": "java-one-pass-easy",
                "content": "```\\npublic int numPairsDivisibleBy60(int[] time) {\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        int count = 0;\\n        \\n        for (int i = 0; i < time.length; i++) {\\n            \\n            var mod = time[i] % 60;\\n            var rem = mod == 0? 0: 60 - mod;\\n            count += map.getOrDefault(rem, 0);\\n            \\n            map.put(mod, 1 + map.getOrDefault(mod, 0));\\n        }\\n        \\n        return count;\\n    }\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numPairsDivisibleBy60(int[] time) {\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        int count = 0;\\n        \\n        for (int i = 0; i < time.length; i++) {\\n            \\n            var mod = time[i] % 60;\\n            var rem = mod == 0? 0: 60 - mod;\\n            count += map.getOrDefault(rem, 0);\\n            \\n            map.put(mod, 1 + map.getOrDefault(mod, 0));\\n        }\\n        \\n        return count;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 965379,
                "title": "python-clean-concise-time-o-n-space-o-1",
                "content": "```python\\nclass Solution(object):\\n    def numPairsDivisibleBy60(self, time):\\n        cnt = [0] * 60\\n        ans = 0\\n        for t in time:\\n            t %= 60\\n            ans += cnt[(60-t) % 60]\\n            cnt[t] += 1\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def numPairsDivisibleBy60(self, time):\\n        cnt = [0] * 60\\n        ans = 0\\n        for t in time:\\n            t %= 60\\n            ans += cnt[(60-t) % 60]\\n            cnt[t] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964990,
                "title": "heavily-commented-javascript-solution",
                "content": "Brute force approach would be to try each number with the numbers right of it\\n```\\n     30 & 20\\n     30 & 150\\n     30 & 100\\n     30 & 40\\n     20 & 150 etc...\\n ```\\n \\n This is not great with a list of 500 and I expect it would time out.\\n\\n So can we play around with the numbers? Does sorting help?\\n Simplify the numbers? Here they are sorted and simplified\\n```\\n [2,3,4,10,15] % 6\\n```\\n\\n Can we identify what a number \"needs\" to be moddable pair ?\\n \\n*  2 needs 4\\n*  3 needs 3\\n*  4 needs 2\\n*  10 needs 2\\n*  15 needs 3\\n\\n Now I see that 15 and 10 are just more complicated 4 and 3\\n We should mod those numbers by 6 and consider \\n```\\n [2,3,4,4,3]  % 6\\n```\\n\\n that looks simpler, now what? with a \"x needs y\" construct, an occurance count lookup map would help. which gets us\\n```\\n {\\n\\t2: 1,\\n\\t3: 2,\\n\\t4: 2\\n }\\n ```\\n So now I can do a O(1) look up for each number to see if a pair can be formed\\n\\n*  2 needs a 4, we have two 4\\'s so that increases our count by two\\n*  3 needs a 3, so every pair is a count++\\n*  4 we shouldn\\'t double count, so we should set the matching count to zero in our occurance map as we find what we need.\\n\\n Enough of an idea to start coding! \\n\\n --- coding ---\\n\\n I failed on the case:\\n ```\\n [418,204,77,278,239,457,284,263,372,279,476,416,360,18]\\n```\\n\\n I count 2 where there should be only 1 apparently. I count each number modded to 0 as one, which I shouldn\\'t, it should still be forming a pair, so I should treat it the same as \\'30\\'s.\\n \\nThat works!\\n\\n```\\n\\nvar numPairsDivisibleBy60 = function(time) {\\n   \\n    var i, l;\\n    var occuranceMap = {};\\n    var pairCount = 0;\\n    \\n    // Count the unique numbers we see under 60\\n    for (i = 0, l = time.length; i < l; i++) {\\n        \\n        time[i] = time[i] % 60;\\n        \\n        if (!occuranceMap[time[i]]) {\\n            occuranceMap[time[i]] = 0;\\n        }        \\n        occuranceMap[time[i]]++;\\n        \\n    }\\n    \\n    // for each unique number, calculate how many pairs we can form\\n    for (let entry in occuranceMap) {\\n        let numberToMatch = 60 - parseInt(entry, 10);\\n       \\n        if (entry === \\'30\\' || entry === \\'0\\') {\\n\\n            // special case, count every possible pair: (x * (x - 1)) / 2\\n            pairCount += (occuranceMap[entry] * (occuranceMap[entry] - 1)) / 2;\\n        \\n        } else if (occuranceMap[numberToMatch]) {\\n            \\n            // default case, we should count  x * y\\n            pairCount += occuranceMap[entry] * occuranceMap[numberToMatch];\\n            \\n            // set the matched number to zero so we don\\'t double count\\n            occuranceMap[numberToMatch] = 0;\\n        }\\n    }\\n    \\n    return pairCount; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n     30 & 20\\n     30 & 150\\n     30 & 100\\n     30 & 40\\n     20 & 150 etc...\\n ```\n```\\n [2,3,4,10,15] % 6\\n```\n```\\n [2,3,4,4,3]  % 6\\n```\n```\\n {\\n\\t2: 1,\\n\\t3: 2,\\n\\t4: 2\\n }\\n ```\n```\\n [418,204,77,278,239,457,284,263,372,279,476,416,360,18]\\n```\n```\\n\\nvar numPairsDivisibleBy60 = function(time) {\\n   \\n    var i, l;\\n    var occuranceMap = {};\\n    var pairCount = 0;\\n    \\n    // Count the unique numbers we see under 60\\n    for (i = 0, l = time.length; i < l; i++) {\\n        \\n        time[i] = time[i] % 60;\\n        \\n        if (!occuranceMap[time[i]]) {\\n            occuranceMap[time[i]] = 0;\\n        }        \\n        occuranceMap[time[i]]++;\\n        \\n    }\\n    \\n    // for each unique number, calculate how many pairs we can form\\n    for (let entry in occuranceMap) {\\n        let numberToMatch = 60 - parseInt(entry, 10);\\n       \\n        if (entry === \\'30\\' || entry === \\'0\\') {\\n\\n            // special case, count every possible pair: (x * (x - 1)) / 2\\n            pairCount += (occuranceMap[entry] * (occuranceMap[entry] - 1)) / 2;\\n        \\n        } else if (occuranceMap[numberToMatch]) {\\n            \\n            // default case, we should count  x * y\\n            pairCount += occuranceMap[entry] * occuranceMap[numberToMatch];\\n            \\n            // set the matched number to zero so we don\\'t double count\\n            occuranceMap[numberToMatch] = 0;\\n        }\\n    }\\n    \\n    return pairCount; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 892004,
                "title": "python3-easy-solution-with-time-o-n-space-o-1",
                "content": "```   \\n\\t\\tres = 0\\n        counter = [0] * 60 // create an array of 60 elements with init value 0\\n\\n\\t\\tfor i in time:\\n            res = res + counter[-i % 60]\\n\\t\\t\\t//  (-i%60) will give the remaining val that we are looking for \\n\\t\\t\\t// ex (40%60) = 40, (-40%60) = 20\\n            counter[i % 60] = counter[i % 60] + 1\\n            \\n        return res\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```   \\n\\t\\tres = 0\\n        counter = [0] * 60 // create an array of 60 elements with init value 0\\n\\n\\t\\tfor i in time:\\n            res = res + counter[-i % 60]\\n\\t\\t\\t//  (-i%60) will give the remaining val that we are looking for \\n\\t\\t\\t// ex (40%60) = 40, (-40%60) = 20\\n            counter[i % 60] = counter[i % 60] + 1\\n            \\n        return res\\n\\t\\t\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 793836,
                "title": "java-simple-program-using-constant-array-space",
                "content": "```\\n\\npublic int numPairsDivisibleBy60(int[] time) {\\n        \\n        int[] map = new int[60];\\n        int count=0;\\n        \\n        for(int i=0;i<time.length;i++){\\n            time[i] %= 60;\\n            \\n            if(map[(60-time[i])%60] > 0)\\n                count += map[(60-time[i])%60];  \\n            map[time[i]]++;   \\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\npublic int numPairsDivisibleBy60(int[] time) {\\n        \\n        int[] map = new int[60];\\n        int count=0;\\n        \\n        for(int i=0;i<time.length;i++){\\n            time[i] %= 60;\\n            \\n            if(map[(60-time[i])%60] > 0)\\n                count += map[(60-time[i])%60];  \\n            map[time[i]]++;   \\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3650221,
                "title": "c-counting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> v(60,0);\\n        int ans = 0;\\n        for(auto &i: time){\\n            //<!-- cout<<i<<\" \"; -->\\n            ans += (v[(60-((i)%60))%60]);\\n            v[((i))%60]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> v(60,0);\\n        int ans = 0;\\n        for(auto &i: time){\\n            //<!-- cout<<i<<\" \"; -->\\n            ans += (v[(60-((i)%60))%60]);\\n            v[((i))%60]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2100729,
                "title": "c-one-pass-concise-and-clean-code",
                "content": "```\\n  int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int,int> reminders;\\n        int ans=0;\\n        for(auto &it : time)\\n        {\\n            ans+= reminders[(60-it%60)%60];  // extra \"% 60\" at end as it%60 could be 0\\n            reminders[it%60]++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int,int> reminders;\\n        int ans=0;\\n        for(auto &it : time)\\n        {\\n            ans+= reminders[(60-it%60)%60];  // extra \"% 60\" at end as it%60 could be 0\\n            reminders[it%60]++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945160,
                "title": "most-efficient-python-solution-that-beats-95-solutions",
                "content": "***Intution:***\\nWe\\'ll be using a dictionary to store the remainders of values in time matrix when they are divided by 60.\\nInitialise answer variable \\'ans\\' with 0.\\n\\nSome values would be completely divisible by 60, in that case the number of values divisible by 60 would be the value of key 0.\\n\\nThese values will contribute to answer based on following formula:\\n\\n`ans+=cnt.get(0,0)*(cnt.get(0,0)-1)//2`\\n\\nWe\\'re using the get() function to provide the default value as 0 in case the key is not present.\\nThe another term cnt.get(0,0)-1 is multiplied as a single value is unable to make a pair.\\nThe final product is divisible by 2 to eliminate the permutations (to ensure i and j are treated only once and not twice as i,j and j,i)\\n\\nSome values would return 30 as the remainder in that case these values will contribute to the answer based on the following formula:\\n\\n`ans+=cnt.get(30,0)*(cnt.get(30,0)-1)//2`\\n\\nEverything  would be same as explained for the previous formula.\\n\\nNow we\\'ve covered the posibilities of number fully divided by 60 and numbers leaving the remainder 30.\\n\\nNow we would count the pairs made by the numbers ranging from 1 to 29 and 31 to 59 by running following loop and using this formula:\\n\\n```\\nfor i in range(1,30):\\n            ans+=cnt.get(i,0) * cnt.get(60-i,0)\\n```\\n\\nAt the end our answer would be stored in variable \\'\\'ans\\'\\' which we will return.\\n\\n***Complexity Analysis:***\\n\\nTime Complexity:\\nO(n) [Linear]\\n\\nSpace complexity:\\nO(1) [Constant]\\n*(Therefore the values stored by dictionary would never exceed 60)*\\n\\n***Code:***\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        ans=0\\n        cnt={}\\n        for t in time:\\n            if t%60 in cnt:\\n                cnt[t%60]+=1\\n            else:\\n                cnt[t%60]=1\\n        ans+=(cnt.get(0,0)*(cnt.get(0,0)-1)//2)+(cnt.get(30,0)*(cnt.get(30,0)-1)//2)\\n        for i in range(1,30):\\n            ans+=cnt.get(i,0)*cnt.get(60-i,0)\\n        return ans\\n```\\n\\n**PLEASE UPVOTE THE ANSWER TO MOTIVATE ME FOR CONTINUING THE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfor i in range(1,30):\\n            ans+=cnt.get(i,0) * cnt.get(60-i,0)\\n```\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        ans=0\\n        cnt={}\\n        for t in time:\\n            if t%60 in cnt:\\n                cnt[t%60]+=1\\n            else:\\n                cnt[t%60]=1\\n        ans+=(cnt.get(0,0)*(cnt.get(0,0)-1)//2)+(cnt.get(30,0)*(cnt.get(30,0)-1)//2)\\n        for i in range(1,30):\\n            ans+=cnt.get(i,0)*cnt.get(60-i,0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661705,
                "title": "java-concept-explained-o-n",
                "content": "```\\nclass Solution {\\n    //TC : O(N)\\n    \\n    /*\\n    Concept:\\n    % operator gives us how much more he have than required. Like if we have 70%60 than we get 10.\\n    Here 10 tells us that we have 10 extra . For 120%60 we have 0 extra. This extra will range between 0 to 59. \\n    For this question we would consider a pair as answer if sum of extra is 0 or 60.\\n    \\n    Algorithm :\\n    We will keep a remainder array to keep count of remainders.\\n    Now let\\'s traverse array.Consider we get an element 40.We will then find extra of 40,which will come out as 40.\\n\\tNow we will check how many numbers we have previously seen with remainder as \\n    60-40=20.If count comes out as 2 than we will have 2 pairs as answer and add 2 in our count variable.\\n\\tThere is one exception if remainder comes as 0.\\n\\tThen we can\\'t find if there is someone with remainder 60-0=60.We need to find numbers with remainder as 0.\\n\\tWe will make array of size 60,since remainders can only be between 0 to 59.\\n    */\\n    \\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] rem=new int[60];  //to keep count of remainders\\n        int count=0;\\n        for(int t:time){\\n            if(t%60==0)\\n                count+=rem[0];\\n            else\\n                count+=rem[60-t%60];\\n            rem[t%60]++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //TC : O(N)\\n    \\n    /*\\n    Concept:\\n    % operator gives us how much more he have than required. Like if we have 70%60 than we get 10.\\n    Here 10 tells us that we have 10 extra . For 120%60 we have 0 extra. This extra will range between 0 to 59. \\n    For this question we would consider a pair as answer if sum of extra is 0 or 60.\\n    \\n    Algorithm :\\n    We will keep a remainder array to keep count of remainders.\\n    Now let\\'s traverse array.Consider we get an element 40.We will then find extra of 40,which will come out as 40.\\n\\tNow we will check how many numbers we have previously seen with remainder as \\n    60-40=20.If count comes out as 2 than we will have 2 pairs as answer and add 2 in our count variable.\\n\\tThere is one exception if remainder comes as 0.\\n\\tThen we can\\'t find if there is someone with remainder 60-0=60.We need to find numbers with remainder as 0.\\n\\tWe will make array of size 60,since remainders can only be between 0 to 59.\\n    */\\n    \\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] rem=new int[60];  //to keep count of remainders\\n        int count=0;\\n        for(int t:time){\\n            if(t%60==0)\\n                count+=rem[0];\\n            else\\n                count+=rem[60-t%60];\\n            rem[t%60]++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305951,
                "title": "java-map-solution",
                "content": "-> Make a map of reminders ( times[i] % 60) and then check for the pairs of reminders that sum upto 60. \\n-> Store the combination(map.get(i) * map.get(60-i)) in a variable. \\n-> But 0 and 30 are two different cases they themselves are the pairs so we need to calculate the frequency separately and ultimately store them in the same variable we used to store the other combinations.  \\n->Return that variable in the end. \\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count =0;\\n        for(int i= 0; i< time.length;i++){\\n            map.put(time[i] % 60, map.getOrDefault(time[i] % 60, 0)+1);\\n        }\\n        for(int i= 1; i< 30;i++){\\n            if(map.containsKey(i) && map.containsKey(60-i)){\\n                count += map.get(i) * map.get(60-i);\\n            }\\n        }\\n\\t\\t\\n        if(map.containsKey(0)) {\\n            count += (map.get(0)-1) * map.get(0) / 2;\\n        }    \\n        if(map.containsKey(30)) {\\n            count += (map.get(30)-1) * map.get(30)/2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count =0;\\n        for(int i= 0; i< time.length;i++){\\n            map.put(time[i] % 60, map.getOrDefault(time[i] % 60, 0)+1);\\n        }\\n        for(int i= 1; i< 30;i++){\\n            if(map.containsKey(i) && map.containsKey(60-i)){\\n                count += map.get(i) * map.get(60-i);\\n            }\\n        }\\n\\t\\t\\n        if(map.containsKey(0)) {\\n            count += (map.get(0)-1) * map.get(0) / 2;\\n        }    \\n        if(map.containsKey(30)) {\\n            count += (map.get(30)-1) * map.get(30)/2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894139,
                "title": "c-o-n-time-o-1-space-unordered-map",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) \\n    {\\n        const int N = time.size();        \\n        unordered_map<int, int> table;\\n        \\n        int numPairs = 0;\\n        for (int i = 0; i < N; ++i)\\n        {\\n            int r = time[i] % 60;\\n            numPairs += table[r > 0 ? 60-r : 0];\\n            table[r]++;\\n        }\\n        \\n        return numPairs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) \\n    {\\n        const int N = time.size();        \\n        unordered_map<int, int> table;\\n        \\n        int numPairs = 0;\\n        for (int i = 0; i < N; ++i)\\n        {\\n            int r = time[i] % 60;\\n            numPairs += table[r > 0 ? 60-r : 0];\\n            table[r]++;\\n        }\\n        \\n        return numPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762220,
                "title": "two-javascript-solutions-brute-force-and-hashmap",
                "content": "1) Brute force\\n\\n```\\n// O(N2), O(1)\\n// 6532ms (13.10%), 39.6MB (10.00%)\\nvar numPairsDivisibleBy60 = function(time) {\\n    let counter = 0;\\n    for (let i = 0; i < time.length - 1; i++) {\\n        for (let j = i + 1; j < time.length; j++) {\\n            if ((time[i] + time[j]) % 60 === 0) counter++;\\n        }\\n    }\\n    return counter;\\n};\\n```\\n\\n2) Hash map\\n\\n```\\n// O(n), O(n)\\n// 100ms (71.03%), 39.8MB (10.00%)\\nvar numPairsDivisibleBy60 = function(time) {\\n    let hashMap = new Array(60).fill(0);\\n    let c = 0;\\n    for (let i = 0; i < time.length; i++) {\\n        let val = time[i] % 60;\\n        c += hashMap[(60 - val) % 60];\\n        hashMap[val] += 1;\\n    }\\n    return c;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(N2), O(1)\\n// 6532ms (13.10%), 39.6MB (10.00%)\\nvar numPairsDivisibleBy60 = function(time) {\\n    let counter = 0;\\n    for (let i = 0; i < time.length - 1; i++) {\\n        for (let j = i + 1; j < time.length; j++) {\\n            if ((time[i] + time[j]) % 60 === 0) counter++;\\n        }\\n    }\\n    return counter;\\n};\\n```\n```\\n// O(n), O(n)\\n// 100ms (71.03%), 39.8MB (10.00%)\\nvar numPairsDivisibleBy60 = function(time) {\\n    let hashMap = new Array(60).fill(0);\\n    let c = 0;\\n    for (let i = 0; i < time.length; i++) {\\n        let val = time[i] % 60;\\n        c += hashMap[(60 - val) % 60];\\n        hashMap[val] += 1;\\n    }\\n    return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532956,
                "title": "java-fast-array-detail-easy",
                "content": "Full detail explanation: https://medium.com/@hch.hkcontact/goldman-sachs-top-50-leetcode-questions-q21-pairs-of-songs-with-total-durations-divisible-by-60-4c578f1223f\\n\\nPerformance:\\n- Time: O(n), n is no. of number in input array\\n- Space: O(n), n is no. of number in the input array\\n\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n\\n        int[] cnt = new int[60];\\n        int total = 0;\\n        for (int num : time) {\\n            int remainder = num % 60;\\n            int comp = (60 - remainder) % 60;\\n            total += cnt[comp];\\n            cnt[remainder]++;\\n        }\\n\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n\\n        int[] cnt = new int[60];\\n        int total = 0;\\n        for (int num : time) {\\n            int remainder = num % 60;\\n            int comp = (60 - remainder) % 60;\\n            total += cnt[comp];\\n            cnt[remainder]++;\\n        }\\n\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375947,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nSo the task is to find all `(n1+n2) % 60 == 0`. \\nThe first intuition should be if `n1 = x*60+a` and `n2 = y*60+b`, then left over parts combined `(a+b)` should be divisible by 60.\\nThat means, imagine the corresponding remainder array `[a, b, ...]`for each element. Now, we are looking at two sum kind of problem where `target sum = 60`.\\n\\nRefer https://leetcode.com/problems/two-sum/discuss/154904/Two-Java-Approaches (Basic idea for two sum is \"every number will check for its partner and also adds itself to the `partners` in the hope that its future partner will find it\")\\n\\nThere is another tricky point for this problem. All the remainders are mapped to `[0,1,2,..,59]`. So our partner pairs look like \\n\\n0+60\\n1+59\\n2+58\\n...\\n30+30\\n\\n`0` is a special case as its partner `60` will never be present by definition (`modulo` wraps around at `60`). So `0` partner is not `60` in our `partners` map rather `0` itself.\\n\\n```\\npublic int numPairsDivisibleBy60(int[] times) {\\n        int count = 0;\\n        Map<Integer, Integer> partners = new HashMap<>();\\n        for(int time : times){\\n            int t = time%60;\\n            if(t == 0)\\n                count += partners.getOrDefault(t, 0);\\n            else\\n                count += partners.getOrDefault(60-t, 0);\\n            partners.put(t, partners.getOrDefault(t, 0)+1);\\n        }\\n        return count;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int numPairsDivisibleBy60(int[] times) {\\n        int count = 0;\\n        Map<Integer, Integer> partners = new HashMap<>();\\n        for(int time : times){\\n            int t = time%60;\\n            if(t == 0)\\n                count += partners.getOrDefault(t, 0);\\n            else\\n                count += partners.getOrDefault(60-t, 0);\\n            partners.put(t, partners.getOrDefault(t, 0)+1);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274476,
                "title": "fast-and-easy-to-understand-c-solution",
                "content": "```\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int A[60] = {0};\\n        for (int t : time) A[t % 60]++;\\n\\t\\t\\n\\t\\t// A[0] and A[30] are special k * (k-1) / 2 pairs.\\n        int cnt = A[0] * (A[0] - 1) / 2 + A[30] * (A[30] - 1) / 2;\\n\\t\\t\\n        #pragma unroll\\n        for (int i = 1; i < 30; ++i) {\\n            cnt += A[i] * A[60 - i];\\n        }\\n        \\n        return cnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int A[60] = {0};\\n        for (int t : time) A[t % 60]++;\\n\\t\\t\\n\\t\\t// A[0] and A[30] are special k * (k-1) / 2 pairs.\\n        int cnt = A[0] * (A[0] - 1) / 2 + A[30] * (A[30] - 1) / 2;\\n\\t\\t\\n        #pragma unroll\\n        for (int i = 1; i < 30; ++i) {\\n            cnt += A[i] * A[60 - i];\\n        }\\n        \\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3197449,
                "title": "o-n-frequency-table-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<long long> freq(60,0);\\n        long long count=0;\\n        int n=time.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int rem = time[i]%60;\\n            freq[rem]++;\\n        }\\n        for(int i=1;i<30;i++)\\n        {\\n            count += (long long) freq[i]*freq[60-i];\\n        }\\n        count += (long long)(freq[0]*(freq[0]-1) )/2 ;\\n        count += (long long)(freq[30]*(freq[30]-1) )/2 ;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<long long> freq(60,0);\\n        long long count=0;\\n        int n=time.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int rem = time[i]%60;\\n            freq[rem]++;\\n        }\\n        for(int i=1;i<30;i++)\\n        {\\n            count += (long long) freq[i]*freq[60-i];\\n        }\\n        count += (long long)(freq[0]*(freq[0]-1) )/2 ;\\n        count += (long long)(freq[30]*(freq[30]-1) )/2 ;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948944,
                "title": "javascript-easy-solution",
                "content": "```\\nvar numPairsDivisibleBy60 = function(time) {\\n    let num=0;\\n    let arr=new Array(60).fill(0);\\n\\n    for(let i of time){\\n        let k=i%60;\\n\\n        if(k===0)\\n            num+=arr[k];\\n        else\\n            num+=arr[60-k];\\n        \\n        arr[k]++;\\n    }\\n    return num;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numPairsDivisibleBy60 = function(time) {\\n    let num=0;\\n    let arr=new Array(60).fill(0);\\n\\n    for(let i of time){\\n        let k=i%60;\\n\\n        if(k===0)\\n            num+=arr[k];\\n        else\\n            num+=arr[60-k];\\n        \\n        arr[k]++;\\n    }\\n    return num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2380490,
                "title": "python-with-simple-explanation-on-arriving-at-twosum-problem",
                "content": "![image](https://assets.leetcode.com/users/images/a7b12d6d-f136-4681-a03a-fbb4f97a62fc_1659648494.4292617.png)\\n\\n\\tclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n        for i,t in enumerate(time):\\n            time[i] = t%60\\n            \\n        \\n        mp = defaultdict(int)\\n        ans = 0\\n        for modtime in time:\\n            if modtime == 0:\\n                ans+= mp[modtime]\\n            else:\\n                ans+= mp[60-modtime]\\n            mp[modtime]+=1\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/a7b12d6d-f136-4681-a03a-fbb4f97a62fc_1659648494.4292617.png)\\n\\n\\tclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n        for i,t in enumerate(time):\\n            time[i] = t%60\\n            \\n        \\n        mp = defaultdict(int)\\n        ans = 0\\n        for modtime in time:\\n            if modtime == 0:\\n                ans+= mp[modtime]\\n            else:\\n                ans+= mp[60-modtime]\\n            mp[modtime]+=1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1751679,
                "title": "c-easy-and-best-solution-brute-optimal",
                "content": "```\\n//naive approach\\nint numPairsDivisibleBy60(vector<int>& time) {\\nint n = time.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n\\t\\t\\t//apply given condtion as per question \\n                if(j>i&&(time[i]+time[j])%60==0)count++;\\n            }\\n        }\\n        return count;\\n}\\n\\n//optimal approach\\nint numPairsDivisibleBy60(vector<int>& time) {\\n//maintain a vector of size an initilize with 0\\n        vector<int> v(60,0);\\n        int n = time.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n\\t\\t//find mod.\\n            int value = time[i]%60;\\n\\t\\t\\t//if multipple of 60 comes 60,120,180 ..... \\n            if(value==0){\\n                count+=v[value];\\n            }else{\\n                count+=v[60-value];\\n            }\\n\\t\\t\\t//update the value in vector\\n            v[value]++;\\n        }\\n        return count;\\n    }\\n```\\npls upvote!!! thanku",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting Sort"
                ],
                "code": "```\\n//naive approach\\nint numPairsDivisibleBy60(vector<int>& time) {\\nint n = time.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n\\t\\t\\t//apply given condtion as per question \\n                if(j>i&&(time[i]+time[j])%60==0)count++;\\n            }\\n        }\\n        return count;\\n}\\n\\n//optimal approach\\nint numPairsDivisibleBy60(vector<int>& time) {\\n//maintain a vector of size an initilize with 0\\n        vector<int> v(60,0);\\n        int n = time.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n\\t\\t//find mod.\\n            int value = time[i]%60;\\n\\t\\t\\t//if multipple of 60 comes 60,120,180 ..... \\n            if(value==0){\\n                count+=v[value];\\n            }else{\\n                count+=v[60-value];\\n            }\\n\\t\\t\\t//update the value in vector\\n            v[value]++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1665198,
                "title": "python-solution-with-explanation",
                "content": "Since, we have to find pairs of numbers that sum up to multiples of 60, **we can first simplify the problem by finding modulo 60 of each number. This will reduce all numbers to a range of 0 to 59 (60 modulo 60 will be 0) and thus we now have to find all pairs of numbers that sum to 60.** arr2 stores time modulo 60 numbers.\\n\\nNow we have **3 cases -** \\n\\n1. For eg, we know that 20 will pair up with 60-20 = 40, so if we just multiply occurences of 20 and 40 in arr2, we will get the total pairs (multiplication will consider pairs (20, 40) and (40, 20) as well). So for any pair (i, 60-i), we just have to multiply their occurences for total pairs.\\n\\n2. 30 will pair up with 30, so we have to pair up occurences of 30 with itself. If 30 appears for 2 times, it will be 1 pair, if it appears for 3 times, it will be 3 pairs, basically to pair up, there will be n(n-1)/2 pairs\\n\\n3. Similarly, multiples of 60 modulo 60 will be 0. And multiples of 60 will pair up with each other (bcoz sum will be multiple of 60). So this means 0 will pair up with 0, and hence just like above case, there will be n(n-1)/2 pairs of 0.\\n\\n\\nSo total pairs will be sum of all the above 3 cases.\\n\\n\\n\\n\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n               \\n        arr2 = [i%60 for i in time]\\n        # print(arr2)\\n        \\n        count_dict = Counter(arr2)\\n        # print(count_dict)\\n        pair_count = 0\\n        \\n        \\n        for i in range(1, 30):\\n            \\n            pair_count += count_dict[i] * count_dict[60-i]\\n            \\n        # print(pair_count)\\n            \\n        pair_count += count_dict[30] * (count_dict[30]-1)  // 2\\n        pair_count += count_dict[0] * (count_dict[0] -1)  // 2\\n            \\n        return pair_count\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n               \\n        arr2 = [i%60 for i in time]\\n        # print(arr2)\\n        \\n        count_dict = Counter(arr2)\\n        # print(count_dict)\\n        pair_count = 0\\n        \\n        \\n        for i in range(1, 30):\\n            \\n            pair_count += count_dict[i] * count_dict[60-i]\\n            \\n        # print(pair_count)\\n            \\n        pair_count += count_dict[30] * (count_dict[30]-1)  // 2\\n        pair_count += count_dict[0] * (count_dict[0] -1)  // 2\\n            \\n        return pair_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662737,
                "title": "python-hashmap-simple-solution-similar-to-two-sum",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        hashmap = {}\\n        pairs = 0\\n        for song in time:\\n            song = song % 60\\n            counterpart = 60-song if song else song\\n            if counterpart in hashmap:\\n                pairs += hashmap[counterpart]\\n            if song in hashmap:    \\n                hashmap[song] += 1\\n            else:\\n                hashmap[song] = 1\\n        return pairs\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        hashmap = {}\\n        pairs = 0\\n        for song in time:\\n            song = song % 60\\n            counterpart = 60-song if song else song\\n            if counterpart in hashmap:\\n                pairs += hashmap[counterpart]\\n            if song in hashmap:    \\n                hashmap[song] += 1\\n            else:\\n                hashmap[song] = 1\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661673,
                "title": "c-solution-leetcode-1010-pairs-of-songs-with-total-durations-divisible-by-60",
                "content": "OPTIMAL SOLUTION:\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> rem(60); //initialize remainder array which is the size of divisor\\n        \\n        for(int elem : time)\\n            rem[elem%60]+=1; //iterate the given elements and assign their remainder into the vector\\n        \\n        int output = 0;\\n        output += ((rem[0]-1)*rem[0])/2;  //special case 1: where 0 can be a remainder which can form a pair with only itself\\n        output += ((rem[30]-1)*rem[30])/2; //special case 2: where 30 can be a remainder where it can form a pair with only itself\\n\\t\\tfor(int i=1;i<=29;++i){  //iterate through first half excluding 0&30(as it a special case) to avoid duplication\\n            output+=rem[i]*rem[60-i]; //check in the remainder vector for corresponding pair to increment the count of divisibility \\n        }\\n        \\n        return output;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> rem(60); //initialize remainder array which is the size of divisor\\n        \\n        for(int elem : time)\\n            rem[elem%60]+=1; //iterate the given elements and assign their remainder into the vector\\n        \\n        int output = 0;\\n        output += ((rem[0]-1)*rem[0])/2;  //special case 1: where 0 can be a remainder which can form a pair with only itself\\n        output += ((rem[30]-1)*rem[30])/2; //special case 2: where 30 can be a remainder where it can form a pair with only itself\\n\\t\\tfor(int i=1;i<=29;++i){  //iterate through first half excluding 0&30(as it a special case) to avoid duplication\\n            output+=rem[i]*rem[60-i]; //check in the remainder vector for corresponding pair to increment the count of divisibility \\n        }\\n        \\n        return output;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535704,
                "title": "python3-two-sum",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \"\"\"\\n        (time[i]+ time[j]) % 60 =  0 \\n        case one:\\n            time[i] % 60 + time[j] % 60 = 60 \\n            20 % 60 + 100 % 60 = 20 + 40 = 60\\n        case two:\\n            time[i] % 60 = 0\\n            time[j] % 60 = 0\\n            60  % 60 = 0\\n            120 % 60 = 0\\n        \"\"\"\\n        result = 0 \\n        mapping = defaultdict(int)\\n        for t in time:\\n            key = t % 60\\n            if key == 0:\\n                result += mapping[0]\\n            else:\\n                result += mapping[60 - key]\\n            mapping[key] += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \"\"\"\\n        (time[i]+ time[j]) % 60 =  0 \\n        case one:\\n            time[i] % 60 + time[j] % 60 = 60 \\n            20 % 60 + 100 % 60 = 20 + 40 = 60\\n        case two:\\n            time[i] % 60 = 0\\n            time[j] % 60 = 0\\n            60  % 60 = 0\\n            120 % 60 = 0\\n        \"\"\"\\n        result = 0 \\n        mapping = defaultdict(int)\\n        for t in time:\\n            key = t % 60\\n            if key == 0:\\n                result += mapping[0]\\n            else:\\n                result += mapping[60 - key]\\n            mapping[key] += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286993,
                "title": "c-faster-than-96-easy-to-understand",
                "content": "```\\nunordered_map<int,int> mp;\\n      int a;\\n      for(int i=0;i<time.size();i++) \\n      {\\n          a=time[i]%60;\\n          mp[a]++;\\n      }\\n      \\n      int ans=0;\\n      for(int i=1;i<=29;i++)\\n      {\\n          if(mp.find(i)!=mp.end()&&mp.find(60-i)!=mp.end())\\n          {\\n              ans+=mp[i]*mp[60-i];\\n          }\\n      }\\n      if(mp.find(0)!=mp.end())\\n      {\\n         ans+=mp[0]*(mp[0]-1)/2;  \\n      }  \\n      if(mp.find(30)!=mp.end())\\n      {\\n         ans+=mp[30]*(mp[30]-1)/2;  \\n      }\\n      return ans;\\n```\\nIf you liked the code, Give it a **Thumbs Up** !!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nunordered_map<int,int> mp;\\n      int a;\\n      for(int i=0;i<time.size();i++) \\n      {\\n          a=time[i]%60;\\n          mp[a]++;\\n      }\\n      \\n      int ans=0;\\n      for(int i=1;i<=29;i++)\\n      {\\n          if(mp.find(i)!=mp.end()&&mp.find(60-i)!=mp.end())\\n          {\\n              ans+=mp[i]*mp[60-i];\\n          }\\n      }\\n      if(mp.find(0)!=mp.end())\\n      {\\n         ans+=mp[0]*(mp[0]-1)/2;  \\n      }  \\n      if(mp.find(30)!=mp.end())\\n      {\\n         ans+=mp[30]*(mp[30]-1)/2;  \\n      }\\n      return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1210861,
                "title": "java-simple-two-pass-solution-beats-99-85",
                "content": "*Please upvote if you found this post helpful.*\\n\\nFor people who are questioning if we can solve this problem without knowing the property mentioned in the solution, \\nYes, we can. I only observed the pattern in the problem and came up with the following solution.\\n\\nIntuition:\\n\\n* Store the remainders in an array or hashmap. Hashmap takes more processing time compared to an array and since the size of the array in our case is limited (=60), array is the better option.\\n* Once we iterate through the given `time` array once, we will have all the remainders.\\n* Iterate over the remainder array to calculate the result. \\n* We have 2 scenarios here.\\n\\t* The remainder is 0 or 30.\\n\\t* The remainder is any other value.\\n* If the remainder is 0 or 30, we basically have to see how many combinations can be formed from the remainder values. I observed that is an arithmetic series 1+2+3+..n = n(n-1)/2.\\n* If the remainder is not 0 or 30, we take the two sum approach and multiply (i.e) see if the `60 - x` value is availble where `x` is the remainder value.\\n\\n\\nCode:\\n```\\nclass Solution {\\n    \\n    public int series(int n){\\n        return n * (n - 1) / 2;\\n    }\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] arr = new int[60];\\n        \\n        for(int i : time){\\n            arr[i % 60]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 60; i++){\\n            if(arr[i] > 0){\\n                if(i == 0 || i == 30) ans += series(arr[i]);\\n                else if(arr[60 - i] > 0){\\n                    ans += arr[i] * arr[60 - i];\\n                    arr[i] = 0;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int series(int n){\\n        return n * (n - 1) / 2;\\n    }\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] arr = new int[60];\\n        \\n        for(int i : time){\\n            arr[i % 60]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 60; i++){\\n            if(arr[i] > 0){\\n                if(i == 0 || i == 30) ans += series(arr[i]);\\n                else if(arr[60 - i] > 0){\\n                    ans += arr[i] * arr[60 - i];\\n                    arr[i] = 0;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079583,
                "title": "python-remember-how-much-off-60-we-are",
                "content": "We only need to count the matching pairs, so in remains array we save the number of elements that are off being a multiple of 60 by the amount that is the index:\\n```\\ndef numPairsDivisibleBy60(self, time: List[int]) -> int:\\n\\tremains = [0] * 60\\n\\ttotal = 0\\n\\tfor t in time:\\n\\t\\tneed = t % 60\\n\\t\\ttotal += remains[-need % 60]  # equivalent to (60 - need) % 60\\n\\t\\tremains[need] += 1\\n\\treturn total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numPairsDivisibleBy60(self, time: List[int]) -> int:\\n\\tremains = [0] * 60\\n\\ttotal = 0\\n\\tfor t in time:\\n\\t\\tneed = t % 60\\n\\t\\ttotal += remains[-need % 60]  # equivalent to (60 - need) % 60\\n\\t\\tremains[need] += 1\\n\\treturn total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 966625,
                "title": "c-easy-implementation-using-map-time-o-n-space-o-1",
                "content": "```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n        int count = 0;\\n        unordered_map<int, int> lookup; // maximum 60 key/value pairs will be there so constant space.\\n        for(int i = 0; i < time.size(); i++) {\\n            int curr = time[i]%60;\\n            if(lookup.find(60 - curr) != lookup.end()) {\\n                count += lookup[60 - curr];\\n            }\\n            if(curr == 0) {\\n                lookup[60 - curr]++;\\n            } else {\\n                lookup[curr]++;  \\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n        int count = 0;\\n        unordered_map<int, int> lookup; // maximum 60 key/value pairs will be there so constant space.\\n        for(int i = 0; i < time.size(); i++) {\\n            int curr = time[i]%60;\\n            if(lookup.find(60 - curr) != lookup.end()) {\\n                count += lookup[60 - curr];\\n            }\\n            if(curr == 0) {\\n                lookup[60 - curr]++;\\n            } else {\\n                lookup[curr]++;  \\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 965670,
                "title": "java-hashing",
                "content": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] a) {\\n        \\n        int c[] = new int[60];\\n        for(int i=0;i<60;i++)\\n            c[i] = 0;\\n        int count = 0;\\n        \\n        for(int i:a){\\n            int l = i%60;\\n            c[l]++;\\n            if(l==30 || l==0)\\n                count += c[l]-1;\\n            else\\n                count += c[60-l];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] a) {\\n        \\n        int c[] = new int[60];\\n        for(int i=0;i<60;i++)\\n            c[i] = 0;\\n        int count = 0;\\n        \\n        for(int i:a){\\n            int l = i%60;\\n            c[l]++;\\n            if(l==30 || l==0)\\n                count += c[l]-1;\\n            else\\n                count += c[60-l];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965404,
                "title": "python-3-use-hashmap-like-2sum-o-n-time-and-space",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n\\t\\t# note each song <= 500, total <= 1000\\n        totals = list(range(60, 1001, 60))\\n        \\n        counts = Counter()\\n        res = 0\\n        for t in time: \\n            for total in totals:\\n                diff = total - t\\n                if diff > 0 and diff in counts: \\n                    res += counts[diff]\\n                \\n            counts[t] += 1\\n            \\n        return res\\n```\\n\\nanother version using mod. But I like the first version more as it is more straightforward\\n\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n        res = 0\\n        counts = Counter()\\n        for t in time: \\n            mod = t % 60\\n            if mod == 0: \\n                if 0 in counts:\\n                    res += counts[0]\\n            else:\\n                if 60 - mod in counts:\\n                    res += counts[60 - mod]\\n            \\n            counts[mod] += 1\\n        \\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n\\t\\t# note each song <= 500, total <= 1000\\n        totals = list(range(60, 1001, 60))\\n        \\n        counts = Counter()\\n        res = 0\\n        for t in time: \\n            for total in totals:\\n                diff = total - t\\n                if diff > 0 and diff in counts: \\n                    res += counts[diff]\\n                \\n            counts[t] += 1\\n            \\n        return res\\n```\n```\\nfrom collections import Counter\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n        res = 0\\n        counts = Counter()\\n        for t in time: \\n            mod = t % 60\\n            if mod == 0: \\n                if 0 in counts:\\n                    res += counts[0]\\n            else:\\n                if 60 - mod in counts:\\n                    res += counts[60 - mod]\\n            \\n            counts[mod] += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965050,
                "title": "c-simple-solution-beats-97",
                "content": "Runtime: 116 ms, faster than 97.09% of C# online submissions for Pairs of Songs With Total Durations Divisible by 60.\\nMemory Usage: 32.9 MB, less than 76.36% of C# online submissions for Pairs of Songs With Total Durations Divisible by 60.\\n```\\npublic class Solution\\n{\\n    int[] dict = new int[60];\\n\\n    public int NumPairsDivisibleBy60(int[] time)\\n    {\\n        int res = 0;\\n\\n        foreach(var t in time)\\n        {\\n            res += dict[(60 - t % 60) % 60];  //count number of matching modulus in visited values\\n            dict[t % 60]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    int[] dict = new int[60];\\n\\n    public int NumPairsDivisibleBy60(int[] time)\\n    {\\n        int res = 0;\\n\\n        foreach(var t in time)\\n        {\\n            res += dict[(60 - t % 60) % 60];  //count number of matching modulus in visited values\\n            dict[t % 60]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964948,
                "title": "c-python-two-sum-with-remnant-flavor",
                "content": "We use an array to count occurrences of number % 60. For each number t, we add the count of complimenting numbers (60 - t % 60) % 60 to the result [1].\\n\\n```\\nSolution 1: \\nclass Solution { // Brute force, and will cause TLE error\\npublic: // Time/Space: O(N^2); O(1)\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int ans = 0;\\n        for(int i = 0, n = time.size(); i < n; i++)\\n            for(int j = i + 1; j < n; j++)\\n                if( (time[i] + time[j] )% 60== 0 ) ans++;\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nSolution 2: \\n```\\nclass Solution { //two-sum\\npublic: // Time/Space: O(N); O(1)\\n    int numPairsDivisibleBy60(vector<int>& time, int res = 0) {\\n        vector<int> m(60);\\n        for (auto t : time) {\\n            res += m[(60 - t % 60) % 60]; // current remnant: t%60; the desired partner:  60 -  t%60\\n            ++m[t % 60];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\nPython:\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        m=[0]*60\\n        res = 0\\n        for t in time:\\n            res += m[(60 - t % 60) % 60]\\n            m[t % 60] += 1\\n        return res\\n```\\nReferecence:\\n[1] https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/discuss/256722/C%2B%2B-5-lines-two-sum",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nSolution 1: \\nclass Solution { // Brute force, and will cause TLE error\\npublic: // Time/Space: O(N^2); O(1)\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int ans = 0;\\n        for(int i = 0, n = time.size(); i < n; i++)\\n            for(int j = i + 1; j < n; j++)\\n                if( (time[i] + time[j] )% 60== 0 ) ans++;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution { //two-sum\\npublic: // Time/Space: O(N); O(1)\\n    int numPairsDivisibleBy60(vector<int>& time, int res = 0) {\\n        vector<int> m(60);\\n        for (auto t : time) {\\n            res += m[(60 - t % 60) % 60]; // current remnant: t%60; the desired partner:  60 -  t%60\\n            ++m[t % 60];\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        m=[0]*60\\n        res = 0\\n        for t in time:\\n            res += m[(60 - t % 60) % 60]\\n            m[t % 60] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964936,
                "title": "c-100-time-and-space-simple-solution",
                "content": "My C++ one pass solution using an array to store the remainders of up to 60 for each element \\n\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        // initialise result and an array of size 60 we will use to store the remainder of each element we have met in the for loop\\n        int result = 0, m[60] = {0};\\n        \\n        // iterate through the list of numbers solving in one pass\\n        for (int i = 0; i < time.size(); ++i) {\\n            // increment the result by the number of remainders we have met till now which match the condition of being divisble by 60\\n            result += m[(600 - time[i]) % 60];\\n            \\n            // increment in the array the remainder of the current time[i] by one\\n            m[time[i] % 60]++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        // initialise result and an array of size 60 we will use to store the remainder of each element we have met in the for loop\\n        int result = 0, m[60] = {0};\\n        \\n        // iterate through the list of numbers solving in one pass\\n        for (int i = 0; i < time.size(); ++i) {\\n            // increment the result by the number of remainders we have met till now which match the condition of being divisble by 60\\n            result += m[(600 - time[i]) % 60];\\n            \\n            // increment in the array the remainder of the current time[i] by one\\n            m[time[i] % 60]++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964774,
                "title": "python-3-simple-math",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time) -> int:\\n        \"\"\"\\n        Given an array of song times, this program determines\\n        the number of pairs of songs whose total time is divisible\\n        by 60.\\n\\n        :param time: array of song times\\n        :type time: list[int]\\n        :return: number of pairs of songs whose total time is\\n                 divisible by 60\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Create song_times, an array of buckets, one for each\\n        song time modulo 60. Each bucket value is equal to the\\n        number of songs whose time modulo 60 is the same as the\\n        bucket index.  Generate the bucket values from the given\\n        array time.\\n        \"\"\"\\n        song_times = [0 for _ in range(60)]\\n        for song in time:\\n            song_times[song % 60] += 1\\n\\n        \"\"\"\\n        Determine the number of pairs of songs whose total time\\n        is divisible by 60.\\n        - Buckets 0 and 30 are special cases because the bucket\\n          values of both songs in a pair are taken from the same\\n          bucket.\\n        - Bucket values for songs whose time modulo 60 is in\\n          the range of 1 through 29 are taken from different\\n          buckets.\\n        \"\"\"\\n        answer = 0\\n        for k in [0, 30]:\\n            answer += song_times[k] * (song_times[k] - 1) // 2\\n        for k in range(1, 30):\\n            answer += song_times[k] * song_times[60 - k]\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time) -> int:\\n        \"\"\"\\n        Given an array of song times, this program determines\\n        the number of pairs of songs whose total time is divisible\\n        by 60.\\n\\n        :param time: array of song times\\n        :type time: list[int]\\n        :return: number of pairs of songs whose total time is\\n                 divisible by 60\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Create song_times, an array of buckets, one for each\\n        song time modulo 60. Each bucket value is equal to the\\n        number of songs whose time modulo 60 is the same as the\\n        bucket index.  Generate the bucket values from the given\\n        array time.\\n        \"\"\"\\n        song_times = [0 for _ in range(60)]\\n        for song in time:\\n            song_times[song % 60] += 1\\n\\n        \"\"\"\\n        Determine the number of pairs of songs whose total time\\n        is divisible by 60.\\n        - Buckets 0 and 30 are special cases because the bucket\\n          values of both songs in a pair are taken from the same\\n          bucket.\\n        - Bucket values for songs whose time modulo 60 is in\\n          the range of 1 through 29 are taken from different\\n          buckets.\\n        \"\"\"\\n        answer = 0\\n        for k in [0, 30]:\\n            answer += song_times[k] * (song_times[k] - 1) // 2\\n        for k in range(1, 30):\\n            answer += song_times[k] * song_times[60 - k]\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914788,
                "title": "java-concise-solution-raghav-soni",
                "content": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] map = new int[60];\\n        int result = 0;\\n        \\n        for(int curr: time){\\n            curr = curr % 60;\\n            result += curr == 0 ? map[0] : map[60 - curr];\\n            // or \\n            // result += map[(60 - curr) % 60];\\n            map[curr]++;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] map = new int[60];\\n        int result = 0;\\n        \\n        for(int curr: time){\\n            curr = curr % 60;\\n            result += curr == 0 ? map[0] : map[60 - curr];\\n            // or \\n            // result += map[(60 - curr) % 60];\\n            map[curr]++;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772009,
                "title": "clumsy-solution",
                "content": "```\\nint numPairsDivisibleBy60(vector<int>& t) \\n{\\n\\tint out{0};\\n\\tint m[60] = {0};\\n\\tfor(const auto i : t) m[i%60]++;\\n\\n\\tfor(int i{1}; i<30; ++i) out += m[i] * m[60-i];\\n\\n\\tout += (m[0] * (m[0]-1))/2 + (m[30] * (m[30]-1))/2;\\n\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numPairsDivisibleBy60(vector<int>& t) \\n{\\n\\tint out{0};\\n\\tint m[60] = {0};\\n\\tfor(const auto i : t) m[i%60]++;\\n\\n\\tfor(int i{1}; i<30; ++i) out += m[i] * m[60-i];\\n\\n\\tout += (m[0] * (m[0]-1))/2 + (m[30] * (m[30]-1))/2;\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539322,
                "title": "c-faster-than-84-93-less-than-100-mem-o-n",
                "content": "Runtime: 120 ms\\nMemory Usage: 32.2 MB\\n\\n```\\n    public int NumPairsDivisibleBy60(int[] time) {\\n        int count = 0;       \\n        int mod = 0;\\n        int[] lookup = new int[60];\\n        \\n        for(int i=0; i<time.Length; i++)\\n        {\\n           mod = time[i] % 60;             \\n           count += lookup[(mod == 0)? 0 : 60-mod];  \\n           lookup[mod]++;\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 120 ms\\nMemory Usage: 32.2 MB\\n\\n```\\n    public int NumPairsDivisibleBy60(int[] time) {\\n        int count = 0;       \\n        int mod = 0;\\n        int[] lookup = new int[60];\\n        \\n        for(int i=0; i<time.Length; i++)\\n        {\\n           mod = time[i] % 60;             \\n           count += lookup[(mod == 0)? 0 : 60-mod];  \\n           lookup[mod]++;\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 460329,
                "title": "simple-java-solution",
                "content": "```\\npublic int numPairsDivisibleBy60(int[] time) {\\n        int[] m = new int[60];\\n        \\n\\t\\t// get mods\\n        for(int i = 0; i < time.length; i++){\\n            m[time[i] % 60]++;\\n        }\\n        \\n\\t\\t// check for mod 0 and mod 30\\n        int num = (m[0]*(m[0]-1))/2;\\n         num = num + (m[30]*(m[30]-1))/2;\\n\\t\\t\\n\\t\\t// check complements \\n        int i = 1;\\n        int j = 59;\\n        while(i<j){\\n            num = num + (m[i]*m[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numPairsDivisibleBy60(int[] time) {\\n        int[] m = new int[60];\\n        \\n\\t\\t// get mods\\n        for(int i = 0; i < time.length; i++){\\n            m[time[i] % 60]++;\\n        }\\n        \\n\\t\\t// check for mod 0 and mod 30\\n        int num = (m[0]*(m[0]-1))/2;\\n         num = num + (m[30]*(m[30]-1))/2;\\n\\t\\t\\n\\t\\t// check complements \\n        int i = 1;\\n        int j = 59;\\n        while(i<j){\\n            num = num + (m[i]*m[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444378,
                "title": "javascript-o-n",
                "content": "```\\nvar numPairsDivisibleBy60 = function(nums) {\\n    let count = 0, map = new Map();\\n    \\n    for(let num of nums){\\n        let mod = num % 60;\\n        let sHalf = mod === 0 ? 0 : 60 - mod;\\n        \\n        \\n        if(map.has(sHalf)){\\n            count +=  map.get(sHalf)\\n        }\\n        \\n        if(map.has(mod)){\\n            map.set(mod, map.get(mod) + 1)\\n        } else {\\n            map.set(mod, 1)\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numPairsDivisibleBy60 = function(nums) {\\n    let count = 0, map = new Map();\\n    \\n    for(let num of nums){\\n        let mod = num % 60;\\n        let sHalf = mod === 0 ? 0 : 60 - mod;\\n        \\n        \\n        if(map.has(sHalf)){\\n            count +=  map.get(sHalf)\\n        }\\n        \\n        if(map.has(mod)){\\n            map.set(mod, map.get(mod) + 1)\\n        } else {\\n            map.set(mod, 1)\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391392,
                "title": "concise-9-line-python-solution-with-explanation-o-n",
                "content": "If ```X``` has a remainder (i.e., ```x % 60 = r```), then the only number that forms a pair with ```X ``` is a number whose mod with 60 was ```60 - r```. So using a counter array would be a wise choise here, a counter array that is bounded by 60, since our space is bounded by 60 (clock problem). The counter array keeps track of frequency of all the remainders that we have seen so far, and at first is filled with all with zeros. It is important keep in mind that there are no 0 second length songs.\\n\\n```\\ndef numPairsDivisibleBy60(self, time):\\n\\tcounter, res = [0] * 61, 0\\n\\tfor i in range(len(time)):\\n\\t\\tr = time[i] % 60\\n\\t\\tres += counter[60 - r]\\n\\t\\tif r == 0:\\n\\t\\t\\tcounter[60] += 1\\n\\t\\telse:\\n\\t\\t\\tcounter[r] += 1\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```X```\n```x % 60 = r```\n```X ```\n```60 - r```\n```\\ndef numPairsDivisibleBy60(self, time):\\n\\tcounter, res = [0] * 61, 0\\n\\tfor i in range(len(time)):\\n\\t\\tr = time[i] % 60\\n\\t\\tres += counter[60 - r]\\n\\t\\tif r == 0:\\n\\t\\t\\tcounter[60] += 1\\n\\t\\telse:\\n\\t\\t\\tcounter[r] += 1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 373723,
                "title": "easy-c-sol-with-explanation-beats-93-100",
                "content": "**Hash solution**\\n\\nWhat do we know?\\nThere are two elements where (x + y)%60 == 0;\\n\\nSo for every element, we need to find 60 - x%60 in the hash, and add the count to the result.\\nFor every new element, we need to find the extra when divided by 60, hence %60. \\nThen find if the extra can be found in the hash(more importantly an element whose i < j so already is added to the hash).\\n\\n```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n        \\n        int res = 0;\\n        vector<int> mp(60,0);\\n        \\n        for(int t : time)\\n        {\\n            t = t%60;\\n            int diff = 60 - t;\\n            \\n            if(diff == 60)\\n                diff = 0;\\n            res += mp[diff];\\n            mp[t]++;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "**Hash solution**\\n\\nWhat do we know?\\nThere are two elements where (x + y)%60 == 0;\\n\\nSo for every element, we need to find 60 - x%60 in the hash, and add the count to the result.\\nFor every new element, we need to find the extra when divided by 60, hence %60. \\nThen find if the extra can be found in the hash(more importantly an element whose i < j so already is added to the hash).\\n\\n```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n        \\n        int res = 0;\\n        vector<int> mp(60,0);\\n        \\n        for(int t : time)\\n        {\\n            t = t%60;\\n            int diff = 60 - t;\\n            \\n            if(diff == 60)\\n                diff = 0;\\n            res += mp[diff];\\n            mp[t]++;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 310765,
                "title": "python-o-n-using-counter",
                "content": "```\\ndef numPairsDivisibleBy60(self, time: List[int]) -> int:\\n\\tfrom collections import Counter\\n\\tc, res = Counter([t%60 for t in time]), 0\\n    for k in c:\\n\\t\\tif k == 0 or k == 30:\\n\\t\\t\\tres += c[k] * (c[k]-1) // 2\\n\\t\\telif k < 30:\\n\\t\\t\\tres += c[k] * c[60-k]\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndef numPairsDivisibleBy60(self, time: List[int]) -> int:\\n\\tfrom collections import Counter\\n\\tc, res = Counter([t%60 for t in time]), 0\\n    for k in c:\\n\\t\\tif k == 0 or k == 30:\\n\\t\\t\\tres += c[k] * (c[k]-1) // 2\\n\\t\\telif k < 30:\\n\\t\\t\\tres += c[k] * c[60-k]\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 258648,
                "title": "simple-python-solution-with-some-comments",
                "content": "```\\nimport collections\\n\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        if len(time) ==0:\\n            return 0\\n        \\n        remain = collections.defaultdict(list)\\n        count = 0\\n        \\n        for t in time:\\n            key = t % 60\\n            com_key = (60 - key) % 60 # Complementary key\\n            \\n            if com_key in remain:\\n                count += len(remain[com_key]) # because the elements in complementary list must have smaller indices, so we can count all of them\\n                \\n            remain[key].append(t)\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        if len(time) ==0:\\n            return 0\\n        \\n        remain = collections.defaultdict(list)\\n        count = 0\\n        \\n        for t in time:\\n            key = t % 60\\n            com_key = (60 - key) % 60 # Complementary key\\n            \\n            if com_key in remain:\\n                count += len(remain[com_key]) # because the elements in complementary list must have smaller indices, so we can count all of them\\n                \\n            remain[key].append(t)\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257629,
                "title": "python-5-lines-array-solution",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        mod = [0] * 61\\n        for t in time:\\n            mod[-1] += mod[(60 - t % 60) % 60]\\n            mod[t % 60] += 1\\n        return mod[-1]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        mod = [0] * 61\\n        for t in time:\\n            mod[-1] += mod[(60 - t % 60) % 60]\\n            mod[t % 60] += 1\\n        return mod[-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646963,
                "title": "python-hashmap-o-n-time-and-space-80-t-75-s",
                "content": "We only need to consider song length modulo 60. \\n\\nFor every pair(a, b) we know a + b should = 60 to count as valid. \\nSolving for a, we get 60 - b which we can hash and use to check against the rest of the array to generate the number of valid pairs.\\n\\nTo handle the case where pair(a % 60 = 0, b % 60 = 0) ex. (60,120), we add up the # of sixty\\'s or numbers perfectly divisible and \\nperform an n choose k operation where k = 2 and n = # of sixty\\'s or numbers perfectly divisible.\\n\\n*n choose k = (C(n,k)) ways to choose an (unordered) subset of k elements from a fixed set of n elements.\\n\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        reverseMap = {}\\n        count = 0\\n        sixtyCount = 0\\n        \\n        for song in time:\\n            index = 60 - song % 60\\n\\n            if(song % 60 == 0):\\n                sixtyCount += 1\\n                continue\\n                \\n            if(song % 60 in reverseMap):\\n                count += reverseMap[song % 60]\\n            \\n            if(index in reverseMap):\\n                reverseMap[index] += 1\\n            else:\\n                reverseMap[index] = 1\\n        \\n        # n choose 2 where n = # songs perfectly divisible by 60\\n        return count + comb(sixtyCount, 2)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        reverseMap = {}",
                "codeTag": "Java"
            },
            {
                "id": 3038632,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n         int count=0;\\n        vector<int>v(60,0);\\n        for(int i=0;i<time.size();i++)\\n        {\\n            int a=time[i]%60;\\n            if(a==0)\\n                count+=v[0];\\n            else\\n                count+=v[60-a];\\n            v[a]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n         int count=0;\\n        vector<int>v(60,0);\\n        for(int i=0;i<time.size();i++)\\n        {\\n            int a=time[i]%60;\\n            if(a==0)\\n                count+=v[0];\\n            else\\n                count+=v[60-a];\\n            v[a]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907937,
                "title": "concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, long long> m;\\n        for(int i : time) m[i % 60]++;\\n\\n        long long ans = 0, i = 1, j = 59;\\n        if(m[0] > 1) ans += (m[0] * (m[0] - 1)) / 2;\\n        if(m[30] > 1) ans += (m[30] * (m[30] - 1)) / 2;\\n        while(i < j) {\\n            if(m[i] && m[j]) ans += m[i] * m[j];\\n            i++, j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, long long> m;\\n        for(int i : time) m[i % 60]++;\\n\\n        long long ans = 0, i = 1, j = 59;\\n        if(m[0] > 1) ans += (m[0] * (m[0] - 1)) / 2;\\n        if(m[30] > 1) ans += (m[30] * (m[30] - 1)) / 2;\\n        while(i < j) {\\n            if(m[i] && m[j]) ans += m[i] * m[j];\\n            i++, j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566047,
                "title": "easy-java-solution-working",
                "content": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {  \\n        int count =0;\\n        int[] arr = new int[60];\\n        Arrays.fill(arr,0);\\n        \\n        for(int i=0;i<time.length;i++){\\n            int r = time[i]%60;\\n            if(r==0){\\n                arr[0]++;\\n                count+= arr[0] -1;\\n            }else if(arr[60-r] > 0){ // 1+59\\n                count+= arr[60-r];\\n                arr[r]++;\\n            }else{\\n                arr[r]++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n\\ndifferent approch below\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {  \\n        int count =0;\\n        int[] arr = new int[60];\\n        Arrays.fill(arr,0);\\n        for(int i=0;i<time.length;i++){\\n            int r = time[i]%60;\\n            arr[r]++;\\n        }\\n        \\n        // for 0 and 30 \\n        if(arr[30] >1){\\n            count += arr[30] * (arr[30] - 1) /2;\\n        }\\n        \\n        if(arr[0] >1){\\n            if(arr[0] %2 == 0){\\n                int c = arr[0]/2;\\n                int d = c * (arr[0] - 1);\\n                count += d;\\n            }else{\\n                int c = (arr[0] - 1)/2;\\n                int d = c * arr[0];\\n                count += d;\\n            }\\n        }\\n        // for 1 to 29\\n        for(int i=1;i<30;i++){\\n            count += arr[i] * arr[60-i];\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\ngive some thumb up for this.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {  \\n        int count =0;\\n        int[] arr = new int[60];\\n        Arrays.fill(arr,0);\\n        \\n        for(int i=0;i<time.length;i++){\\n            int r = time[i]%60;\\n            if(r==0){\\n                arr[0]++;\\n                count+= arr[0] -1;\\n            }else if(arr[60-r] > 0){ // 1+59\\n                count+= arr[60-r];\\n                arr[r]++;\\n            }else{\\n                arr[r]++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {  \\n        int count =0;\\n        int[] arr = new int[60];\\n        Arrays.fill(arr,0);\\n        for(int i=0;i<time.length;i++){\\n            int r = time[i]%60;\\n            arr[r]++;\\n        }\\n        \\n        // for 0 and 30 \\n        if(arr[30] >1){\\n            count += arr[30] * (arr[30] - 1) /2;\\n        }\\n        \\n        if(arr[0] >1){\\n            if(arr[0] %2 == 0){\\n                int c = arr[0]/2;\\n                int d = c * (arr[0] - 1);\\n                count += d;\\n            }else{\\n                int c = (arr[0] - 1)/2;\\n                int d = c * arr[0];\\n                count += d;\\n            }\\n        }\\n        // for 1 to 29\\n        for(int i=1;i<30;i++){\\n            count += arr[i] * arr[60-i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389437,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n=time.size();\\n        unordered_map<int,int>mp;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find((60-(time[i]%60))%60)!=mp.end())\\n            {\\n                count+=mp[(60-(time[i]%60))%60];\\n            } \\n            mp[time[i]%60]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n=time.size();\\n        unordered_map<int,int>mp;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find((60-(time[i]%60))%60)!=mp.end())\\n            {\\n                count+=mp[(60-(time[i]%60))%60];\\n            } \\n            mp[time[i]%60]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317605,
                "title": "python-simple-hashmap",
                "content": "\\n    def numPairsDivisibleBy60(self, time):\\n        dict1, total = Counter([i%60 for i in time]), 0\\n        \\n        for i in range(31):\\n            if i == 0 or i == 30:\\n                total += dict1[i]*(dict1[i] - 1)//2\\n            else:\\n                total += dict1[i]*dict1[60-i]\\n        \\n        return total",
                "solutionTags": [],
                "code": "\\n    def numPairsDivisibleBy60(self, time):\\n        dict1, total = Counter([i%60 for i in time]), 0\\n        \\n        for i in range(31):\\n            if i == 0 or i == 30:\\n                total += dict1[i]*(dict1[i] - 1)//2\\n            else:\\n                total += dict1[i]*dict1[60-i]\\n        \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 2105897,
                "title": "java-easy-hashmap-solution",
                "content": "class Solution {\\n\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int ans=0;    \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i:time){\\n            int ref=i%60;\\n            int main=60-ref;\\n            if(map.containsKey(main)){\\n               ans+=map.get(main);     \\n            }\\n            if(ref==0){\\n               map.put(60,map.getOrDefault(60,0)+1);     \\n            }\\n               else{ \\n                 map.put(ref,map.getOrDefault(ref,0)+1);\\n               }\\n        } \\n            return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int ans=0;    \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i:time){\\n            int ref=i%60;\\n            int main=60-ref;\\n            if(map.containsKey(main)){\\n               ans+=map.get(main);     \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2004218,
                "title": "python-sol-hashmap-mod-intution-explained-approach-explained",
                "content": "# EXPLANATION\\n\\n```\\nTo solve such questions when we need to find number of pairs such that sum of multiply anything is divisible by any number the solution is -> HASHMAP + MOD\\n\\nSay we have a number 100 and another 140\\n100 is 60 + 40 , so to be divisible by 60 it needs number which will be 60x + 20\\nsuch that total = 60(x+1) + 40 + 20 = 60(x+2)\\n\\n140 = 60 + 60 + 20 \\nSo as 100 will require a number whose mod is 60 - 100%60 i.e. 20\\n100 + 140 = 240 which is divisible by 60\\n```\\n\\n\\n# CODE\\n\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        map = defaultdict(int)\\n        ans = 0\\n        for t in time:\\n            if t % 60 == 0:\\n                t = 60\\n                ans += map[60]\\n            else:\\n                t = t % 60\\n                ans += map[60-t]\\n            map[t] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nTo solve such questions when we need to find number of pairs such that sum of multiply anything is divisible by any number the solution is -> HASHMAP + MOD\\n\\nSay we have a number 100 and another 140\\n100 is 60 + 40 , so to be divisible by 60 it needs number which will be 60x + 20\\nsuch that total = 60(x+1) + 40 + 20 = 60(x+2)\\n\\n140 = 60 + 60 + 20 \\nSo as 100 will require a number whose mod is 60 - 100%60 i.e. 20\\n100 + 140 = 240 which is divisible by 60\\n```\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        map = defaultdict(int)\\n        ans = 0\\n        for t in time:\\n            if t % 60 == 0:\\n                t = 60\\n                ans += map[60]\\n            else:\\n                t = t % 60\\n                ans += map[60-t]\\n            map[t] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894923,
                "title": "python-solution-hashmap-faster-than-75-45",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        d={}\\n        ans=0\\n        for i in time:\\n            t=i%60\\n            if t==0:\\n                if t in d:\\n                    ans+=d[0]\\n            elif (60-t) in d:\\n                ans+=d[60-t]\\n            if t in d:\\n                d[t]+=1\\n            else:\\n                d[t]=1\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        d={}",
                "codeTag": "Java"
            },
            {
                "id": 1715362,
                "title": "python-easy-solution-o-n",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, s: List[int]) -> int:\\n        count = 0\\n\\n        m = [0] * 60\\n        for i in range(len(s)):\\n            s[i] = s[i] % 60\\n            m[s[i]]+=1\\n\\n        count+=((m[0]-1)*m[0])/2 # 0 and 30 make pair with themself so the number of pair = (n-1)*n/2\\n        count+=((m[30]-1)*m[30])/2\\n\\n        for i in range(1, 30):  # iterating over half of the value, other values are its mirror value\\n            count+=m[i] * m[60-i]\\n\\n\\n        return int(count)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, s: List[int]) -> int:\\n        count = 0\\n\\n        m = [0] * 60\\n        for i in range(len(s)):\\n            s[i] = s[i] % 60\\n            m[s[i]]+=1\\n\\n        count+=((m[0]-1)*m[0])/2 # 0 and 30 make pair with themself so the number of pair = (n-1)*n/2\\n        count+=((m[30]-1)*m[30])/2\\n\\n        for i in range(1, 30):  # iterating over half of the value, other values are its mirror value\\n            count+=m[i] * m[60-i]\\n\\n\\n        return int(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664822,
                "title": "java-solution-o-n-with-simple-modulo-reminder-approach",
                "content": "To make a pair , both the elements modulus should leave reminder 0 on adding.\\n\\nSo, If 1st element leaves reminder **X** and 2nd element of pair leaves reminder **Y** thn in order to be a valid pair it must satisfy **Y = 60-X** ;\\n\\nSuppose, We have a pair **[140,220]**,\\n\\nThen there reminder with 60 will be **[20,40]**\\n\\nClearly, if X = 20 and Y = 40 , then to be a valid Pair with  **Y** should equal to **60-X** i.e **60-20** i.e **40** which makes up a valid pair.\\n\\nWe are increasing the pair ans only if we get  compliment modulo for that number.\\n\\nAlso, in case the reminder is 0 that means the number is fully divisible by 60 which means the no. of elements having reminder 0 will add up to ans on each founding and the freq will increase by 1. \\nThus, if we got 3 elements with reminder as 0 , thn the total Pairs will be 2+1 \\nEg: if we have [60, 120, 80] then, the valid pairs will be \\n[60,120],\\n[60,180],\\n[120,180]\\ngiving as as 2 + 1 + 0 i.e 3 pairs.\\n\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] rem = new int[60];\\n        int count = 0 ;\\n        for(int i = 0 ; i < time.length ; i++){\\n            \\n            int mod = time[i] % 60 ; // checking for compliment wrt 60\\n            \\n            if(mod == 0){\\n                count += rem[0]; // if mod = 0, just adding the present frequency in count and increasing the freqeucy at that index after this if-statment\\n            } \\n            else {\\n                count += rem[60-mod]; // Adding count with valid compliment number in compliment pair index\\n            }\\n            rem[mod]++ ; // freq must increase in both the above cases irrespective of value of mod\\n            \\n        }\\n        return count ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] rem = new int[60];\\n        int count = 0 ;\\n        for(int i = 0 ; i < time.length ; i++){\\n            \\n            int mod = time[i] % 60 ; // checking for compliment wrt 60\\n            \\n            if(mod == 0){\\n                count += rem[0]; // if mod = 0, just adding the present frequency in count and increasing the freqeucy at that index after this if-statment\\n            } \\n            else {\\n                count += rem[60-mod]; // Adding count with valid compliment number in compliment pair index\\n            }\\n            rem[mod]++ ; // freq must increase in both the above cases irrespective of value of mod\\n            \\n        }\\n        return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664300,
                "title": "who-sum-what-sum-two-sum",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n        d = {}\\n        count = 0\\n        for i in range(len(time)):\\n            query = 0 if time[i] % 60 == 0 else 60 - time[i] % 60\\n            store = time[i] % 60\\n            count += d.get(query, 0)\\n            d[store] = d.get(store, 0) + 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        \\n        d = {}\\n        count = 0\\n        for i in range(len(time)):\\n            query = 0 if time[i] % 60 == 0 else 60 - time[i] % 60\\n            store = time[i] % 60\\n            count += d.get(query, 0)\\n            d[store] = d.get(store, 0) + 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662747,
                "title": "java-easy-to-digest",
                "content": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> hm = new HashMap<>();\\n        int pairs = 0;\\n        \\n        for (int i: time) {\\n            int actual = i % 60;\\n            int needed = (60 - actual) % 60; // Mod 60, because if actual is already divisible by 60 then needed must be 0, not 60.\\n            \\n            if (hm.containsKey(needed)) {\\n                pairs += hm.get(needed);\\n            }\\n            hm.put(actual, hm.getOrDefault(actual, 0) + 1);\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> hm = new HashMap<>();\\n        int pairs = 0;\\n        \\n        for (int i: time) {\\n            int actual = i % 60;\\n            int needed = (60 - actual) % 60; // Mod 60, because if actual is already divisible by 60 then needed must be 0, not 60.\\n            \\n            if (hm.containsKey(needed)) {\\n                pairs += hm.get(needed);\\n            }\\n            hm.put(actual, hm.getOrDefault(actual, 0) + 1);\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661568,
                "title": "c-o-n-short-and-simple-solution",
                "content": "**simply do mod(%) and find the answer**\\n\\nclass Solution {\\npublic:\\n\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n = time.size();\\n        int total = 0;\\n        unordered_map<int , int>mp;\\n        \\n        for(int i = 0 ; i < time.size() ; i++){\\n            int val = time[i] % 60;\\n            int value = 60 - val;\\n            if(mp[value] > 0){\\n                total += mp[value];\\n            }\\n            if(val == 0){\\n                mp[60]++;\\n                continue;\\n            }\\n            mp[val]++;\\n        }\\n        \\n        return total;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n = time.size();\\n        int total = 0;\\n        unordered_map<int , int>mp;\\n        \\n        for(int i = 0 ; i < time.size() ; i++){\\n            int val = time[i] % 60;\\n            int value = 60 - val;\\n            if(mp[value] > 0){\\n                total += mp[value];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1661553,
                "title": "c-hash-table-detailed-explanation",
                "content": "**1010. Pairs of Songs With Total Durations Divisible by 60**\\n\\n**Hash Table**\\n\\n+ For each duration `x` of a song, we let `x = x % 60`, since `(x + y) % 60 == 0` is equivalent to `(x % 60) + (y % 60) == 60`.\\n+ Then, we scan each duration `x` from left to right. If `60 - x` is in the hash table, then we can get `table[60 - x]` such pairs.\\n+ Pay attention to the special case `x == 0`, since `60 - x = 60` can not exist in the hash table. In such case, we can get `table[0]` pairs.\\n\\t+ For example, `x = 120, y = 180`, and then `x %= 60` and `y %= 60` are both 0, but they can make a pair.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> table;\\n        int res = 0;\\n        for (int x : time) \\n        {\\n            x %= 60;\\n            if (table.count(60 - x)) \\n                res += table[60 - x];\\n            else if (x == 0)\\n                res += table[0];\\n            table[x]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> table;\\n        int res = 0;\\n        for (int x : time) \\n        {\\n            x %= 60;\\n            if (table.count(60 - x)) \\n                res += table[60 - x];\\n            else if (x == 0)\\n                res += table[0];\\n            table[x]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661442,
                "title": "rust-o-n",
                "content": "Simple mod operation using frequency array\\n\\n```\\n\\tpub fn num_pairs_divisible_by60(time: Vec<i32>) -> i32 {\\n        \\n        let mut freq = [0;61];\\n        let mut res = 0;\\n        \\n        for tim in time {\\n            let mut t = (tim % 60) as usize;\\n            res += freq[60 - t];\\n            if t == 0 {\\n                t = 60;\\n            }\\n            freq[t] += 1;\\n        }\\n        \\n        res\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\tpub fn num_pairs_divisible_by60(time: Vec<i32>) -> i32 {\\n        \\n        let mut freq = [0;61];\\n        let mut res = 0;\\n        \\n        for tim in time {\\n            let mut t = (tim % 60) as usize;\\n            res += freq[60 - t];\\n            if t == 0 {\\n                t = 60;\\n            }\\n            freq[t] += 1;\\n        }\\n        \\n        res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661355,
                "title": "c-different-methods-to-solve-the-problem-easy-understanding-brute-force-to-most-optimum",
                "content": "## Different methods to solve the problem-\\n1)**Brute force**: Time complexity  = O(n^2) and Space complexity = O(1)\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int count = 0;\\n        int n = time.size();\\n        for(int i = 0; i<n-1; i++){\\n            for(int j = i+1; j<n; j++){\\n                if((time[i] + time[j])%60 == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n2)**Optimum approach**: Use hash tables (can also use array/vector of size 60) and little bit maths. Time complexity = O(n) and space complexity = O(1)\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n = time.size();\\n        // Storing number of songs with the same remainder\\n        // after dividing the song length by 60\\n        unordered_map<int, int> rem;\\n        for(int i = 0; i<n; i++){\\n            rem[time[i]%60]++;\\n        }\\n        // Finding the count of song pairs which will be \\n        // divisible by 60\\n        int count = 0;\\n        for(int i = 0; i<=30; i++){\\n            if(i == 0 || i == 30){\\n                // Choosing all pairs out of songs which are \\n                // completely divisible on their OWN or in \\n                // pairs (use combinations)\\n                count+=(rem[i]*(rem[i]-1))/2; \\n            }\\n            else{\\n                // Taking all songs pair which are neither\\n                // completely divisible on their own or in \\n                // pairs (use permutations)\\n                count += rem[i]*rem[60-i];  \\n            } \\n        }\\n        return count;\\n    }\\n};\\n```\\n3)**Most optimum approach**: Time complexity = O(n) and space complexity = O(1)\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> v(60, 0);\\n        int count = 0;\\n        // For each song in the songs, we want another song\\n        // such that their sum of times is divisible by 60\\n        for(auto t: time){\\n            count += v[(60-(t%60))%60];\\n            v[t%60]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int count = 0;\\n        int n = time.size();\\n        for(int i = 0; i<n-1; i++){\\n            for(int j = i+1; j<n; j++){\\n                if((time[i] + time[j])%60 == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int n = time.size();\\n        // Storing number of songs with the same remainder\\n        // after dividing the song length by 60\\n        unordered_map<int, int> rem;\\n        for(int i = 0; i<n; i++){\\n            rem[time[i]%60]++;\\n        }\\n        // Finding the count of song pairs which will be \\n        // divisible by 60\\n        int count = 0;\\n        for(int i = 0; i<=30; i++){\\n            if(i == 0 || i == 30){\\n                // Choosing all pairs out of songs which are \\n                // completely divisible on their OWN or in \\n                // pairs (use combinations)\\n                count+=(rem[i]*(rem[i]-1))/2; \\n            }\\n            else{\\n                // Taking all songs pair which are neither\\n                // completely divisible on their own or in \\n                // pairs (use permutations)\\n                count += rem[i]*rem[60-i];  \\n            } \\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> v(60, 0);\\n        int count = 0;\\n        // For each song in the songs, we want another song\\n        // such that their sum of times is divisible by 60\\n        for(auto t: time){\\n            count += v[(60-(t%60))%60];\\n            v[t%60]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661324,
                "title": "two-sum-c",
                "content": "```\\n// 20%60 = 20 and 40%60 = 40  => (20+40)%60=0\\n// 160%60 = 40 and 140%60 = 20 => (40+20)%60=0\\n//Since we have to consider all the times[i] and times[j] i<j, so we will add the encountered counts of 60-times[index] and then \\n//increment the count for [times[index]%60].\\n//Eg- [60,60,60]\\n// arr = [0,0,0,0,0.......0] (size=60)\\n// ind = 0 => ans+= arr[(60-60)%60] => ans+=  arr[0], Since the value of arr[0] = 0 ,So ans=0 and we will add for current ind arr[60%60]++;\\n// ind = 1 => ans+=arr[(60-60)%60] = ans+=arr[0], Since the value of arr[0] =1, ans=1, we will add for current ind arr[60%60]++; => arr[0] becomes 2.\\n// Same for ind =2 , So ans becomes 1+ 2 = 3.\\n\\n\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int arr[60];\\n        memset(arr,0,sizeof(arr));\\n        int ans=0;\\n        for(int i=0;i<time.size();i++){\\n            ans+=arr[(60-(time[i]%60))%60];\\n            arr[time[i]%60]++;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// 20%60 = 20 and 40%60 = 40  => (20+40)%60=0\\n// 160%60 = 40 and 140%60 = 20 => (40+20)%60=0\\n//Since we have to consider all the times[i] and times[j] i<j, so we will add the encountered counts of 60-times[index] and then \\n//increment the count for [times[index]%60].\\n//Eg- [60,60,60]\\n// arr = [0,0,0,0,0.......0] (size=60)\\n// ind = 0 => ans+= arr[(60-60)%60] => ans+=  arr[0], Since the value of arr[0] = 0 ,So ans=0 and we will add for current ind arr[60%60]++;\\n// ind = 1 => ans+=arr[(60-60)%60] = ans+=arr[0], Since the value of arr[0] =1, ans=1, we will add for current ind arr[60%60]++; => arr[0] becomes 2.\\n// Same for ind =2 , So ans becomes 1+ 2 = 3.\\n\\n\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int arr[60];\\n        memset(arr,0,sizeof(arr));\\n        int ans=0;\\n        for(int i=0;i<time.size();i++){\\n            ans+=arr[(60-(time[i]%60))%60];\\n            arr[time[i]%60]++;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661075,
                "title": "java-solution-without-using-hashmap",
                "content": "\\tclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int arr[] = new int[61];\\n        int count = 0;\\n        for(int i=0; i<time.length; i++){\\n            count += arr[60 - (time[i] % 60)];\\n            arr[time[i] % 60]++; \\n        }\\n        \\n        count += (arr[0] * (arr[0]-1)) / 2;\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int arr[] = new int[61];\\n        int count = 0;\\n        for(int i=0; i<time.length; i++){\\n            count += arr[60 - (time[i] % 60)];\\n            arr[time[i] % 60]++; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1552358,
                "title": "easy-c",
                "content": "```\\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numPairsDivisibleBy60(vector<int>& time) {\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i=0; i<time.size(); i++){\\n\\t\\t\\t\\tint x = time[i] % 60;\\n\\t\\t\\t\\tint y = (60 - x) % 60;\\n\\t\\t\\t\\tans += mp[y];\\n\\t\\t\\t\\tmp[x]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n```\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262788,
                "title": "simple-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> vmap;\\n        int count = 0;\\n        for (int i = 0; i < time.size(); i++) {\\n            time[i] %= 60;\\n            if (time[i] == 0) count += vmap[0];\\n            else count += vmap[60 - time[i]];\\n            vmap[time[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> vmap;\\n        int count = 0;\\n        for (int i = 0; i < time.size(); i++) {\\n            time[i] %= 60;\\n            if (time[i] == 0) count += vmap[0];\\n            else count += vmap[60 - time[i]];\\n            vmap[time[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255526,
                "title": "c-solution-similar-to-two-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) \\n    {\\n        unordered_map<int, int>M;\\n        int count=0;\\n        \\n        for(auto &t:time)\\n        {\\n            t %= 60;\\n            if(t == 0)\\n                count += M[0];\\n            else\\n                count += M[60 - t];\\n            \\n            M[t]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) \\n    {\\n        unordered_map<int, int>M;\\n        int count=0;\\n        \\n        for(auto &t:time)\\n        {\\n            t %= 60;\\n            if(t == 0)\\n                count += M[0];\\n            else\\n                count += M[60 - t];\\n            \\n            M[t]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149947,
                "title": "c-three-approaches-bruteforce-unordered-map-vector-time-o-n-space-o-1",
                "content": "**Bruteforce - TLE**\\nTime: O (n^2)\\nSpace: O (1)\\n```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n\\tint count=0;\\n\\tfor (int i=0; i<time.size(); i++) {\\n\\t\\t\\tfor (int j=i+1; j<time.size(); j++) {\\n\\t\\t\\t\\t\\tif ((time[i] + time[j]) % 60 == 0) count++;\\n\\t\\t\\t}\\n\\t}\\nreturn count;\\n}\\n```\\n**Unordered_map**\\nTime: O (n)\\nSpace: O (n)\\n```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n\\tint count=0;\\n\\tunordered_map<int, int> umap;\\n\\tfor (int i=0; i<time.size(); i++) {\\n\\t\\t\\tif (time[i]%60==0) count+=umap[0];\\n\\t\\t\\telse count+=umap[60-time[i]%60];\\n\\t\\t\\tumap[time[i]%60]++;\\n\\t}\\nreturn count;\\n}\\n```\\n**Vector/Array**\\nTime: O (n)\\nSpace: O (1)\\n```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n\\tint count=0;\\n\\tvector<int> umap(60, 0);\\n\\tfor (int i=0; i<time.size(); i++) {\\n\\t\\t\\tif (time[i]%60==0) count+=umap[0];\\n\\t\\t\\telse count+=umap[60-time[i]%60];\\n\\t\\t\\tumap[time[i]%60]++;\\n\\t}\\nreturn count;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n\\tint count=0;\\n\\tfor (int i=0; i<time.size(); i++) {\\n\\t\\t\\tfor (int j=i+1; j<time.size(); j++) {\\n\\t\\t\\t\\t\\tif ((time[i] + time[j]) % 60 == 0) count++;\\n\\t\\t\\t}\\n\\t}\\nreturn count;\\n}\\n```\n```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n\\tint count=0;\\n\\tunordered_map<int, int> umap;\\n\\tfor (int i=0; i<time.size(); i++) {\\n\\t\\t\\tif (time[i]%60==0) count+=umap[0];\\n\\t\\t\\telse count+=umap[60-time[i]%60];\\n\\t\\t\\tumap[time[i]%60]++;\\n\\t}\\nreturn count;\\n}\\n```\n```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n\\tint count=0;\\n\\tvector<int> umap(60, 0);\\n\\tfor (int i=0; i<time.size(); i++) {\\n\\t\\t\\tif (time[i]%60==0) count+=umap[0];\\n\\t\\t\\telse count+=umap[60-time[i]%60];\\n\\t\\t\\tumap[time[i]%60]++;\\n\\t}\\nreturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120832,
                "title": "simple-python-solution-with-explanation",
                "content": "We will loop through the time list and for each time we will get its remainder `rem` when divided by 60. We then have a dictionary mapping from `remainder -> count of times with this remainder`. The remainder is in the range [0,59]. If the remainder is > 0, then any time we have previously seen which has a remainder of `(60 - (t % 60))`, which we call `need`, can be matched with the time we are currently processing to form a pair whose sum is divisible by 60. If the remainder is 0, then we can match the time we are currently processing with any time that also had a remainder of 0. If the remainder is in the dictionary we increment its count, otherwise we initialize it to 1.\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        d = {}\\n        ans = 0\\n        for t in time:\\n            rem = t % 60\\n            need = (60 - (t % 60)) if rem else 0\\n            if need in d:\\n                ans += d[need]\\n            if rem in d:\\n                d[rem] += 1\\n            else:\\n                d[rem] = 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        d = {}\\n        ans = 0\\n        for t in time:\\n            rem = t % 60\\n            need = (60 - (t % 60)) if rem else 0\\n            if need in d:\\n                ans += d[need]\\n            if rem in d:\\n                d[rem] += 1\\n            else:\\n                d[rem] = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090832,
                "title": "simple-o-n-using-hash-map",
                "content": "```\\n\\nvar numPairsDivisibleBy60 = function (time) {\\n  // define a count and storage map\\n  let count = 0,\\n    map = new Map();\\n\\n  // loop through time array\\n  for (let songTime of time) {\\n    // get our mod\\n    const mod = songTime % 60;\\n\\n    // get our possible\\n    const possible = mod === 0 ? 0 : 60 - mod;\\n\\n    // if possible is in map, add that num to count or add 0\\n    count += map.get(possible) || 0;\\n\\n    // if mod in map, set to 0 but always add 1s\\n    map.set(mod, (map.get(mod) || 0) + 1);\\n  }\\n\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar numPairsDivisibleBy60 = function (time) {\\n  // define a count and storage map\\n  let count = 0,\\n    map = new Map();\\n\\n  // loop through time array\\n  for (let songTime of time) {\\n    // get our mod\\n    const mod = songTime % 60;\\n\\n    // get our possible\\n    const possible = mod === 0 ? 0 : 60 - mod;\\n\\n    // if possible is in map, add that num to count or add 0\\n    count += map.get(possible) || 0;\\n\\n    // if mod in map, set to 0 but always add 1s\\n    map.set(mod, (map.get(mod) || 0) + 1);\\n  }\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1043721,
                "title": "simple-c-solution-faster-than-100-similar-to-two-sum",
                "content": "\\n\\t class Solution {\\n\\t public:\\n\\tint numPairsDivisibleBy60(vector<int>& time) \\n     {\\n        vector<int>data(60,0);\\n        int count=0;\\n        for(int n:time)\\n        {\\n            int s=n%60;\\n            data[s]++;\\n        }\\n        for(int i=0;i<=data.size()/2;i++)\\n        {\\n            count+=(i==30 || i==0) ? data[i]*(data[i]-1)/2:data[i]*data[60-i];\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n\\t public:\\n\\tint numPairsDivisibleBy60(vector<int>& time) \\n     {\\n        vector<int>data(60,0);\\n        int count=0;\\n        for(int n:time)\\n        {\\n            int s=n%60;\\n            data[s]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 965226,
                "title": "pairs-of-songs-o-n-solution-it-beat-97-submissions-python",
                "content": "[](http://)[](http://)\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        ret = 0\\n        modulo = [0] * 60\\n        for i in time:\\n            modulo[i%60] +=1\\n        for i in range(1,30):\\n            ret += max(modulo[i],0)*max(modulo[60-i],0)\\n        \\n        ret += int(max(modulo[0],0)*max(modulo[0]-1,0)/2)\\n        ret += int(max(modulo[30],0)*max(modulo[30]-1,0)/2)\\n        \\n        return ret\\n```\\n\\n#python\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        ret = 0\\n        modulo = [0] * 60\\n        for i in time:\\n            modulo[i%60] +=1\\n        for i in range(1,30):\\n            ret += max(modulo[i],0)*max(modulo[60-i],0)\\n        \\n        ret += int(max(modulo[0],0)*max(modulo[0]-1,0)/2)\\n        ret += int(max(modulo[30],0)*max(modulo[30]-1,0)/2)\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965169,
                "title": "javascript-3-line-solution-o-n-99-5-o-1-93",
                "content": "Create an arraymap to keep track of modulo results. Iterate through once and for each value: find its modulo result, check the arraymap for the complimentary time, add that number to the answer, then update the arraymap with the current modulo result.\\n\\n```\\nvar numPairsDivisibleBy60 = function(time) {\\n    let m = new Array(60).fill(0), ans = 0, t\\n    for (let i = 0; i < time.length; i++)\\n        t = time[i] % 60, ans += m[(60 - t) % 60], m[t] += 1\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numPairsDivisibleBy60 = function(time) {\\n    let m = new Array(60).fill(0), ans = 0, t\\n    for (let i = 0; i < time.length; i++)\\n        t = time[i] % 60, ans += m[(60 - t) % 60], m[t] += 1\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 965037,
                "title": "java-map-and-array-implemntation",
                "content": "\\n\\nMap implemetation    : \\tAccepted\\t**13 ms\\t45.3 MB**\\nArray implementatio : Accepted\\t**3 ms\\t44.7 MB**\\n\\n*Upvote* if this helped \\n\\nMap \\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n         Map< Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int i = 0; i < time.length ; i++) {\\n            int n = time[i]%60;\\n            if(n == 0 ) n =60;\\n                count  += map.getOrDefault(60-n,0);\\n                if(n == 60 ) map.put(0, map.getOrDefault(0 , 0)+1);\\n                else map.put(n, map.getOrDefault(n , 0)+1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```\\n\\nArray\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        \\n          int[] dp = new int[61];\\n        int count = 0;\\n        for(int i = 0; i < time.length ; i++) {\\n            int n = time[i]%60;\\n            if(n == 0 ) n =60;\\n                count  += dp[60-n];\\n                if(n == 60 ) dp[0]++;\\n                else dp[n]++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n         Map< Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int i = 0; i < time.length ; i++) {\\n            int n = time[i]%60;\\n            if(n == 0 ) n =60;\\n                count  += map.getOrDefault(60-n,0);\\n                if(n == 60 ) map.put(0, map.getOrDefault(0 , 0)+1);\\n                else map.put(n, map.getOrDefault(n , 0)+1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        \\n          int[] dp = new int[61];\\n        int count = 0;\\n        for(int i = 0; i < time.length ; i++) {\\n            int n = time[i]%60;\\n            if(n == 0 ) n =60;\\n                count  += dp[60-n];\\n                if(n == 60 ) dp[0]++;\\n                else dp[n]++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964729,
                "title": "go-solution",
                "content": "```\\nfunc numPairsDivisibleBy60(time []int) int {\\n    hashmap := make(map[int]int)\\n    res := 0\\n    for i := 0; i < len(time); i++ {\\n        if time[i] % 60 == 0 {\\n            val, found := hashmap[0]\\n            if found {\\n                res = res + val\\n            }\\n        } else {\\n            val, found := hashmap[60 - (time[i] % 60)]\\n            if found {\\n                res = res + val\\n            }\\n        }\\n        hashmap[time[i] % 60] = hashmap[time[i] % 60] + 1\\n        // fmt.Println(hashmap, res)\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numPairsDivisibleBy60(time []int) int {\\n    hashmap := make(map[int]int)\\n    res := 0\\n    for i := 0; i < len(time); i++ {\\n        if time[i] % 60 == 0 {\\n            val, found := hashmap[0]\\n            if found {\\n                res = res + val\\n            }\\n        } else {\\n            val, found := hashmap[60 - (time[i] % 60)]\\n            if found {\\n                res = res + val\\n            }\\n        }\\n        hashmap[time[i] % 60] = hashmap[time[i] % 60] + 1\\n        // fmt.Println(hashmap, res)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 964314,
                "title": "python-hash-table",
                "content": "Two songs `x1` and `x2` with `0<=x1+x2<=1000` and there are 15 multiples of 60 in this interval. Check how many pairs we can get ending at the current index.\\n\\nTime: `O(N)`\\nSpace: `O(1)` (if we assume `500` as constant)\\n\\n```python\\nfrom collections import defaultdict\\nclass Solution:\\n    def numPairsDivisibleBy60(self, A):\\n        ans = 0\\n        ht = defaultdict(int)\\n        for x in A:\\n            for i in range(17): \\n                ans += ht[60*i-x]\\n            ht[x] += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\nclass Solution:\\n    def numPairsDivisibleBy60(self, A):\\n        ans = 0\\n        ht = defaultdict(int)\\n        for x in A:\\n            for i in range(17): \\n                ans += ht[60*i-x]\\n            ht[x] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964266,
                "title": "c-99-100-memory-8-liner-crispy-af",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int res = 0;\\n        int freq[60] = {0};\\n        for (auto t : time) {\\n            t %= 60;\\n            res += freq[(60 - t) % 60];\\n            freq[t]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nExplanation -\\n\\n1. Store times modulo 60\\n2. Add number of available times that could sum up to 60\\n3. ???\\n4. Profit! \\uD83E\\uDD19\\n\\nAs always,\\n\\uD83E\\uDD19 Stay crispy guys \\uD83E\\uDD19",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int res = 0;\\n        int freq[60] = {0};\\n        for (auto t : time) {\\n            t %= 60;\\n            res += freq[(60 - t) % 60];\\n            freq[t]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910395,
                "title": "javascript-compliment-hash-easy-to-read",
                "content": "```\\nvar numPairsDivisibleBy60 = function(time) {\\n    \\n   let map={};\\n    \\n   let pairs = 0;\\n    \\n    for(index in time) {\\n\\t    // get remainder after dividing by 60\\n        let num = time[index]%60;\\n        // compliment is 60 minus our number (or 0 if evenly divisible)\\n        let compliment = (num ? 60-num : 0);\\n        if(map[compliment]) {\\n            pairs += map[compliment];\\n        }\\n        // if not in map, add it, if it is, add one\\n\\t\\t// you want to increment so that when you find its compliment, \\n\\t\\t// you know how many matches it has in the set\\n        map[num] = (map[num]) ? map[num]+1 : 1;\\n    }\\n    \\n    return pairs;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numPairsDivisibleBy60 = function(time) {\\n    \\n   let map={};\\n    \\n   let pairs = 0;\\n    \\n    for(index in time) {\\n\\t    // get remainder after dividing by 60\\n        let num = time[index]%60;\\n        // compliment is 60 minus our number (or 0 if evenly divisible)\\n        let compliment = (num ? 60-num : 0);\\n        if(map[compliment]) {\\n            pairs += map[compliment];\\n        }\\n        // if not in map, add it, if it is, add one\\n\\t\\t// you want to increment so that when you find its compliment, \\n\\t\\t// you know how many matches it has in the set\\n        map[num] = (map[num]) ? map[num]+1 : 1;\\n    }\\n    \\n    return pairs;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871005,
                "title": "c-very-elegant-solution-using-map-o-n-time-o-1-space",
                "content": "```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n        int map[60]={0}, n=0;\\n        for(int t:time) {\\n            n+= t%60==0 ? map[0] : map[60-t%60];\\n            map[t%60]++;\\n        }\\n        return n;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n        int map[60]={0}, n=0;\\n        for(int t:time) {\\n            n+= t%60==0 ? map[0] : map[60-t%60];\\n            map[t%60]++;\\n        }\\n        return n;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 801647,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        for(int i = 0; i < time.size(); i++) {\\n            res += time[i] % 60 ? m[60 - time[i] % 60] : m[0];\\n            m[time[i] % 60]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        for(int i = 0; i < time.size(); i++) {\\n            res += time[i] % 60 ? m[60 - time[i] % 60] : m[0];\\n            m[time[i] % 60]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798346,
                "title": "java-solution-with-clear-explanation",
                "content": "To go on with the solution of this problem, we first need to understand the terms **remainder**   and  **complement** as used in this context.\\nFor a value n, the remainder is what remains after n/60. (ie. n % 60).\\nFor a value n, the complement is the required number whose sum with n is divisible by 60:\\n**Note that the remainder of a value can be the complement of another value. For such two values, they form a pair.**\\nExample for a number 85, its remainder is 25 and its complements are x = (35, 95, 155,...,x+60). In other words, for an integer k, if  the value of k % 60(remainder of k) is 35, then the number is a complement of 85. Therefore, 85 forms a pair with all values in set x. \\nThese complements , k%60, ranges from 0 to 59.\\n\\nNow lets map all these complements to their count. We can use an array since the complements are integers from 0 t0 59. First initialize their counts to 0;\\n\\n**Logic**\\nFor each value n in the array, calculate its remainder and its complement.\\nIf its  complement is in the map, then you have two pairs whose sum is divisible by 60.\\n\\nNow lets talk about how we know the complement of the value  n is in the map.\\nWe do this by incrementing the count of each value\\'s remainder after every iteration. So that on the *ith* value, the count of its complement in the map will determine the number of previous values that form a pair with it\\n\\n**Algorithm**\\nResult = 0\\nFor each value, if the count of complement(value) > 0, then add count to value.\\nIncrement the count of remainder(value) in map.\\n\\t\\n ```\\n class Solution {\\n  public int numPairsDivisibleBy60(int[] time) {\\n        int[] map = new int[60];\\n        int count=0;\\n        \\n        for(int n : time){\\n            int rem = n % 60;\\n            int comp = (60-rem);\\n            if(map[comp % 60] > 0); //comp%60 is to ensure you do not exceed map size\\n                count += map[comp % 60];  //eg if n=0, comp==60 and so map[60] will throw an out of bounds error.\\n            map[rem]++;   \\n        }\\n        return count;\\n    }\\n}\\n \\n ```\\n Time complexity: O(N) Since we iterate through the array once.\\n Space complexity: O(1) The size of the map is independent of the array size.  \\n \\n I hope this help. Feel free to shoot me a message if you don\\'t understand anything or find fault with this solution.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n  public int numPairsDivisibleBy60(int[] time) {\\n        int[] map = new int[60];\\n        int count=0;\\n        \\n        for(int n : time){\\n            int rem = n % 60;\\n            int comp = (60-rem);\\n            if(map[comp % 60] > 0); //comp%60 is to ensure you do not exceed map size\\n                count += map[comp % 60];  //eg if n=0, comp==60 and so map[60] will throw an out of bounds error.\\n            map[rem]++;   \\n        }\\n        return count;\\n    }\\n}\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 618765,
                "title": "java-o-n-1-loop",
                "content": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int count = 0;\\n        int[] mins = new int[60];\\n        for (int t : time) {\\n\\t\\t\\tint c =( 60 - (t % 60) ) % 60  // compliment value\\n            count += mins[c];\\n            mins[t % 60]++;  // increase count\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int count = 0;\\n        int[] mins = new int[60];\\n        for (int t : time) {\\n\\t\\t\\tint c =( 60 - (t % 60) ) % 60  // compliment value\\n            count += mins[c];\\n            mins[t % 60]++;  // increase count\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577905,
                "title": "c-easy-solution-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        auto numberOfPairs = 0;\\n        vector<int> durations(60, 0);\\n        for (auto t : time) {\\n            int first = t % 60;\\n            int second = (60 - first) % 60;\\n            numberOfPairs += durations[second];\\n            durations[first]++;\\n        }\\n        return numberOfPairs;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        auto numberOfPairs = 0;\\n        vector<int> durations(60, 0);\\n        for (auto t : time) {\\n            int first = t % 60;\\n            int second = (60 - first) % 60;\\n            numberOfPairs += durations[second];\\n            durations[first]++;\\n        }\\n        return numberOfPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477612,
                "title": "c-o-n-using-array-of-size-of-60",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int A[60] = {0};\\n        for(int i = 0;i<time.size();i++){\\n            A[time[i]%60]++;\\n        }\\n        int ans = A[0]*(A[0]-1)/2 +A[30]*(A[30]-1)/2;\\n        int t = 0;\\n        for(int i = 1;i<30;i++){\\n           \\n            if(A[i]!=0&&A[60-i]!=0){\\n                \\n                t += A[i]*A[60-i];\\n            }\\n            \\n        }\\n        return ans + t;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int A[60] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 475726,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int NumPairsDivisibleBy60(int[] time)\\n    {\\n        IDictionary<int, int> mod2Count = new Dictionary<int, int>();\\n        foreach (var t in time)\\n        {\\n            if (!mod2Count.ContainsKey(t % 60))\\n            {\\n                mod2Count[t % 60] = 0;\\n            }\\n\\n            mod2Count[t % 60]++;\\n        }\\n\\n        int res = 0;\\n\\n        for (int i = 1; i <= 29; i++)\\n        {\\n            if (mod2Count.ContainsKey(i) && mod2Count.ContainsKey(60 - i))\\n            {\\n                res += (mod2Count[i] * mod2Count[60 - i]);\\n            }\\n        }\\n\\n\\n        //choose 2 from N\\n        if (mod2Count.ContainsKey(0))\\n        {\\n            res += mod2Count[0] * (mod2Count[0] - 1) / 2;\\n        }\\n\\n        if (mod2Count.ContainsKey(30))\\n        {\\n            res += mod2Count[30] * (mod2Count[30] - 1) / 2;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int NumPairsDivisibleBy60(int[] time)\\n    {\\n        IDictionary<int, int> mod2Count = new Dictionary<int, int>();\\n        foreach (var t in time)\\n        {\\n            if (!mod2Count.ContainsKey(t % 60))\\n            {\\n                mod2Count[t % 60] = 0;\\n            }\\n\\n            mod2Count[t % 60]++;\\n        }\\n\\n        int res = 0;\\n\\n        for (int i = 1; i <= 29; i++)\\n        {\\n            if (mod2Count.ContainsKey(i) && mod2Count.ContainsKey(60 - i))\\n            {\\n                res += (mod2Count[i] * mod2Count[60 - i]);\\n            }\\n        }\\n\\n\\n        //choose 2 from N\\n        if (mod2Count.ContainsKey(0))\\n        {\\n            res += mod2Count[0] * (mod2Count[0] - 1) / 2;\\n        }\\n\\n        if (mod2Count.ContainsKey(30))\\n        {\\n            res += mod2Count[30] * (mod2Count[30] - 1) / 2;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432385,
                "title": "c-easy-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int res = 0;\\n        map<int, int> arr;\\n        for(int i = 0; i < time.size(); i++) {\\n            time[i] %= 60;\\n            arr[time[i]]++;\\n        }\\n        for(auto it = arr.begin(); it != arr.end(); it++) {\\n            if((it->first == 30) || (it->first == 0))\\n                res += it->second * (it->second - 1) / 2;\\n            else if(arr[60 - it->first] > 0) {\\n                res += it->second*arr[60 - it->first];\\n                arr.erase(60 - it->first);\\n            }    \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int res = 0;\\n        map<int, int> arr;\\n        for(int i = 0; i < time.size(); i++) {\\n            time[i] %= 60;\\n            arr[time[i]]++;\\n        }\\n        for(auto it = arr.begin(); it != arr.end(); it++) {\\n            if((it->first == 30) || (it->first == 0))\\n                res += it->second * (it->second - 1) / 2;\\n            else if(arr[60 - it->first] > 0) {\\n                res += it->second*arr[60 - it->first];\\n                arr.erase(60 - it->first);\\n            }    \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428046,
                "title": "java-6-liner-solution-using-hashmap",
                "content": "```\\npublic int numPairsDivisibleBy60(int[] time) {\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tint count = 0;\\n\\tfor(int t : time) {\\n\\t\\tcount +=  hm.getOrDefault((60 - t % 60) % 60, 0);\\n\\t\\thm.put(t%60, hm.getOrDefault(t%60,0)+1);\\n\\t}        \\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numPairsDivisibleBy60(int[] time) {\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tint count = 0;\\n\\tfor(int t : time) {\\n\\t\\tcount +=  hm.getOrDefault((60 - t % 60) % 60, 0);\\n\\t\\thm.put(t%60, hm.getOrDefault(t%60,0)+1);\\n\\t}        \\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354494,
                "title": "share-my-python3-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        if not time:\\n            return 0\\n        helper = [0] * 60\\n        for x in time:\\n            helper[x % 60] += 1\\n\\n        res = helper[0] * (helper[0]-1)\\n        res += helper[30] * (helper[30]-1)\\n        for i in range(1, 30):\\n            if helper[i]:\\n                res += helper[i] * helper[60-i]\\n        for i in range(31, 60):\\n            if helper[i]:\\n                res += helper[i] * helper[60-i]\\n        return res // 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        if not time:\\n            return 0\\n        helper = [0] * 60\\n        for x in time:\\n            helper[x % 60] += 1\\n\\n        res = helper[0] * (helper[0]-1)\\n        res += helper[30] * (helper[30]-1)\\n        for i in range(1, 30):\\n            if helper[i]:\\n                res += helper[i] * helper[60-i]\\n        for i in range(31, 60):\\n            if helper[i]:\\n                res += helper[i] * helper[60-i]\\n        return res // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309137,
                "title": "python-two-sum-with-dict",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: [int]) -> int:\\n        m = defaultdict(int)\\n        for t in time:\\n            m[t % 60] += 1\\n\\n        res = 0\\n        for k in m:\\n            if k == 0 or k == 30:\\n                res += int(m[k] * (m[k] - 1) / 2)\\n            elif k < 30 and 60 - k in m:\\n                res += m[k] * m[60 - k]\\n\\n        return res",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: [int]) -> int:\\n        m = defaultdict(int)\\n        for t in time:\\n            m[t % 60] += 1\\n\\n        res = 0\\n        for k in m:\\n            if k == 0 or k == 30:\\n                res += int(m[k] * (m[k] - 1) / 2)\\n            elif k < 30 and 60 - k in m:\\n                res += m[k] * m[60 - k]\\n\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 298152,
                "title": "python-simple-solution-reduce-to-two-sum",
                "content": "```\\n# O(n) time\\n# O(n) space\\ndef numPairsDivisibleBy60(self, time):\\n\\ttime = [t%60 for t in time]\\n\\t# Now it\\'s just a two sum problem:\\n\\tnum_songs_with_t = defaultdict(int)  # {t : num songs}\\n\\tcount = 0\\n\\tfor t in time:\\n\\t\\tt_complementary = (60-t)%60\\n\\t\\tif t_complementary in num_songs_with_t:\\n\\t\\t\\tcount += num_songs_with_t[t_complementary]\\n\\t\\tnum_songs_with_t[t] += 1\\n\\treturn count\\n```",
                "solutionTags": [],
                "code": "```\\n# O(n) time\\n# O(n) space\\ndef numPairsDivisibleBy60(self, time):\\n\\ttime = [t%60 for t in time]\\n\\t# Now it\\'s just a two sum problem:\\n\\tnum_songs_with_t = defaultdict(int)  # {t : num songs}\\n\\tcount = 0\\n\\tfor t in time:\\n\\t\\tt_complementary = (60-t)%60\\n\\t\\tif t_complementary in num_songs_with_t:\\n\\t\\t\\tcount += num_songs_with_t[t_complementary]\\n\\t\\tnum_songs_with_t[t] += 1\\n\\treturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 284273,
                "title": "4-lines-python",
                "content": "```\\nb = [0]*60; res = 0\\nfor song in time:\\n    res += b[60 - song%60 if song%60 else 0]; b[song%60] += 1\\nreturn res\\n```",
                "solutionTags": [],
                "code": "```\\nb = [0]*60; res = 0\\nfor song in time:\\n    res += b[60 - song%60 if song%60 else 0]; b[song%60] += 1\\nreturn res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260555,
                "title": "python-o-n-one-pass",
                "content": "```python\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        cnt, res = collections.Counter(), 0\\n        for t in time:\\n            res += cnt[60 - t % 60] if t % 60 else cnt[0]\\n            cnt[t % 60] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        cnt, res = collections.Counter(), 0\\n        for t in time:\\n            res += cnt[60 - t % 60] if t % 60 else cnt[0]\\n            cnt[t % 60] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256885,
                "title": "js-o-n-time-and-space-hashmap-and-hashset-combined",
                "content": "```\\nconst numPairsDivisibleBy60 = time => {\\n    let total = 0, map = {};\\n    \\n    for (let i = 0; i < time.length; i++) {\\n        let t = time[i] % 60;\\n        \\n        if (!map[t]) { \\n            map[t] = new Set(); \\n        }\\n        \\n        map[t].add(i);\\n    }\\n    \\n    for (let i = 0; i < time.length; i++) {\\n        let t = (60 - (time[i] % 60)) % 60;\\n        if (map[t]) { \\n            total += map[t].size - (map[t].has(i) ? 1 : 0);\\n        }\\n    }\\n    \\n    return total / 2;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst numPairsDivisibleBy60 = time => {\\n    let total = 0, map = {};\\n    \\n    for (let i = 0; i < time.length; i++) {\\n        let t = time[i] % 60;\\n        \\n        if (!map[t]) { \\n            map[t] = new Set(); \\n        }\\n        \\n        map[t].add(i);\\n    }\\n    \\n    for (let i = 0; i < time.length; i++) {\\n        let t = (60 - (time[i] % 60)) % 60;\\n        if (map[t]) { \\n            total += map[t].size - (map[t].has(i) ? 1 : 0);\\n        }\\n    }\\n    \\n    return total / 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256716,
                "title": "kt-js-py3-cpp-map-of-buckets",
                "content": "**Synopsis:**\\n\\nPerform a linear scan of each value `x` in `A` and use a map `m` to store the frequency of each value `x % 60` in \"buckets\" from `0..59` inclusive.  Let `y` be the corresponding \"bucket\" needed by each `x` to create pairs `x, y` such that `(x + y) % 60 == 0`.  Then the total sum of `pairs` is found by accumulating the frequency of each corresponding `y` bucket for each `x` in `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun numPairsDivisibleBy60(A: IntArray): Int {\\n        var pairs = 0\\n        var m = mutableMapOf<Int, Int>()\\n        A.forEachIndexed{ i, x -> A[i] = x % 60 }\\n        A.forEach{ x ->\\n            var y = (60 - x) % 60\\n            pairs += m.getOrElse(y) { 0 }\\n            m[x] = 1 + m.getOrPut(x) { 0 }\\n        }\\n        return pairs\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numPairsDivisibleBy60 = (A, m = new Map(), pairs = 0) => {\\n    A = A.map(x => x % 60);\\n    for (let x of A) {\\n        let y = (60 - x) % 60;\\n        pairs += (m.get(y) || 0);\\n        m.set(x, 1 + (m.get(x) || 0));\\n    }\\n    return pairs;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, A: List[int], pairs = 0) -> int:\\n        m = {}\\n        A = [x % 60 for x in A]\\n        for x in A:\\n            y = (60 - x) % 60\\n            pairs += m[y] if y in m else 0\\n            m[x] = 1 + m[x] if x in m else 1\\n        return pairs\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int numPairsDivisibleBy60(VI& A, Map m = {}, int pairs = 0) {\\n        transform(A.begin(), A.end(), A.begin(), [](auto x) { return x % 60; });\\n        for (auto x: A) {\\n            auto y = (60 - x) % 60;\\n            pairs += m[y];\\n            ++m[x];\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numPairsDivisibleBy60(A: IntArray): Int {\\n        var pairs = 0\\n        var m = mutableMapOf<Int, Int>()\\n        A.forEachIndexed{ i, x -> A[i] = x % 60 }\\n        A.forEach{ x ->\\n            var y = (60 - x) % 60\\n            pairs += m.getOrElse(y) { 0 }\\n            m[x] = 1 + m.getOrPut(x) { 0 }\\n        }\\n        return pairs\\n    }\\n}\\n```\n```\\nlet numPairsDivisibleBy60 = (A, m = new Map(), pairs = 0) => {\\n    A = A.map(x => x % 60);\\n    for (let x of A) {\\n        let y = (60 - x) % 60;\\n        pairs += (m.get(y) || 0);\\n        m.set(x, 1 + (m.get(x) || 0));\\n    }\\n    return pairs;\\n};\\n```\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, A: List[int], pairs = 0) -> int:\\n        m = {}\\n        A = [x % 60 for x in A]\\n        for x in A:\\n            y = (60 - x) % 60\\n            pairs += m[y] if y in m else 0\\n            m[x] = 1 + m[x] if x in m else 1\\n        return pairs\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int numPairsDivisibleBy60(VI& A, Map m = {}, int pairs = 0) {\\n        transform(A.begin(), A.end(), A.begin(), [](auto x) { return x % 60; });\\n        for (auto x: A) {\\n            auto y = (60 - x) % 60;\\n            pairs += m[y];\\n            ++m[x];\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083960,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] arr) {\\n        int n = arr.length;\\n\\n        long count[] = new long[60];\\n\\n        for(int i=0; i<n; i++){\\n            count[arr[i]%60]++;\\n        }\\n\\n        long ans = 0;\\n\\n        for(int i=1; i<30; i++){\\n            ans = ans + count[i]*count[60-i];\\n        }\\n\\n        ans = ans + (count[0]*(count[0]-1))/2 + (count[30]*(count[30]-1))/2;\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] arr) {\\n        int n = arr.length;\\n\\n        long count[] = new long[60];\\n\\n        for(int i=0; i<n; i++){\\n            count[arr[i]%60]++;\\n        }\\n\\n        long ans = 0;\\n\\n        for(int i=1; i<30; i++){\\n            ans = ans + count[i]*count[60-i];\\n        }\\n\\n        ans = ans + (count[0]*(count[0]-1))/2 + (count[30]*(count[30]-1))/2;\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808980,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<time.size();i++){\\n            int x=time[i]%60;\\n            if(x==0)\\n            {\\n                count+=mp[x]; \\n            }\\n           else if(mp.find(60-x)!=mp.end())\\n            count+=mp[60-x];\\n            mp[x]++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<time.size();i++){\\n            int x=time[i]%60;\\n            if(x==0)\\n            {\\n                count+=mp[x]; \\n            }\\n           else if(mp.find(60-x)!=mp.end())\\n            count+=mp[60-x];\\n            mp[x]++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544071,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> remainders(60);\\n        int count = 0;\\n        for(int t : time) {\\n           if(t % 60 == 0) count += remainders[0];\\n\\n           else count += remainders[60 - t % 60]; \\n\\n            remainders[t % 60]++;\\n        }\\n         return count;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        L = [t % 60 for t in time]\\n        L = Counter(L)\\n        res = 0\\n        for t in L:\\n            if t < 30 :\\n                res += L[t] * L[60 - t]\\n        return res + (L[0] * (L[0] - 1) // 2) + (L[30] * (L[30] - 1) // 2)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] freq = new int[60];\\n        int res=0;\\n\\n        for(int t: time){\\n            int val = t%60;\\n            if(val==0){\\n                res += freq[0];\\n            }\\n            else{\\n                res += freq[60-val];\\n            }\\n            freq[val]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> remainders(60);\\n        int count = 0;\\n        for(int t : time) {\\n           if(t % 60 == 0) count += remainders[0];\\n\\n           else count += remainders[60 - t % 60]; \\n\\n            remainders[t % 60]++;\\n        }\\n         return count;\\n    }\\n};\\n```\n```Python3 []\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        L = [t % 60 for t in time]\\n        L = Counter(L)\\n        res = 0\\n        for t in L:\\n            if t < 30 :\\n                res += L[t] * L[60 - t]\\n        return res + (L[0] * (L[0] - 1) // 2) + (L[30] * (L[30] - 1) // 2)\\n```\n```Java []\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] freq = new int[60];\\n        int res=0;\\n\\n        for(int t: time){\\n            int val = t%60;\\n            if(val==0){\\n                res += freq[0];\\n            }\\n            else{\\n                res += freq[60-val];\\n            }\\n            freq[val]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531959,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumPairsDivisibleBy60(int[] time) {\\n        int mod =0, counter = 0, required=0;\\n        Dictionary<int, int> hashMap = new Dictionary<int, int>();\\n\\n        for(int i=0; i< time.Length; i++)\\n        {\\n            mod = time[i] % 60;\\n            required = (mod == 0)? 0: 60-mod;\\n\\n            if(hashMap.ContainsKey(required))\\n            {\\n                counter += hashMap[required];\\n            }\\n\\n            if(hashMap.ContainsKey(mod))\\n            {\\n                hashMap[mod]++;\\n            }\\n            else\\n            {\\n                hashMap.Add(mod, 1);\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumPairsDivisibleBy60(int[] time) {\\n        int mod =0, counter = 0, required=0;\\n        Dictionary<int, int> hashMap = new Dictionary<int, int>();\\n\\n        for(int i=0; i< time.Length; i++)\\n        {\\n            mod = time[i] % 60;\\n            required = (mod == 0)? 0: 60-mod;\\n\\n            if(hashMap.ContainsKey(required))\\n            {\\n                counter += hashMap[required];\\n            }\\n\\n            if(hashMap.ContainsKey(mod))\\n            {\\n                hashMap[mod]++;\\n            }\\n            else\\n            {\\n                hashMap.Add(mod, 1);\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496288,
                "title": "lc-1010-m-python3-a-plain-solution",
                "content": "Note that `i > j` is symmetric with `i < j` for calculation.\\nTC: $\\\\Omicron(n)$ | SC: $\\\\Omicron(n)$, where `n = len(time)`.\\n \\n```Python3 []\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        cnter = defaultdict(int)\\n        res = 0\\n        for t in time:\\n            t %= 60\\n            res += cnter[(60-t) % 60]\\n            cnter[t] += 1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        cnter = defaultdict(int)\\n        res = 0\\n        for t in time:\\n            t %= 60\\n            res += cnter[(60-t) % 60]\\n            cnter[t] += 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168545,
                "title": "java-solution-using-hashmap",
                "content": "# Approach\\nConverted all values to less than 60.\\nStoring in HashMap with the value and it\\'s frequency.\\nfor time at 60 or 0 we increment the count if there is any previous 0 or 60.\\nfor the rest of the values we verify if there is complement present previously.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int count =0;\\n        for(int i=0;i<time.length;i++){\\n            if(time[i]>=60) time[i]%=60;\\n        }\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<time.length;i++){\\n            if(time[i]==0 && map.containsKey(time[i])){\\n                count+=map.get(time[i]);\\n            }\\n            if(map.containsKey(60-time[i])){\\n                count+=map.get(60-time[i]);\\n            }\\n            map.put(time[i],map.getOrDefault(time[i],0)+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int count =0;\\n        for(int i=0;i<time.length;i++){\\n            if(time[i]>=60) time[i]%=60;\\n        }\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<time.length;i++){\\n            if(time[i]==0 && map.containsKey(time[i])){\\n                count+=map.get(time[i]);\\n            }\\n            if(map.containsKey(60-time[i])){\\n                count+=map.get(60-time[i]);\\n            }\\n            map.put(time[i],map.getOrDefault(time[i],0)+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004251,
                "title": "java-hashmap-frequency-array",
                "content": "# Please Upvote :D\\n----\\n##### Using HashMap (TwoSum approach):\\n``` java []\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int ans = 0;\\n        for (int t : time) {\\n            int mod = t % 60;\\n            int rem = (mod == 0)? 0 : 60 - mod;\\n            ans += map.getOrDefault(rem, 0);\\n            map.put(mod, 1 + map.getOrDefault(mod, 0));\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n--- \\n##### Using a mod-frequency array (Efficient):\\n``` java []\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] freq = new int[61];\\n        int ans = 0;\\n        for (int t : time) {\\n            int mod = t % 60;\\n            int rem = (mod == 0)? 0 : 60 - mod;\\n            ans += freq[rem];\\n            freq[mod]++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int ans = 0;\\n        for (int t : time) {\\n            int mod = t % 60;\\n            int rem = (mod == 0)? 0 : 60 - mod;\\n            ans += map.getOrDefault(rem, 0);\\n            map.put(mod, 1 + map.getOrDefault(mod, 0));\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] freq = new int[61];\\n        int ans = 0;\\n        for (int t : time) {\\n            int mod = t % 60;\\n            int rem = (mod == 0)? 0 : 60 - mod;\\n            ans += freq[rem];\\n            freq[mod]++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886033,
                "title": "pairs-of-songs-with-total-durations-divisible-by-60-cpp-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int,int> pairs;\\n        int n = time.size(), ans = 0;\\n        for(int i = 0 ; i < n ; i++) time[i] = time[i] % 60;\\n\\n        for(int i = 0 ;i < n ;i++){\\n            int k = time[i] == 0 ? 0 : 60 - time[i];\\n            if(pairs.find(k) != pairs.end()){\\n                ans += pairs[k];\\n            }\\n            pairs[time[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int,int> pairs;\\n        int n = time.size(), ans = 0;\\n        for(int i = 0 ; i < n ; i++) time[i] = time[i] % 60;\\n\\n        for(int i = 0 ;i < n ;i++){\\n            int k = time[i] == 0 ? 0 : 60 - time[i];\\n            if(pairs.find(k) != pairs.end()){\\n                ans += pairs[k];\\n            }\\n            pairs[time[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571565,
                "title": "99-faster-python3",
                "content": "class Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:       \\n\\t    \\n\\t\\trem={}\\n        count=0\\n        for x in time:\\n            r=x%60\\n            if r in rem:\\n                rem[r]=rem[r]+1\\n            else:\\n                rem[r]=1 \\n        if 0 in rem:\\n            n=rem[0]\\n            count=count+(n*(n-1))//2\\n            del rem[0]\\n        if 30 in rem:\\n            n=rem[30]\\n            count=count+(n*(n-1))//2\\n            del rem[30]\\n        for i in range(1,30):\\n            if(60-i) in rem and i in rem:\\n                p=rem[i]\\n                q=rem[60-i]\\n                count=count+(p*q)\\n        return(count)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:       \\n\\t    \\n\\t\\trem={}",
                "codeTag": "Java"
            },
            {
                "id": 2519609,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        arr=[0]*60\\n        count=0\\n        for i in range(len(time)):\\n            temp=time[i]%60\\n            count+=arr[-temp%60]\\n            arr[temp]+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        arr=[0]*60\\n        count=0\\n        for i in range(len(time)):\\n            temp=time[i]%60\\n            count+=arr[-temp%60]\\n            arr[temp]+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451173,
                "title": "pairs-of-songs-with-total-durations-divisible-by-60",
                "content": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n     int count=0;\\n     HashMap<Integer,Integer> hm=new HashMap<>();\\n     for(int i=0;i<time.length;i++)\\n     {\\n         int div=time[i]%60;\\n         if(hm.containsKey(60-div))\\n         {\\n             count+=hm.get(60-div);\\n         }\\n         if(div==0)\\n             hm.put(60,hm.getOrDefault(60,0)+1);\\n         else\\n             hm.put(div,hm.getOrDefault(div,0)+1);\\n     }\\n     return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n     int count=0;\\n     HashMap<Integer,Integer> hm=new HashMap<>();\\n     for(int i=0;i<time.length;i++)\\n     {\\n         int div=time[i]%60;\\n         if(hm.containsKey(60-div))\\n         {\\n             count+=hm.get(60-div);\\n         }\\n         if(div==0)\\n             hm.put(60,hm.getOrDefault(60,0)+1);\\n         else\\n             hm.put(div,hm.getOrDefault(div,0)+1);\\n     }\\n     return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434009,
                "title": "c-hashmap-easytounderstand",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < time.size(); ++i){\\n            ++mp[time[i]%60];\\n        }\\n        \\n        int64_t counter = 0;\\n        for(int i = 0; i < time.size(); ++i){\\n            int t = (time[i] % 60);\\n            if(t != 0)      t = 60 - t;\\n            if(mp.find(t) != mp.end()){\\n                counter = counter + mp[t];\\n                if(t == (time[i] % 60)){\\n                    --counter;\\n                }\\n            } \\n        }\\n        return counter/2;\\n    }\\n};\\n```\\n**Output**\\n```\\nRuntime: 85 ms, faster than 25.77% of C++ online submissions for Pairs of Songs With Total Durations Divisible by 60.\\nMemory Usage: 28.2 MB, less than 30.47% of C++ online submissions for Pairs of Songs With Total Durations Divisible by 60.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < time.size(); ++i){\\n            ++mp[time[i]%60];\\n        }\\n        \\n        int64_t counter = 0;\\n        for(int i = 0; i < time.size(); ++i){\\n            int t = (time[i] % 60);\\n            if(t != 0)      t = 60 - t;\\n            if(mp.find(t) != mp.end()){\\n                counter = counter + mp[t];\\n                if(t == (time[i] % 60)){\\n                    --counter;\\n                }\\n            } \\n        }\\n        return counter/2;\\n    }\\n};\\n```\n```\\nRuntime: 85 ms, faster than 25.77% of C++ online submissions for Pairs of Songs With Total Durations Divisible by 60.\\nMemory Usage: 28.2 MB, less than 30.47% of C++ online submissions for Pairs of Songs With Total Durations Divisible by 60.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414082,
                "title": "simple-o-n-c-solution",
                "content": "```\\nunordered_map<int,int> mp;\\n        int count=0;\\n        for(int i=0;i<time.size();i++){\\n            int rem=time[i]%60;\\n            if(mp.find(60-rem)!=mp.end()){\\n                count+=mp[60-rem];\\n            }\\n            if(rem==0) rem=60;\\n            mp[rem]++;\\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nunordered_map<int,int> mp;\\n        int count=0;\\n        for(int i=0;i<time.size();i++){\\n            int rem=time[i]%60;\\n            if(mp.find(60-rem)!=mp.end()){\\n                count+=mp[60-rem];\\n            }\\n            if(rem==0) rem=60;\\n            mp[rem]++;\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386522,
                "title": "c-code-two-sum-modified-3-lines-of-code",
                "content": "```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> c(60);\\n        int res = 0;\\n        for (int t : time) {\\n            res += c[(600 - t) % 60];\\n            c[t % 60] += 1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> c(60);\\n        int res = 0;\\n        for (int t : time) {\\n            res += c[(600 - t) % 60];\\n            c[t % 60] += 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386302,
                "title": "c-o-n-using-map-easy-3lines",
                "content": "//we have to store time%60  everytime and just check 2condtions if tim%60==0 then we\\'ll be checking m[0] else if time%60 is anything just add that with our c;\\n        //Example [30,20,150,100,40]\\n        //check if 60-(30%60) exists in map. No, so just increment [30%60] by 1\\n        //next check if 60-(20%60) exists in map. No, so just increment [20%60] by 1\\n        //next check if 60-(150%60)=30 exists in map. Yes it exists,first add counter with   60-m[150%60] , then just increment [150%60] by 1\\n        //similarly, check if 60-(100%60)=20 exists in map. Yes it exists,first add counter with 60-m[100%60] , then just increment [150%60] by 1\\n        //Let\\'s CODE\\n    \\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int,int>m;  int c=0;\\n        for(auto t:time)\\n        {\\n            //1st base condition when remainder is 0\\n            if(t%60==0) c+=m[0];\\n            else c+=m[60-(t%60)];  //addding the corresponding pair if exists\\n            m[t%60]++;  //inc the remainder of every time element\\n        }\\n        return c;\\n    }",
                "solutionTags": [],
                "code": "//we have to store time%60  everytime and just check 2condtions if tim%60==0 then we\\'ll be checking m[0] else if time%60 is anything just add that with our c;\\n        //Example [30,20,150,100,40]\\n        //check if 60-(30%60) exists in map. No, so just increment [30%60] by 1\\n        //next check if 60-(20%60) exists in map. No, so just increment [20%60] by 1\\n        //next check if 60-(150%60)=30 exists in map. Yes it exists,first add counter with   60-m[150%60] , then just increment [150%60] by 1\\n        //similarly, check if 60-(100%60)=20 exists in map. Yes it exists,first add counter with 60-m[100%60] , then just increment [150%60] by 1\\n        //Let\\'s CODE\\n    \\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int,int>m;  int c=0;\\n        for(auto t:time)\\n        {\\n            //1st base condition when remainder is 0\\n            if(t%60==0) c+=m[0];\\n            else c+=m[60-(t%60)];  //addding the corresponding pair if exists\\n            m[t%60]++;  //inc the remainder of every time element\\n        }\\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2364807,
                "title": "c-code-o-n-approach",
                "content": "Basically the remainder will be from 0 to right\\nif remainder == 0 or remainder ==30\\nthen we will have to add (remainder\\'s count value -1 + remainder\\'s count value -2+ ......... +1)\\nelse\\nif (60-remainder is present)\\nthen add product of the value count of remainder and 60-remainder\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int,int>ma;\\n        int result=0;\\n        for(int i=0;i<time.size();i=i+1)\\n        {\\n            ma[time[i]%60]++;\\n        }\\n        if(ma.find(0)!=ma.end())\\n        {\\n            int k=ma[0];\\n            int j=k-1;\\n            cout <<k <<\" \";\\n            if(k%2==0)\\n                k=k/2;\\n            else\\n                j=j/2;\\n            result=k*j;\\n        }\\n        if(ma.find(30)!=ma.end())\\n        {\\n            cout <<\"2\";\\n            int k=ma[30];\\n            int j=k-1;\\n            if(k%2==0)\\n                k=k/2;\\n            else\\n                j=j/2;\\n            result=result+(k*j);\\n        }\\n        for(auto it=ma.begin();it!=ma.end();it++)\\n        {\\n            cout <<\"1\";\\n            if(it->first!=0 && it->first!=30)\\n            {\\n                int p=it->first;\\n                if(ma.find(60-p)!=ma.end())\\n                {\\n                    cout <<\"4\";\\n                    result=result+(it->second*(ma[60-p]));\\n                }\\n                ma[p]=0;\\n            }\\n        }\\n        return result;\\n    }\\n};****",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        unordered_map<int,int>ma;\\n        int result=0;\\n        for(int i=0;i<time.size();i=i+1)\\n        {\\n            ma[time[i]%60]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2357444,
                "title": "java-solution-hashing",
                "content": "```java \\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] a = new int[60];\\n        \\n        for(int i=0;i<time.length;i++)\\n        {\\n            a[time[i]%60]++;\\n        }\\n        \\n        int c=0;\\n        \\n        for(int i=0;i<59;i++)\\n        {\\n            for(int j=i+1;j<60;j++)\\n            {\\n                if(a[i]!=0&&(i+j)%60==0)\\n                {\\n                    c+=a[i]*a[j];\\n                }      \\n            }\\n        }\\n        if(a[0]>=2)\\n            c+=((long)(a[0]-1)*(a[0]))/2;\\n        if(a[30]>=2)\\n            c+=((long)a[30]*(a[30]-1))/2;\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] a = new int[60];\\n        \\n        for(int i=0;i<time.length;i++)\\n        {\\n            a[time[i]%60]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2347278,
                "title": "python-dictionary",
                "content": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        time = [t % 60 for t in time]\\n        dic = defaultdict(int)\\n        for t in time : \\n            dic[t] +=1\\n            \\n        counter = (dic[0] * (dic[0]-1)) //2 +(dic[30] * (dic[30]-1)) //2\\n        for i in range(1,30):\\n            counter += dic[i] * dic[60-i]\\n        return counter",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        time = [t % 60 for t in time]\\n        dic = defaultdict(int)\\n        for t in time : \\n            dic[t] +=1\\n            \\n        counter = (dic[0] * (dic[0]-1)) //2 +(dic[30] * (dic[30]-1)) //2\\n        for i in range(1,30):\\n            counter += dic[i] * dic[60-i]\\n        return counter",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565419,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1946334,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1757044,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1899074,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1762647,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1640306,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 2063181,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 2052070,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1969548,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1787024,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1565419,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1946334,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1757044,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1899074,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1762647,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1640306,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 2063181,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 2052070,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1969548,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            },
            {
                "id": 1787024,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Use an Array to Store Frequencies\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the first thing that comes to mind after seeing this problem is two sum problem"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The last test case is time 60 repeated 60000 times, which would make the count exceed the int limit in Java. Be cautious and use a `long[]` to store the counts. \\n\\nProbably not a very meaningful test case."
                    },
                    {
                        "username": "jaggz01",
                        "content": "I find this difficult. "
                    },
                    {
                        "username": "mochiball",
                        "content": "facts i thought itll be easy since its similar to 2sum. fml"
                    },
                    {
                        "username": "ck1910",
                        "content": "Key concept to this problem is the complement of the remainder.\\nIf the sum of the pair is divisible by 60 (or any target number), the sum of remainders needs to be equal to 0 or 60 (or the targeted number).\\nHence, the solution is to maintain an array of matching remainder count.\\n\\nint target = 60;\\nint[] remainder2count = new int[target];"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "what\\'s good chat"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "what\\'s good.\\nthis ui is poggers am I right boys"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why am I haaving hard time understanding this. The brute force is easy but the O(N) solution is hard to even come up with in a real interview\\n"
                    },
                    {
                        "username": "slash6521",
                        "content": "is the solution using remainders intuitive for everyone?"
                    },
                    {
                        "username": "BatMe",
                        "content": "not for me\\n"
                    },
                    {
                        "username": "layyy",
                        "content": "better to use long long here "
                    },
                    {
                        "username": "ankush920",
                        "content": "best way T.C. =O(n)    S.C. =O(n)\\n\\nclass Solution {\\npublic:\\n\\nint fac(int n)\\n{\\n    int product= 0;\\n    while(n!=0)\\n    {\\n         product= product+n;\\n         n--;\\n    }\\n    return product;\\n}\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n\\n    unordered_map<int ,int> check ;\\n    int output=0;\\n     \\n     \\n    for(int i=0 ; i<time.size();i++)\\n    {\\n        time[i]= time[i]%60;\\n        check[time[i]]++;\\n    }\\n\\n\\n    for( auto it: time)\\n    {\\n        if( (it==0 ||it==30) && check[it]>0)\\n        {\\n            output=output+fac(check[it]-1);\\n            check[it]=0;\\n            continue;\\n        }\\n      \\n      if( check[it]>0)\\n      {\\n         int ans=60 -it;\\n    \\n         output= output + check[it]*check[ans] ;\\n         check[it]=0;\\n         check[ans]=0;\\n       \\n    }\\n    }\\n\\n     return output;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "leoniescape",
                        "content": "space complexity of your solution should be O(1), because in your solution, there are atmost 60 keys in your hashtable"
                    }
                ]
            }
        ]
    }
]